<html lang="en">
<head>
<title>Nausicaa/IrRegex</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa/IrRegex">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.1d0 of Nausicaa/IrRegex, a
repackaging of IrRegex by Alex Shinn designed to fit into the Nausicaa
infrastructure.  It embeds IrRegex version 0.7.1.

IrRegex is a fully portable and efficient R[456]RS
implementation of regular expressions, supporting both POSIX syntax
with various (irregular) PCRE extensions, as well as SCSH's
SRE syntax, with various aliases for commonly used patterns.
DFA matching is used when possible, otherwise a
closure--compiled NFA approach is used.

The package is distributed under a BSD style license and can be
downloaded from:

                        `http://synthcode.com/'


Copyright (C) 2005--2008 by Alex Shinn.  See the
``Package License'' appendix for copying conditions.

This document is derived from the original IrRegex documentation, which
was reformatted in Texinfo and adapted to the Nausicaa repackaging by
Marco Maggi <marcomaggi@gna.org>.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">Nausicaa/IrRegex</h1>
<div class="node">
<p><hr>
<a name="Top"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#overview">overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">IrRegex for Ikarus Scheme</h2>

<p class="noindent">This document describes version 0.1d0 of Nausicaa/IrRegex, a
repackaging of IrRegex by Alex Shinn designed to fit into the Nausicaa
infrastructure.  It embeds IrRegex version 0.7.1.

   <p>IrRegex is a fully portable and efficient <acronym>R[456]RS</acronym>
implementation of regular expressions, supporting both <acronym>POSIX</acronym> syntax
with various (irregular) <acronym>PCRE</acronym> extensions, as well as SCSH's
<acronym>SRE</acronym> syntax, with various aliases for commonly used patterns. 
<acronym>DFA</acronym> matching is used when possible, otherwise a
closure&ndash;compiled <acronym>NFA</acronym> approach is used.

   <p>The package is distributed under a <acronym>BSD</acronym> style license and can be
downloaded from:

<div align="center"><a href="http://synthcode.com/">http://synthcode.com/</a></div>

<p class="noindent">Copyright &copy; 2005&ndash;2008 by Alex Shinn.  See the
&ldquo;Package License&rdquo; appendix for copying conditions.

   <p>This document is derived from the original IrRegex documentation, which
was reformatted in Texinfo and adapted to the Nausicaa repackaging by
Marco Maggi <a href="mailto:marcomaggi@gna.org">marcomaggi@gna.org</a>.

<ul class="menu">
<li><a accesskey="1" href="#overview">overview</a>:                     Overview of the package. 
<li><a accesskey="2" href="#compile">compile</a>:                      Compiling regular expressions. 
<li><a accesskey="3" href="#match">match</a>:                        Match objects. 
<li><a accesskey="4" href="#replace">replace</a>:                      Replacing substrings. 
<li><a accesskey="5" href="#chunk">chunk</a>:                        Chunked string matching. 
<li><a accesskey="6" href="#misc">misc</a>:                         Miscellaneous functions. 
<li><a accesskey="7" href="#syntax">syntax</a>:                       Supported regular expressions
                                syntax.

</li></ul>
<p>Appendices

</p>
<ul class="menu">
<li><a accesskey="8" href="#Package-License">Package License</a>:              Package License. 
<li><a accesskey="9" href="#references">references</a>:                   Bibliography and references.

</li></ul>
<p>Indexes

</p>
<ul class="menu">
<li><a href="#concept-index">concept index</a>:                An entry for each concept. 
<li><a href="#function-index">function index</a>:               An entry for each function. 
<li><a href="#variable-index">variable index</a>:               An entry for each variable. 
<li><a href="#type-index">type index</a>:                   An entry for each type. 
</ul>

<!--  -->
<!-- page -->
<div class="node">
<p><hr>
<a name="overview"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#compile">compile</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Overview of the package</h2>

<blockquote>
At this moment there was a loud ring at the bell, and I could hear
Mrs. Hudson, our landlady, raising her voice in a wail of expostulation
and dismay.

        <p>&ldquo;By heaven, Holmes,&rdquo; I said, half rising, &ldquo;I believe that they are
really after us.&rdquo;

        <p>&ldquo;No, it's not quite so bad as that.  It is the unofficial force&mdash;&ndash;the
Baker Street irregulars.&rdquo;
</blockquote>

<p class="noindent">IrRegex by Alex Shinn is a fully portable and efficient <acronym>R456RS</acronym>
implementation of regular expressions, supporting both <acronym>POSIX</acronym> syntax
with various (irregular) <acronym>PCRE</acronym> extensions, as well as SCSH's
<acronym>SRE</acronym> syntax, with various aliases for commonly used patterns. 
<acronym>DFA</acronym> matching is used when possible, otherwise a
closure&ndash;compiled <acronym>NFA</acronym> approach is used.

   <p>The library makes no assumptions about the encoding of strings or range
of characters and can thus be used in Unicode&ndash;aware Scheme
implementations.  Matching may be performed over standard Scheme
strings, or over arbitrarily chunked streams of strings.

   <p>Nausicaa/IrRegex wraps IrRegex version 0.7.1 repackaged to
fit the Nausicaa standards.  To import it we can to:

<pre class="example">     (import (irregex))
</pre>
   <p class="noindent">and it requires the Nausicaa <acronym>SRFI</acronym> to be installed.

<!--  -->
<!-- page -->
<div class="node">
<p><hr>
<a name="compile"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#match">match</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#overview">overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Compiling regular expressions</h2>

<div class="defun">
&mdash; Function: <b>irregex?</b><var> obj<a name="index-irregex_003f-1"></a></var><br>
<blockquote><p>Return <code>#t</code> if, and only if, <var>obj</var> is a compiled regular
expression. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex</b><var> posix-string-or-sre </var>[<var>options ...</var>]<var><a name="index-irregex-2"></a></var><br>
&mdash; Function: <b>string-&gt;irregex</b><var> posix-string </var>[<var>options ...</var>]<var><a name="index-string_002d_003eirregex-3"></a></var><br>
&mdash; Function: <b>sre-&gt;irregex</b><var> sre </var>[<var>options ...</var>]<var><a name="index-sre_002d_003eirregex-4"></a></var><br>
<blockquote><p>Compile a regular expression from either a <acronym>POSIX</acronym>&ndash;style regular
expression string (with most <acronym>PCRE</acronym> extensions) or an SCSH&ndash;style
<acronym>SRE</acronym>.  Return an object representing the compiled regular expression.

        <p>There is no <code>(rx ...)</code> syntax to specify the regular expression, we
just use normal Scheme lists.  Technically a string by itself could be
considered a valid <acronym>SRE</acronym>, so if we want to just match a literal string
we should use something like:

     <pre class="example">          (irregex `(: ,str))
     </pre>
        <p class="noindent">or use the explicit:

     <pre class="example">          (string-&gt;irregex str)
     </pre>
        <p>The <var>options</var> are a list of any of the following symbols, which must
be quoted:

          <dl>
<dt><code>i</code><dt><code>case-insensitive</code><dd>match case&ndash;insensitively;

          <br><dt><code>m</code><dt><code>multi-line</code><dd>treat string as multiple lines (effects <code>^</code> and <code>$</code>);

          <br><dt><code>s</code><br><dt><code>single-line</code><dd>treat string as a single line (<code>.</code> can match newline);

          <br><dt><code>utf8</code><dd><acronym>UTF</acronym>-8 mode, assumes strings are byte&ndash;strings;

          <br><dt><code>fast</code><dd>try to optimize the regular expression;

          <br><dt><code>small</code><dd>try to compile a smaller regular expression. 
</dl>

        <blockquote>
<em>Note:</em> The <code>fast</code> and <code>small</code> options may not actually
make the compiled expression any faster or smaller at the moment. 
</blockquote>
        </p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<p><hr>
<a name="match"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#replace">replace</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#compile">compile</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Match objects</h2>

<div class="defun">
&mdash; Function: <b>irregex-search</b><var> irx str </var>[<var>start end</var>]<var><a name="index-irregex_002dsearch-5"></a></var><br>
<blockquote><p>Search for any instance of the pattern <var>irx</var> (a <acronym>POSIX</acronym> string,
<acronym>SRE</acronym> sexp, or pre&ndash;compiled regular expression) in <var>str</var>,
optionally between the given range.  If a match is found, return a match
object, otherwise <code>#f</code>.

        <p>Match objects can be used to query the selected substring or its
submatches using the <span class="sc">irregex-match-*</span> procedures below.

        <p>Examples:

     <pre class="example">          (irregex-search "[a-z]+" "123abc456")
          =&gt; ... ; match object
          
          (irregex-search "[a-z]+" "123456")
          =&gt; #f
          
          (irregex-search "foobar" "abcFOOBARdef")
          =&gt; #f
          
          (irregex-search (string-&gt;irregex "foobar" 'case-insensitive)
                          "abcFOOBARdef")
          =&gt; ... ; match object
     </pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex-match</b><var> irx str<a name="index-irregex_002dmatch-6"></a></var><br>
<blockquote><p>Like <span class="sc">irregex-search</span>, but performs an anchored match against the
beginning and end of the string, without searching.

        <p>Examples:

     <pre class="example">          (irregex-match '(w/nocase "foobar") "abcFOOBARdef")
          =&gt; #f
          
          (irregex-match '(w/nocase "foobar") "FOOBAR")
          =&gt; ... ; match object
     </pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex-match-data?</b><var> match-obj<a name="index-irregex_002dmatch_002ddata_003f-7"></a></var><br>
<blockquote><p>Return <code>#t</code> if, and only if, the object is a successful match result
from <span class="sc">irregex-search</span> or <span class="sc">irregex-match</span>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex-match-substring</b><var> match-obj </var>[<var>index-or-name</var>]<var><a name="index-irregex_002dmatch_002dsubstring-8"></a></var><br>
&mdash; Function: <b>irregex-match-start-index</b><var> match-obj </var>[<var>index-or-name</var>]<var><a name="index-irregex_002dmatch_002dstart_002dindex-9"></a></var><br>
&mdash; Function: <b>irregex-match-end-index</b><var> match-obj </var>[<var>index-or-name</var>]<var><a name="index-irregex_002dmatch_002dend_002dindex-10"></a></var><br>
<blockquote><p>Fetch the matched substring (or its start or end offset) at the given
submatch index, or named submatch.

        <p>The entire match is index 0, the first 1, etc.  The default is index 0.

        <p>Examples:

     <pre class="example">          (irregex-match-substring
             (irregex-search "ciao" "hello ciao salut")
             0)
          =&gt; "ciao"
     </pre>
        </blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<p><hr>
<a name="replace"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#chunk">chunk</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#match">match</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Replacing substrings</h2>

<div class="defun">
&mdash; Function: <b>irregex-replace</b><var> irx str </var>[<var>replacements ...</var>]<var><a name="index-irregex_002dreplace-11"></a></var><br>
&mdash; Function: <b>irregex-replace/all</b><var> irx str </var>[<var>replacements ...</var>]<var><a name="index-irregex_002dreplace_002fall-12"></a></var><br>
<blockquote><p>Match a pattern in a string, and replaces it with a (possibly empty)
list of substitutions.

        <p>Each <var>replacement</var> can be either a string literal, a numeric index,
a symbol (as a named submatch), or a procedure which takes one argument
(the match object) and returns a string.

        <p>Examples:

     <pre class="example">          (irregex-replace "[aeiou]" "hello world" "*") =&gt; "h*llo world"
          
          (irregex-replace/all "[aeiou]" "hello world" "*") =&gt; "h*ll* w*rld"
     </pre>
        </blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<p><hr>
<a name="chunk"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#misc">misc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#replace">replace</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Chunked string matching</h2>

<p>It's often desirable to perform regular expression matching over
sequences of characters not represented as a single string.  The most
obvious example is a text&ndash;buffer data structure, but we may also want
to match over lists or trees of strings (i.e. ropes), over only certain
ranges within a string, over an input port, etc.

   <p>With existing regular expression libraries, the only way to accomplish
this is by converting the abstract sequence into a freshly allocated
string. This can be expensive, or even impossible if the object is a
text&ndash;buffer opened onto a 500MB file.

   <p>IrRegex provides a chunked string <acronym>API</acronym> specifically for this
purpose.

<div class="defun">
&mdash; Function: <b>make-irregex-chunker</b><var> get-next get-string </var>[<var>get-start get-end get-next get-substring get-subchunk</var>]<var><a name="index-make_002dirregex_002dchunker-13"></a></var><br>
<blockquote><p>Define a chunking <acronym>API</acronym>.

          <dl>
<dt><code>(</code><var>get-next</var><code> chunk)</code><dd>Return the next chunk, or <code>#f</code> if there are no more chunks.

          <br><dt><code>(</code><var>get-string</var><code> chunk)</code><dd>A string source for the chunk.

          <br><dt><code>(</code><var>get-start</var><code> chunk)</code><dd>The start index of the result of <var>get-string</var> (defaults to always 0).

          <br><dt><code>(</code><var>get-end</var><code> chunk)</code><dd>The end (exclusive) of the string (defaults to string-length of the
source string).

          <br><dt><code>(</code><var>get-substring</var> <var>cnk1</var> <var>i</var> <var>cnk2</var> <var>j</var><code>)</code><dd>A substring for the range between the chunk <var>cnk1</var> starting at index
<var>i</var> and ending at <var>cnk2</var> at index <var>j</var>.

          <br><dt><code>(</code><var>get-subchunk</var> <var>cnk1</var> <var>i</var> <var>cnk2</var> <var>j</var><code>)</code><dd>As above but returns a new chunked data type instead of a string
(optional). 
</dl>

        <p>There are two important constraints on the <var>get-next</var> procedure.  It
must return an <span class="sc">eq?</span> identical object when called multiple times on
the same chunk, and it must not return a chunk with an empty string
(start == end).  This second constraint is for performance reasons, we
push the work of possibly filtering empty chunks to the chunker since
there are many chunk types for which empty strings aren't possible, and
this work is thus not needed.  Note that the initial chunk passed to
match on is allowed to be empty.

        <p><var>get-substring</var> is provided for possible performance improvements,
without it a default is used.

        <p><var>get-subchunk</var> is optional, without it we may not use
<span class="sc">irregex-match-subchunk</span>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex-match-subchunk</b><var> match-obj </var>[<var>index-or-name</var>]<var><a name="index-irregex_002dmatch_002dsubchunk-14"></a></var><br>
<blockquote><p>Generate a chunked data&ndash;type for the given match item, of the same type
as the underlying chunk type (see Chunked String Matching below). This
is only available if the chunk type specifies the <span class="sc">get-subchunk</span>
<acronym>API</acronym>, otherwise an error is raised. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex-search/chunked</b><var> irx chunker chunk<a name="index-irregex_002dsearch_002fchunked-15"></a></var><br>
&mdash; Function: <b>irregex-match/chunked</b><var> irx chunker chunk<a name="index-irregex_002dmatch_002fchunked-16"></a></var><br>
<blockquote><p>These return normal match&ndash;data objects.

        <p>Example: To match against a simple, flat list of strings use:

     <pre class="example">          (define (rope-&gt;string rope1 start rope2 end)
            (if (eq? rope1 rope2)
                (substring (car rope1) start end)
                (let loop ((rope (cdr rope1))
                           (res (list (substring (car rope1) start))))
                   (if (eq? rope rope2)
                       (string-concatenate-reverse      ; from SRFI-13
                        (cons (substring (car rope) 0 end) res))
                       (loop (cdr rope) (cons (car rope) res))))))
          
          (define rope-chunker
            (make-irregex-chunker (lambda (x) (and (pair? (cdr x)) (cdr x)))
                                  car
                                  (lambda (x) 0)
                                  (lambda (x) (string-length (car x)))
                                  rope-&gt;string))
          
          (irregex-search/chunked &lt;pat&gt; rope-chunker &lt;list-of-strings&gt;)
     </pre>
        <p>Here we are just using the default start, end and substring behaviors,
so the above chunker could simply be defined as:

     <pre class="example">          (define rope-chunker
            (make-irregex-chunker (lambda (x) (and (pair? (cdr x)) (cdr x))) car))
     </pre>
        </blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<p><hr>
<a name="misc"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#syntax">syntax</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#chunk">chunk</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Miscellaneous functions</h2>

<div class="defun">
&mdash; Function: <b>irregex-fold</b><var> irx kons knil str </var>[<var>finish start end</var>]<var><a name="index-irregex_002dfold-17"></a></var><br>
<blockquote><p>This follows the <acronym>API</acronym> for <span class="sc">regexp-fold</span> from SCSH. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex-quote</b><var> str<a name="index-irregex_002dquote-18"></a></var><br>
<blockquote><p>Return a new string with any special regular expression characters
escaped, to match the original string literally in <acronym>POSIX</acronym> regular
expressions. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex-opt</b><var> list-of-strings<a name="index-irregex_002dopt-19"></a></var><br>
<blockquote><p>Return an optimized <acronym>POSIX</acronym> string matching any of the literal strings
in the list, like Emacs' <span class="sc">regexp-opt</span>.  Note this optimization
doesn't help when <span class="sc">irregex</span> is able to build a <acronym>DFA</acronym>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>sre-&gt;string</b><var> sre<a name="index-sre_002d_003estring-20"></a></var><br>
<blockquote><p>Convert an <acronym>SRE</acronym> to a <acronym>POSIX</acronym>&ndash;style regular expression string, if
possible. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<p><hr>
<a name="syntax"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Package-License">Package License</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#misc">misc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Supported regular expressions syntax</h2>

<h5 class="subsubheading">Supported <acronym>PCRE</acronym> syntax</h5>

<p>Since the <acronym>PCRE</acronym> syntax is so overwhelming complex, it's easier to just
list what we <strong>don't</strong> support for now.  Refer to the <acronym>PCRE</acronym>
documentation for details.

   <p>Unicode character classes (<code>\P</code>) are not supported, but will be in
an upcoming release.  <code>\C</code> named characters are not supported.

   <p>Callbacks, subroutine patterns and recursive patterns are not
supported. <code>(*FOO)</code> patterns are not supported and may never be.

   <p><code>\G</code> and <code>\K</code> are not supported.

   <p>Octal character escapes are not supported because they are ambiguous
with back&ndash;references, just use hex character escapes.

   <p>Other than that everything should work, including named submatches,
zero-width assertions, conditional patterns, etc.

   <p>In addition, <code>\&lt;</code> and <code>\&gt;</code> act as beginning&ndash;of&ndash;word and
end&ndash;of&ndash;word marks, respectively, as in Emacs regular expressions.

<!--  -->
<h5 class="subsubheading">Extended <acronym>SRE</acronym> Syntax</h5>

<p>The following extensions to standard <acronym>SRE</acronym> syntax are provided:

<pre class="example">     (?? &lt;sre&gt; ...)                 ; shy (non-greedy) patterns
     (*? &lt;sre&gt; ...)
     (**? &lt;from&gt; &lt;to&gt; &lt;sre&gt; ...)    ; +? isn't valid so use this
     (backref &lt;n&gt;)
     (look-ahead &lt;sre&gt; ...)         ; or Emacsish looking-at
     (look-behind &lt;sre&gt; ...)        ; or Emacsish looking-back
     (neg-look-ahead &lt;sre&gt; ...)     ; or not- prefix
     (neg-look-behind &lt;sre&gt; ...)
     (atomic &lt;sre&gt; ...)             ; for (?&gt;...) independent patterns
     (if &lt;test&gt; &lt;pass&gt; [&lt;fail&gt;])    ; conditional patterns
     (submatch-named &lt;name&gt; &lt;sre&gt; ...)
     newline                        ; general newline pattern
     nwb                            ; non-word-boundary
     commit                         ; disable backtracking beyond this (i.e. cut)
</pre>
   <p>The following utility regular expressions are also provided for common
patterns:

<pre class="example">     integer                        ; an integer
     real                           ; a real number (including scientific)
     string                         ; a "quoted" string
     ipv4-address                   ; a numeric decimal ipv4 address
     ipv6-address                   ; a numeric hexadecimal ipv6 address
     domain                         ; a domain name
     email                          ; an email address
     http-url                       ; a URL beginning with https?://
</pre>
   <p>More common patterns are planned.

<!--  -->
<!-- page -->
<div class="node">
<p><hr>
<a name="Package-License"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#references">references</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#syntax">syntax</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix A Package License</h2>

<p>Copyright &copy; 2005&ndash;2008 Alex Shinn.  All rights reserved.

   <p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

     <ol type=1 start=1>
<li>Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

     <li>Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the
distribution.

     <li>The name of the author may not be used to endorse or promote products
derived from this software without specific prior written permission.

        </ol>

   <p>THIS SOFTWARE IS PROVIDED BY THE AUTHOR &ldquo;AS IS&rdquo; AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

<!--  -->
<!-- page -->
<div class="node">
<p><hr>
<a name="references"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#concept-index">concept index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Package-License">Package License</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix B Bibliography and references</h2>

<!--  -->
<!-- page -->
<div class="node">
<p><hr>
<a name="concept-index"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#function-index">function index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#references">references</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix C An entry for each concept</h2>

<ul class="index-cp" compact>
</ul><div class="node">
<p><hr>
<a name="function-index"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#variable-index">variable index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#concept-index">concept index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix D An entry for each function.</h2>



<ul class="index-fn" compact>
<li><a href="#index-irregex-2"><code>irregex</code></a>: <a href="#compile">compile</a></li>
<li><a href="#index-irregex_002dfold-17"><code>irregex-fold</code></a>: <a href="#misc">misc</a></li>
<li><a href="#index-irregex_002dmatch-6"><code>irregex-match</code></a>: <a href="#match">match</a></li>
<li><a href="#index-irregex_002dmatch_002ddata_003f-7"><code>irregex-match-data?</code></a>: <a href="#match">match</a></li>
<li><a href="#index-irregex_002dmatch_002dend_002dindex-10"><code>irregex-match-end-index</code></a>: <a href="#match">match</a></li>
<li><a href="#index-irregex_002dmatch_002dstart_002dindex-9"><code>irregex-match-start-index</code></a>: <a href="#match">match</a></li>
<li><a href="#index-irregex_002dmatch_002dsubchunk-14"><code>irregex-match-subchunk</code></a>: <a href="#chunk">chunk</a></li>
<li><a href="#index-irregex_002dmatch_002dsubstring-8"><code>irregex-match-substring</code></a>: <a href="#match">match</a></li>
<li><a href="#index-irregex_002dmatch_002fchunked-16"><code>irregex-match/chunked</code></a>: <a href="#chunk">chunk</a></li>
<li><a href="#index-irregex_002dopt-19"><code>irregex-opt</code></a>: <a href="#misc">misc</a></li>
<li><a href="#index-irregex_002dquote-18"><code>irregex-quote</code></a>: <a href="#misc">misc</a></li>
<li><a href="#index-irregex_002dreplace-11"><code>irregex-replace</code></a>: <a href="#replace">replace</a></li>
<li><a href="#index-irregex_002dreplace_002fall-12"><code>irregex-replace/all</code></a>: <a href="#replace">replace</a></li>
<li><a href="#index-irregex_002dsearch-5"><code>irregex-search</code></a>: <a href="#match">match</a></li>
<li><a href="#index-irregex_002dsearch_002fchunked-15"><code>irregex-search/chunked</code></a>: <a href="#chunk">chunk</a></li>
<li><a href="#index-irregex_003f-1"><code>irregex?</code></a>: <a href="#compile">compile</a></li>
<li><a href="#index-make_002dirregex_002dchunker-13"><code>make-irregex-chunker</code></a>: <a href="#chunk">chunk</a></li>
<li><a href="#index-sre_002d_003eirregex-4"><code>sre-&gt;irregex</code></a>: <a href="#compile">compile</a></li>
<li><a href="#index-sre_002d_003estring-20"><code>sre-&gt;string</code></a>: <a href="#misc">misc</a></li>
<li><a href="#index-string_002d_003eirregex-3"><code>string-&gt;irregex</code></a>: <a href="#compile">compile</a></li>
   </ul><div class="node">
<p><hr>
<a name="variable-index"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#type-index">type index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#function-index">function index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix E An entry for each variable.</h2>



<ul class="index-vr" compact>
   </ul><div class="node">
<p><hr>
<a name="type-index"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#variable-index">variable index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix F An entry for each type.</h2>



<ul class="index-tp" compact>
   </ul>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">IrRegex for Ikarus Scheme</a>
<li><a name="toc_overview" href="#overview">1 Overview of the package</a>
<li><a name="toc_compile" href="#compile">2 Compiling regular expressions</a>
<li><a name="toc_match" href="#match">3 Match objects</a>
<li><a name="toc_replace" href="#replace">4 Replacing substrings</a>
<li><a name="toc_chunk" href="#chunk">5 Chunked string matching</a>
<li><a name="toc_misc" href="#misc">6 Miscellaneous functions</a>
<li><a name="toc_syntax" href="#syntax">7 Supported regular expressions syntax</a>
<li><a name="toc_Package-License" href="#Package-License">Appendix A Package License</a>
<li><a name="toc_references" href="#references">Appendix B Bibliography and references</a>
<li><a name="toc_concept-index" href="#concept-index">Appendix C An entry for each concept</a>
<li><a name="toc_function-index" href="#function-index">Appendix D An entry for each function.</a>
<li><a name="toc_variable-index" href="#variable-index">Appendix E An entry for each variable.</a>
<li><a name="toc_type-index" href="#type-index">Appendix F An entry for each type.</a>
</li></ul>
</div>

</body></html>

