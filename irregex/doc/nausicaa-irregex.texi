\input texinfo.tex
@c %**start of header
@setfilename nausicaa-irregex.info
@settitle Nausicaa/IrRegex
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@macro irregexversion{}
0.7.1
@end macro


@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@macro bsd{}
@acronym{BSD}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro ram{}
@acronym{RAM}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@c Remember that @url is already used by Texinfo.
@macro urla{}
@acronym{URL}
@end macro

@macro sre{}
@acronym{SRE}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Software related macros.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@macro glibc{}
@gnu{} C Library
@end macro

@macro pcre{}
@acronym{PCRE}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro icmp{}
@acronym{ICMP}
@end macro

@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro https{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@macro snmp{}
@acronym{SNMP}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Arguments macros.
@c ------------------------------------------------------------

@macro vari{ARG}
@var{\ARG\1}
@end macro

@macro varii{ARG}
@var{\ARG\2}
@end macro

@macro variii{ARG}
@var{\ARG\3}
@end macro

@macro variv{ARG}
@var{\ARG\4}
@end macro

@macro varn{ARG}
@var{\ARG\n}
@end macro

@macro vark{ARG}
@var{\ARG\k}
@end macro

@macro varj{ARG}
@var{\ARG\j}
@end macro

@c ------------------------------------------------------------

@macro meta{ARG}
<\ARG\>
@end macro

@macro metai{ARG}
@meta{\ARG\1}
@end macro

@macro metaii{ARG}
@meta{\ARG\2}
@end macro

@macro metaiii{ARG}
@meta{\ARG\3}
@end macro

@macro metaiv{ARG}
@meta{\ARG\4}
@end macro

@macro metan{ARG}
@meta{\ARG\n}
@end macro

@macro metak{ARG}
@meta{\ARG\k}
@end macro

@macro metaj{ARG}
@meta{\ARG\j}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro null{}
@code{NULL}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{NAME}
@code{(\NAME\)}
@end macro

@macro module{NAME}
@code{\NAME\}
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@ignore
Separating the @srfi{}  macro from the number with a  '--' rather than a
'-' makes the expansion look ugly in menu entries under the Info reader.
IMHO this should not happen, but  it does; so we live with this, because
the main purpose of this document is to provide an Info version.
@end ignore
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@c ------------------------------------------------------------

@macro func{NAME}
@code{@sc{\NAME\}}
@end macro

@macro nil{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@macro rsixref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@end macro

@macro rfiveref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r5rs}
@end macro

@macro ikarusref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,ikarus}
@end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro


@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      IrRegex for Ikarus Scheme

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/IrRegex

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-irregex

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2005--2008

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a
repackaging of IrRegex by Alex Shinn designed to fit into the Nausicaa
infrastructure.  It embeds IrRegex version @irregexversion{}.

IrRegex is a fully portable and efficient @acronym{R[456]RS}
implementation of regular expressions, supporting both @posix{} syntax
with various (irregular) @pcre{} extensions, as well as SCSH's
@acronym{SRE} syntax, with various aliases for commonly used patterns.
@acronym{DFA} matching is used when possible, otherwise a
closure--compiled @acronym{NFA} approach is used.

The package is distributed under a @bsd{} style license and can be
downloaded from:

@center @url{http://synthcode.com/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by Alex Shinn.  See the
``Package License'' appendix for copying conditions.

This document is derived from the original IrRegex documentation, which
was reformatted in Texinfo and adapted to the Nausicaa repackaging by
@value{AUTHOR} @value{AUTHOR_EMAIL}.
@end copying

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author Alex Shinn
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-irregex: (nausicaa-irregex). Regular expressions
                                        for Ikarus Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c ------------------------------------------------------------

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying
     
@menu
* overview::                    Overview of the package. 
* compile::                     Compiling regular expressions.
* match::                       Match objects.
* replace::                     Replacing substrings.
* chunk::                       Chunked string matching.
* misc::                        Miscellaneous functions.
* syntax::                      Supported regular expressions
                                syntax.

Appendices

* Package License::             Package License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept. 
* function index::              An entry for each function. 
* variable index::              An entry for each variable. 
* type index::                  An entry for each type. 
@end menu
@end ifnottex

@c ------------------------------------------------------------

@c page
@node overview
@chapter Overview of the package


@quotation
At this moment there was a loud ring at the bell, and I could hear
Mrs. Hudson, our landlady, raising her voice in a wail of expostulation
and dismay.

``By heaven, Holmes,'' I said, half rising, ``I believe that they are
really after us.''

``No, it's not quite so bad as that.  It is the unofficial force----the
Baker Street irregulars.''
@end quotation


@noindent
IrRegex by Alex Shinn is a fully portable and efficient @rnrs{456}
implementation of regular expressions, supporting both @posix{} syntax
with various (irregular) @pcre{} extensions, as well as SCSH's
@acronym{SRE} syntax, with various aliases for commonly used patterns.
@acronym{DFA} matching is used when possible, otherwise a
closure--compiled @acronym{NFA} approach is used.

The library makes no assumptions about the encoding of strings or range
of characters and can thus be used in Unicode--aware Scheme
implementations.  Matching may be performed over standard Scheme
strings, or over arbitrarily chunked streams of strings.

@value{PACKAGE} wraps IrRegex version @irregexversion{} repackaged to
fit the Nausicaa standards.  To import it we can to:

@example
(import (irregex))
@end example

@noindent
and it requires the Nausicaa @srfi{} to be installed.


@c ------------------------------------------------------------

@c page
@node compile
@chapter Compiling regular expressions


@defun {irregex?} @var{obj}
Return @true{} if, and only if, @var{obj} is a compiled regular
expression.
@end defun


@defun irregex @var{posix-string-or-sre} [@var{options} ...]
@defunx {string->irregex} @var{posix-string} [@var{options} ...]
@defunx {sre->irregex} @var{sre} [@var{options} ...]
Compile a regular expression from either a @posix{}--style regular
expression string (with most @pcre{} extensions) or an SCSH--style
@sre{}.  Return an object representing the compiled regular expression.

There is no @code{(rx ...)} syntax to specify the regular expression, we
just use normal Scheme lists.  Technically a string by itself could be
considered a valid @sre{}, so if we want to just match a literal string
we should use something like:

@example
(irregex `(: ,str))
@end example

@noindent
or use the explicit:

@example
(string->irregex str)
@end example

The @var{options} are a list of any of the following symbols, which must
be quoted:

@table @code
@item i
@itemx case-insensitive
match case--insensitively;

@item m
@itemx multi-line
treat string as multiple lines (effects @code{^} and @code{$});

@item s
@item single-line
treat string as a single line (@code{.} can match newline);

@item utf8
@utf{}-8 mode, assumes strings are byte--strings;

@item fast
try to optimize the regular expression;

@item small
try to compile a smaller regular expression.
@end table

@quotation
@emph{Note:} The @code{fast} and @code{small} options may not actually
make the compiled expression any faster or smaller at the moment.
@end quotation
@end defun


@c ------------------------------------------------------------

@c page
@node match
@chapter Match objects


@defun irregex-search @var{irx} @var{str} [@var{start} @var{end}]
Search for any instance of the pattern @var{irx} (a @posix{} string,
@sre{} sexp, or pre--compiled regular expression) in @var{str},
optionally between the given range.  If a match is found, return a match
object, otherwise @false{}.

Match objects can be used to query the selected substring or its
submatches using the @func{irregex-match-*} procedures below.

Examples:

@example
(irregex-search "[a-z]+" "123abc456")
=> ... ; match object

(irregex-search "[a-z]+" "123456")
=> #f

(irregex-search "foobar" "abcFOOBARdef")
=> #f

(irregex-search (string->irregex "foobar" 'case-insensitive)
                "abcFOOBARdef")
=> ... ; match object
@end example
@end defun


@defun irregex-match @var{irx} @var{str}
Like @func{irregex-search}, but performs an anchored match against the
beginning and end of the string, without searching.

Examples:

@example
(irregex-match '(w/nocase "foobar") "abcFOOBARdef")
=> #f

(irregex-match '(w/nocase "foobar") "FOOBAR")
=> ... ; match object
@end example
@end defun


@defun {irregex-match-data?} @var{match-obj}
Return @true{} if, and only if, the object is a successful match result
from @func{irregex-search} or @func{irregex-match}.
@end defun


@defun irregex-match-substring @var{match-obj} [@var{index-or-name}]
@defunx irregex-match-start-index @var{match-obj} [@var{index-or-name}]
@defunx irregex-match-end-index @var{match-obj} [@var{index-or-name}]
Fetch the matched substring (or its start or end offset) at the given
submatch index, or named submatch.

The entire match is index 0, the first 1, etc.  The default is index 0.

Examples:

@example
(irregex-match-substring
   (irregex-search "ciao" "hello ciao salut")
   0)
=> "ciao"
@end example
@end defun


@c ------------------------------------------------------------

@c page
@node replace
@chapter Replacing substrings


@defun irregex-replace @var{irx} @var{str} [@var{replacements} ...]
@defunx {irregex-replace/all} @var{irx} @var{str} [@var{replacements} ...]
Match a pattern in a string, and replaces it with a (possibly empty)
list of substitutions.

Each @var{replacement} can be either a string literal, a numeric index,
a symbol (as a named submatch), or a procedure which takes one argument
(the match object) and returns a string.

Examples:

@example
(irregex-replace "[aeiou]" "hello world" "*") => "h*llo world"

(irregex-replace/all "[aeiou]" "hello world" "*") => "h*ll* w*rld"
@end example
@end defun


@c ------------------------------------------------------------

@c page
@node chunk
@chapter Chunked string matching


It's often desirable to perform regular expression matching over
sequences of characters not represented as a single string.  The most
obvious example is a text--buffer data structure, but we may also want
to match over lists or trees of strings (i.e. ropes), over only certain
ranges within a string, over an input port, etc.

With existing regular expression libraries, the only way to accomplish
this is by converting the abstract sequence into a freshly allocated
string. This can be expensive, or even impossible if the object is a
text--buffer opened onto a 500MB file.

IrRegex provides a chunked string @api{} specifically for this
purpose.


@defun make-irregex-chunker @var{get-next} @var{get-string} [@var{get-start} @var{get-end} @var{get-next} @var{get-substring} @var{get-subchunk}]
Define a chunking @api{}.

@table @code
@item (@var{get-next} chunk)
Return the next chunk, or @false{} if there are no more chunks.

@item (@var{get-string} chunk)
A string source for the chunk.

@item (@var{get-start} chunk)
The start index of the result of @var{get-string} (defaults to always 0).

@item (@var{get-end} chunk)
The end (exclusive) of the string (defaults to string-length of the
source string).

@item (@var{get-substring} @var{cnk1} @var{i} @var{cnk2} @var{j})
A substring for the range between the chunk @var{cnk1} starting at index
@var{i} and ending at @var{cnk2} at index @var{j}.

@item (@var{get-subchunk} @var{cnk1} @var{i} @var{cnk2} @var{j})
As above but returns a new chunked data type instead of a string
(optional).
@end table

There are two important constraints on the @var{get-next} procedure.  It
must return an @func{eq?} identical object when called multiple times on
the same chunk, and it must not return a chunk with an empty string
(start == end).  This second constraint is for performance reasons, we
push the work of possibly filtering empty chunks to the chunker since
there are many chunk types for which empty strings aren't possible, and
this work is thus not needed.  Note that the initial chunk passed to
match on is allowed to be empty.

@var{get-substring} is provided for possible performance improvements,
without it a default is used.

@var{get-subchunk} is optional, without it we may not use
@func{irregex-match-subchunk}.
@end defun


@defun irregex-match-subchunk @var{match-obj} [@var{index-or-name}]
Generate a chunked data--type for the given match item, of the same type
as the underlying chunk type (see Chunked String Matching below). This
is only available if the chunk type specifies the @func{get-subchunk}
@api{}, otherwise an error is raised.
@end defun


@defun {irregex-search/chunked} @var{irx} @var{chunker} @var{chunk}
@defunx {irregex-match/chunked} @var{irx} @var{chunker} @var{chunk}
These return normal match--data objects.

Example: To match against a simple, flat list of strings use:

@example
(define (rope->string rope1 start rope2 end)
  (if (eq? rope1 rope2)
      (substring (car rope1) start end)
      (let loop ((rope (cdr rope1))
                 (res (list (substring (car rope1) start))))
         (if (eq? rope rope2)
             (string-concatenate-reverse      ; from SRFI-13
              (cons (substring (car rope) 0 end) res))
             (loop (cdr rope) (cons (car rope) res))))))

(define rope-chunker
  (make-irregex-chunker (lambda (x) (and (pair? (cdr x)) (cdr x)))
                        car
                        (lambda (x) 0)
                        (lambda (x) (string-length (car x)))
                        rope->string))

(irregex-search/chunked <pat> rope-chunker <list-of-strings>)
@end example

Here we are just using the default start, end and substring behaviors,
so the above chunker could simply be defined as:

@example
(define rope-chunker
  (make-irregex-chunker (lambda (x) (and (pair? (cdr x)) (cdr x))) car))
@end example
@end defun


@c ------------------------------------------------------------

@c page
@node misc
@chapter Miscellaneous functions


@defun irregex-fold @var{irx} @var{kons} @var{knil} @var{str} [@var{finish} @var{start} @var{end}]
This follows the @api{} for @func{regexp-fold} from SCSH.
@end defun


@defun irregex-quote @var{str}
Return a new string with any special regular expression characters
escaped, to match the original string literally in @posix{} regular
expressions.
@end defun


@defun irregex-opt @var{list-of-strings}
Return an optimized @posix{} string matching any of the literal strings
in the list, like Emacs' @func{regexp-opt}.  Note this optimization
doesn't help when @func{irregex} is able to build a @acronym{DFA}.
@end defun


@defun {sre->string} @var{sre}
Convert an @sre{} to a @posix{}--style regular expression string, if
possible.
@end defun


@c ------------------------------------------------------------

@c page
@node syntax
@chapter Supported regular expressions syntax


@subsubheading Supported @pcre{} syntax


Since the @pcre{} syntax is so overwhelming complex, it's easier to just
list what we @strong{don't} support for now.  Refer to the @pcre{}
documentation for details.

Unicode character classes (@code{\P}) are not supported, but will be in
an upcoming release.  @code{\C} named characters are not supported.

Callbacks, subroutine patterns and recursive patterns are not
supported. @code{(*FOO)} patterns are not supported and may never be.

@code{\G} and @code{\K} are not supported.

Octal character escapes are not supported because they are ambiguous
with back--references, just use hex character escapes.

Other than that everything should work, including named submatches,
zero-width assertions, conditional patterns, etc.

In addition, @code{\<} and @code{\>} act as beginning--of--word and
end--of--word marks, respectively, as in Emacs regular expressions.

@c ------------------------------------------------------------

@subsubheading Extended @sre{} Syntax


The following extensions to standard @sre{} syntax are provided:

@example
(?? <sre> ...)                 ; shy (non-greedy) patterns
(*? <sre> ...)
(**? <from> <to> <sre> ...)    ; +? isn't valid so use this
(backref <n>)
(look-ahead <sre> ...)         ; or Emacsish looking-at
(look-behind <sre> ...)        ; or Emacsish looking-back
(neg-look-ahead <sre> ...)     ; or not- prefix
(neg-look-behind <sre> ...)
(atomic <sre> ...)             ; for (?>...) independent patterns
(if <test> <pass> [<fail>])    ; conditional patterns
(submatch-named <name> <sre> ...)
newline                        ; general newline pattern
nwb                            ; non-word-boundary
commit                         ; disable backtracking beyond this (i.e. cut)
@end example

The following utility regular expressions are also provided for common
patterns:

@example
integer                        ; an integer
real                           ; a real number (including scientific)
string                         ; a "quoted" string
ipv4-address                   ; a numeric decimal ipv4 address
ipv6-address                   ; a numeric hexadecimal ipv6 address
domain                         ; a domain name
email                          ; an email address
http-url                       ; a URL beginning with https?://
@end example

More common patterns are planned. 


@c ------------------------------------------------------------

@c page
@node Package License
@appendix Package License


Copyright @copyright{} 2005--2008 Alex Shinn.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

@enumerate
@item
Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

@item
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the
distribution.

@item
The name of the author may not be used to endorse or promote products
derived from this software without specific prior written permission.

@end enumerate

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.


@c ------------------------------------------------------------

@c page
@node references
@appendix Bibliography and references



@c ------------------------------------------------------------

@c page
@node concept index
@appendix An entry for each concept
     
@printindex cp
     
@node function index
@appendix An entry for each function. 

@printindex fn

@node variable index
@appendix An entry for each variable. 

@printindex vr

@node type index
@appendix An entry for each type. 

@printindex tp

@contents
@bye

@c end of file
