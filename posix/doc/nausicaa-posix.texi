\input texinfo.tex
@c %**start of header
@setfilename nausicaa-posix.info
@settitle POSIX for Nausicaa
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro


@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@macro rsixref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@end macro

@macro rfiveref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r5rs}
@end macro

@macro ikarusref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,ikarus}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@macro bibref{TAG}
@samp{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @posix{} for Nausicaa

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@posix{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-posix

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2008, 2009

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a
distribution of libraries for @rnrs{6} Scheme exposing the @posix{}
interface to the Scheme language level; some @gnu{} C Library extensions
are also exposed.  It is built on top of the Nausicaa/Scheme libraries,
making use of its foreign-functions interface; so, at present, it
supports only @gnu{}+Linux systems.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/nausicaa/downloads}

@noindent
the project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/tree/master}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-posix: (nausicaa-posix).     @posix{} for Nausicaa.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview.
* environment::                 Environment variables.
* file::                        File system.
* stat::                        Inspecting file attributes.
* fd::                          File descriptors.
* streams::                     Stream functions.
* time::                        Date and time.
* process::                     Processes.
* job::                         Job control.
* users::                       Users and groups.
* strings::                     More C string functions.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Overview

* overview libraries::          Libraries organisation.
* overview interface::          Interface organisation.

File system

* file inspect::                System inspection.
* file working directory::      The working directory.
* file directory access::       Accessing directory entries.
* file links::                  Hard and symbolic links.
* file remove::                 Removing files and directories.
* file rename::                 Renaming files and directories.
* file mkdir::                  Creating directories.
* file attr::                   Changing file attributes.
* file temp::                   Temporary files.
* file times::                  Setting file times.

Accessing directory entries

* file directory access types:: Type definitions.
* file directory access open::  Accessing a directory stream.
* file directory access read::  Reading a directory stream.
* file directory access seek::  Random access to a directory stream.
* file directory access scan::  Scanning a directory.
* file directory access tree::  Scanning a hierarchy of directories.

Changing file attributes

* file attr owner::             Changing owner and group.
* file attr mode::              Changing file permissions.
* file attr access::            Testing access.
* file attr size::              Size of files.

Inspecting file attributes

* stat constants::              Constant values and structure accessors.
* stat record::                 Acquiring the file attributes.
* stat api::                    Interface functions.
* stat type::                   Type inspection.
* stat perms::                  Access permissions inspection.

File descriptors

* fd typedefs::                 File descriptor related data types.
* fd constants::                Constant values and structure accessors.
* fd open close::               Opening and closing.
* fd read write::               Reading and writing.
* fd seek::                     Setting the file position.
* fd sync::                     Synchronisation.
* fd control::                  Control operations.
* fd dup::                      Duplicating file descriptors.
* fd lock::                     File locks.
* fd pipe::                     Pipes and FIFOs.
* fd scatter::                  Scatter/gather input/output.
* fd mmap::                     Memory mapped input/output.
* fd select::                   Waiting for input or output.
@c * fd aio::                      Asynchronous input/output.
* fd custom::                   Custom Scheme ports.

File descriptor related data types

* fd typedefs fds::             File descriptors.
* fd typedefs flocks::          File locking.
* fd typedefs fdsets::          File descriptor sets.

Constant values and structure accessors

* fd constants status::         File status flags.
* fd constants perms::          Permissions.
* fd constants control::        File control flags.
* fd constants seek::           File positions.
* fd constants lock::           Locking.
* fd constants mmap::           Memory--mapped files.
* fd constants select::         Waiting for file descriptor events.

Stream functions

* streams typedefs::            Object type definitions.
* streams constants::           Constants.
* streams errors::              Detecting errors on streams.
* streams open close::          Opening and closing.
* streams writing::             Writing to streams.
* streams reading::             Reading from streams.
* streams unreading::           Unreading to streams.
* streams seeking::             Stream positioning.
* streams fd::                  Streams and file descriptors.
* streams unlocked::            Unlocked stream operations.
* streams extended::            Extended stream operations.
* streams lines::               Reading lines.

Date and time

* time intro::                  Introduction.
* time structs::                Data structures.
* time records::                Record types.
* time constants::              Constant values.
* time clock::                  Processor time.
* time calendar::               Simple calendar time.
* time hires::                  High resolution calendar.
* time broken::                 Broken--down time.
* time hiaccu::                 High accuracy clock.
* time format::                 Formatting broken--down time.
* time parsing::                Parsing time strings.
* time alarm::                  Setting time alarms.
* time sleep::                  Sleeping.

Data structures

* time structs timeval::        @code{struct timeval} inspection.
* time structs timespec::       @code{struct timespec} inspection.
* time structs tms::            @code{struct tms} inspection.
* time structs timezone::       @code{struct timezone} inspection.
* time structs tm::             @code{struct tm} inspection.
* time structs ntptimeval::     @code{struct ntptimeval} inspection.
* time structs timex::          @code{struct timex} inspection.
* time structs itimerval::      @code{struct itimerval} inspection.

Record types

* time records tms::            @code{struct tms} mirror.
* time records timeval::        @code{struct timeval} mirror.
* time records timespec::       @code{struct timespec} mirror.
* time records timezone::       @code{struct timezone} mirror.
* time records tm::             @code{struct tm} mirror.
* time records ntptimeval::     @code{struct ntptimeval} mirror.
* time records timex::          @code{struct timex} mirror.
* time records itimerval::      @code{struct itimerval} mirror.

Processes

* process record::              Record types.
* process id::                  Process identification.
* process fork::                Creating a process.
* process exec::                Executing a file.
* process wait::                Process completion.

Job control

* job terminal::                Terminal identification.
* job group::                   Process group functions.
* job access::                  Terminal access.

Users and groups

* users persona::               Process' persona.

More C string functions

* strings search::              Searching.

@end detailmenu
@end menu

@end ifnottex

@c page
@node overview
@chapter Overview


@value{PACKAGE} is a distribution of libraries for @rnrs{6} Scheme
exposing the @posix{} interface to the Scheme language level; some
@gnu{} C Library extensions and Linux extensions are also exposed.

The libraries are built on top of the Nausicaa/Scheme libraries, making
use of their foreign-functions interface; some libraries depend upon the
C language library @samp{libnausicaa-posix}, which is built and
installed by this package.

@menu
* overview libraries::          Libraries organisation.
* overview interface::          Interface organisation.
@end menu

@c page
@node overview libraries
@section Libraries organisation


The distribution attempts to split functions compliant to the @posix{}
standard from functions available only through extensions; the standard
C library functions are classified as extensions.  This splitting is
meant to make it easier to port the distribution on non--@gnu{} systems;
it is an ongoing process (the manual pages on GNU+Linux systems should
contain notes about @posix{} standard compliance).

Unless otherwise specified, libraries are split in three sets:

@table @library
@item foreign posix ---
@itemx foreign glibc ---
@itemx foreign linux ---
The high--level interface: Slower but user friendly.  We should really
import these libraries by prefixing the identifiers; for example:

@example
(import (rnrs)
  (prefix (foreign posix fd)   posix:)
  (prefix (foreign glibc file) glibc:))
@end example

@item foreign posix --- primitives
@itemx foreign glibc --- primitives
@itemx foreign linux --- primitives
The middle--level interface; does marshaling of arguments and return
values.  In this documentation, all the bindings from these libraries
are prefixed with @samp{primitive:}, but they are exported
@strong{without} this prefix.

@item foreign posix --- platform
@itemx foreign glibc --- platform
@itemx foreign linux --- platform
The low--level interface: Faster but raw.  In this documentation, all
the bindings from these libraries are prefixed with @samp{platform:},
but they are exported @strong{without} this prefix.
@end table

Additionally, the following libraries are installed:

@table @library
@item foreign posix sizeof
Exports bindings for constant values (like @samp{O_CREAT}) and data
structure accessors and mutators.

@item foreign posix typedefs
Defines new Scheme object types to be used as wrappers for system
objects (file descriptors, pointers to specific data structures, etc.)

@item foreign posix extensions
Defines extensions for the types exported by @library{foreign posix
typedefs}, to be used with the @file{records} library (from the
Nausicaa/Scheme package).  For this purpose, this library must be
imported for the @code{expand} phase.
@end table

Let's take as reference the @code{file} set of features; when the
documentation states that a set of bindings is exported by the @posix{}
@code{file} libraries, it means that the bindings are exported by the
following libraries:

@example
(foreign posix file)
(foreign posix file primitives)
(foreign posix file platform)
@end example

@noindent
when the documentation states that a set of bindings is exported by the
Glibc @code{file} libraries, it means that the bindings are exported by
the following libraries:

@example
(foreign glibc file)
(foreign glibc file primitives)
(foreign glibc file platform)
@end example

@noindent
when the documentation states that a set of bindings is exported by the
Linux @code{file} libraries, it means that the bindings are exported by
the following libraries:

@example
(foreign linux file)
(foreign linux file primitives)
(foreign linux file platform)
@end example

When the documentation states that a set of bindings is exported by the
@code{sizeof} libraries, it means that the bindings are exported by the
@library{foreign posix sizeof} library.

@c page
@node overview interface
@section Interface organisation


For all the functions only a brief description is given: We have to use
the foreign function's own documentation to have all the details.
Unless otherwise specified, the interface adheres to the following
pattern for function @func{x}:

@deffn Function x @var{arg} ...
@deffnx Parameter x-function
@deffnx Function primitive:x @var{arg} ...
@deffnx Function platform:x @var{c-arg} ...
This is an interface for the @cfunc{x} foreign function.

@func{x} and @func{primitive:x} do something with the arguments, which
are regular Scheme values.  They take the same arguments and return the
same return values.  If successful they return values representing the
result; in case of error they raise an @samp{&errno} condition.
@nauref{errno, C language system errors}.

@func{x} does the job by applying to the arguments the current value of
the @func{x-function} parameter, which must be a function; the parameter
is initialised to @func{primitive:x}.

@func{platform:x} is the direct wrapper for the foreign function.  It
accepts C language level arguments (like C strings), and returns 2
values: the return value from the foreign function call and the value of
@samp{errno} right after the call.

Notice that, for almost all the functions, the value of @samp{errno} is
meaningful only if the return value from the foreign function call
indicates an error; @samp{errno} may be non--zero even if the function
call was successful.

For the meaning of the C level arguments we have to read the foreign
function's original documentation.
@end deffn


This interface gives us 3 choices:

@enumerate
@item
To call directly the foreign function using the @func{platform:x}
wrapper; in this case we are responsible to convert the Scheme arguments
to the appropriate C language level values (beware to non--garbage
collected values!).

@item
To call the Scheme adapter @func{primitive:x}; this gives us: automatic
conversion of arguments, exceptions in case of errors, automatic
retrying in case the foreign function call is interrupted by an
@samp{EINTR} signal.

@item
To call the high--level, parameterised, @func{x} interface; this gives
us everything @func{primitive:x} does and additionally allows us to
replace the primitive function with a version that returns controlled
values, or raises an error, and/or logs the operation.  This feature can
be used to test Scheme code execution paths that handle exceptions.
@end enumerate


Example of usage of failing primitive fork function:

@example
(define (fake-fork)
  (raise-errno-error 'fork EINVAL))

(parametrise ((fork-function fake-fork))
  ---
  (fork)
  ---)
@end example

@c page
@node environment
@chapter Environment variables


Unless otherwise specified, the following bindings are exported by the
@posix{} @code{environment} libraries.  @glibcref{Environment
Access,Environment Access}.  @nauref{naulib environment, Accessing
environment variables}.


@deffn Function getenv @var{varname}
@deffnx Parameter getenv-function
@deffnx Function primitive:getenv @var{varname}
@deffnx Function platform:getenv @var{varname-cstr}
Return the current value of the environment variable @var{varname}, as a
Scheme string.  @var{varname} must be a Scheme string or symbol.  If the
variable is not set, the return value if @false{}; if the variable is
set to the empty string, the return value is the empty string.
@end deffn


@deffn Function setenv @var{varname} @var{value}
@deffnx Function setenv @var{varname} @var{value} @var{replace}
@deffnx Parameter setenv-function
@deffnx Function primitive:setenv @var{varname} @var{value}
@deffnx Function primitive:setenv @var{varname} @var{value} @var{replace}
@deffnx Function platform:setenv @var{varname} @var{value} @var{replace}
Set a new value for the environment variable @var{varname}.
@var{varname} and @var{value} must be Scheme strings or symbols.  If the
environment already contains @var{varname}, then @var{replace} controls
the action: if true the value is replaced, if @false{} it is left alone.
@end deffn


@deffn Function environ
@deffnx Parameter environ-function
@deffnx Function primitive:environ
@deffnx Function platform:environ
Direct access to the process' environment variables.  @func{environ} and
@func{primitive:environ} return a list of strings, each of the form
@samp{NAME=VALUE} where @samp{NAME} is the name of an environment
variable and @samp{VALUE} its value.

@func{platform:environ} returns a pointer to an array of pointers, each
referencing a C string with the format @samp{NAME=VALUE}.  The pointer
is suitable to be used as argument to @func{arg->strings}
(@nauref{cstrings argv, Converting arrays of strings}).
@end deffn


@defun environ-table
Internally invoke @func{environ} and convert the list of strings into a
hashtable; return the hashtable.  The keys are Scheme symbols
representing the defined environment variables, the values are Scheme
symbols representing the environment variables' values.
@end defun


@defun environ->table @var{environ}
@defunx table->environ @var{table}
Convert between a list of strings in ``environ'' format and a hashtable.
@end defun

@c ------------------------------------------------------------

@subsubheading @gnu{} C library functions

The following bindings are exported by the Glibc @code{environment}
libraries.


@deffn Function clearenv
@deffnx Function primitive:clearenv
@deffnx Function platform:clearenv
Remove all the entries from the process' environment.
@end deffn


@deffn Function unsetenv @var{varname}
@deffnx Function primitive:unsetenv @var{varname}
@deffnx Function platform:unsetenv @var{varname-cstr}
Remove the entry for @var{varname} from the environment.  @var{varname}
must be a Scheme string or symbol.
@end deffn


@deffn Function putenv @var{assignment}
@deffnx Function primitive:putenv @var{assignment}
@deffnx Function platform:putenv @var{assignment-cstr}
Put the variable assignment described by the Scheme string or symbol
@var{assignment} in the environment.  @var{assignment} must have the
format @samp{NAME=VALUE}.
@end deffn


@defun putenv* @var{name} @var{value}
@defunx primitive:putenv* @var{name} @var{value}
Append the Scheme strings or symbols @var{name} and @var{value} to form
a single strings with @samp{=} in the middle; then put the resulting
variable assignment in the environment.
@end defun

@c page
@node file
@chapter File system


Unless otherwise specified, the bindings described in this chapter are
exported by the @posix{} @code{file} libraries.

@menu
* file inspect::                System inspection.
* file working directory::      The working directory.
* file directory access::       Accessing directory entries.
* file links::                  Hard and symbolic links.
* file remove::                 Removing files and directories.
* file rename::                 Renaming files and directories.
* file mkdir::                  Creating directories.
* file attr::                   Changing file attributes.
* file temp::                   Temporary files.
* file times::                  Setting file times.
@end menu

@c page
@node file inspect
@section System inspection


The following functions inspect the system limits and capabilities.
@glibcref{Pathconf, Using @code{pathconf}}.


@deffn Function pathconf @var{pathname} @var{feature}
@deffnx Parameter pathconf-function
@deffnx Function primitive:pathconf @var{pathname} @var{feature}
@deffnx Function platform:pathconf @var{pathname-str} @var{feature}
Return an exact integer representing the value of the selected
@var{feature} related to the @var{pathname}, which must be a Scheme
string or symbol.
@end deffn


@deffn Function fpathconf @var{fd} @var{feature}
@deffnx Parameter fpathconf-function
@deffnx Function primitive:fpathconf @var{fd} @var{feature}
@deffnx Function platform:fpathconf @var{fd} @var{feature}
Return an exact integer representing the value of the selected
@var{feature} related to the file descriptor @var{fd}.
@end deffn


@defvr Constant _PC_LINK_MAX
@defvrx Constant _PC_MAX_CANON
@defvrx Constant _PC_MAX_INPUT
@defvrx Constant _PC_NAME_MAX
@defvrx Constant _PC_PATH_MAX
@defvrx Constant _PC_PIPE_BUF
@defvrx Constant _PC_CHOWN_RESTRICTED
@defvrx Constant _PC_NO_TRUNC
@defvrx Constant _PC_VDISABLE
@defvrx Constant _PC_SYNC_IO
@defvrx Constant _PC_ASYNC_IO
@defvrx Constant _PC_PRIO_IO
@defvrx Constant _PC_FILESIZEBITS
@defvrx Constant _PC_REC_INCR_XFER_SIZE
@defvrx Constant _PC_REC_MAX_XFER_SIZE
@defvrx Constant _PC_REC_MIN_XFER_SIZE
@defvrx Constant _PC_XFER_ALIGN
Values for the @var{feature} argument of @func{pathconf} and
@func{fpathconf}.  These bindings are exported by the @code{sizeof}
library.
@end defvr

@c page
@node file working directory
@section The working directory


The following functions manage the process' current directory.
@glibcref{Working Directory,Working Directory}.


@deffn Function getcwd
@deffnx Parameter getcwd-function
@deffnx Function primitive:getcwd
@deffnx Function platform:getcwd
Return a string representing the current working directory.
@end deffn


@defun pwd
An alias for @func{getcwd}.
@end defun


@deffn Function chdir @var{pathname}
@deffnx Parameter chdir-function
@deffnx Function primitive:chdir @var{pathname}
@deffnx Function platform:chdir @var{pathname}
Change the current directory to the selected @var{pathname}, which must
be a Scheme string or symbol.  If an error occurs changing directory,
because of access permissions: An exception is raised.
@end deffn


@deffn Function fchdir @var{fd}
@deffnx Parameter fchdir-function
@deffnx Function primitive:fchdir @var{fd}
@deffnx Function platform:fchdir @var{fd}
Change the current directory to the one associated to the file
descriptor @var{fd}.
@end deffn

@c page
@node file directory access
@section Accessing directory entries


The functions described in this section handle accessing directories.
@glibcref{Accessing Directories,Accessing Directories}.

@menu
* file directory access types:: Type definitions.
* file directory access open::  Accessing a directory stream.
* file directory access read::  Reading a directory stream.
* file directory access seek::  Random access to a directory stream.
* file directory access scan::  Scanning a directory.
* file directory access tree::  Scanning a hierarchy of directories.
@end menu

@c page
@node file directory access types
@subsection Type definitions


The following bindings are exported from the @code{sizeof} library.
@glibcref{Directory Entries,Format of a directory entry}.


@defvr Constant sizeof-dirent
@defvrx Constant alignof-dirent
@defvrx Constant strideof-dirent
Size, alignment and array stride of @code{struct dirent} types.
@end defvr


@deffn Syntax struct-dirent-d_ino-set! @var{pointer} @var{value}
@deffnx Syntax struct-dirent-d_ino-ref @var{pointer}
@deffnx Syntax struct-dirent-d_off-set! @var{pointer} @var{value}
@deffnx Syntax struct-dirent-d_off-ref @var{pointer}
@deffnx Syntax struct-dirent-d_reclen-set! @var{pointer} @var{value}
@deffnx Syntax struct-dirent-d_reclen-ref @var{pointer}
@deffnx Syntax struct-dirent-d_type-set! @var{pointer} @var{value}
@deffnx Syntax struct-dirent-d_type-ref @var{pointer}
Accessors and mutators for the fields of the @code{struct dirent} type;
some fields may not be present on different platforms.  See below for
the accessor of the @code{d_name} field.
@end deffn


@deffn Syntax struct-dirent-d_name-ref @var{pointer}
Accessor for the @code{d_name} field of a @code{struct dirent} type.
Evaluates to a pointer to the first byte of the @code{char d_name[]}
array.
@end deffn


@defvr Constant OFFSETOF_STRUCT_DIRENT_D_NAME
Offset in bytes of the @code{d_name} field in a @code{struct dirent}
type.
@end defvr


@defvr Constant _DIRENT_HAVE_D_NAMELEN
@defvrx Constant _DIRENT_HAVE_D_RECLEN
@defvrx Constant _DIRENT_HAVE_D_OFF
@defvrx Constant _DIRENT_HAVE_D_TYPE
Set to @true{} by the @gnu{} C Library if the named field is present in
the @code{struct dirent} type.
@end defvr


@defvr Constant DT_BLK
@defvrx Constant DT_CHR
@defvrx Constant DT_DIR
@defvrx Constant DT_FIFO
@defvrx Constant DT_LNK
@defvrx Constant DT_REG
@defvrx Constant DT_SOCK
@defvrx Constant DT_UNKNOWN
Values for the @code{d_type} field of a @code{struct dirent} type.
These are specific for the @gnu{} C Library.
@end defvr

@c page
@node file directory access open
@subsection Accessing a directory stream


The following functions manage opening and closing of special
@dfn{stream} objects used to access directory contents.
@glibcref{Opening a Directory,Opening a directory stream}.
@glibcref{Reading/Closing Directory,Reading and closing a directory
stream}.

Usage examples:

@example
(let ((stream #f))
  (dynamic-wind
    (lambda ()
      (set! stream (opendir "/home/marco/share/sounds")))
    (lambda ()
      ---)
    (lambda ()
      (closedir stream))))

(with-compensations
  (let ((stream (opendir/c "/home/marco/share/sounds")))
    ---))
@end example


@deffn Function opendir @var{pathname}
@deffnx Parameter opendir-function
@deffnx Function primitive:opendir @var{pathname}
@deffnx Function platform:opendir @var{pathname-cstr}
Open and return a stream associated to the directory selected by the
Scheme string or symbol @var{pathname}.
@end deffn


@deffn Function fdopendir @var{fd}
@deffnx Parameter fdopendir-function
@deffnx Function primitive:fdopendir @var{fd}
@deffnx Function platform:fdopendir @var{fd}
Open and return a stream associated to the directory selected by the
file descriptor @var{fd}.
@end deffn


@deffn Function closedir @var{stream}
@deffnx Parameter closedir-function
@deffnx Function primitive:closedir @var{stream}
@deffnx Function platform:closedir @var{stream}
Close the directory @var{stream} previously opened with @func{opendir}
or @func{fdopendir}.

@quotation
@strong{NOTE} Applying this function to a stream that was opened with
@func{fdopendir}, closes the underlying file descriptor, too.  This is
weird but I have tested it with @file{libc-2.5.so}, so believe me.

This means that we have to avoid closing the file descriptor with
@func{close} (as it is very obscurely written in the @gnu{} C Library
documentation).
@end quotation
@end deffn


@defun opendir/compensated @var{pathname}
@defunx fdopendir/compensated @var{fd}
@defunx opendir/c @var{pathname}
@defunx fdopendir/c @var{fd}
Like @func{opendir} and @func{fdopendir}, but push the appropriate call
to @func{closedir} on the dynamic environment of the current
compensation stack.  @nauref{compensations, Compensation stacks}
@end defun


@deffn Function dirfd @var{stream}
@deffnx Parameter dirfd-function
@deffnx Function primitive:dirfd @var{stream}
@deffnx Function platform:dirfd @var{stream}
Return the file descriptor associated to the directory @var{stream}
previously opened with @func{opendir} or @func{fdopendir}.
@end deffn

@c page
@node file directory access read
@subsection Reading a directory stream


The following functions manage reading the special @dfn{stream} objects
used to access directory contents.  @glibcref{Reading/Closing
Directory,Reading and closing a directory stream}.

As a usage example for the low level functions, let's see how
@func{directory-entries} is implemented:

@example
(define (%directory-entries dir)
  (let loop ((entry  (readdir_r dir))
             (layout '()))
    (if (pointer-null? entry)
        layout
      (loop (readdir_r dir)
            (cons (dirent-name->string entry) layout)))))

(define (directory-entries pathname)
  (with-compensations
    (%directory-entries (opendir/compensated pathname))))
@end example

@noindent
to read a directory and sort the entries:

@example
(list-sort string<? (directory-entries "/home/marco"))
@end example

@noindent
to read a directory using the file descriptor and the @gnu{} flag
@code{O_NOATIME}:

@example
(with-compensations
  (letrec ((fd (compensate
                   (open the-root
                         (if (number? O_NOATIME)
                             (bitwise-ior O_RDONLY
                                          O_NOATIME)
                           O_RDONLY)
                         0)
                 (with
                  (close fd)))))
    (directory-entries/fd fd)))
@end example


@deffn Function readdir @var{stream}
@deffnx Parameter readdir-function
@deffnx Function primitive:readdir @var{stream}
@deffnx Function platform:readdir @var{stream}
Return a pointer to a statically allocated @code{struct dirent}
describing the next entry from the directory @var{stream}, previously
opened with @func{opendir} or @func{fdopendir}.

Notice that the returned strings are the names of the entries relative
to the uplevel directory.  No slash and no parent directory part are in
there.
@end deffn


@deffn Function readdir_r @var{stream}
@deffnx Parameter readdir_r-function
@deffnx Function primitive:readdir_r @var{stream}
@deffnx Function platform:readdir_r @var{stream}
Like @func{readdir}, but operates in a reentrant manner.
@end deffn


@defun directory-entries @var{pathname}
@defunx directory-entries/fd @var{fd}
High--level functions that open the directory selected by the Scheme
string or symbol @var{pathname} or file descriptor @var{fd}, read all
the entries and return a list of Scheme strings holding the entry names.

It makes use of @func{opendir}, @func{closedir} and @func{readdir_r}.
@end defun


@defun dirent-name->string @var{struct-dirent-pointer}
@defunx primitive:dirent-name->string @var{struct-dirent-pointer}
Build and return a Scheme string containing the name of the directory
described by @var{struct-dirent-pointer}.
@end defun

@c page
@node file directory access seek
@subsection Random access to a directory stream


The following function handle seeking the current position in the
special @dfn{stream} objects used to access directory contents.
@glibcref{Random Access Directory, Random Access in a Directory Stream}.

For the following bindings: The @code{platform:} functions return a
@strong{single} value, they do not use @code{errno} to signal errors.


@deffn Function rewinddir @var{stream}
@deffnx Parameter rewinddir-function
@deffnx Function primitive:rewinddir @var{stream}
@deffnx Function platform:rewinddir @var{stream}
Rewind to the first entry the directory @var{stream} previously opened
with @func{opendir} or @func{fdopendir}.
@end deffn


@deffn Function telldir @var{stream}
@deffnx Parameter telldir-function
@deffnx Function primitive:telldir @var{stream}
@deffnx Function platform:telldir @var{stream}
Return an exact integer representing the current position in the
directory @var{stream} previously opened with @func{opendir} or
@func{fdopendir}.

Notice that returned values look like arbitrary integers, they do not
follow a predictable sequence.
@end deffn


@deffn Function seekdir @var{stream} @var{position}
@deffnx Parameter seekdir-function
@deffnx Function primitive:seekdir @var{stream} @var{position}
@deffnx Function platform:seekdir @var{stream} @var{position}
Seek to @var{position} the directory @var{stream} previously opened with
@func{opendir} or @func{fdopendir}.  @var{position} must be a value
previously returned by @func{telldir}.
@end deffn

@c page
@node file directory access scan
@subsection Scanning a directory


The following functions implement the scan operation of directory
entries.  @glibcref{Scanning Directory Content, Scanning the Content of
a Directory}.  All the following bindings are exported by the Glibc
@code{file} libraries.

Usage example: Sort the entries in increasing lexicographic order,
excluding the dots:

@smallexample
(scandir "/some/path/name"
         (make-scandir-selector-callback
            (lambda (struct-dirent)
              (let ((name (dirent-name->string struct-dirent)))
                (not (or (string=? "."  name)
                         (string=? ".." name))))))
         platform:alphasort)
@end smallexample

@noindent
and if we want to sort the entries in decreasing lexicographic order:

@example
(scandir "/some/path/name"
         (make-scandir-selector-callback
          (lambda (struct-dirent)
            #t))
         (make-scandir-compare-callback
          (lambda (a b)
            (let ((a (dirent-name->string a))
                  (b (dirent-name->string b)))
              (cond ((string<? a b) +1)
                    ((string>? a b) -1)
                    (else            0))))))
@end example


@deffn Function scandir @var{pathname} @var{selector} @var{compare}
@deffnx Parameter scandir-function
@deffnx Function primitive:scandir @var{pathname} @var{selector} @var{compare}
@deffnx Function platform:scandir @var{pathname} @var{namelist} @var{selector} @var{compare}
Scan the directory selected by @var{pathname}, which must be a string or
symbol, and return a list of Scheme strings representing the names of
the entries in the directory.

@var{selector} and @var{compare} must be raw pointers to C language
functions, either native or built with @func{make-c-callback}.
@nauref{ffi call back, Calling Scheme functions}.

The function referenced by @var{selector} takes a pointer to
@code{struct dirent} as argument and must return: @samp{1} if the entry
has to be included in the output, @samp{0} if it has to be excluded.

The function referenced by @var{compare} takes two pointers of type
@code{struct dirent **} as arguments and must return a ternary
comparison result (as @cfunc{strcmp} does).
@end deffn


@defun make-scandir-selector-callback @var{scheme-function}
@defunx make-scandir-compare-callback @var{scheme-function}
@defunx primitive:make-scandir-selector-callback @var{scheme-function}
@defunx primitive:make-scandir-compare-callback @var{scheme-function}
Given a Scheme function, return a callback pointer to be used as
@var{selector} or @var{compare} argument to @func{scandir}.  They are
implemented as follows:

@smallexample
(define (make-scandir-selector-callback scheme-function)
  (make-c-callback int
    (lambda (struct-dirent)
      (if (scheme-function struct-dirent) 1 0))
    (void*)))

(define (make-scandir-compare-callback scheme-function)
  (make-c-callback int scheme-function (void* void*)))
@end smallexample
@end defun


@defvr {Function Pointer} platform:alphasort
@defvrx {Function Pointer} platform:versionsort
Raw pointers to comparison functions exported by the @gnu{} C Library;
they are meant to be used as @var{compare} arguments for the
@func{scandir} function.

@func{alphasort} will sort the strings in increasing lexicographic
order.
@end defvr

@c page
@node file directory access tree
@subsection Scanning a hierarchy of directories


The following functions manage to scan a hierarchy of directories.
@glibcref{Working with Directory Trees, Working with Directory Trees}.

Usage example to just list the tree entries:

@example
(define-syntax set-cons!
  (syntax-rules ()
    ((_ ?name ?form)
     (set! ?name (cons ?form ?name)))))

(begin0-let ((result '()))
  (ftw "/some/path/name"
       (make-ftw-callback (lambda (pathname stat flag)
                            (set-cons! result pathname)))
       5))
@end example


@deffn Function ftw @var{pathname} @var{inspector} @var{descriptors}
@deffnx Parameter ftw-function
@deffnx Function primitive:ftw @var{pathname} @var{inspector} @var{descriptors}
@deffnx Function primitive:ftw @var{pathname-cstr} @var{inspector} @var{descriptors}
Invoke the C language function referenced by the raw pointer
@var{inspector} for each entry in the directory hierarchy whose root is
@var{pathname}, which must be a Scheme string or symbol.

The callback function referenced by @var{inspector} can be a C language
coded one or a callback built with @func{make-c-callback}; @nauref{ffi
call back, Calling Scheme functions}.  The callback takes three
arguments: a pointer to the current pathname as a C string, a pointer to
a @code{struct stat} for the current pathname, an exact integer holding
flag values.

@var{descriptors} is the number of file descriptors the system is
allowed to use while walking the directory tree.
@end deffn


@deffn Function nftw @var{pathname} @var{inspector} @var{descriptors} @var{flags}
@deffnx Parameter nftw-function
@deffnx Function primitive:nftw @var{pathname} @var{inspector} @var{descriptors} @var{flags}
@deffnx Function primitive:nftw @var{pathname-cstr} @var{inspector} @var{descriptors} @var{flags}
Invoke the C language function referenced by the raw pointer
@var{inspector} for each entry in the directory hierarchy whose root is
@var{pathname}, which must be a Scheme string or symbol.

The callback function referenced by @var{inspector} can be a C language
coded one or a callback built with @func{make-c-callback}.  @nauref{ffi
call back, Calling Scheme functions}.  The callback takes four
arguments: a pointer to the current pathname as a C string, a pointer to
a @code{struct stat} for the current pathname, a pointer to a
@code{struct FTW} for the current pathname, an exact integer holding
flag values.

@var{descriptors} is the number of file descriptors the system is
allowed to use while walking the directory tree.  @var{flags} is an
inclusive OR-ed combination of flag values used to configure the
iteration; to select no flags, we can use zero.
@end deffn


@defun make-ftw-callback @var{scheme-function}
@defunx make-nftw-callback @var{scheme-function}
@defunx primitive:make-ftw-callback @var{scheme-function}
@defunx primitive:make-nftw-callback @var{scheme-function}
Build and return a callback to be used with @func{ftw} and @func{nftw};
they are implemented as follows:

@smallexample
(define (make-ftw-callback scheme-function)
  (make-c-callback int
     (lambda (pathname-cstr struct-stat flag)
       (guard (E (else -1))
         (scheme-function (cstring->string pathname-cstr)
                          (if (= 0 (bitwise-and flag FTW_NS))
                              #f
                            (struct-stat->record struct-stat))
                          flag)))
     (char* void* int)))

(define (make-nftw-callback scheme-function)
  (make-c-callback int
     (lambda (pathname-cstr struct-stat flag struct-ftw)
       (guard (E (else -1))
         (scheme-function (cstring->string pathname-cstr)
                          (if (= 0 (bitwise-and flag FTW_NS))
                              #f
                            (struct-stat->record struct-stat))
                          flag
                          (struct-ftw-base-ref  struct-ftw)
                          (struct-ftw-level-ref struct-ftw))))
     (char* void* int void*)))
@end smallexample
@end defun


The following bindings are exported by the @code{sizeof} library.


@deffn Syntax struct-ftw-base-ref @var{pointer}
@deffnx Syntax struct-ftw-level-ref @var{pointer}
Accessors for the @code{base} and @code{level} fields of a @code{struct
FTW} type.
@end deffn


@defvr Constant FTW_F
@defvrx Constant FTW_D
@defvrx Constant FTW_NS
@defvrx Constant FTW_DNR
@defvrx Constant FTW_SL
Flags used for the @var{flag} argument to the @func{ftw} and @func{nftw}
callbacks; we should use @func{bitwise-and} to test for them.
@end defvr


@defvr Constant FTW_DP
@defvrx Constant FTW_SLN
Additional flag values used for the @var{flag} argument to the
@func{nftw} callback; we should use @func{bitwise-and} to test for them.
@end defvr


@defvr Constant FTW_PHYS
@defvrx Constant FTW_MOUNT
@defvrx Constant FTW_CHDIR
@defvrx Constant FTW_DEPTH
@defvrx Constant FTW_ACTIONRETVAL
Flags for the @var{flags} arguments to @func{nftw};  we must use
@func{bitwise-ior} to compose them.
@end defvr


@defvr Constant FTW_CONTINUE
@defvrx Constant FTW_STOP
@defvrx Constant FTW_SKIP_SUBTREE
@defvrx Constant FTW_SKIP_SIBLINGS
Possible return values for the callback to @func{nftw} when the
@samp{FTW_ACTIONRETVAL} flag is used in the @var{flags} argument.
@end defvr

@c page
@node file links
@section Hard and symbolic links


@cindex @cfunc{canonicalize_file_name}


The following functions manage hard and symbolic links to files.
@glibcref{Hard Links,Hard Links}.  @glibcref{Symbolic Links,Symbolic
Links}.


@deffn Function link @var{old-pathname} @var{new-pathname}
@deffnx Parameter link-function
@deffnx Function primitive:link @var{old-pathname} @var{new-pathname}
@deffnx Function platform:link @var{old-pathname-cstr} @var{new-pathname-cstr}
Link to the new name specified by the Scheme string or symbol
@var{new-pathname}, the file selected by the Scheme string or symbol
@var{old-pathname}.
@end deffn


@deffn Function symlink @var{old-pathname} @var{new-pathname}
@deffnx Parameter symlink-function
@deffnx Function primitive:symlink @var{old-pathname} @var{new-pathname}
@deffnx Function platform:symlink @var{old-pathname-cstr} @var{new-pathname-cstr}
Symbolically link to the new name specified by the Scheme string or
symbol @var{new-pathname}, the file selected by the Scheme string or
symbol @var{old-pathname}.
@end deffn


@deffn Function readlink @var{pathname}
@deffnx Parameter readlink-function
@deffnx Function primitive:readlink @var{pathname}
@deffnx Function platform:readlink @var{pathname-cstr}
Return a string representing the value of the symbolic link
@var{pathname}, which must be a Scheme string or symbol.
@end deffn


@deffn Function realpath @var{pathname}
@deffnx Parameter realpath-function
@deffnx Function primitive:realpath @var{pathname}
@deffnx Function platform:realpath @var{pathname-cstr} @var{buffer-ptr}
Return a string representing the absolute name of the file represented
by @var{pathname}, which must be a Scheme string or symbol.  The
returned name contains neither @samp{.} or @samp{..} components, nor
sequences of path separators (slashes).

@quotation
@strong{NOTE} The @gnu{} C Library exports the function
@cfunc{canonicalize_file_name} which does the same work of
@func{realpath}; for this reason it is not exposed at the Scheme level.
@end quotation
@end deffn

@c page
@node file remove
@section Removing files and directories


The following functions manage removal of files and directories from a
file system.  @glibcref{Deleting Files,Deleting Files}.


@deffn Function unlink @var{pathname}
@deffnx Parameter unlink-function
@deffnx Function primitive:unlink @var{pathname}
@deffnx Function platform:unlink @var{pathname}
Remove the file selected by the Scheme string or symbol @var{pathname}.
@end deffn


@deffn Function remove @var{pathname}
@deffnx Parameter remove-function
@deffnx Function primitive:remove @var{pathname}
@deffnx Function platform:remove @var{pathname}
Remove the file or directory selected by the Scheme string or symbol
@var{pathname}.
@end deffn


@deffn Function rmdir @var{pathname}
@deffnx Parameter rmdir-function
@deffnx Function primitive:rmdir @var{pathname}
@deffnx Function platform:rmdir @var{pathname}
Remove the directory selected by the Scheme string or symbol
@var{pathname}.  The directory has to be empty.
@end deffn

@c page
@node file rename
@section Renaming files and directories


The following functions manage renaming of files and directories from a
file system.  @glibcref{Renaming Files,Renaming Files}.


@deffn Function rename @var{old-pathname} @var{new-pathname}
@deffnx Parameter rename-function
@deffnx Function primitive:rename @var{old-pathname} @var{new-pathname}
@deffnx Function platform:rename @var{old-pathname} @var{new-pathname}
Rename the file selected by the string or symbol @var{old-pathname} to
the pathname selected by the string or symbol @var{new-pathname}.
@end deffn

@c page
@node file mkdir
@section Creating directories


The following functions manage creating new directories.
@glibcref{Creating Directories, Creating Directories}.


@deffn Function mkdir @var{pathname}
@deffnx Parameter mkdir-function
@deffnx Function primitive:mkdir @var{pathname}
@deffnx Function platform:mkdir @var{pathname}
Create a new directory with pathname selected by the Scheme string or
symbol @var{pathname}.
@end deffn

@c page
@node file attr
@section Changing file attributes


The functions described in this section manage file and directory
attributes.  @glibcref{File Attributes, File Attributes}.

@menu
* file attr owner::             Changing owner and group.
* file attr mode::              Changing file permissions.
* file attr access::            Testing access.
* file attr size::              Size of files.
@end menu

@c page
@node file attr owner
@subsection File owner and group


The following functions manage file ownership attributes.
@glibcref{File Owner, File Owner}.


@deffn Function chown @var{pathname} @var{owner-id} @var{group-id}
@deffnx Parameter chown-function
@deffnx Function primitive:chown @var{pathname} @var{owner-id} @var{group-id}
@deffnx Function platform:chown @var{pathname-cstr} @var{owner-id} @var{group-id}
Change the file owner and group to the given numeric identifiers.
@var{pathname} must be a Scheme string or symbol representing a
pathname.
@end deffn


@deffn Function fchown @var{fd} @var{owner-id} @var{group-id}
@deffnx Parameter fchown-function
@deffnx Function primitive:fchown @var{fd} @var{owner-id} @var{group-id}
@deffnx Function platform:fchown fchown @var{fd} @var{owner-id} @var{group-id}
Change the file owner and group to the given numeric identifiers.
@var{fd} must be a file descriptor.
@end deffn

@c page
@node file attr mode
@subsection Changing file permissions


The following functions manage file access permissions.
@glibcref{Setting Permissions, Assigning File Permissions}.

The @var{mask} argument must be an exact integer representing access
permissions bits.  @ref{fd constants perms} for details about composing
the the mask value as a bitwise combination of predefined constants.


@deffn Function umask @var{mask}
@deffnx Parameter umask-function
@deffnx Function primitive:umask @var{mask}
@deffnx Function platform:umask @var{mask}
Set the umask to @var{mask} and return the old mask value.  To query the
current mask without changing it:

@example
(let ((m (umask 0)))
  (umask m)
  m)
@end example

@noindent
or use @func{getumask}, which has exactly this implementation.
@end deffn


@defun getumask
@defunx primitive:getumask
Return the current umask.
@end defun


@deffn Function chmod @var{pathname} @var{mask}
@deffnx Parameter chmod-function
@deffnx Function primitive:chmod @var{pathname} @var{mask}
@deffnx Function platform:chmod @var{pathname-cstr} @var{mask}
Change the file access permissions bits to the given numeric mask.
@var{pathname} must be a Scheme string or symbol representing a
pathname.
@end deffn


@deffn Function fchmod @var{fd} @var{mask}
@deffnx Parameter fchmod-function
@deffnx Function primitive:fchmod @var{fd} @var{mask}
@deffnx Function platform:fchmod @var{fd} @var{mask}
Change the file access permissions bits to the given numeric mask.
@var{fd} must be a file descriptor.
@end deffn

@c page
@node file attr access
@subsection Testing access


The following functions manage testing if the process has access
permissions for a file or directory.  @glibcref{Testing File Access,
Testing permission to access a file}.

Example:

@example
(access "file.ext" (bitwise-ior R_OK W_OK))
@end example


@deffn Function access @var{pathname} @var{mask}
@deffnx Parameter access-function
@deffnx Function primitive:access @var{pathname} @var{mask}
@deffnx Function platform:access @var{pathname-cstr} @var{mask}
Return @true{} if the process has permission to access the file selected
by the Scheme string or symbol @var{pathname} as specified by
@var{mask}; return @false{} otherwise.

@var{mask} can be the bitwise combination of: @code{F_OK}, @code{R_OK},
@code{W_OK}, @code{X_OK}.
@end deffn


@defvr Constant F_OK
@defvrx Constant R_OK
@defvrx Constant W_OK
@defvrx Constant X_OK
Constants representing requests for access permission testing with
@func{access}.  These bindings are exported by @library{foreign posix
sizeof}.
@end defvr

@c page
@node file attr size
@subsection Size of files


@deffn Function file-size @var{fd/pathname}
@deffnx Parameter file-size-function
@deffnx Function primitive:file-size @var{fd/pathname}
Return the size of the selected file.  @var{fd/pathname} can be a file
descriptor or a pathname in the form of a Scheme string or symbol.

This function is implemented using @func{lseek} as described in @ref{fd
seek, Setting the file position}.
@end deffn


@deffn Function truncate @var{fd/pathname} @var{length}
@deffnx Parameter truncate-function
@deffnx Function primitive:truncate @var{fd/pathname} @var{length}
@deffnx Function platform:truncate @var{fd/pathname-cstr} @var{length}
Set to @var{length} the size of the selected file.  @var{fd/pathname}
can be a file descriptor or a pathname in the form of a Scheme string or
symbol.
@end deffn


@deffn Function ftruncate @var{fd/pathname} @var{length}
@deffnx Parameter ftruncate-function
@deffnx Function primitive:ftruncate @var{fd/pathname} @var{length}
@deffnx Function platform:ftruncate @var{fd/pathname-cstr} @var{length}
Set to @var{length} the size of the selected file.  @var{fd/pathname}
can be a file descriptor or a pathname in the form of a Scheme string or
symbol.
@end deffn

@c page
@node file temp
@section Temporary files


The following functions manage the creation of temporary files and
directories.  @glibcref{Temporary Files, Temporary Files}.

Usage example:

@example
(let-values (((fd pathname) (mkstemp "/tmp/XXXXXX")))
  ---
  (close fd)
  (delete-file pathname))
@end example


@deffn Function mkstemp @var{template}
@deffnx Parameter mkstemp-function
@deffnx Function primitive:mkstemp @var{template}
@deffnx Function platform:mkstemp @var{template-cstr}
Return two values: a file descriptor and a file pathname as Scheme
string.  The pathname is built from the Scheme string or symbol
@var{template}, which must include the @code{XXXXXX} sequence of
characters (six times @code{X}).  @var{template} is @strong{not}
mutated.
@end deffn


@deffn Function mkdtemp @var{template}
@deffnx Parameter mkdtemp-function
@deffnx Function primitive:mkdtemp @var{template}
@deffnx Function platform:mkdtemp @var{template-cstr}
Create a new directory and return its pathname as Scheme string.  The
pathname is built from the Scheme string or symbol @var{template}, which
must include the @code{XXXXXX} sequence of characters (six times
@code{X}).  @var{template} is @strong{not} mutated.
@end deffn

@c ------------------------------------------------------------

@subsubheading @gnu{} C Library functions

The following bindings are exported by the Glibc @code{file} libraries.


@deffn Function tmpfile
@deffnx Parameter tmpfile-function
@deffnx Function primitive:tmpfile
@deffnx Function platform:tmpfile
Create a temporary file, open it and return a file stream object.

@quotation
@strong{NOTE} This function is @posix{} compliant, but it is exported by
a Glibc function because it makes use of @code{FILE *} streams.  It is
decided that streams--related functions are not to be exported by the
@posix{} libraries.
@end quotation
@end deffn


@deffn Function mktemp @var{template}
@deffnx Parameter mktemp-function
@deffnx Function primitive:mktemp @var{template}
@deffnx Function platform:mktemp @var{template-cstr}
Return a file pathname, as Scheme string, that, at the time of the call,
does not exist on the system.  The pathname is built from the Scheme
string or symbol @var{template}, which must include the @code{XXXXXX}
sequence of characters (six times @code{X}).  @var{template} is
@strong{not} mutated.
@end deffn


@deffn Function tempnam @var{directory} @var{prefix}
@deffnx Parameter tempnam-function
@deffnx Function primitive:tempnam @var{directory} @var{prefix}
@deffnx Function platform:tempnam @var{directory-cstr} @var{prefix-cstr}
Build and return a file pathname, as Scheme string, that, at the time of
the call, does not exists on the system.  @var{directory} and
@var{prefix} can be Scheme string or symbols or @false{} (inplace of
@cnull{} pointers).  @var{directory} is used as directory pathname in
which to create the temporary file; @var{prefix} is used as prefix for
the file name.
@end deffn


@deffn Function tmpnam
@deffnx Parameter tmpnam-function
@deffnx Function primitive:tmpnam
@deffnx Function platform:tmpnam
Return a file pathname, as Scheme string, that, at the time of the call,
does not exist on the system.  The implementation of
@func{primitive:tmpnam} is reentrant.
@end deffn

@c page
@node file times
@section Setting file times


@deffn Function utime @var{pathname}
@deffnx Function utime @var{pathname} @var{access-time} @var{modification-time}
@deffnx Parameter utime-function
@deffnx Function primitive:utime @var{pathname}
@deffnx Function primitive:utime @var{pathname} @var{access-time} @var{modification-time}
@deffnx Function platform:utime @var{pathname-cstr} @var{utimbuf-pointer}
Set the access and modification times for the file selected by
@var{pathname}, which must be a Scheme string or symbol.  If
@var{access-time} and @var{modification-time} are not given, set the
times to the current time.

@quotation
@strong{NOTE} The @acronym{SUS}@footnote{Single @acronym{UNIX}
Specification.

@center @url{http://www.unix.org/single_unix_specification/}
} states that an implementation may choose not to set the access time of
the file, even though it is requested by the @cfunc{utime} call.
@end quotation
@end deffn

@deffn Function utimes @var{pathname}
@deffnx Function utimes @var{pathname} @var{atime} @var{atime-usec} @var{mtime} @var{mtime-usec}
@deffnx Parameter utimes-function
@deffnx Function primitive:utimes @var{pathname}
@deffnx Function primitive:utimes @var{pathname} @var{atime} @var{atime-usec} @var{mtime} @var{mtime-usec}
@deffnx Function platform:utimes @var{pathname-cstr} @var{utimbuf-pointer}
Set the access and modification times, both the integer part and the
fractional part, for the file selected by @var{pathname}, which must be
a Scheme string or symbol.  If the time arguments are not given, set the
times to the current time.
@end deffn


@c ------------------------------------------------------------

@subsubheading @gnu{} C Library functions

The following bindings are exported by the Glibc @code{file} library.
@deffn Function lutimes @var{pathname}
@deffnx Function lutimes @var{pathname} @var{atime} @var{atime-usec} @var{mtime} @var{mtime-usec}
@deffnx Parameter lutimes-function
@deffnx Function primitive:lutimes @var{pathname}
@deffnx Function primitive:lutimes @var{pathname} @var{atime} @var{atime-usec} @var{mtime} @var{mtime-usec}
@deffnx Function platform:lutimes @var{pathname-cstr} @var{utimbuf-pointer}
Like @func{utimes}, but does not follow symbolic links.
@end deffn


@deffn Function futimes @var{fd}
@deffnx Function futimes @var{fd} @var{atime} @var{atime-usec} @var{mtime} @var{mtime-usec}
@deffnx Parameter futimes-function
@deffnx Function primitive:futimes @var{fd}
@deffnx Function primitive:futimes @var{fd} @var{atime} @var{atime-usec} @var{mtime} @var{mtime-usec}
@deffnx Function platform:futimes @var{fd} @var{utimbuf-pointer}
Like @func{utimes}, but act upon the file associated to the given file
descriptor.
@end deffn

@c page
@node stat
@chapter Inspecting file attributes


Unless otherwise specified, the bindings described in this section are
exported by the @posix{} @code{stat} libraries.

@menu
* stat constants::              Constant values and structure accessors.
* stat record::                 Acquiring the file attributes.
* stat api::                    Interface functions.
* stat type::                   Type inspection.
* stat perms::                  Access permissions inspection.
@end menu

@c page
@node stat constants
@section Constant values and structures accessors


The following bindings are exported by the @library{foreign posix stat
platform} library; this is because @code{struct stat} is somewhat
``special'', so we relay on the @file{libnausicaa-posix.so} stub library
to deal with it.


@defvr Constant sizeof-stat
The size of the @code{struct stat} data structure in bytes.  This
binding is exported by @library{foreign posix stat platform}.
@end defvr


@defun struct-stat-st_mode-ref @var{stat-pointer}
@defunx struct-stat-st_ino-ref @var{stat-pointer}
@defunx struct-stat-st_dev-ref @var{stat-pointer}
@defunx struct-stat-st_nlink-ref @var{stat-pointer}
@defunx struct-stat-st_uid-ref @var{stat-pointer}
@defunx struct-stat-st_gid-ref @var{stat-pointer}
@defunx struct-stat-st_size-ref @var{stat-pointer}
@defunx struct-stat-st_atime-ref @var{stat-pointer}
@defunx struct-stat-st_atime_usec-ref @var{stat-pointer}
@defunx struct-stat-st_mtime-ref @var{stat-pointer}
@defunx struct-stat-st_mtime_usec-ref @var{stat-pointer}
@defunx struct-stat-st_ctime-ref @var{stat-pointer}
@defunx struct-stat-st_ctime_usec-ref @var{stat-pointer}
@defunx struct-stat-st_blocks-ref @var{stat-pointer}
@defunx struct-stat-st_blksize-ref @var{stat-pointer}
Accessors for the named field of a @code{struct stat}.  Notice that some
field may be undefined on some platform (examples: @code{st_atime_usec},
@code{st_mtime_usec}, @code{st_ctime_usec}), in this case the return
value is zero.
@end defun

@c page
@node stat record
@section Acquiring the file attributes


The following bindings are exported by the @library{foreign posix stat
record-types} library.  The informations about a file or directory can
be stored in a Scheme record.  @glibcref{Attribute Meanings, The meaning
of the File Attributes}.


@deftp {Record Type Name} <struct-stat>
@deftpx {Record Type Descriptor} <struct-stat-rtd>
Type of record used to hold fields from a @code{struct stat}.  List of
fields follows:

@example
mode            ino
dev             nlink
uid             gid
size
atime           atime_usec
mtime           mtime_usec
ctime           ctime_usec
blocks          blksize
@end example

@noindent
all the fields are immutable; we have to refer to the original
documentation of @code{struct stat} for their meaning.

Some fields are not available on every platform in the foreign
@code{struct stat} data structure; in this case the associated field in
the @class{struct-stat} record should be set to @false{}.  For example
@code{atime_usec}, @code{mtime_usec}, @code{ctime_usec} are not
available on some common platforms.
@end deftp


@defun make-<struct-stat> @var{mode} @var{ino} @var{dev} @var{nlink} @var{uid} @var{gid} @var{size} @var{atime} @var{atime_usec} @var{mtime} @var{mtime_usec} @var{ctime} @var{ctime_usec} @var{blocks} @var{blksize}
Build and return a new @class{struct-stat} record.
@end defun


@defun <struct-stat>? @var{obj}
Return @true{} if @var{obj} is a @class{struct-stat} record.
@end defun


@defun <struct-stat>-mode @var{struct-stat}
@defunx <struct-stat>-ino @var{struct-stat}
@defunx <struct-stat>-dev @var{struct-stat}
@defunx <struct-stat>-nlink @var{struct-stat}
@defunx <struct-stat>-uid @var{struct-stat}
@defunx <struct-stat>-gid @var{struct-stat}
@defunx <struct-stat>-size @var{struct-stat}
@defunx <struct-stat>-atime @var{struct-stat}
@defunx <struct-stat>-atime_usec @var{struct-stat}
@defunx <struct-stat>-mtime @var{struct-stat}
@defunx <struct-stat>-mtime_usec @var{struct-stat}
@defunx <struct-stat>-ctime @var{struct-stat}
@defunx <struct-stat>-ctime_usec @var{struct-stat}
@defunx <struct-stat>-blocks @var{struct-stat}
@defunx <struct-stat>-blksize @var{struct-stat}
Accessors for the fields of a @class{struct-stat} record.
@end defun


@defun struct-stat->record @var{pointer}
Given a pointer to a block of memory holding a foreign @code{struct
stat}, build and return a @class{struct-stat} record.  All the fields
that are not available in the foreign structure are set to zero.
@end defun

@c page
@node stat api
@section Interface functions


The following bindings manage file attributes inspection.
@glibcref{Reading Attributes, Reading Attributes}.


@deffn Function stat @var{pathname}
@deffnx Parameter stat-function
@deffnx Function primitive:stat @var{pathname}
@deffnx Function platform:stat @var{pathname-cstr} @var{pointer}
Return a @class{struct-stat} record filled with attributes of the file or
directory selected by the Scheme string or symbol @var{pathname}.
@end deffn


@deffn Function fstat @var{fd}
@deffnx Parameter fstat-function
@deffnx Function primitive:fstat @var{fd}
@deffnx Function platform:fstat @var{fd} @var{pointer}
Return a @class{struct-stat} record filled with attributes of the file or
directory selected by the file descriptor @var{fd}.
@end deffn


@deffn Function lstat @var{pathname}
@deffnx Parameter lstat-function
@deffnx Function primitive:lstat @var{pathname}
@deffnx Function platform:lstat @var{pathname-cstr} @var{pointer}
Return a @class{struct-stat} record filled with attributes of the
symbolic link selected by the Scheme string or symbol @var{pathname}.
@end deffn

@c page
@node stat type
@section Type inspection


The integer in the @code{mode} field of a @class{struct-stat} record can
be inspected with the following functions.  Unless otherwise specified,
the following bindings are exported by the @library{foreign posix stat}
library.


@defun file-is-directory? @var{fd/pathname}
@defunx file-is-character-special? @var{fd/pathname}
@defunx file-is-block-special? @var{fd/pathname}
@defunx file-is-regular? @var{fd/pathname}
@defunx file-is-fifo? @var{fd/pathname}
@defunx file-is-socket? @var{fd/pathname}
Return @true{} if @var{fd/pathname} is associated to a file of the named
type, @false{} otherwise.  @var{fd/pathname} can be a file descriptor or
a Scheme string or symbol representing a pathname.  The @code{mode}
field of @code{struct stat} is acquired with a call to @func{fstat} or
@func{stat}.

@quotation
@strong{NOTE} There is no way to distinguish between an integer
representing a file descriptor and an integer representing the
@code{mode} field, so the argument to these functions @strong{cannot} be
a mode field.
@end quotation
@end defun


@defun file-is-symbolic-link? @var{pathname}
Return @true{} if @var{pathname} is associated to a symbolic link,
@false{} otherwise.  @var{pathname} must be a Scheme string or symbol
representing a pathname.  The @code{mode} field of @code{struct stat} is
acquired with a call to @func{lstat}.
@end defun


@defun file-is-message-queue? @var{fd/pathname}
@defunx file-is-semaphore? @var{fd/pathname}
@defunx file-is-shared-memory? @var{fd/pathname}
Return @true{} if @var{fd/pathname} is associated to a file of the named
type, @false{} otherwise.  @var{fd/pathname} can be a file descriptor or
a Scheme string or symbol representing a pathname.

Unfortunately, these predicates require access to the full @code{struct
stat}, so, at present, they are implemented with the low--level
@func{platform:stat} and @func{platform:fstat}.  This prevents using
parameterised functions like @func{stat} and @func{fstat}.
@end defun

@c ------------------------------------------------------------

@subsubheading Low--level predicates

The following bindings are exported by the libraries:

@example
(foreign posix stat)
(foreign posix stat primitives)
(foreign posix stat platform)
@end example


@defun S_ISDIR @var{mode}
@defunx S_ISCHR @var{mode}
@defunx S_ISBLK @var{mode}
@defunx S_ISREG @var{mode}
@defunx S_ISFIFO @var{mode}
@defunx S_ISLNK @var{mode}
@defunx S_ISSOCK @var{mode}
Return non--zero if the file or directory associated with the integer
@var{mode} is of the named type, otherwise return zero.
@end defun


@defun S_TYPEISMQ @var{pointer}
@defunx S_TYPEISSEM @var{pointer}
@defunx S_TYPEISSHM @var{pointer}
Return non--zero if the file or directory associated with the
@code{struct stat} referenced by @var{pointer} is of the named type,
otherwise return zero.
@end defun

@c page
@node stat perms
@section Access permissions inspection


Access permissions can be inspected with a bitwise combination between
the @code{mode} field of @code{struct stat} and the permissions
constants, @ref{fd constants perms}.  For example, the following
evaluates to @false{} if @file{/bin/ls} is readable by its owner:

@example
(= 0 (bitwise-and S_IRUSR
                  (<struct-stat>-mode (stat "/bin/ls"))))
@end example

@noindent
while the following evaluates to @false{} if @file{/bin/ls} is readable
both by its owner and group:

@example
(= 0 (bitwise-and (bitwise-ior S_IRUSR S_IRGRP)
                  (<struct-stat>-mode (stat "/bin/ls"))))
@end example

The following bindings are exported by the @library{foreign posix stat}
library.


@defun file-user-readable? @var{fd/pathname}
@defunx file-user-writable? @var{fd/pathname}
@defunx file-user-executable? @var{fd/pathname}
@defunx file-group-readable? @var{fd/pathname}
@defunx file-group-writable? @var{fd/pathname}
@defunx file-group-executable? @var{fd/pathname}
@defunx file-other-readable? @var{fd/pathname}
@defunx file-other-writable? @var{fd/pathname}
@defunx file-other-executable? @var{fd/pathname}
@defunx file-setuid? @var{fd/pathname}
@defunx file-setgid? @var{fd/pathname}
@defunx file-sticky? @var{fd/pathname}
Return @true{} if the named permission bit is set, @false{} otherwise.
@var{fd/pathname} can a file descriptor or a Scheme string or symbol
representing a pathname.  The @code{mode} field of @code{struct stat} is
acquired with a call to @func{fstat} or @func{stat}.
@end defun


@defun lfile-user-readable? @var{pathname}
@defunx lfile-user-writable? @var{pathname}
@defunx lfile-user-executable? @var{pathname}
@defunx lfile-group-readable? @var{pathname}
@defunx lfile-group-writable? @var{pathname}
@defunx lfile-group-executable? @var{pathname}
@defunx lfile-other-readable? @var{pathname}
@defunx lfile-other-writable? @var{pathname}
@defunx lfile-other-executable? @var{pathname}
@defunx lfile-setuid? @var{pathname}
@defunx lfile-setgid? @var{pathname}
@defunx lfile-sticky? @var{pathname}
Return @true{} if the named permission bit is set, @false{} otherwise.
@var{pathname} must be a Scheme string or symbol representing a
pathname.  The the @code{mode} field of @code{struct stat} is acquired
with @func{lstat}.
@end defun


@defun file-permissions @var{fd/pathname}
@defunx lfile-permissions @var{pathname}
Return an exact integer representing the access permissions bits from
the @code{mode} field of a @code{struct stat}.

For @func{file-permissions}: @var{fd/pathname} can be a file descriptor
or a pathname in the form of a Scheme string or symbol; the mode is
acquired with a call to @func{fstat} or @func{stat}.

For @func{lfile-permissions}: @var{pathname} must be a pathname in the
form of a Scheme string or symbol; the mode is acquired with a call to
@func{lstat}.

The returned value can be examined and manipulated using the @code{S_*}
constants (@pxref{fd constants perms}) and also used as argument for a
call to @func{chmod} or @func{fchmod}.
@end defun

@c page
@node fd
@chapter File descriptors


Unless otherwise specified, the bindings described in this chapter are
exported by the following libraries:

@example
(foreign posix fd)
(foreign posix fd primitives)
(foreign posix fd platform)
@end example

@menu
* fd typedefs::                 File descriptor related data types.
* fd constants::                Constant values and structure accessors.
* fd open close::               Opening and closing.
* fd read write::               Reading and writing.
* fd seek::                     Setting the file position.
* fd sync::                     Synchronisation.
* fd control::                  Control operations.
* fd dup::                      Duplicating file descriptors.
* fd lock::                     File locks.
* fd pipe::                     Pipes and FIFOs.
* fd scatter::                  Scatter/gather input/output.
* fd mmap::                     Memory mapped input/output.
* fd select::                   Waiting for input or output.
@c * fd aio::                      Asynchronous input/output.
* fd custom::                   Custom Scheme ports.
@end menu

@c page
@node fd typedefs
@section File descriptor related data types


Unless otherwise specified, the bindings documented in this section are
exported by the @library{foreign posix typedefs} library.

@menu
* fd typedefs fds::             File descriptors.
* fd typedefs flocks::          File locking.
* fd typedefs fdsets::          File descriptor sets.
@end menu

@c page
@node fd typedefs fds
@subsection File descriptors


Functions from the primitives and high--level file descriptor libraries
accept objects of type @code{file-descriptor} as @var{fd} arguments.
Functions from the platform libraries accept exact integers as
representing file descriptors.


@deftp {Object Type} file-descriptor
Object type representing a file descriptor integer; it is disjoint from
all the other Scheme object types.
@end deftp


@defun file-descriptor? @var{obj}
Return true if @var{obj} is a file descriptor object.
@end defun


@defun file-descriptor->integer @var{fd}
@defunx integer->file-descriptor @var{integer}
Convert between a file descriptor object and an integer object.
@end defun

@c page
@node fd typedefs flocks
@subsection File locking


Functions from the primitives and high--level file descriptor libraries
accept objects of type @code{struct-flock} as @var{flock} arguments.
Functions from the platform libraries accept pointer objects as
references to @code{struct flock} data structures.


@deftp {Object Type} struct-flock
Object type referencing a @code{struct flock} data structure; it is
disjoint from all the other Scheme object types.
@end deftp


@defun make-struct-flock @var{malloc}
Build and return a new @code{struct-flock} object, referencing a newly
allocated C language @code{struct flock} value.

Memory is allocated using the function @var{malloc}, whose behaviour
must match the one of @func{malloc} from @library{foreign memory}.
@nauref{memory alloc high, Exception raising functions}.  To release
memory we have to convert the @code{struct-flock} object to a pointer
object and call the appropriate free function.
@end defun


@defun struct-flock? @var{obj}
Return true if @var{obj} is a @code{struct-flock} object.
@end defun


@defun struct-flock->pointer @var{fd}
@defunx pointer->struct-flock @var{flock}
Convert between a @code{struct-flock} object and a pointer object.
@end defun


The following bindings are exported by the @library{foreign posix
extensions} library.


@deftp {Extension Type} struct-flock*
Extension type which allows accessing and mutating the fields of a
@code{struct flock} data structure using the facilities of the
@library{records} library.  It has the following fields:

@table @code
@item type
@itemx whence
@itemx start
@itemx len
@itemx pid
One virtual field for each field of @code{struct flock}.
@end table
@end deftp


@c page
@node fd typedefs fdsets
@subsection File descriptor sets


Functions from the primitive and high--level libraries acting upon file
descriptor sets (C language type @code{fd_set}) accept objects of type
@code{fdset} as @var{fdset} arguments.  Functions from the platform
libraries accept pointer objects as references to @code{fd_set} values.
@ref{fd typedefs, File descriptor related data types}.


@deftp {Object Type} fdset
Object type referencing a file descriptor set; it is disjoint from all
the other Scheme object types.
@end deftp


@defun fdset? @var{obj}
Return true if @var{obj} is a file descriptor object.
@end defun


@defun make-fdset @var{malloc}
Build and return a new @code{fdset} object, referencing a newly
allocated C language @code{fd_set} value.

Memory is allocated using the function @var{malloc}, whose behaviour
must match the one of @func{malloc} from @library{foreign memory}.
@nauref{memory alloc high, Exception raising functions}.  To release
memory we have to convert the @code{fdset} object to a pointer object
and call the appropriate free function.
@end defun


@defun fdset->pointer @var{fdset}
@defunx pointer->fdset @var{integer}
Convert between a file descriptor object and an integer object.
@end defun


@c page
@node fd constants
@section Constant values and structure accessors


@menu
* fd constants status::         File status flags.
* fd constants perms::          Permissions.
* fd constants control::        File control flags.
* fd constants seek::           File positions.
* fd constants lock::           Locking.
* fd constants mmap::           Memory--mapped files.
* fd constants select::         Waiting for file descriptor events.
@end menu

@c page
@node fd constants status
@subsection File status flags


All the following bindings are exported by the @library{foreign posix
sizeof} library.  If a value is not defined on the underlying platform:
The corresponding binding is to @false{}.  @glibcref{File Status Flags,
File Status Flags}.


@defvr Constant O_RDONLY
@defvrx Constant O_WRONLY
@defvrx Constant O_RDWR
File access modes to be used with @func{open}.
@end defvr


@defvr Constant O_EXEC
@defvrx Constant O_READ
@defvrx Constant O_WRITE
These are @gnu{} only values.  @code{O_EXEC} is used with @func{open} to
open a file for execution.  @code{O_READ} and @code{O_WRITE} are like
@code{O_RDONLY} and @code{O_WRONLY}.
@end defvr


@defvr Constant O_ACCMODE
To be used with @func{fcntl} to query the open access mode of file
descriptors.
@end defvr


@defvr Constant O_CREAT
@defvrx Constant O_EXCL
@defvrx Constant O_APPEND
@defvrx Constant O_NONBLOCK
@defvrx Constant O_NOCTTY
Open--time flags to be used with @func{open}.
@end defvr


@defvr Constant O_NDELAY
@acronym{BSD} only alias for @code{O_NONBLOCK}.
@end defvr


@defvr Constant O_IGNORE_CTTY
@defvrx Constant O_NOLINK
@defvrx Constant O_NOTRANS
@gnu{} only file name translation flags to be used with @func{open}.
@end defvr


@defvr Constant O_TRUNC
Open--time action flags to be used with @func{open}.
@end defvr


@defvr Constant O_SHLOCK
@defvrx Constant O_EXLOCK
@acronym{BSD} only flags to be used with @func{open}.
@end defvr


@defvr Constant O_ASYNC
@defvrx Constant O_FSYNC
@defvrx Constant O_SYNC
@acronym{BSD} only flags to be used with @func{open}.
@end defvr


@defvr Constant O_NOATIME
@gnu{} only flag to be used with @func{open}.
@end defvr

@c page
@node fd constants perms
@subsection Permissions


All the following bindings are exported by the @library{foreign posix
sizeof} library.  @glibcref{Permission Bits, The mode bits for access
permission}.


@defvr Constant S_IRUSR
@defvrx Constant S_IWUSR
@defvrx Constant S_IXUSR
Permissions bits for file owner access.
@end defvr

@defvr Constant S_IRGRP
@defvrx Constant S_IWGRP
@defvrx Constant S_IXGRP
Permissions bits for group access.
@end defvr

@defvr Constant S_IROTH
@defvrx Constant S_IWOTH
@defvrx Constant S_IXOTH
Permissions bits for other users access.
@end defvr

@defvr Constant S_IRWXU
This is the bitwise combination of permissions bits for user access; it
could be defined as:

@example
(define S_IRWXU
  (bitwise-ior S_IRUSR S_IWUSR S_IXUSR))
@end example
@end defvr


@defvr Constant S_IRWXG
This is the bitwise combination of permissions bits for group access.
It could be defined as:

@example
(define S_IRWXG
  (bitwise-ior S_IRGRP S_IWGRP S_IXGRP))
@end example
@end defvr


@defvr Constant S_IRWXO
This is the bitwise combination of permissions bits for other users
access.  It could be defined as:

@example
(define S_IRWXO
  (bitwise-ior S_IROTH S_IWOTH S_IXOTH))
@end example
@end defvr


@defvr Constant S_ISUID
@defvrx Constant S_ISGID
@defvrx Constant S_ISVTX
These are the setuid, setgid and ``sticky bit'' values.
@end defvr

@c page
@node fd constants control
@subsection File control flags


All the following bindings are exported by the @library{foreign posix
sizeof} library; the values are meant to be used as @var{operation}
argument in call to @func{fcntl}.


@defvr Constant F_GETFL
@defvrx Constant F_SETFL
Set/get the status of a file.  @glibcref{Getting File Status Flags,
Getting and Setting File Status Flags}.
@end defvr


@defvr Constant F_DUPFD
Duplicate the file descriptor.  @glibcref{Duplicating Descriptors,
Duplicating Descriptors}.
@end defvr


@defvr Constant F_GETFD
@defvrx Constant F_SETFD
Set/get the status of a file descriptor.  @glibcref{Descriptor Flags,
File Descriptor Flags}.
@end defvr


@defvr Constant FD_CLOEXEC
State that the file descriptor has to be closed if an @cfunc{exec} is
performed.  @glibcref{Descriptor Flags, File Descriptor Flags}.
@end defvr


@defvr Constant F_SETLK
@defvrx Constant F_GETLK
@defvrx Constant F_SETLKW
Set/get a file lock.  @code{F_SETLKW} sets a file lock, but waits for
completion.  @glibcref{File Locks, File Locks}.
@end defvr


@defvr Constant F_GETOWN
@defvrx Constant F_SETOWN
Set/get process to receive @code{SIGIO} signals.  @glibcref{Interrupt
Output, Interrupt--Driven Output}.
@end defvr

@c page
@node fd constants seek
@subsection File positions


All the following bindings are exported by the @library{foreign posix
sizeof} library.  @glibcref{File Position Primitive, Setting the File
Position of a Descriptor}.


@defvr Constant SEEK_SET
@defvrx Constant SEEK_CUR
@defvrx Constant SEEK_END
File positions for the @var{whence} argument to @func{lseek}.
@end defvr

@c page
@node fd constants lock
@subsection Locking


All the following bindings are exported by the @library{foreign posix
sizeof} library.  @glibcref{File Locks, File Locks}.


@defvr Constant F_RDLCK
@defvrx Constant F_WRLCK
@defvrx Constant F_UNLCK
Flags for file descriptor locking.
@end defvr


@defvr Constant sizeof-flock
@defvrx Constant alignof-flock
@defvrx Constant strideof-flock
These are: the number of bytes required to hold a structure of type
@code{struct flock}; the alignment of the structure when embedded in
another structure; the number of bytes between two elements in an array
of structures.
@end defvr


@deffn Syntax struct-flock-l_type-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_type-ref @var{pointer}
@deffnx Syntax struct-flock-l_whence-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_whence-ref @var{pointer}
@deffnx Syntax struct-flock-l_start-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_start-ref @var{pointer}
@deffnx Syntax struct-flock-l_len-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_len-ref @var{pointer}
@deffnx Syntax struct-flock-l_pid-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_pid-ref @var{pointer}
Peekers and pokers for the fields of a @code{struct flock}.
@end deffn

@c page
@node fd constants mmap
@subsection Memory--mapped files


All the following bindings are exported by the @library{foreign posix
sizeof} library.  @glibcref{Memory-mapped I/O, Memory--mapped I/O}.


@defvr Constant MAP_PRIVATE
@defvrx Constant MAP_SHARED
@defvrx Constant MAP_FIXED
@defvrx Constant MAP_ANON
@defvrx Constant MAP_ANONYMOUS
@defvrx Constant MAP_32BITS
@defvrx Constant MAP_DENYWRITE
@defvrx Constant MAP_EXECUTABLE
@defvrx Constant MAP_FILE
@defvrx Constant MAP_GROWSDOWN
@defvrx Constant MAP_LOCKED
@defvrx Constant MAP_NONBLOCK
@defvrx Constant MAP_NORESERVE
@defvrx Constant MAP_POPULATE
@defvrx Constant MAP_STACK
@defvrx Constant MAP_AUTOGROW
@defvrx Constant MAP_AUTORESRV
@defvrx Constant MAP_COPY
Values for the @var{flags} argument to @func{mmap}; they must be
composed with bitwise inclusive OR.  One among @samp{MAP_PRIVATE} and
@samp{MAP_SHARED} must be used.
@end defvr


@defvr Constant PROT_READ
@defvrx Constant PROT_WRITE
@defvrx Constant PROT_EXEC
@defvrx Constant PROT_NONE
Values for the @var{protect} argument to @func{mmap}; they must be
composed with bitwise inclusive OR.
@end defvr


@defvr Constant MS_SYNC
@defvrx Constant MS_ASYNC
Values for the @var{flags} argument to @func{msync}; they must be
composed with bitwise inclusive OR.
@end defvr


@defvr Constant MREMAP_MAYMOVE
Value for the @var{flags} argument to @func{mremap}.
@end defvr

@c page
@node fd constants select
@subsection Waiting for file descriptor events


All the following bindings are exported by the @library{foreign posix
sizeof} library.  @glibcref{Waiting for I/O, Waiting for Input and
Output}.


@defvr Constant FD_SETSIZE
Maximum number of file descriptors that a @code{fd_set} can hold
informations about.  It is meant to be used as @var{max-fd} argument to
@func{select}.
@end defvr


@defvr Constant sizeof-fdset
@defvrx Constant alignof-fdset
@defvrx Constant strideof-fdset
Size, alignment and array stride of data structures of type
@code{fd_set}.
@end defvr

@c page
@node fd open close
@section Opening and closing


The following functions manage opening and closing file descriptors.
@glibcref{Opening and Closing Files, Opening and Closing Files}.

Example using compensations:

@example
(letrec
    ((fd (compensate
             (open "/tmp/marco/name.ext"
                   (bitwise-ior O_CREAT O_EXCL O_WRONLY)
                   #o640)
           (with
            (close fd)))))
  ---)
@end example

@noindent
with symbolic permissions bits (more portable):

@example
(letrec
    ((fd (compensate
             (open "/tmp/marco/name.ext"
                   (bitwise-ior O_CREAT O_EXCL O_WRONLY)
                   (bitwise-ior S_IRUSR S_IWUSR S_IRGRP)))
           (with
            (close fd))))
  ---)
@end example

@noindent
we should really create bindings for a selection of precomputed modes
and permissions:

@example
(define open-mode-cew
  (bitwise-ior O_CREAT O_EXCL O_WRONLY))

(define open-perm-rw/w
  (bitwise-ior S_IRUSR S_IWUSR S_IRGRP))
@end example


@float Table
@multitable {#o755} {user perms} {group perms} {other perms}
@headitem mode @tab user perms @tab group perms @tab other perms
@item @code{#o640}
@tab @code{rw-}
@tab @code{r--}
@tab @code{---}
@item @code{#o400}
@tab @code{r--}
@tab @code{---}
@tab @code{---}
@item @code{#o644}
@tab @code{rw-}
@tab @code{r--}
@tab @code{r--}
@item @code{#o755}
@tab @code{rwx}
@tab @code{r-x}
@tab @code{r-x}
@end multitable
@caption{Octal number examples of the most common values, where:
@code{r} stands for readable, @code{w} for writable, @code{x} for
executable.}
@end float

@float Table
@multitable {digit} {mode} {digit} {mode}
@headitem digit @tab mode @tab digit @tab mode
@item 0 @tab @code{---} @tab 4 @tab @code{r--}
@item 1 @tab @code{--x} @tab 5 @tab @code{r-x}
@item 2 @tab @code{-w-} @tab 6 @tab @code{rw-}
@item 3 @tab @code{-wx} @tab 7 @tab @code{rwx}
@end multitable
@caption{The octal digits.}
@end float


@deffn Function open @var{pathname} @var{mode} @var{permissions}
@deffnx Parameter open-function
@deffnx Function primitive:open @var{pathname} @var{mode} @var{permissions}
@deffnx Function platform:open @var{pathname-cstr} @var{mode} @var{permissions}
Open with @var{mode} the file selected by @var{pathname} and return a
file descriptor object; if the file is created, it is created with
access @var{permissions}.

@var{pathname} must be a Scheme string or symbol.

@var{mode} must be an exact integer, and it can be built with
@func{bitwise-ior} from the following constants: one among
@code{O_RDWR}, @code{O_RDONLY} and @code{O_WRONLY} and optionally
@code{O_TRUNC}, @code{O_EXCL}, @code{O_NONBLOCK}.

@var{permissions} must be an exact integer and it is better given as an
octal number or a bitwise combination of constants (@pxref{fd constants
perms}).  It can be zero if we are not interested in creating a new
file.
@end deffn


@deffn Function close @var{fd}
@deffnx Parameter close-function
@deffnx Function primitive:close @var{fd}
@deffnx Function platform:close @var{fd-int}
Close the file descriptor @var{fd}.
@end deffn

@c page
@node fd read write
@section Reading and writing


The following functions manage reading and writing with file
descriptors.  @glibcref{I/O Primitives,Input and Output Primitives}

The bindings @func{read} and @func{write} defined below have the same
names of the @func{read} and @func{write} defined by @rnrs{6}.  So when
importing the @library{foreign posix fd ---} libraries, we have to make
use of some augmented import specification.  For example the following
avoids importing the @rnrs{6} procedures:

@example
(import (except (rnrs) read write)
  (foreign posix fd))
@end example

@noindent
and the following prefixes with @samp{posix:} all the bindings from
@library{foreign posix fd}:

@example
(import (rnrs)
  (prefix (foreign posix fd) posix:))
@end example

@c ------------------------------------------------------------

@subsubheading Reading


@deffn Function read @var{fd} @var{pointer} @var{number-of-bytes}
@deffnx Parameter read-function
@deffnx Function primitive:read @var{fd} @var{pointer} @var{number-of-bytes}
@deffnx Function platform:read @var{fd-int} @var{pointer} @var{number-of-bytes}
Read at most @var{number-of-bytes} from @var{fd}, starting at the
current file position, and store them in the buffer referenced by
@var{pointer}.  The file position is advanced.  Return the number of
bytes actually read.
@end deffn


@deffn Function pread @var{fd} @var{pointer} @var{number-of-bytes} @var{offset}
@deffnx Parameter pread-function
@deffnx Function primitive:pread @var{fd} @var{pointer} @var{number-of-bytes} @var{offset}
@deffnx Function platform:pread @var{fd-int} @var{pointer} @var{number-of-bytes} @var{offset}
Read at most @var{number-of-bytes} from @var{fd}, starting at
@var{offset} from the beginning of the file, and store them in the
buffer referenced by @var{pointer}.  The file position is left
untouched.  Return the number of bytes actually read.
@end deffn

@c ------------------------------------------------------------

@subsubheading Writing


@deffn Function write @var{fd} @var{pointer} @var{number-of-bytes}
@deffnx Parameter write-function
@deffnx Function primitive:write @var{fd} @var{pointer} @var{number-of-bytes}
@deffnx Function platform:write @var{fd-int} @var{pointer} @var{number-of-bytes}
Write to @var{fd}, starting at the current file position, at most
@var{number-of-bytes} from the buffer referenced by @var{pointer}.  The
file position is advanced.  Return the number of bytes actually written.
@end deffn


@deffn Function pwrite @var{fd} @var{pointer} @var{number-of-bytes} @var{offset}
@deffnx Parameter pwrite-function
@deffnx Function primitive:pwrite @var{fd} @var{pointer} @var{number-of-bytes} @var{offset}
@deffnx Function platform:pwrite @var{fd-int} @var{pointer} @var{number-of-bytes} @var{offset}
Write to @var{fd}, starting at @var{offset} from the beginning of the
file, at most @var{number-of-bytes} from the buffer referenced by
@var{pointer}.  The file position is left untouched.  Return the number
of bytes actually written.
@end deffn

@c page
@node fd seek
@section Setting the file position


The following functions manage adjusting the current position with file
descriptors.  @glibcref{File Position Primitive, Setting the File
Position of a Descriptor}.


@deffn Function lseek @var{fd} @var{offset} @var{whence}
@deffnx Paramter lseek-function
@deffnx Function primitive:lseek @var{fd} @var{offset} @var{whence}
@deffnx Function platform:lseek @var{fd-int} @var{offset} @var{whence}
Move the file position of @var{fd} at @var{offset} from the position
selected with @var{whence}, which must be a value among @code{SEEK_SET},
@code{SEEK_CUR}, @code{SEEK_END} (@pxref{fd constants seek}).  Return
the number of bytes from the beginning of the file to the selected file
position.

@quotation
@strong{NOTE} It seems that @cfunc{lseek} cannot be interrupted by
@code{EINTR}.
@end quotation
@end deffn


We can use the return value to acquire the current file position with:

@example
(lseek fd 0 SEEK_CUR)
@end example

@noindent
which will leave the file position unchanged.  We can determine the file
size with:

@example
(define (file-size-from-descriptor fd)
  (with-compensations
    (letrec ((pos (compensate
                      (lseek fd 0 SEEK_CUR)
                    (with
                     (lseek fd pos SEEK_SET)))))
       (lseek fd 0 SEEK_END))))
@end example

@c page
@node fd sync
@section Synchronisation


The following functions manage synchronisation between the state of a
file descriptor and the underlying device.  @glibcref{Synchronizing I/O,
Synchronizing I/O}.


@deffn Function sync
@deffnx Parameter sync-function
@deffnx Function primitive:sync
@deffnx Function platform:sync
Synchronise data for all the file descriptors with the underlying
devices.  Does not return until the operation is terminated.
@end deffn


@deffn Function fsync @var{fd}
@deffnx Parameter fsync-function
@deffnx Function primitive:fsync @var{fd}
@deffnx Function platform:fsync @var{fd-int}
Synchronise data for @var{fd} with the underlying device.
@end deffn


@deffn Function fdatasync @var{fd}
@deffnx Parameter fdatasync-function
@deffnx Function primitive:fdatasync @var{fd}
@deffnx Function platform:fdatasync @var{fd-int}
Flushes the output buffer of @var{fd} to the underlying device.  This
function does not synchronise the file meta data (like the access time).
@end deffn

@c page
@node fd control
@section Control operations


The following functions manage miscellaneous control operations on a
file descriptor.  @glibcref{Control Operations, Control Operations on
Files}.  @glibcref{IOCTLs, I/O Control Operations}.


@deffn Function fcntl @var{fd} @var{operation} @var{arg}
@deffnx Parameter fcntl-function
@deffnx Function primitive:fcntl @var{fd} @var{operation} @var{arg}
@deffnx Function platform:fcntl @var{fd-int} @var{operation} @var{arg-int}
@deffnx Function platform:fcntl/ptr @var{fd-int} @var{operation} @var{arg-ptr}
Perform @var{operation} on @var{fd} using @var{arg}.  @var{operation}
must be an exact integer; @var{arg} can be an exact integer, a pointer
object or a @code{struct-flock} object.  @ref{fd constants control} for
the list of the supported operations.

@func{primitive:fcntl} assumes that: If the return value of
@func{platform:fcntl} or @func{platform:fcntl/ptr} is @code{-1}, an
error occurred.

If @var{arg} has to be a pointer (like when requesting a lock on the
file), we must use @func{platform:fcntl/ptr}; if it has to be an exact
integer, we must use @func{platform:fcntl}.  @func{primitive:fcntl}
dispatches correctly by examining the type of @var{arg}.
@end deffn


@deffn Function ioctl @var{fd} @var{operation} @var{arg}
@deffnx Parameter ioctl-function
@deffnx Function primitive:ioctl @var{fd} @var{operation} @var{arg}
@deffnx Function platform:ioctl @var{fd-int} @var{operation} @var{arg}
Perform @var{operation} on @var{fd} using @var{arg}.  @var{operation}
and @var{arg} must be exact integers.  @ref{fd constants control} for
the list of the supported operations.

@func{primitive:ioctl} assumes that: If the return value of
@func{platform:ioctl} is @code{-1}, an error occurred.
@end deffn

@c page
@node fd dup
@section Duplicating file descriptors


The following functions manage duplication of file descriptors.
@glibcref{Duplicating Descriptors,Duplicating Descriptors}.


@deffn Function dup @var{fd}
@deffnx Parameter dup-function
@deffnx Function primitive:dup @var{fd}
@deffnx Function platform:dup @var{fd}
Duplicate @var{fd}, return the new file descriptor object.
@end deffn


@deffn Function dup2 @var{old-fd} @var{new-fd/int}
@deffnx Parameter dup2-function
@deffnx Function primitive:dup2 @var{old-fd} @var{new-fd/int}
@deffnx Function platform:dup2 @var{old-fd-int} @var{new-fd-int}
Copy @var{old-fd}, a file descriptor object, to a file descriptor whose
number is @var{new-fd/int}, which can be a file descriptor object or an
exact integer.  Return the new file descriptor object.
@end deffn

@c page
@node fd lock
@section File locks


Locking is performed by @func{fcntl} with the @code{F_GETLK},
@code{F_SETLK} and @code{F_SETLKW} operations.  When locking, the third
argument to @func{fcntl} must be a pointer to a structure of type
@code{struct flock}.  @glibcref{File Locks,File Locks}.

Usage example:

@example
(with-compensations
  (let ((fd     ---)
        (lock   (make-struct-flock malloc-block/c)))
    (with-fields* (((type whence start len) struct-flock* lock))
      (set! lock.type   F_WRLCK)
      (set! lock.whence SEEK_SET)
      (set! lock.start  0)
      (set! lock.len    10)

      (fcntl fd F_SETLK lock)
      ---
      (fcntl fd F_UNLCK lock))))
@end example

@c page
@node fd pipe
@section Pipes and FIFOs


The following functions manage creation of pipes and @acronym{FIFO}s.
@glibcref{Creating a Pipe, Creating a Pipe}.  @glibcref{FIFO Special
Files, FIFO Special Files}.

This is a meaningless example of @acronym{FIFO} usage; we have to
remember that the binding forms in a @func{let} have no guaranteed
evaluation order, so if we need to open the two ports in a specified
order we have to use @func{let*}:

@example
(with-compensations
    (compensate
        (mkfifo pathname #o600)
      (with
       (delete-file pathname)))
  (let* ((in (open pathname
                   (bitwise-ior O_NONBLOCK O_RDONLY)
                   0))
         (ou (open pathname O_WRONLY 0)))
    (letrec ((inp (compensate
                      (fd->textual-input-port  in)
                    (with
                     (close-port inp))))
             (oup (compensate
                      (fd->textual-output-port ou)
                    (with
                     (close-port oup)))))
      (put-string oup "ciao\n")
      (flush-output-port oup)
      (get-string-n inp 5))))
@end example


@deffn Function pipe
@deffnx Parameter pipe-function
@deffnx Function primitive:pipe
@deffnx Function platform:pipe @var{pointer}
Open a pipe: A pair of file descriptors linked together.  Return two
values: the first is the reading file descriptor, the second is the
writing file descriptor.
@end deffn


@deffn Function mkfifo @var{pathname} @var{mode}
@deffnx Parameter mkfifo-function
@deffnx Function primitive:mkfifo mkfifo @var{pathname} @var{mode}
@deffnx Function platform:mkfifo @var{pathname-cstr} @var{mode}
Create a named pipe pseudofile: A special file that can be used for
interprocess communication.  The Scheme string or symbol @var{pathname}
selects the file pathname.  @var{mode} is a numeric access permissions
mode like the one used by @func{open}.
@end deffn

@c page
@node fd scatter
@section Scatter/gather input/output


The following functions manage reading/writing from/to file descriptors
using an array of data buffers.  @glibcref{Scatter-Gather, Fast
Scatter--Gather I/O}.


@deffn Function readv @var{fd} @var{iovec-array-pointer} @var{iovec-array-size}
@deffnx Parameter readv-function
@deffnx Function primitive:readv @var{fd} @var{iovec-array-pointer} @var{iovec-array-size}
@deffnx Function platform:readv @var{fd-int} @var{iovec-array-pointer} @var{iovec-array-size}
Read data from @var{fd} storing it in the buffers described by the
@code{iovec} array.  Return the total number of bytes read.
@end deffn


@deffn Function writev @var{fd} @var{iovec-array-pointer} @var{iovec-array-size}
@deffnx Parameter writev-function
@deffnx Function primitive:writev @var{fd} @var{iovec-array-pointer} @var{iovec-array-size}
@deffnx Function platform:writev @var{fd-int} @var{iovec-array-pointer} @var{iovec-array-size}
Write data to @var{fd} reading it from the buffers described by the
@code{iovec} array.  Return the total number of bytes written.
@end deffn


The following bindings are exported by the library @library{foreign
posix sizeof}.


@defvr Constant sizeof-iovec
@defvrx Constant alignof-iovec
@defvrx Constant strideof-iovec
Size, structure alignment and array stride of data structures of type
@code{struct iovec}.
@end defvr


@deffn Syntax sizeof-iovec-array @var{number-of-elements}
Expands to the size of an array holding @var{number-of-elements} data
structures of type @code{struct iovec}.
@end deffn


@deffn Syntax array-ref-c-iovec @var{pointer} @var{index}
Expands to a pointer to the first byte of the element at @var{index} in
the array of @code{struct iovec} referenced by @var{pointer}.
@end deffn


@deffn Syntax struct-iovec-iov_base-ref @var{pointer}
@deffnx Syntax struct-iovec-iov_base-set! @var{pointer} @var{value}
@deffnx Syntax struct-iovec-iov_len-ref @var{pointer}
@deffnx Syntax struct-iovec-iov_len-set! @var{pointer} @var{value}
Accessors and mutators for the fields of @code{struct iovec}.
@end deffn


Usage example, writing strings:

@example
(with-compensations
  (letrec ((fd (compensate
                   (posix:open pathname
                               (bitwise-ior O_CREAT O_RDWR)
                               (bitwise-ior S_IRUSR S_IWUSR))
                 (with
                  (posix:close fd)))))
    (let* ((iovec-count 3)
           (iovec**     (malloc-block/c
                          (sizeof-iovec-array iovec-count))))
      (let loop ((i     0)
                 (ell   '("ciao" "salut" "hello")))
        (unless (= i iovec-count)
          (let ((iovec* (array-ref-c-iovec iovec** i))
                (cstr   (string->cstring/c (car ell))))
            (struct-iovec-iov_base-set! iovec* cstr)
            (struct-iovec-iov_len-set!  iovec* (strlen cstr)))
          (loop (+ 1 i) (cdr ell))))

      (posix:writev fd iovec** iovec-count))))
@end example

@c page
@node fd mmap
@section Memory mapped input/output


The following functions manage input/outut through a file mapped to a
region of memory.  @glibcref{Memory-mapped I/O, Memory--mapped I/O}.


@deffn Function mmap @var{address} @var{length} @var{protect} @var{flags} @var{fd} @var{offset}
@deffnx Parameter mmap-function
@deffnx Function primitive:mmap @var{address} @var{length} @var{protect} @var{flags} @var{fd} @var{offset}
@deffnx Function platform:mmap @var{address} @var{length} @var{protect} @var{flags} @var{fd-int} @var{offset}
Create a memory mapping for @var{fd}, starting at file position
@var{offset}, for @var{length} bytes starting at @var{address} (which
can be @code{pointer-null}).  Return the effective address of the
mapping, which may be different from @var{address}.

Beware that @var{address} and @var{offset} must be page aligned or an
@code{EINVAL} error will be raised; see the original documentation.

The @var{flags} and @var{protect} arguments must be exact integers
composed with bitwise inclusive OR from appropriate constant values.
@ref{fd constants mmap, Memory mapped files}.
@end deffn


@deffn Function munmap @var{address} @var{length}
@deffnx Parameter munmap-function
@deffnx Function primitive:munmap @var{address} @var{length}
@deffnx Function platform:munmap @var{address} @var{length}
Unmap a previously created memory mapping.
@end deffn


@deffn Function msync @var{address} @var{length} @var{flags}
@deffnx Parameter msync-function
@deffnx Function primitive:msync @var{address} @var{length} @var{flags}
@deffnx Function platform:msync @var{address} @var{length} @var{flags}
Synchronise a memory mapped region with the corresponding file on the
underlying device.

The @var{flags} argument must be an exact integer composed with bitwise
inclusive OR from appropriate constant values.  @ref{fd constants mmap,
Memory mapped files}.
@end deffn


@deffn Function mremap @var{address} @var{length} @var{new-length} @var{flags}
@deffnx Parameter mremap-function
@deffnx Function primitive:mremap @var{address} @var{length} @var{new-length} @var{flags}
@deffnx Function platform:mremap @var{address} @var{length} @var{new-length} @var{flags}
Change the size of an existing memory mapping.

The @var{flags} argument must be an exact integer composed with bitwise
inclusive OR from appropriate constant values.  @ref{fd constants mmap,
Memory mapped files}.
@end deffn


Usage example:

@example
(letrec* ((fd         (compensate
                          (open pathname
                                (bitwise-ior O_CREAT O_RDWR)
                                (bitwise-ior S_IRUSR S_IWUSR))
                        (with
                         (close fd))))
          (map-len    4096)
          (address    (compensate
                          (mmap pointer-null map-len
                                (bitwise-ior PROT_READ PROT_WRITE)
                                MAP_SHARED fd 0)
                        (with
                         (munmap address map-len)))))

  (pointer-ref-c-signed-char address 10))
@end example

@c page
@node fd select
@section Waiting for input or output


The following functions manage watiting for input and outut on file
descriptors.  @glibcref{Waiting for I/O, Waiting for Input and Output}.

In the following descriptions the @var{fdset} arguments are @code{fdset}
objects.  @ref{fd typedefs, File descriptor related data types}.


@deffn Function select @var{max-fd} @var{read-fdset} @var{write-fdset} @var{except-fdset} @var{timeout}
@deffnx Parameter select-function
@deffnx Function primitive:select @var{max-fd} @var{read-fdset} @var{write-fdset} @var{except-fdset} @var{timeout}
@deffnx Function platform:select @var{max-fd} @var{read-fdset} @var{write-fdset} @var{except-fdset} @var{timeout}
Wait for an event on the file descriptors in the sets referenced by the
@var{fdset} arguments.  @var{timeout} must be a @code{struct-timeval}
object.

@strong{NOTE} This function can be interrupted and return with
@code{errno} set to @code{EINTR}; the library does not automatically
reinvoke it, rather it raises an error with @func{raise-errno-error}.
@end deffn


@deffn Function FD_ZERO @var{fdset}
@deffnx Function primitive:FD_ZERO @var{fdset}
@deffnx Function platform:FD_ZERO @var{fdset}
Initialises the file descriptor set referenced by @var{fdset}.  The
return value is undefined, platform function included.
@end deffn


@deffn Function FD_SET @var{fd} @var{fdset}
@deffnx Function primitive:FD_SET @var{fd} @var{fdset}
@deffnx Function platform:FD_SET @var{fd} @var{fdset}
Add @var{fd} to the file descriptor set referenced by @var{fdset}.  The
return value is undefined, platform function included.
@end deffn


@deffn Function FD_CLR @var{fd} @var{fdset}
@deffnx Function primitive:FD_CLR @var{fd} @var{fdset}
@deffnx Function platform:FD_CLR @var{fd} @var{fdset}
Remove @var{fd} from the file descriptor set referenced by @var{fdset}.
The return value is undefined, platform function included.
@end deffn


@deffn Function FD_ISSET @var{fd} @var{fdset}
@deffnx Function primitive:FD_ISSET @var{fd} @var{fdset}
@deffnx Function platform:FD_ISSET @var{fd} @var{fdset}
Return true if @var{fd} is a member of the file descriptor set
referenced by @var{fdset}.  @func{platform:FD_ISSET} returns a single
value, an integer with C language true/false meaning.
@end deffn


Usage example:

@example
(import (except (rnrs) read write)
  (records)
  (foreign memory)
  (foreign posix fd)
  (foreign posix sizeof)
  (for (foreign posix typedefs) expand run)
  (for (foreign posix extensions) expand))

(let ((fd        ---)
      (rd-fdset  (make-fdset malloc-block/c))
      (wr-fdset  (make-fdset malloc-block/c))
      (ex-fdset  (make-fdset malloc-block/c))
      (timeout   (make-struct-timeval malloc-block/c)))

  (with-fields* (((sec usec) struct-timeval* timeout))
    (set! timeout.sec  1)
    (set! timeout.usec 0))

  (posix:FD_ZERO rd-fdset)
  (posix:FD_ZERO wr-fdset)
  (posix:FD_ZERO ex-fdset)

  (posix:FD_SET fd rd-fdset)

  (posix:select FD_SETSIZE rd-fdset wr-fdset ex-fdset timeout)
  (posix:FD_ISSET fd rd-fdset))
@end example

@c page
@ignore
@node fd aio
@section Asynchronous input/output


The following functions asynchronous input/output on multiple file
descriptors.  @glibcref{Asynchronous I/O, Perform I/O Operations in
Parallel}.
@end ignore

@c page
@node fd custom
@section Custom Scheme ports


The following bindings are exported by the @library{foreign posix fd}
library.


@defun fd->binary-input-port @var{fd}
@defunx fd->binary-output-port @var{fd}
@defunx fd->binary-input/output-port @var{fd}
@defunx fd->textual-input-port @var{fd}
@defunx fd->textual-output-port @var{fd}
@defunx fd->textual-input/output-port @var{fd}
Wrap the given file descriptor with a Scheme port; return the port.
Closing the Scheme port closes the file descriptor too.
@end defun


@defun pipe-binary-ports
@defunx pipe-textual-ports
Invoke @func{pipe} then wrap the file descriptors with Scheme ports.
Return 2 values: the reading port and the writing port.

Position handling (seeking) is @strong{not} implemented for pipe ports.
@end defun

@c ------------------------------------------------------------

@subsubheading Everyone should mind his own buffers


Unfortunately there are Scheme implementations that insist in
implementing buffering for custom ports.  One can say that they are
called ``custom'' to let the customers (that is us) decide how to handle
the underlying device, buffering included.  This is not the opinion of
some Scheme implementers.

So with some implementations we have to turn off buffering and turn on
non-blocking mode for the device.


@subsubheading Do it yourself


If we feel the need to implement our own wrappers, we may find useful to
know that a custom read function can be implemented like this:

@example
(define (custom-binary-read fd bv start count)
  (with-compensations
    (let* ((p   (malloc-block/c count))
           (len (read fd p count)))
      (do ((i 0 (+ 1 i)))
          ((= i len)
           len)
        (bytevector-u8-set! bv (+ start i)
                            (peek-unsigned-char p i))))))

(define (custom-textual-read fd str start count)
  (with-compensations
    (let* ((p   (malloc-block/c count))
           (len (read fd p count)))
      (do ((i 0 (+ 1 i)))
          ((= i len)
           len)
        (string-set! str (+ start i)
                     (integer->char (peek-unsigned-char p i)))))))
@end example

@noindent
and a custom write function can be implemented like this:

@example
(define (custom-binary-write fd bv start count)
  (with-compensations
    (let ((p (malloc-block/c count)))
      (do ((i 0 (+ 1 i)))
          ((= i count)
           (write fd p count))
        (poke-char! p i (bytevector-u8-ref bv (+ start i)))))))

(define (custom-textual-write fd str start count)
  (with-compensations
    (let ((p (malloc-block/c count)))
      (do ((i 0 (+ 1 i)))
          ((= i count)
           (write fd p count))
        (poke-char! p i
           (char->integer (string-ref str (+ start i))))))))
@end example

Then the following implementations are possible:

@example
(define (fd->binary-input-port fd)
  (make-custom-binary-input-port
   "fd input port"
   (lambda (bv start count)
     (custom-binary-read fd bv start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->binary-output-port fd)
  (make-custom-binary-output-port
   "fd output port"
   (lambda (bv start count)
     (custom-binary-write fd bv start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->binary-input/ouput-port fd)
  (make-custom-binary-input-port
   "fd input/output port"
   (lambda (bv start count)
     (custom-binary-read fd bv start count))
   (lambda (bv start count)
     (custom-binary-write fd bv start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->textual-input-port fd)
  (make-custom-textual-input-port
   "fd input port"
   (lambda (str start count)
     (custom-textual-read fd str start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->textual-output-port fd)
  (make-custom-textual-output-port
   "fd output port"
   (lambda (str start count)
     (custom-textual-write fd str start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->textual-input/ouput-port fd)
  (make-custom-textual-input-port
   "fd input/output port"
   (lambda (str start count)
     (custom-textual-read fd str start count))
   (lambda (str start count)
     (custom-textual-write fd str start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (pipe-binary-ports)
  (let-values (((in ou) (pipe)))
    (values (make-custom-binary-input-port
             "fd pipe binary reading port"
             (lambda (bv start count)
               (custom-binary-read in bv start count))
             #f
             #f
             (lambda ()
               (close in)))
            (make-custom-binary-output-port
             "fd pipe binary writing port"
             (lambda (bv start count)
               (custom-binary-write ou bv start count))
             #f
             #f
             (lambda ()
               (close ou))))))

(define (pipe-textual-ports)
  (let-values (((in ou) (pipe)))
    (values (make-custom-textual-input-port
             "fd pipe textual reading port"
             (lambda (bv start count)
               (custom-textual-read in bv start count))
             #f
             #f
             (lambda ()
               (close in)))
            (make-custom-textual-output-port
             "fd pipe textual writing port"
             (lambda (bv start count)
               (custom-textual-write ou bv start count))
             #f
             #f
             (lambda ()
               (close ou))))))
@end example

@c page
@node streams
@chapter Stream functions


Unless otherwise specified, the bindings described in this chapter  are
exported by the following libraries:

@example
(foreign glibc streams)
(foreign glibc streams primitives)
(foreign glibc streams platform)
@end example

@menu
* streams typedefs::            Object type definitions.
* streams constants::           Constants.
* streams errors::              Detecting errors on streams.
* streams open close::          Opening and closing.
* streams writing::             Writing to streams.
* streams reading::             Reading from streams.
* streams unreading::           Unreading to streams.
* streams seeking::             Stream positioning.
* streams fd::                  Streams and file descriptors.
* streams unlocked::            Unlocked stream operations.
* streams extended::            Extended stream operations.
* streams lines::               Reading lines.
@end menu

@c page
@node streams typedefs
@section Object type definitions


Functions from the primitives and high--level stream libraries accept
objects of type @code{FILE*} as @var{stream} arguments.  Functions from
the platform libraries accept pointer objects as representing stream
pointers.

The following bindings are exported by the @library{foreign posix
typedefs} library.


@deftp {Object Type} FILE*
Object type representing a @code{FILE *} pointer; it is disjoint from
all the other Scheme object types.
@end deftp


@defun FILE*->pointer @var{stream}
@defunx pointer->FILE* @var{pointer}
Convert between a stream object and a pointer object.
@end defun


@defun FILE*? @var{obj}
Return true if @var{obj} is a stream object.
@end defun

@c page
@node streams constants
@section Constants


The following bindings are exported by the @library{foreign posix
sizeof} library.  Notice that the seek constants @code{SEEK_SET},
@code{SEEK_CUR} and @code{SEEK_END} are also exported by the same
library.  @ref{fd constants seek, File positions}


@defvr Constant EOF
The value of @code{EOF}.  @glibcref{EOF and Errors, End--of--file and
Errors}.
@end defvr

@c page
@node streams errors
@section Detecting errors on streams


The following functions manage error detection on streams operations.
@glibcref{EOF and Errors, End--Of--File and Errors}.


@deffn Function ferror @var{stream}
@deffnx Parameter ferror-function
@deffnx Function primitive:-ferror @var{stream}
@deffnx Function platform:ferror @var{stream}
Return @true{} if the error indicator of @var{stream} is set, @false{}
otherwise.  @func{platform:ferror} returns a single value: The return
value of the foreign function call.
@end deffn


@defun clearerr @var{stream}
@defunx primitive:clearerr @var{stream}
@defunx platform:clearerr @var{stream}
Clear the error and end--of--file indicators for @var{stream}.
@func{platform:clearerr} returns a single value: The return value of the
foreign function call.
@end defun

@c page
@node streams open close
@section Opening and closing


The following functions manage opening and closing of streams.
@glibcref{Opening Streams, Opening Streams}.  @glibcref{Closing Streams,
Closing Streams}.


@deffn Function fopen @var{pathname} @var{mode}
@deffnx Parameter fopen-function
@deffnx Function primitive:fopen @var{pathname} @var{mode}
@deffnx Function platform:fopen @var{pathname-cstr} @var{mode-cstr}
Open a file selected by @var{pathname} with the given mode and return a
@code{FILE*} object.  @var{pathname} and @var{mode} must be Scheme
strings or symbols.
@end deffn


@deffn Function fclose @var{stream}
@deffnx Parameter fclose-function
@deffnx Function primitive:fclose @var{stream}
@deffnx Function platform:fclose @var{stream-ptr}
Close the previously opened @var{stream}.
@end deffn


@deffn Function fcloseall
@deffnx Parameter fcloseall-function
@deffnx Function primitive:fcloseall
@deffnx Function platform:fcloseall
Close all the open streams of the process.
@end deffn

@c page
@node streams writing
@section Writing to streams


The following functions manage writing data to streams.  @glibcref{Block
Input/Output, Block Input/Output}.  @glibcref{Flushing Buffers, Flushing
Buffers}.


@deffn Function fwrite @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Parameter fwrite-function
@deffnx Function primitive:fwrite @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Function platform:fwrite @var{pointer} @var{size} @var{count} @var{stream-ptr}
Write up to @var{count} elements of @var{size} bytes from the block of
memory referenced by @var{pointer} to @var{stream}.  If successful
return @var{count}.
@end deffn


@deffn Function fputc @var{char} @var{stream}
@deffnx Parameter fputc-function
@deffnx Function primitive:fputc @var{char} @var{stream}
@deffnx Function platform:fputc @var{char} @var{stream-ptr}
Write a character to @var{stream}.  @var{char} must be a Scheme
character with scalar value in the range @code{[0, 255]}; the scalar
value is computed with @func{char->integer}.  If successful return the
scalar representing @var{char}.
@end deffn


@deffn Function fputs @var{string} @var{stream}
@deffnx Parameter fputs-function
@deffnx Function primitive:fputs @var{string} @var{stream}
@deffnx Function platform:fputs @var{cstring} @var{stream-ptr}
Write a string to @var{stream}.  @var{string} must be a Scheme string or
symbol.  If successful return the scalar representing @var{char}.
@end deffn


@deffn Function fflush @var{stream}
@deffnx Parameter fflush-function
@deffnx Function primitive:fflush @var{stream}
@deffnx Function platform:fflush @var{stream-ptr}
Flush the contents of the buffer to the underlying device.
@end deffn

@c page
@node streams reading
@section Reading from streams


The following functions manage reading data from streams.
@glibcref{Block Input/Output, Block Input/Output}.


@deffn Function fread @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Parameter fread-function
@deffnx Function primitive:fread @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Function platform:fread @var{pointer} @var{size} @var{count} @var{stream-ptr}
Read up to @var{count} elements of @var{size} bytes from @var{stream}
and store them in the block of memory referenced by @var{pointer}.
Return the number of objects actually read (which may be less than
@var{count}).
@end deffn


@deffn Function fgetc @var{stream}
@deffnx Parameter fgetc-function
@deffnx Function primitive:fgetc @var{stream}
@deffnx Function platform:fgetc @var{stream-ptr}
Read a single character from @var{stream}.  Return a Scheme character.
@end deffn


@deffn Function fgets @var{pointer} @var{count} @var{stream}
@deffnx Parameter fgets-function
@deffnx Function primitive:fgets @var{pointer} @var{count} @var{stream}
@deffnx Function platform-fgets @var{pointer} @var{count} @var{stream-ptr}
Read a line from @var{stream} and store it in the buffer of @var{count}
bytes referenced by @var{pointer}.  Return @var{pointer}.
@end deffn

@c page
@node streams unreading
@section Unreading to streams


The following functions manage ``unreading'' data from streams.
@glibcref{How Unread, Using @code{ungetc} To Do Unreading}.


@deffn Function ungetc @var{char} @var{stream}
@deffnx Parameter ungetc-function
@deffnx Function primitive:ungetc @var{char} @var{stream}
@deffnx Function platform:ungetc @var{c-char} @var{stream-ptr}
Unread a character to @var{stream}.  @var{char} must be a Scheme
character with scalar value in the range @code{[0, 255]}; the scalar
value is computed with @func{char->integer}.
@end deffn

@c page
@node streams seeking
@section Stream positioning


The following functions manage seeking the current position in streams.
@glibcref{File Positioning, File Positioning}.

Notice that the seek constants @code{SEEK_SET}, @code{SEEK_CUR} and
@code{SEEK_END} are exported by the @library{foreign posix sizeof}
library.  @ref{fd constants seek, File positions}


@deffn Function feof @var{stream}
@deffnx Parameter feof-function
@deffnx Function primitive:feof @var{stream}
@deffnx Function platform:feof @var{stream-ptr}
Return @true{} if the end--of--file indicator of @var{stream} is set,
otherwise @false{}.
@end deffn


@deffn Function fseek @var{stream} @var{offset} @var{whence}
@deffnx Parameter fseek-function
@deffnx Function primitive:fseek @var{stream} @var{offset} @var{whence}
@deffnx Function platform:fseek @var{stream-ptr} @var{offset} @var{whence}
Change the file position of @var{stream} to @var{offset} from
@var{whence}.
@end deffn


@deffn Function fseeko @var{stream} @var{offset} @var{whence}
@deffnx Parameter fseeko-function
@deffnx Function primitive:fseeko @var{stream} @var{offset} @var{whence}
@deffnx Function platform:fseeko @var{stream-ptr} @var{offset} @var{whence}
Like @func{fseek}, but the return value is of type @code{off_t}.
@end deffn


@deffn Function ftell @var{stream}
@deffnx Parameter ftell-function
@deffnx Function primitive:ftell @var{stream}
@deffnx Function platform:ftell @var{stream-ptr}
Return the current file position of @var{stream}.
@end deffn


@deffn Function ftello @var{stream}
@deffnx Parameter ftello-function
@deffnx Function primitive:ftello @var{stream}
@deffnx Function platform:ftello @var{stream-ptr}
Like @func{ftell}, but the return value is of type @code{off_t}.
@end deffn


@deffn Function rewind @var{stream}
@deffnx Parameter rewind-function
@deffnx Function primitive:rewind @var{stream}
@deffnx Function platform:rewind @var{stream-ptr}
Change the file position of @var{stream} to the beginning of the file.
@end deffn

@c page
@node streams fd
@section Streams and file descriptors


The following functions manage conversion of streams to and from raw
file descriptors.  @glibcref{Descriptors and Streams, Descriptors and
Streams}.


@deffn Function fdopen @var{fd} @var{open-mode}
@deffnx Parameter fdopen-function
@deffnx Function primitive:fdopen @var{fd} @var{open-mode}
@deffnx Function platform:fdopen @var{fd} @var{open-mode}
Build a new stream referencing the file descriptor @var{fd} and return a
@code{FILE*} object.  @var{open-mode} must be a Scheme string or symbol
representing the open mode of @var{fd}; it can have the same values
accepted by @func{fopen}.
@end deffn


@deffn Function fileno @var{stream}
@deffnx Parameter fileno-function
@deffnx Function primitive:fileno @var{stream}
@deffnx Function platform:fileno @var{stream-ptr}
Return a @code{file-descriptor} object representing the file descriptor
wrapped by @var{stream}.
@end deffn

@c page
@node streams unlocked
@section Unlocked stream operations


The following functions manage operation on streams without locking for
exclusive access; they are like the corresponding non--@code{_unlocked}
variants, but they do not implicitly lock the stream.

@c ------------------------------------------------------------

@subsubheading Errors


@deffn Function ferror_unlocked @var{stream}
@deffnx Parameter ferror_unlocked-function
@deffnx Function primitive:ferror_unlocked @var{stream}
@deffnx Function platform:ferror_unlocked @var{stream-ptr}
Like @func{ferror}.
@end deffn


@defun clearerr_unlocked @var{stream}
@defunx primitive:clearerr_unlocked @var{stream}
@defunx platform:clearerr_unlocked @var{stream-ptr}
Like @func{clearerr}.
@end defun

@c ------------------------------------------------------------

@subsubheading Writing


@deffn Function fwrite_unlocked @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Parameter fwrite_unlocked-function
@deffnx Function primitive:fwrite_unlocked @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Function platform:fwrite_unlocked @var{pointer} @var{size} @var{count} @var{stream-ptr}
Like @func{fwrite}.
@end deffn


@deffn Function fputc_unlocked @var{char} @var{stream}
@deffnx Parameter fputc_unlocked-function
@deffnx Function primitive:fputc_unlocked @var{c-char} @var{stream}
@deffnx Function platform:fputc_unlocked @var{c-char} @var{stream-ptr}
Like @func{fputc}.
@end deffn


@deffn Function fputs_unlocked @var{string} @var{stream}
@deffnx Parameter fputs_unlocked-function
@deffnx Function primitive:fputs_unlocked @var{cstring} @var{stream}
@deffnx Function platform:fputs_unlocked @var{cstring} @var{stream-ptr}
Like @func{fputs}.
@end deffn


@deffn Function fflush_unlocked @var{stream}
@deffnx Parameter fflush_unlocked-function
@deffnx Function primitive:fflush_unlocked @var{stream}
@deffnx Function platform:fflush_unlocked @var{stream-ptr}
Like @func{fflush}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Reading


@deffn Function fread_unlocked @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Parameter fread_unlocked-function
@deffnx Function primitive:fread_unlocked @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Function platform:fread_unlocked @var{pointer} @var{size} @var{count} @var{stream-ptr}
Like @func{fread}.
@end deffn


@deffn Function fgetc_unlocked @var{stream}
@deffnx Parameter fgetc_unlocked-function
@deffnx Function primitive:fgetc_unlocked @var{stream}
@deffnx Function platform:fgetc_unlocked @var{stream-ptr}
Like @func{fgetc}.
@end deffn


@deffn Function fgets_unlocked @var{pointer} @var{count} @var{stream}
@deffnx Parameter fgets_unlocked-function
@deffnx Function primitive:fgets_unlocked @var{pointer} @var{count} @var{stream}
@deffnx Function platform:fgets_unlocked @var{pointer} @var{count} @var{stream-ptr}
Like @func{fgets}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Seeking


@deffn Function feof_unlocked @var{stream}
@deffnx Parameter feof_unlocked-function
@deffnx Function primitive:feof_unlocked @var{stream}
@deffnx Function platform:feof_unlocked @var{stream-ptr}
Like @func{feof}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Streams an file descriptors


@deffn Function fileno_unlocked @var{stream}
@deffnx Parameter fileno_unlocked-function
@deffnx Function primitive:fileno_unlocked @var{stream}
@deffnx Function platform:fileno_unlocked @var{stream-ptr}
Like @func{fileno}.
@end deffn

@c page
@node streams extended
@section Extended stream operations


The following functions implement extended operations on streams.

@c ------------------------------------------------------------

@subsubheading Inspection


@deffn Function freadable @var{stream}
@deffnx Parameter freadable-function
@deffnx Function primitive:freadable @var{stream}
@deffnx Function platform:freadable @var{stream-ptr}
Return @true{} if @var{stream} was opened for reading, otherwise return
@false{}.  @func{platform:freadable} returns a single value: the return
value from the foreign function.
@end deffn


@deffn Function fwritable @var{stream}
@deffnx Parameter fwritable-function
@deffnx Function primitive:fwritable @var{stream}
@deffnx Function platform:fwritable @var{stream-ptr}
Return @true{} if @var{stream} was opened for writing, otherwise return
@false{}.  @func{platform:fwritable} returns a single value: the return
value from the foreign function.
@end deffn


@deffn Function freading @var{stream}
@deffnx Parameter freading-function
@deffnx Function primitive:freading @var{stream}
@deffnx Function platform:freading @var{stream-ptr}
Return @true{} if @var{stream} was last read from, otherwise return
@false{}.  @func{platform:freading} returns a single value: the return
value from the foreign function.
@end deffn


@deffn Function fwriting @var{stream}
@deffnx Parameter fwriting-function
@deffnx Function primitive:fwriting @var{stream}
@deffnx Function platform:fwriting @var{stream-ptr}
Return @true{} if @var{stream} was last written to, otherwise return
@false{}.  @func{platform:fwriting} returns a single value: the return
value from the foreign function.
@end deffn


@deffn Function fwide @var{stream} @var{mode}
@deffnx Parameter fwide-function
@deffnx Function primitive:fwide @var{stream} @var{mode}
@deffnx Function platform:fwide @var{stream-ptr} @var{mode}
Set or query the orientation of @var{stream}.  @var{mode} must be an
exact integer.  @func{platform:fwide} returns a single value: the return
value from the foreign function.

@itemize
@item
If @var{mode} is zero and the return value is positive: @var{stream} is
oriented for wide characters.

@item
If @var{mode} is zero and the return value is negative: @var{stream} is
oriented for narrow characters.

@item
If @var{mode} is positive: @var{stream} is configured for wide
characters.

@item
If @var{mode} is negative: @var{stream} is configured for narrow
characters.
@end itemize
@end deffn

@c ------------------------------------------------------------

@subsubheading Miscellaneous


@deffn Function fpurge @var{stream}
@deffnx Parameter fpurge-function
@deffnx Function primitive:fpurge @var{stream}
@deffnx Function platform:fpurge @var{stream-ptr}
Discard the contents of the buffer.  @func{platform:fpurge} returns a
single value: the return value from the foreign function.
@end deffn

@c page
@node streams lines
@section Reading lines


The following functions manage reading lines from streams.
@glibcref{Line Input, Line--Oriented Input}.


@deffn Function getline @var{stream}
@deffnx Parameter getline-function
@deffnx Function primitive:getline @var{stream}
@deffnx Function platform:getline @var{pointer-pointer} @var{pointer-count} @var{stream-ptr}
Read characters from @var{stream} until a newline is found, then returns
a string holding those characters and a terminating newline.

If end--of--file is encountered before the newline, but some characters
where read: The acquired characters are stored in a string
@strong{without} terminating newline, and the string is returned.

If end--of--file is encountered before the newline, and no characters
where read: An empty string is returned.

If an error occurs while reading: An exception is raised.
@end deffn


@deffn Function getdelim @var{stream} @var{delimiter}
@deffnx Parameter getdelim-function
@deffnx Function primitive:getdelim @var{stream} @var{delimiter}
@deffnx Function platform:getdelim @var{pointer-pointer} @var{pointer-count} @var{delimiter} @var{stream-ptr}
Like @func{getline} but reads characters until @var{delimiter} is found.
@var{delimiter} must be a Scheme character with an integer
representation in the range @code{[0, 255]}.
@end deffn


As a usage example, the following code reads one line at a time from a
file and accumulates them in the @code{lines} variables:

@smallexample
(import (rnrs)
  (receive)
  (compensations)
  (foreign memory)
  (foreign cstrings)
  (foreign errno)
  (foreign ffi peekers-and-pokers)
  (foreign glibc streams)
  (prefix (foreign glibc streams platform) platform:))

(let* ((pathname the-pathname))
  (with-compensations
    (letrec* ((S           (compensate
                               (fopen pathname "w+")
                             (with
                              (fclose S))))
              (*pointer    (malloc-small/c))
              (*count      (malloc-small/c))
              (getp        (lambda ()
                             (pointer-ref-c-pointer *pointer 0)))
              (free        (lambda ()
                             (let ((p (getp)))
                               (unless (pointer-null? p)
                                 (primitive-free p)))))
              (lines       '()))
      (let loop ()
        (receive (result errno)
            (platform:getline *pointer *count S)
          (cond ((ferror S)
                 (free)
                 (raise-errno-error 'reading-line errno S))
;;; here EOF was found, return the result
                ((= -1 result)
                 (free)
                 (reverse lines))
;;; accumulate the result
                (else
                 (set! lines
                       (cons (cstring->string (getp) result)
                             lines))
                 (loop))))))))
@end smallexample

@c page
@node time
@chapter Date and time


Unless otherwise specified, the bindings documented in this chapter are
exported by the @posix{} @code{time} libraries.

@menu
* time intro::                  Introduction.
* time structs::                Data structures.
* time records::                Record types.
* time constants::              Constant values.
* time clock::                  Processor time.
* time calendar::               Simple calendar time.
* time hires::                  High resolution calendar.
* time broken::                 Broken--down time.
* time hiaccu::                 High accuracy clock.
* time format::                 Formatting broken--down time.
* time parsing::                Parsing time strings.
* time alarm::                  Setting time alarms.
* time sleep::                  Sleeping.
@end menu

@c page
@node time intro
@section Introduction


Time handling is a complex topic, so we really want to read some
discussion on it; for example the introduction in the @gnu{} C Library
documentation.  @glibcref{Time Basics, Time Basics}.

@c ------------------------------------------------------------

@subsubheading About the @code{time_t} type


The @code{time_t} type is used by several functions, but it is not fully
specified@footnote{See for example (@aurl{} last verified Thu Nov 12,
2009):

@center @url{http://en.wikipedia.org/wiki/Unix_time}
}; it represents the @dfn{epoch}: The number of seconds elapsed since
00:00:00 on January 1, 1970, Coordinated Universal Time.

To solve the representation problem, @code{time_t} values are casted to
native @code{double} values and then converted to Scheme inexact real
numbers, whatever they are for the underlying Scheme representation.

@c page
@node time structs
@section Data structures


Unless otherwise specified, the bindings documented in this section are
exported by the @code{sizeof} library.

@menu
* time structs timeval::        @code{struct timeval} inspection.
* time structs timespec::       @code{struct timespec} inspection.
* time structs tms::            @code{struct tms} inspection.
* time structs timezone::       @code{struct timezone} inspection.
* time structs tm::             @code{struct tm} inspection.
* time structs ntptimeval::     @code{struct ntptimeval} inspection.
* time structs timex::          @code{struct timex} inspection.
* time structs itimerval::      @code{struct itimerval} inspection.
@end menu

@c page
@node time structs timeval
@subsection @code{struct timeval} inspection


@defvr Constant sizeof-timeval
@defvrx Constant alignof-timeval
@defvrx Constant strideof-timeval
These are: the number of bytes required to hold a @code{struct timeval};
the alignment of this structure when embedded into another structure;
the number of bytes between two elements in an array of these
structures.
@end defvr


@deffn Syntax struct-timeval-tv_sec-ref @var{pointer}
@deffnx Syntax struct-timeval-tv_sec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timeval-tv_usec-ref @var{pointer}
@deffnx Syntax struct-timeval-tv_usec-set! @var{pointer} @var{value}
Accessors and mutators for the fields of a @code{struct timeval}.
@end deffn

@c page
@node time structs timespec
@subsection @code{struct timespec} inspection


@defvr Constant sizeof-timespec
@defvrx Constant alignof-timespec
@defvrx Constant strideof-timespec
These are: the number of bytes required to hold a @code{struct timespec};
the alignment of this structure when embedded into another structure;
the number of bytes between two elements in an array of these
structures.
@end defvr


@deffn Syntax struct-timespec-tv_sec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timespec-tv_sec-ref @var{pointer}
@deffnx Syntax struct-timespec-tv_nsec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timespec-tv_nsec-ref @var{pointer}
Accessors and mutators for the fields of a @code{struct timespec}.
@end deffn

@c page
@node time structs tms
@subsection @code{struct tms} inspection


@defvr Constant sizeof-tms
@defvrx Constant alignof-tms
@defvrx Constant strideof-tms
These are: the number of bytes required to hold a @code{struct tms}; the
alignment of this structure when embedded into another structure; the
number of bytes between two elements in an array of these structures.
@end defvr


@defun struct-tms-tms_utime-ref @var{pointer}
@defunx struct-tms-tms_utime-set! @var{pointer} @var{value}
@defunx struct-tms-tms_stime-ref @var{pointer}
@defunx struct-tms-tms_stime-set! @var{pointer} @var{value}
@defunx struct-tms-tms_cutime-ref @var{pointer}
@defunx struct-tms-tms_cutime-set! @var{pointer} @var{value}
@defunx struct-tms-tms_cstime-ref @var{pointer}
@defunx struct-tms-tms_cstime-set! @var{pointer} @var{value}
Accessors for the fields of a @code{struct tms} type.

These bindings are exported by the @library{foreign posix time platform}
library.
@end defun

@c page
@node time structs timezone
@subsection @code{struct timezone} inspection


@defvr Constant sizeof-timezone
@defvrx Constant alignof-timezone
@defvrx Constant strideof-timezone
These are: the number of bytes required to hold a @code{struct
timezone}; the alignment of this structure when embedded into another
structure; the number of bytes between two elements in an array of these
structures.
@end defvr


@deffn Syntax struct-timezone-tz_minuteswest-ref @var{pointer}
@deffnx Syntax struct-timezone-tz_minuteswest-set! @var{pointer} @var{value}
@deffnx Syntax struct-timezone-tz_dsttime-ref @var{pointer}
@deffnx Syntax struct-timezone-tz_dsttime-set! @var{pointer} @var{value}
Peekers and pokers for the fields of a @code{struct timezone}.
@end deffn

@c page
@node time structs tm
@subsection @code{struct tm} inspection


@defvar sizeof-tm
@defvarx alignof-tm
@defvarx strideof-tm
These are: the number of bytes required to hold a @code{struct tm}; the
alignment of this structure when embedded into another structure; the
number of bytes between two elements in an array of these structures.
@end defvar


@deffn Syntax struct-tm-tm_sec-ref @var{pointer}
@deffnx Syntax struct-tm-tm_sec-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_min-ref @var{pointer}
@deffnx Syntax struct-tm-tm_min-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_hour-ref @var{pointer}
@deffnx Syntax struct-tm-tm_hour-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_mday-ref @var{pointer}
@deffnx Syntax struct-tm-tm_mday-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_mon-ref @var{pointer}
@deffnx Syntax struct-tm-tm_mon-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_year-ref @var{pointer}
@deffnx Syntax struct-tm-tm_year-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_wday-ref @var{pointer}
@deffnx Syntax struct-tm-tm_wday-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_yday-ref @var{pointer}
@deffnx Syntax struct-tm-tm_yday-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_isdst-ref @var{pointer}
@deffnx Syntax struct-tm-tm_isdst-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_gmtoff-ref @var{pointer}
@deffnx Syntax struct-tm-tm_gmtoff-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_zone-ref @var{pointer}
@deffnx Syntax struct-tm-tm_zone-set! @var{pointer} @var{value}
Accessors and mutators for the fields of a @code{struct tm}.
@end deffn

@c page
@node time structs ntptimeval
@subsection @code{struct ntptimeval} inspection



@defvar sizeof-ntptimeval
@defvarx alignof-ntptimeval
@defvarx strideof-ntptimeval
These are: the number of bytes required to hold a @code{struct
ntptimeval}; the alignment of this structure when embedded into another
structure; the number of bytes between two elements in an array of these
structures.
@end defvar


@deffn Syntax struct-ntptimeval-time-ref @var{pointer}
Given a pointer to a @code{struct ntptimeval} instance, evaluates to a
pointer to the first byte of the @code{struct timeval time} field of the
structure.
@end deffn


@deffn Syntax struct-ntptimeval-maxerror-ref @var{pointer}
@deffnx Syntax struct-ntptimeval-maxerror-set! @var{pointer} @var{value}
@deffnx Syntax struct-ntptimeval-esterror-ref @var{pointer}
@deffnx Syntax struct-ntptimeval-esterror-set! @var{pointer} @var{value}
Accessors and mutators for the fields of a @code{struct ntptimeval}
type.
@end deffn

@c page
@node time structs timex
@subsection @code{struct timex} inspection


The following bindings implement inspection for the @code{struct timex}
type.  @glibcref{High Accuracy Clock, High Accuracy Clock}.


@defvar sizeof-timex
@defvarx alignof-timex
@defvarx strideof-timex
These are: the number of bytes required to hold a @code{struct
timex}; the alignment of this structure when embedded into another
structure; the number of bytes between two elements in an array of these
structures.
@end defvar


@deffn Syntax struct-timex-time-ref @var{pointer}
Given a pointer to a @code{struct timex} instance, evaluates to a
pointer to the first byte of the @code{struct timeval time} field of the
structure.
@end deffn


@deffn Syntax struct-timex-modes-ref @var{pointer}
@deffnx Syntax struct-timex-modes-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-offset-ref @var{pointer}
@deffnx Syntax struct-timex-offset-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-freq-ref @var{pointer}
@deffnx Syntax struct-timex-freq-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-maxerror-ref @var{pointer}
@deffnx Syntax struct-timex-maxerror-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-esterror-ref @var{pointer}
@deffnx Syntax struct-timex-esterror-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-status-ref @var{pointer}
@deffnx Syntax struct-timex-status-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-constant-ref @var{pointer}
@deffnx Syntax struct-timex-constant-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-precision-ref @var{pointer}
@deffnx Syntax struct-timex-precision-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-tolerance-ref @var{pointer}
@deffnx Syntax struct-timex-tolerance-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-tick-ref @var{pointer}
@deffnx Syntax struct-timex-tick-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-ppsfreq-ref @var{pointer}
@deffnx Syntax struct-timex-ppsfreq-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-jitter-ref @var{pointer}
@deffnx Syntax struct-timex-jitter-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-shift-ref @var{pointer}
@deffnx Syntax struct-timex-shift-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-stabil-ref @var{pointer}
@deffnx Syntax struct-timex-stabil-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-jitcnt-ref @var{pointer}
@deffnx Syntax struct-timex-jitcnt-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-calcnt-ref @var{pointer}
@deffnx Syntax struct-timex-calcnt-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-errcnt-ref @var{pointer}
@deffnx Syntax struct-timex-errcnt-set! @var{pointer} @var{value}
@deffnx Syntax struct-timex-stbcnt-ref @var{pointer}
@deffnx Syntax struct-timex-stbcnt-set! @var{pointer} @var{value}
Accessors and mutators for the fields of a @code{struct timex}
type.
@end deffn

@c page
@node time structs itimerval
@subsection @code{struct itimerval} inspection


The following bindings implement inspection for the @code{struct
itimerval} type.  @glibcref{Setting an Alarm, Setting an Alarm}.


@defvar sizeof-itimerval
@defvarx alignof-itimerval
@defvarx strideof-itimerval
These are: the number of bytes required to hold a @code{struct
itimerval}; the alignment of this structure when embedded into another
structure; the number of bytes between two elements in an array of these
structures.
@end defvar


@deffn Syntax struct-itimerval-it_value-ref @var{pointer}
@deffnx Syntax struct-itimerval-it_interval-ref @var{pointer}
Given a pointer to a @code{struct itimerval} instance, evaluate to a
pointer to the first byte of the @code{struct timeval it_interval} and
@code{struct timeval it_value} fields of the structure.
@end deffn

@c page
@node time records
@section Record types


Unless otherwise specified, the bindings described in this section are
exported by the @library{foreign posix time record-types} library.

@menu
* time records tms::            @code{struct tms} mirror.
* time records timeval::        @code{struct timeval} mirror.
* time records timespec::       @code{struct timespec} mirror.
* time records timezone::       @code{struct timezone} mirror.
* time records tm::             @code{struct tm} mirror.
* time records ntptimeval::     @code{struct ntptimeval} mirror.
* time records timex::          @code{struct timex} mirror.
* time records itimerval::      @code{struct itimerval} mirror.
@end menu

@c page
@node time records tms
@subsection @code{struct tms} mirror


The record type described here is used to mirror the C language data
type @code{struct tms}.  @glibcref{Processor Time, Processor Time
Inquiry}.


@deftp {Record Type Name} <struct-tms>
@deftpx {Record Type Descriptor} <struct-tms-rtd>
A Scheme record used to hold normalised results of @func{times}
invocations.  It has the following fields, one for each field of the
@code{struct tms} type: @code{utime}, @code{stime}, @code{cutime},
@code{cstime}; all the values are inexact real numbers.
@end deftp


@defun make-<struct-tms> @var{utime} @var{stime} @var{cutime} @var{cstime}
@defunx <struct-tms>? @var{obj}
Constructor and predicate for records of type @class{struct-tms}.
@end defun


@defun struct-tms->record @var{pointer}
@defunx record->struct-tms @var{record} @var{malloc}
Convert between a pointer to a @code{struct tms} instance and a record
of type @class{struct-tms}.  The @var{malloc} function is used to
allocate the block of memory in which the @code{struct tms} is stored.
@end defun


@defun <struct-tms>-utime @var{tms}
@defunx <struct-tms>-utime-set! @var{tms} @var{value}
@defunx <struct-tms>-stime @var{tms}
@defunx <struct-tms>-stime-set! @var{tms} @var{value}
@defunx <struct-tms>-cutime @var{tms}
@defunx <struct-tms>-cutime-set! @var{tms} @var{value}
@defunx <struct-tms>-cstime @var{tms}
@defunx <struct-tms>-cstime-set! @var{tms} @var{value}
Accessors and mutators for @class{struct-tms} records.
@end defun

@c page
@node time records timeval
@subsection @code{struct timeval} mirror


The record type described here is used to mirror the C language data
type @code{struct timeval}.  @glibcref{Elapsed Time, Elapsed Time}.


@deftp {Record Type Name} <struct-timeval>
@deftpx {Record Type Descriptor} <struct-timeval-rtd>
Record type that mirrors the @code{struct timeval} type.  It has the
following fields, one for each field of the @code{struct timeval} type:
@code{sec}, @code{usec}.
@end deftp


@defun make-<struct-timeval> @var{tv_sec} @var{tv_usec}
@defunx <struct-timeval>? @var{obj}
Constructor and predicate for @class{struct-timeval} records.
@end defun


@defun struct-timeval->record @var{struct-timeval-pointer}
@defunx record->struct-timeval @var{timeval-record} @var{malloc}
Convert between a pointer to a @code{struct timeval} instance and a
record of type @class{struct-timeval}.  The @var{malloc} function is
used to allocate memory in which the @code{struct timeval} is stored.
@end defun


@defun <struct-timeval>-sec @var{timeval-record}
@defunx <struct-timeval>-sec-set! @var{timeval-record} @var{value}
@defunx <struct-timeval>-usec @var{timeval-record}
@defunx <struct-timeval>-usec-set! @var{timeval-record} @var{value}
Accessors and mutators @class{struct-timeval} records.
@end defun

@c page
@node time records timespec
@subsection @code{struct timespec} mirror


The record type described here is used to mirror the C language data
type @code{struct timespec}.  @glibcref{Elapsed Time, Elapsed Time}.


@deftp {Record Type Name} <struct-timespec>
@deftpx {Record Type Descriptor} <struct-timespec-rtd>
Record type that mirrors the @code{struct timespec} type.  It has the
following fields, one for each field of the @code{struct timespec} type:
@code{sec}, @code{nsec}.
@end deftp


@defun make-<struct-timespec> @var{tv_sec} @var{tv_nsec}
@defunx <struct-timespec>? @var{obj}
Constructor and predicate for @class{struct-timespec} records.
@end defun


@defun struct-timespec->record @var{struct-timespec-pointer}
@defunx record->struct-timespec @var{timespec-record} @var{malloc}
Convert between a pointer to a @code{struct timespec} instance and a
record of type @class{struct-timespec}.  The @var{malloc} function is
used to allocate memory in which the @code{struct timespec} is stored.
@end defun


@defun <struct-timespec>-sec @var{timespec-record}
@defunx <struct-timespec>-sec-set! @var{timespec-record} @var{value}
@defunx <struct-timespec>-nsec @var{timespec-record}
@defunx <struct-timespec>-nsec-set! @var{timespec-record} @var{value}
Accessors and mutators @class{struct-timespec} records.
@end defun

@c page
@node time records timezone
@subsection @code{struct timezone} mirror


The record type described here is used to mirror the C language data
type @code{struct timezone}.  @glibcref{High-Resolution Calendar,
High--Resolution Calendar}.


@deftp {Record Type Name} <struct-timezone>
@deftpx {Record Type Descriptor} <struct-timezone-rtd>
Record type that mirrors the @code{struct timezone} type.  It has the
following fields, one for each field in the @code{struct timezone} type:
@code{minuteswest}, @code{dsttime}.
@end deftp


@defun make-<struct-timezone> @var{tz_minuteswest} @var{tz_dsttime}
@defunx <struct-timezone>? @var{obj}
Constructor and predicate for @class{struct-timezone} records.
@end defun


@defun struct-timezone->record @var{struct-timezone-pointer}
@defunx record->struct-timezone @var{timezone-record} @var{malloc}
Convert between a pointer to a @code{struct timezone} instance and a
record of type @class{struct-timezone}.  The @var{malloc} function is
used to allocate memory in which the @code{struct timezone} is stored.
@end defun


@defun <struct-timezone>-minuteswest @var{timezone-record}
@defunx <struct-timezone>-minuteswest-set! @var{timezone-record} @var{value}
@defunx <struct-timezone>-dsttime @var{timezone-record}
@defunx <struct-timezone>-dsttime-set! @var{timezone-record} @var{value}
Accessors and mutators @class{struct-timezone} records.
@end defun

@c page
@node time records tm
@subsection @code{struct tm} mirror


The record type described here is used to mirror the C language data
type @code{struct tm}.  @glibcref{Broken-down Time, Broken--down Time}.


@deftp {Record Type Name} <struct-tm>
@deftpx {Record Type Descriptor} <struct-tm-rtd>
Record type that mirrors the @code{struct tm} type.  It has the
following fields, one for each field in the @code{struct tm} type:
@code{sec}, @code{min}, @code{hour}, @code{mday}, @code{mon},
@code{year}, @code{wday}, @code{yday}, @code{isdst}, @code{gmtoff},
@code{zone}.

Notice that the @code{zone} field is meant to hold a pointer to a C
string.
@end deftp


@defun make-<struct-tm> @var{tm_sec} @var{tm_min} @var{tm_hour} @var{tm_mday} @var{tm_mon} @var{tm_year} @var{tm_wday} @var{tm_yday} @var{tm_isdst} @var{tm_gmtoff} @var{tm_zone}
@defunx <struct-tm>? @var{obj}
Constructor and predicate for @class{struct-tm} records.
@end defun


@defun struct-tm->record @var{struct-tm-pointer}
@defunx record->struct-tm @var{tm-record} @var{malloc}
Convert between a pointer to a @code{struct tm} instance and a
record of type @class{struct-tm}.  The @var{malloc} function is
used to allocate memory in which the @code{struct tm} is stored.

Notice that no conversion is performed on the value in the @code{zone}
field; we have to explicitly convert between C strings and Scheme
strings.
@end defun


@defun <struct-tm>-sec @var{tm-record}
@defunx <struct-tm>-sec-set! @var{tm-record} @var{value}
@defunx <struct-tm>-min @var{tm-record}
@defunx <struct-tm>-min-set! @var{tm-record} @var{value}
@defunx <struct-tm>-hour @var{tm-record}
@defunx <struct-tm>-hour-set! @var{tm-record} @var{value}
@defunx <struct-tm>-mday @var{tm-record}
@defunx <struct-tm>-mday-set! @var{tm-record} @var{value}
@defunx <struct-tm>-mon @var{tm-record}
@defunx <struct-tm>-mon-set! @var{tm-record} @var{value}
@defunx <struct-tm>-year @var{tm-record}
@defunx <struct-tm>-year-set! @var{tm-record} @var{value}
@defunx <struct-tm>-wday @var{tm-record}
@defunx <struct-tm>-wday-set! @var{tm-record} @var{value}
@defunx <struct-tm>-yday @var{tm-record}
@defunx <struct-tm>-yday-set! @var{tm-record} @var{value}
@defunx <struct-tm>-isdst @var{tm-record}
@defunx <struct-tm>-isdst-set! @var{tm-record} @var{value}
@defunx <struct-tm>-gmtoff @var{tm-record}
@defunx <struct-tm>-gmtoff-set! @var{tm-record} @var{value}
@defunx <struct-tm>-zone @var{tm-record}
@defunx <struct-tm>-zone-set! @var{tm-record} @var{value}
Accessors and mutators @class{struct-tm} records.
@end defun

@c page
@node time records ntptimeval
@subsection @code{struct ntptimeval} mirror


The record type described here is used to mirror the C language data
type @code{struct ntptimeval}.  @glibcref{High Accuracy Clock, High
Accuracy Clock}.


@deftp {Record Type Name} <struct-ntptimeval>
@deftpx {Record Type Descriptor} <struct-ntptimeval-rtd>
Record type that mirrors the @code{struct ntptimeval} type.  It has the
following fields, one for each field in the @code{struct ntptimeval} type:
@code{time}, @code{maxerror}, @code{esterror}.  The @code{time} field
contains a @class{struct-timeval} record.
@end deftp


@defun make-<struct-ntptimeval> @var{time}, @var{maxerror}, @var{esterror}
@defunx <struct-ntptimeval>? @var{obj}
Constructor and predicate for @class{struct-ntptimeval} records.
@end defun


@defun struct-ntptimeval->record @var{struct-ntptimeval-pointer}
@defunx record->struct-ntptimeval @var{ntptimeval-record} @var{malloc}
Convert between a pointer to a @code{struct ntptimeval} instance and a
record of type @class{struct-ntptimeval}.  The @var{malloc} function is
used to allocate memory in which the @code{struct ntptimeval} is stored.
@end defun


@defun <struct-ntptimeval>-time @var{pointer}
@defunx <struct-ntptimeval>-time-set! @var{pointer} @var{value}
@defunx <struct-ntptimeval>-maxerror @var{pointer}
@defunx <struct-ntptimeval>-maxerror-set! @var{pointer} @var{value}
@defunx <struct-ntptimeval>-esterror @var{pointer}
@defunx <struct-ntptimeval>-esterror-set! @var{pointer} @var{value}
Accessors and mutators @class{struct-ntptimeval} records.
@end defun

@c page
@node time records timex
@subsection @code{struct timex} mirror


The record type described here is used to mirror the C language data
type @code{struct timex}.  @glibcref{High Accuracy Clock, High Accuracy
Clock}.


@deftp {Record Type Name} <struct-timex>
@deftpx {Record Type Descriptor} <struct-timex-rtd>
Record type that mirrors the @code{struct timex} type.  It has the
following fields, one for each field in the @code{struct timex} type:
@code{modes}, @code{offset}, @code{freq}, @code{maxerror},
@code{esterror}, @code{status}, @code{constant}, @code{precision},
@code{tolerance}, @code{time}, @code{tick}, @code{ppsfreq},
@code{jitter}, @code{shift}, @code{stabil}, @code{jitcnt},
@code{calcnt}, @code{errcnt}, @code{stbcnt}.  The @code{time} field
contains a @class{struct-timeval} record.
@end deftp


@defun make-<struct-timex> @var{modes} @var{offset} @var{freq} @var{maxerror} @var{esterror} @var{status} @var{constant} @var{precision} @var{tolerance} @var{time} @var{tick} @var{ppsfreq} @var{jitter} @var{shift} @var{stabil} @var{jitcnt} @var{calcnt} @var{errcnt} @var{stbcnt}
@defunx <struct-timex>? @var{obj}
Constructor and predicate for @class{struct-timex} records.
@end defun


@defun struct-timex->record @var{struct-timex-pointer}
@defunx record->struct-timex @var{timex-record} @var{malloc}
Convert between a pointer to a @code{struct timex} instance and a record
of type @class{struct-timex}.  The @var{malloc} function is used to
allocate memory in which the @code{struct timex} is stored.
@end defun


@defun <struct-timex>-modes @var{pointer}
@defunx <struct-timex>-modes-set! @var{pointer} @var{value}
@defunx <struct-timex>-offset @var{pointer}
@defunx <struct-timex>-offset-set! @var{pointer} @var{value}
@defunx <struct-timex>-freq @var{pointer}
@defunx <struct-timex>-freq-set! @var{pointer} @var{value}
@defunx <struct-timex>-maxerror @var{pointer}
@defunx <struct-timex>-maxerror-set! @var{pointer} @var{value}
@defunx <struct-timex>-esterror @var{pointer}
@defunx <struct-timex>-esterror-set! @var{pointer} @var{value}
@defunx <struct-timex>-status @var{pointer}
@defunx <struct-timex>-status-set! @var{pointer} @var{value}
@defunx <struct-timex>-constant @var{pointer}
@defunx <struct-timex>-constant-set! @var{pointer} @var{value}
@defunx <struct-timex>-precision @var{pointer}
@defunx <struct-timex>-precision-set! @var{pointer} @var{value}
@defunx <struct-timex>-tolerance @var{pointer}
@defunx <struct-timex>-tolerance-set! @var{pointer} @var{value}
@defunx <struct-timex>-time @var{pointer}
@defunx <struct-timex>-time-set! @var{pointer} @var{value}
@defunx <struct-timex>-tick @var{pointer}
@defunx <struct-timex>-tick-set! @var{pointer} @var{value}
@defunx <struct-timex>-ppsfreq @var{pointer}
@defunx <struct-timex>-ppsfreq-set! @var{pointer} @var{value}
@defunx <struct-timex>-jitter @var{pointer}
@defunx <struct-timex>-jitter-set! @var{pointer} @var{value}
@defunx <struct-timex>-shift @var{pointer}
@defunx <struct-timex>-shift-set! @var{pointer} @var{value}
@defunx <struct-timex>-stabil @var{pointer}
@defunx <struct-timex>-stabil-set! @var{pointer} @var{value}
@defunx <struct-timex>-jitcnt @var{pointer}
@defunx <struct-timex>-jitcnt-set! @var{pointer} @var{value}
@defunx <struct-timex>-calcnt @var{pointer}
@defunx <struct-timex>-calcnt-set! @var{pointer} @var{value}
@defunx <struct-timex>-errcnt @var{pointer}
@defunx <struct-timex>-errcnt-set! @var{pointer} @var{value}
@defunx <struct-timex>-stbcnt @var{pointer}
@defunx <struct-timex>-stbcnt-set! @var{pointer} @var{value}
Accessors and mutators @class{struct-timex} records.
@end defun

@c page
@node time records itimerval
@subsection @code{struct itimerval} mirror


The record type described here is used to mirror the C language data
type @code{struct itimerval}.  @glibcref{Setting an Alarm, Setting an
Alarm}.


@deftp {Record Type Name} <struct-itimerval>
@deftpx {Record Type Descriptor} <struct-itimerval-rtd>
Record type that mirrors the @code{struct itimerval} type.  It has the
following fields, one for each field in the @code{struct itimerval}
type: @code{interval}, @code{value}.  Both the fields contain a
@class{struct-timeval} record.
@end deftp


@defun make-<struct-itimerval> @var{interval} @var{value}
@defunx <struct-itimerval>? @var{obj}
Constructor and predicate for @class{struct-itimerval} records.
@end defun


@defun struct-itimerval->record @var{struct-itimerval-pointer}
@defunx record->struct-itimerval @var{itimerval-record} @var{malloc}
Convert between a pointer to a @code{struct itimerval} instance and a
record of type @class{struct-itimerval}.  The @var{malloc} function is
used to allocate memory in which the @code{struct itimerval} is stored.
@end defun


@defun <struct-itimerval>-interval @var{pointer}
@defunx <struct-itimerval>-interval-set! @var{pointer} @var{value}
@defunx <struct-itimerval>-value @var{pointer}
@defunx <struct-itimerval>-value-set! @var{pointer} @var{value}
Accessors and mutators @class{struct-itimerval} records.
@end defun

@c page
@node time constants
@section Constant values


The following bindings are exported by the @code{sizeof} library.


@defvr Constant CLOCKS_PER_SEC
The number of clock ticks per second measured by the @func{clock}
function.
@end defvr


@defvr Constant ITIMER_REAL
@defvrx Constant ITIMER_VIRTUAL
@defvrx Constant ITIMER_PROF
Timer selection for @func{setitimer}.
@end defvr

@c page
@node time clock
@section Processor time


The following functions handle processor time.  @glibcref{CPU Time, CPU
Time Inquiry}.  @glibcref{Processor Time, Processor Time Inquiry}.


@deffn Function clock
@deffnx Parameter clock-function
@deffnx Function primitive:clock
@deffnx Function platform:clock
Return the calling process' current @cpu{} time, casted to a native
@code{double} number and then to a Scheme inexact real number.

These bindings are exported by the @posix{} @code{time} libraries.
@end deffn


@deffn Function times
@deffnx Parameter times-function
@deffnx Function primitive:times
@deffnx Function platform:times @var{pointer}
Return two values: the return value from the @cfunc{times} call casted
to a native @code{double} number and then to a Scheme inexact real
number; a record of type @class{struct-tms}.

These bindings are exported by the @posix{} @code{time} libraries.
@end deffn

@c page
@node time calendar
@section Simple calendar time


The following functions deal with simple calendar time.
@glibcref{Simple Calendar Time, Simple Calendar Time}.


@deffn Function time
@deffnx Parameter time-function
@deffnx Function primitive:time
@deffnx Function platform:time
Return the current calendar time represented by a @code{time_t} value,
casted to a native @code{double} value and then converted to a Scheme
inexact real number.  It is the @dfn{epoch}: The number of seconds
elapsed since 00:00:00 on January 1, 1970, Coordinated Universal Time.

These bindings are exported by the @posix{} @code{time} libraries.
@end deffn


@deffn Function stime @var{calendar-time}
@deffnx Parameter stime-function
@deffnx Function primitive:stime @var{calendar-time}
@deffnx Function platform:stime @var{calendar-time-double}
Set the system clock using a calendar time specification.  Superuser
privileges are needed to successfully call this function.

@var{calendar-time} must be a Scheme inexact real number, which is
converted to a native @code{double} and finally casted to a
@code{time_t} value.

These bindings are exported by the Glibc @code{time} libraries.
@end deffn

@c page
@node time hires
@section High--resolution calendar


The following functions manage high--resolution calendar time; the
bindings are exported by the Glibc @code{time} libraries.
@glibcref{High--Resolution Calendar, High--Resolution Calendar}.


@deffn Function gettimeofday
@deffnx Parameter gettimeofday-function
@deffnx Function primitive:gettimeofday
@deffnx Function platform:gettimeofday @var{timeval-ptr} @var{timezone-ptr}
Build and return two values: a record of type @class{struct-timeval}, a
record of type @class{struct-timezone}; they represent the current time.
@end deffn


@deffn Function settimeofday @var{timeval} @var{timezone}
@deffnx Parameter settimeofday-function
@deffnx Function primitive:settimeofday @var{timeval} @var{timezone}
@deffnx Function platform:settimeofday @var{timeval-ptr} @var{timezone-ptr}
Set the system clock to the calendar time specified by the @var{timeval}
and @var{timezone} arguments, which must be a @class{struct-timeval}
record and a @class{struct-timezone} record.

Super user privileges are needed to successfully call this function.
@end deffn


@deffn Function adjtime @var{timeval-delta}
@deffnx Parameter adjtime-function
@deffnx Function primitive:adjtime @var{timeval-delta}
@deffnx Function platform:adjtime @var{timeval-delta-ptr} @var{timeval-old-delta-ptr}
Speed up or slow down the system clock in order to make a gradual
adjustment maintaining a monotonic clock value.  The time delta is
described by @var{timeval-delta}, which must be a record of type
@class{struct-timeval}.

The @func{adjtime} and @func{primitive:adjtime} functions return two
values: the return value from the foreign function and a record of type
@class{timeval-delta} describing any previous time adjustment that has
yet not completed.

Super user privileges are needed to successfully call this function.
@end deffn

@c page
@node time broken
@section Broken--down time


The following functions manage broken--down time; unless otherwise
specified, the bindings are exported by the Glibc @code{time} libraries.
@glibcref{Broken-down Time, Broken--down Time}.


@deffn Function localtime @var{time} @var{malloc}
@deffnx Parameter localtime-function
@deffnx Function primitive:localtime @var{time} @var{malloc}
@deffnx Function platform:localtime_r @var{time} @var{tm-pointer}
Allocate a new @code{struct tm} instance using the @var{malloc}
function, then fill it broken--down values from the calendar @var{time}
(which can be the return value of @func{time}).  The return value is the
pointer to the @code{struct tm} instance.

Despite the names, these functions are wrappers for the
@cfunc{localtime_r} function, so they are reentrant.

For example, to get the current year:

@example
(define (gimme-year)
  (with-compensations
    (let ((tm* (localtime (time) malloc-block/c)))
      (+ 1900 (struct-tm-tm_year-ref tm*)))))
@end example
@end deffn


@deffn Function localtime* @var{time}
@deffnx Parameter localtime*-parameter
@deffnx Function primitive:localtime* @var{time}
Wrapper for @func{primitive:localtime} which automatically converts the
@code{struct tm} instance into a @class{struct-tm} record and returns
it.

For example, to get the current year:

@example
(define (gimme-year*)
  (+ 1900 (<struct-tm>-year (localtime* (time)))))
@end example
@end deffn


@deffn Function gmtime @var{time} @var{malloc}
@deffnx Parameter gmtime-function
@deffnx Function primitive:gmtime @var{time} @var{malloc}
@deffnx Function platform:gmtime @var{time} @var{tm-pointer}
Like @func{localtime} but converts the given time as Coordinated
Universal Time (@acronym{UTC}).
@end deffn


@deffn Function gmtime* @var{time}
@deffnx Parameter gmtime*-parameter
@deffnx Function primitive:gmtime* @var{time}
Wrapper for @func{primitive:gmtime} which automatically converts the
@code{struct tm} instance into a @class{struct-tm} record and returns
it.
@end deffn


@deffn Function timelocal @var{tm-pointer}
@deffnx Parameter timelocal-function
@deffnx Function primitive:timelocal @var{tm-pointer}
@deffnx Function platform:timelocal @var{tm-pointer}
Return a calendar time value from the @code{struct tm} referenced by
@var{tm-pointer}; the returned value is a @code{time_t} casted to a
native @code{double} and converted to a Scheme inexact real number.  It
is the inverse of @func{localtime}.

@cindex @func{mktime}
@quotation
@strong{NOTE} The @cfunc{mktime} function does the same thing of the
@cfunc{timelocal} function; for this reason it is not exported.
@end quotation
@end deffn


@deffn Function timelocal* @var{tm-record}
@deffnx Parameter timelocal*-function
@deffnx Function primitive:timelocal* @var{tm-record}
Wrapper for @func{primitive:timelocal} which automatically converts
@var{tm-record}, which must be a @class{struct-tm} record, into an
instance of @code{struct tm}.
@end deffn


@deffn Function timegm @var{tm-pointer}
@deffnx Parameter timegm-function
@deffnx Function primitive:timegm @var{tm-pointer}
@deffnx Function platform:timegm @var{tm-pointer}
Return a calendar time value from the @code{struct tm} referenced by
@var{tm-pointer}; the returned value is a @code{time_t} casted to a
native @code{double} and converted to a Scheme inexact real number.  It
is the inverse of @func{gmtime}.
@end deffn


@deffn Function timegm* @var{tm-record}
@deffnx Parameter timegm*-function
@deffnx Function primitive:timegm* @var{tm-record}
Wrapper for @func{primitive:timegm} which automatically converts
@var{tm-record}, which must be a @class{struct-tm} record, into an
instance of @code{struct tm}.
@end deffn

@c page
@node time hiaccu
@section High accuracy clock


The following functions implement an interface to the system clock;
unless otherwise specified, the bindings are exported by the Glibc
@code{time} libraries.  @glibcref{High Accuracy Clock, High Accuracy
Clock}.


@deffn Function ntp_gettime @var{pointer}
@deffnx Parameter ntp_gettime-function
@deffnx Function primitive:ntp_gettime @var{pointer}
@deffnx Function platform:ntp_gettime @var{pointer}
Fill the @code{struct ntptimeval} instance referenced by @var{pointer}
with current values from the system's kernel.
@end deffn


@deffn Function ntp_gettime*
@deffnx Parameter ntp_gettime-function
@deffnx Function primitive:ntp_gettime*
Wrappers for @func{primitive:ntp_gettime} which automatically convert
the @code{struct ntptimeval} instance into a @class{struct-ntptimeval}
record; return the record.
@end deffn


@deffn Function ntp_adjtime @var{pointer}
@deffnx Parameter ntp_adjtime-function
@deffnx Function primitive:ntp_adjtime @var{pointer}
@deffnx Function platform:ntp_adjtime @var{pointer}
Set the @code{struct timex} instance referenced by @var{pointer} to
current values, also set some kernel values with values from the
instance.  See the original documentation for details.

Superuser privileges are needed to successfully call this function.
@end deffn


@deffn Function ntp_adjtime* @var{record}
@deffnx Parameter ntp_adjtime-function
@deffnx Function primitive:ntp_adjtime* @var{record}
Wrappers for @func{primitive:ntp_adjtime} which automatically convert
the @class{struct-timex} @var{record} into a @code{struct timex}
instance, hand the structure to @func{primitive:ntp_adjtime}, finally
convert the modified structure into a new @class{struct-timex} record
and return it.

The original @var{record} is @strong{not} mutated.
@end deffn

@c page
@node time format
@section Formatting broken--down time


The following functions format broken--down time specifications into
strings; unless otherwise specified, the bindings are exported by the
Glibc @code{time} libraries.  @glibcref{Formatting Calendar Time,
Formatting Calendar Time}.


@deffn Function asctime @var{pointer}
@deffnx Parameter asctime-function
@deffnx Function primitive:asctime @var{pointer}
@deffnx Function platform:asctime_r @var{pointer} @var{cstr}
Convert the time specification in the @code{struct tm} instance
referenced by @var{pointer} into a string in a standard format; return a
Scheme string.

Despite the names, these are wrappers for @cfunc{asctime_r}, so they are
reentrant.
@end deffn


@deffn Function asctime* @var{record}
@deffnx Parameter asctime*-function
@deffnx Function primitive:asctime* @var{record}
Wrappers for @func{primitive:asctime} which automatically convert the
@class{struct-tm} @var{record} into an instance of @code{struct tm} and
perform the conversion to string.
@end deffn


@deffn Function ctime @var{calendar-time}
@deffnx Parameter ctime-function
@deffnx Function primitive:ctime @var{calendar-time}
@deffnx Function platform:ctime_r @var{calendar-time} @var{cstr}
Convert the time specification of @var{calendar-time} into a string in a
standard format; return a Scheme string.

Despite the names, these are wrappers for @cfunc{ctime_r}, so they are
reentrant.
@end deffn


@deffn Function strftime @var{template} @var{pointer}
@deffnx Parameter strftime-function
@deffnx Function primitive:strftime @var{template} @var{pointer}
@deffnx Function platform:strftime @var{output-cstr} @var{output-len} @var{template-cstr} @var{pointer}
Return a Scheme string representing the date and time specification
described by @var{template}, which must be a Scheme string, and the
@code{struct tm} instance referenced by @var{pointer}.

@quotation
@strong{NOTE} At present the maximum length of the output string is
@math{4095} bytes.  If the time specification and template require more
than that number of bytes, an error is raised.
@end quotation
@end deffn


@deffn Function strftime* @var{template} @var{record}
@deffnx Parameter strftime*-function
@deffnx Function primitive:strftime* @var{template} @var{record}
Wrappers for @func{primitive:strftime} which automatically convert the
@class{struct-tm} @var{record} into an instance of @code{struct tm},
then build and return the output string.
@end deffn

@c page
@node time parsing
@section Parsing time strings


The following functions parse strings containing time and date
specifications; unless otherwise specified, the bindings are exported by
the Glibc @code{time} libraries.  @glibcref{Low-Level Time String
Parsing, Interpret string according to given format}.


@deffn Function strptime @var{input} @var{template} @var{pointer}
@deffnx Parameter strptime-function
@deffnx Function primitive:strptime @var{input} @var{template} @var{pointer}
@deffnx Function platform:strptime @var{input-cstr} @var{template-cstr} @var{pointer}
Parse the @var{input} Scheme string according to the @var{template}
Scheme string and store the values in the @code{struct tm} instance
referenced by @var{pointer}.
@end deffn


@deffn Function strptime* @var{input} @var{template}
@deffnx Parameter strptime*-function
@deffnx Function primitive:strptime* @var{input} @var{template}
Wrappers for @func{primitive:strptime} which allocate a @code{struct tm}
instance and convert it to a @class{struct-tm} record; return the
record.

Before calling @func{primitive:strptime} all the integer fields of
@code{struct tm} are initialised to @code{INT_MAX} and the @code{zone}
field is initialised to the @cnull{} pointer.
@end deffn

@c page
@node time alarm
@section Setting time alarms


The following functions manage time alarms; unless otherwise specified,
the bindings are exported by the Glibc @code{time} libraries.
@glibcref{Setting an Alarm, Setting an Alarm}.


@deffn Function setitimer @var{which} @var{new} @var{old}
@deffnx Parameter setitimer-function
@deffnx Function primitive:setitimer @var{which} @var{new} @var{old}
@deffnx Function platform:setitimer @var{which} @var{new} @var{old}
Set the timer specified by @var{which} according to the time
specification in the @code{struct itimerval} instance referenced by the
pointer @var{new}; the old timer specification, for the selected type,
is stored in the @code{struct itimerval} instance referenced by the
pointer @var{old}.

@var{which} can be one among the values bound to @code{ITIMER_REAL},
@code{ITIMER_VIRTUAL} and @code{ITIMER_PROF}.
@end deffn


@deffn Function setitimer* @var{which} @var{new-record}
@deffnx Parameter setitimer*-function
@deffnx Function primitive:setitimer* @var{which} @var{new-pointer}
Wrappers for @func{primitive:setitimer} which internally convert the
@class{struct-itimerval} record @var{new-record} to a @code{struct
itimerval} instance and set the selected timer accordingly; the return
value is a @class{struct-itimerval} record representing the old
specification of the selected timer.
@end deffn


@deffn Function getitimer @var{which} @var{old}
@deffnx Parameter getitimer-function
@deffnx Function primitive:getitimer @var{which} @var{old}
@deffnx Function platform:getitimer @var{which} @var{old}
Store, in the @code{struct itimerval} instance referenced by the pointer
@var{old}, the current timer specification for the selected type.
@var{which} can be one among the values bound to @code{ITIMER_REAL},
@code{ITIMER_VIRTUAL} and @code{ITIMER_PROF}.
@end deffn


@deffn Function getitimer* @var{which}
@deffnx Parameter getitimer*-function
@deffnx Function primitive:getitimer* @var{which}
Wrappers for @func{primitive:getitimer} which internally allocate a
@code{struct itimerval} instance, query the timer status and return a
@class{struct-itimerval} record.
@end deffn


@deffn Function alarm @var{seconds}
@deffnx Parameter alarm-function
@deffnx Function primitive:alarm @var{seconds}
@deffnx Function platform:alarm @var{seconds}
Set the timer of type @code{ITIMER_REAL} to trigger after @var{seconds}
past the call.
@end deffn

@c page
@node time sleep
@section Sleeping


The following bindings halt the process for a short interval; unless
otherwise specified, the bindings are exported by the Glibc @code{time}
libraries.  @glibcref{Sleeping, Sleeping}.


@defun sleep @var{seconds}
@defunx primitive:sleep @var{seconds}
@defunx platform:sleep @var{seconds}
Halt the process for @var{seconds}; return after the elapsed time or if
a signal is received.  The return value is zero if the time is elapsed
or, if a signal is received, the number of seconds still to wait.
@end defun


@deffn Function nanosleep @var{requested} @var{remaining}
@deffnx Parameter nanosleep-function
@deffnx Function primitive:nanosleep @var{requested} @var{remaining}
@deffnx Function platform:nanosleep @var{requested} @var{remaining}
Halt the process for the time specified in the @code{struct timespec}
instance referenced by the @var{requested} pointer; return after the
elapsed time or if a signal is received.  Store in the @code{struct
timespec} instance referenced by the pointer @var{remaining} the
remaining time.
@end deffn


@deffn Function nanosleep* @var{requested}
@deffnx Parameter nanosleep*-function
@deffnx Function primitive:nanosleep* @var{requested}
Wrappers for @func{primitive:nanosleep} which internally convert the
@class{struct-timespec} record @var{requested} in a @code{struct
timespec} instance, halt the process and return the remaining time in a
@class{struct-timespec} record.
@end deffn

@c page
@node process
@chapter Processes


Unless otherwise specified, the bindings described in this chapter are
exported by the following libraries:

@example
(foreign posix process)
(foreign posix process primitives)
(foreign posix process platform)
@end example

@menu
* process record::              Record types.
* process id::                  Process identification.
* process fork::                Creating a process.
* process exec::                Executing a file.
* process wait::                Process completion.
@end menu

@c page
@node process record
@section Record types


The following bindings are exported by the @library{foreign posix
process record-types} library.  @glibcref{Process Completion Status,
Process Completion Status}.


@deftp {Record Type Name} <process-term-status>
@deftpx {Record Type Descriptor} <process-term-status-rtd>
Record type describing the details of a process termination.  It has the
following fields:

@example
WIFEXITED               WEXITSTATUS
WIFSIGNALED             WTERMSIG
WCOREDUMP               WIFSTOPPED
WSTOPSIG
@end example
@end deftp


@defun make-<process-term-status> @var{WIFEXITED} @var{WEXITSTATUS} @var{WIFSIGNALED} @var{WTERMSIG} @var{WCOREDUMP} @var{WIFSTOPPED} @var{WSTOPSIG}
Build and return a new record of type @class{process-term-status}.
@end defun


@defun process-term-status->record @var{status}
Given the exact integer @var{status} representing a process' termination
status, build and return a record of type @class{process-term-status}.
@end defun


@defun WIFEXITED? @var{status-record}
@defunx WEXITSTATUS? @var{status-record}
@defunx WIFSIGNALED? @var{status-record}
@defunx WTERMSIG? @var{status-record}
@defunx WCOREDUMP? @var{status-record}
@defunx WIFSTOPPED? @var{status-record}
@defunx WSTOPSIG? @var{status-record}
Field accessors for records of type @class{process-term-status}.  The
values are all booleans.
@end defun

@c page
@node process id
@section Process identification


The following functions inspect the process identifier.
@glibcref{Process Identification, Process Identification}

@c @quotation
@c @strong{NOTE} It seems that the following functions cannot fail.
@c @end quotation


@deffn Function getpid
@deffnx Parameter getpid-function
@deffnx Function primitive:getpid
@deffnx Function platform:getpid
Return the process id of the current process.  This function cannot
fail, so @func{platform:getpid} returns a single value.
@end deffn


@deffn Function getppid
@deffnx Parameter getppid-function
@deffnx Functionx primitive:getppid
@deffnx Functionx platform:getppid
Return the process id of the parent process.  This function cannot fail,
so @func{platform:getppid} returns a single value.
@end deffn

@c page
@node process fork
@section Creating a process


The following functions manage process forking.  @glibcref{Creating a
Process, Creating a Process}.

@quotation
@strong{NOTE} Access to @cfunc{vfork} is not implemented because it is
impossible to know what the underlying Scheme implementation does.
@end quotation


@deffn Function fork
@deffnx Parameter fork-function
@deffnx Function primitive:fork
@deffnx Function platform:fork
Create a new process by forking the current one.  If successful
@func{fork} returns zero in the child process and the child process' id
in the parent process.
@end deffn

@c page
@node process exec
@section Executing a file


The following functions manage process forking.  @glibcref{Executing a
File, Executing a File}.


@deffn Function execv @var{pathname} @var{args}
@deffnx Parameter execv-function
@deffnx Function primitive:execv @var{pathname} @var{args}
@deffnx Function platform:execv @var{pathname-cstr} @var{argv}
Execute the file selected by the Scheme string or symbol @var{pathname}
using the list of Scheme strings or symbols @var{args} as command line
arguments.  By convention the first value of @var{args} must be the name
(with no directory pathname) of the executed process.  If successful a
new process is executed and these functions do not return.

Usage example:

@example
(when (= 0 (fork))
  (execv '/bin/ls '(ls "-l" /bin)))
@end example

@noindent
notice that command line options like @code{-l} have to be strings (not
symbols) to prevent a syntax error (because the first char @samp{-} is
reserved for numeric datums).
@end deffn


@deffn Function execve @var{pathname} @var{args} @var{envs}
@deffnx Parameter execve-function
@deffnx Function primitive:execve @var{pathname} @var{args} @var{envs}
@deffnx Function platform:execve @var{pathname-cstr} @var{argv} @var{envv}
Execute the file selected by the Scheme string or symbol @var{pathname}
using the list of Scheme strings or symbols @var{args} as command line
arguments.  By convention the first value of @var{args} must be the name
(with no directory part) of the executed process.

@var{envs} must be a list of Scheme strings or symbols used to set the
process execution environment.

If successful a new process is executed and these functions do not
return.

Usage example:

@example
(when (= 0 (fork))
  (execve '/usr/bin/du
          '(du /bin/ls)
          '("BLOCK_SIZE=human-readable")))
@end example

@noindent
notice that command line options like @code{-l} have to be strings (not
symbols) to prevent a syntax error (because the first char @samp{-} is
reserved for numeric datums).
@end deffn


@deffn Function execvp @var{pathname} @var{args}
@deffnx Parameter execvp-function
@deffnx Function primitive:execvp @var{pathname} @var{args}
@deffnx Function platform:execvp @var{pathname-str} @var{argv}
These functions are like the @func{execv} ones, except that
@var{pathname} can be the name of a file that is searched in the current
@env{PATH} search path.
@end deffn


@deffn Function system @var{command}
@deffnx Parameter system-function
@deffnx Function primitive:system @var{command}
@deffnx Function platform:system @var{command-cstr}
Run @var{command} using the system shell.
@end deffn

@c page
@node process wait
@section Process completion


@cindex @code{WNOHANG}
@cindex @code{WUNTRACED}
@cindex @code{WCONTINUED}

The following functions manage waiting for spawned processes.
@glibcref{Process Completion, Process Completion}.

The @var{options} argument can be zero or a @func{bitwise-ior} of
@code{WNOHANG}, @code{WUNTRACED} and @code{WCONTINUED} which are
exported by @library{foreign posix sizeof}.

The following @code{waitpid} functions return a process termination
status in the form of an exact integer.  Such integer can be analysed
with the functions described in @ref{process record, Record types}.


@deffn Parameter waitpid-function
@deffnx Function primitive:waitpid @var{pid} @var{options}
@deffnx Function platform:waitpid @var{pid} @var{pointer} @var{options}
Wait for a single process or a set of processes in a group.  For the
full documentation we have to refer to the documentation of the foreign
function @cfunc{waitpid}.
@end deffn


@defun waitpid @var{pid} @var{options}
A wrapper for the function in the @func{watipid-function} parameter that
tracks a specific child process.
@end defun


@defun waitpid/any @var{options}
A wrapper for the function in the @func{watipid-function} parameter that
tracks all the child processes.
@end defun


@defun waitpid/any-my-group @var{options}
A wrapper for the function in the @func{watipid-function} parameter that
tracks all the child processes in the same group of the caller.
@end defun


@defun waitpid/group @var{gpid} @var{options}
A wrapper for the function in the @func{watipid-function} parameter that
tracks all the child processes in the group with id @var{gpid}.
@end defun


@defun platform:WIFEXITED @var{status}
@defunx platform:WEXITSTATUS @var{status}
@defunx platform:WIFSIGNALED @var{status}
@defunx platform:WTERMSIG @var{status}
@defunx platform:WCOREDUMP @var{status}
@defunx platform:WIFSTOPPED @var{status}
@defunx platform:WSTOPSIG @var{status}
These are wrappers for the macros that extract a value from the
@var{status} integer returned by the waitpid functions.  They can be
used to query the status without building a record.
@end defun

@c page
@node job
@chapter Job control


Unless otherwise specified, the bindings described in this chapter are
exported by the following libraries:

@example
(foreign posix job)
(foreign posix job primitives)
(foreign posix job platform)
@end example

@menu
* job terminal::                Terminal identification.
* job group::                   Process group functions.
* job access::                  Terminal access.
@end menu

@c page
@node job terminal
@section Terminal identification


The following functions manage identification of the terminal of the
process.  @glibcref{Identifying the Terminal, Identifying the
Controlling Terminal}.


@deffn Function ctermid
@deffnx Parameter ctermid-function
@deffnx Function primitive:ctermid
@deffnx Function platform:ctermid @var{pointer}
Return a string representing the pathname of the controlling terminal
for this process.

@var{pointer} can be @func{pointer-null} or a pointer to a buffer of
@code{L_ctermid} bytes in which the foreign function will store the
terminal file pathname as a C string.  @code{L_ctermid} is exported by
@library{foreign posix sizeof}.
@end deffn

@c page
@node job group
@section Process group functions


The following functions manage process groups and sessions.
@glibcref{Process Group Functions, Process Group Functions}.


@deffn Function setsid
@deffnx Parameter setsid-function
@deffnx Function primitive:setsid
@deffnx Function platform:setsid
Create a new session and return an integer representing the new process
group id.
@end deffn


@deffn Function getsid @var{pid}
@deffnx Parameter getsid-function
@deffnx Function primitive:getsid @var{pid}
@deffnx Function platform:getsid @var{pid}
Return the group id of the session leader of the process with @var{pid}.
@end deffn


@deffn Function getpgrp
@deffnx Parameter getpgrp-function
@deffnx Function primitive:getpgrp
@deffnx Function platform:getpgrp
Return the process group id of the group to which the current process
belongs.
@end deffn


@deffn Function setpgid @var{pid} @var{pgid}
@deffnx Parameter setpgid-function
@deffnx Function primitive:setpgid @var{pid} @var{pgid}
@deffnx Function platform:setpgid @var{pid} @var{pgid}
Put the process @var{pid} in the group @var{pgid}.
@end deffn

@c page
@node job access
@section Terminal access


The following functions manage process access to the controlling
terminal.  @glibcref{Terminal Access Functions, Functions for
Controlling Terminal Access}.


@deffn Function tcgetpgrp @var{fd}
@deffnx Parameter tcgetpgrp-function
@deffnx Function primitive:tcgetpgrp @var{fd}
@deffnx Function platform:tcgetpgrp @var{fd}
Return the process group id of the foreground process group associated
with the terminal open on descriptor @var{fd}.
@end deffn


@deffn Function tcsetpgrp @var{fd} @var{pgid}
@deffnx Parameter tcsetpgrp-function
@deffnx Function primitive:tcsetpgrp @var{fd} @var{pgid}
@deffnx Function platform:tcsetpgrp @var{fd} @var{pgid}
Set a terminal's foreground process group id.
@end deffn


@deffn Function tcgetsid @var{fd}
@deffnx Parameter tcgetsid-function
@deffnx Function primitive:tcgetsid @var{fd}
@deffnx Function platform:tcgetsid @var{fd}
Return the process group id of the session for which the file descriptor
@var{fd} is the controlling terminal.
@end deffn

@c page
@node users
@chapter Users and groups


Unless otherwise specified, the bindings described in this chapter are
exported by the following libraries:

@example
(foreign posix users)
(foreign posix users primitives)
(foreign posix users platform)
@end example

@menu
* users persona::               Process' persona.
@end menu

@c page
@node users persona
@section Process' persona


@glibcref{Reading Persona, Reading the Persona of a Process}

@c page
@node strings
@chapter More C string functions


Unless otherwise specified, the functions described in this chapter are
exported by the following libraries:

@example
(foreign glibc cstrings platform)
@end example

@noindent
the purpose of this interface is to alloc some string processing without
conversion from C strings to Scheme strings.

@menu
* strings search::              Searching.
@end menu

@c page
@node strings search
@section Searching


@defun memchr @var{pointer} @var{byte} @var{size}
Finds the first occurrence of @var{byte} in the initial @var{size} bytes
starting at @var{pointer}.  Return a pointer to the located byte or a
null pointer if @var{uchar} was not found.
@end defun


@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
