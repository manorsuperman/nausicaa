\input texinfo.tex
@c %**start of header
@setfilename nausicaa-posix.info
@settitle Nausicaa/POSIX
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro


@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@macro rsixref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@end macro

@macro rfiveref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r5rs}
@end macro

@macro ikarusref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,ikarus}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@macro bibref{TAG}
@samp{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @posix{} features for @rnrs{6} Scheme

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@posix{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-posix

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2008, 2009

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of Nausicaa/POSIX, a set of
Scheme libraries exposing the @posix{} interface to the Scheme language
level.  It is built on top of the Nausicaa/Scheme libraries.

The project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/tree/master}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-posix: (nausicaa-posix).     @posix{} library for
                                        @rnrs{6} Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* posix::                       @posix{} interface.
* time::                        Date and time.
* file::                        File system.
* fd::                          File descriptors.
* process::                     Processes.
* job::                         Job control.
* users::                       Users and groups.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

@posix{} interface

* posix intro::                 Introduction.
* posix memory::                Memory management.
* posix marshaling::            Marshaling arguments and return values.
* posix environment::           Environment variables.

File system

* file working directory::      The working directory.
* file directory access::       Accessing directory entries.
* file links::                  Hard and symbolic links.
* file remove::                 Removing files and directories.
* file rename::                 Renaming files and directories.
* file mkdir::                  Creating directories.
* file attr::                   File attributes.
* file temp::                   Temporary files.

Accessing directory entries

* file directory access types:: Type definitions.
* file directory access open::  Accessing a directory stream.
* file directory access read::  Reading a directory stream.
* file directory access seek::  Random access to a directory stream.

File attributes

* file attr stat::              File attributes.
* file attr owner::             Changing owner and group.
* file attr mode::              Changing file permissions.
* file attr access::            Testing access.
* file attr size::              Size of files.

File attributes

* file attr stat record::       Acquiring the file attributes.
* file attr stat type::         Type inspection.
* file attr stat perms::        Access permissions inspection.

Date and time

* time structs::                Data structures.
* time clock::                  Processor time.

File descriptors

* fd constants::                Variables holding constant values.
* fd open close::               Opening and closing.
* fd read write::               Reading and writing.
* fd seek::                     Setting the file position.
* fd sync::                     Synchronisation.
* fd control::                  Control operations.
* fd dup::                      Duplicating file descriptors.
* fd lock::                     File locks.
* fd pipe::                     Pipes and FIFOs.
* fd custom::                   Custom Scheme ports.

Variables holding constant values

* fd constants status::         File status flags.
* fd constants perms::          Permissions.
* fd constants control::        File control flags.
* fd constants seek::           File positions.
* fd constants lock::           Locking.

Processes

* process id::                  Process identification.
* process fork::                Creating a process.
* process exec::                Executing a file.
* process wait::                Process completion.

Job control

* job terminal::                Terminal identification.
* job group::                   Process group functions.
* job access::                  Terminal access.

Users and groups

* users

@end detailmenu
@end menu

@end ifnottex

@c page
@node posix
@chapter @posix{} interface


@menu
* posix intro::                 Introduction.
* posix api::                   Interface organisation.
* posix memory::                Memory management.
* posix marshaling::            Marshaling arguments and return values.
* posix environment::           Environment variables.
@end menu

@c page
@node posix intro
@section Introduction


This chapter describes an interface to the @posix{} system functions
offered by the underlying platform.  Additionally an interface to the
@gnu{} C Library and some Linux--specific functions is provided.

Some libraries depend upon the C language library
@samp{libnausicaa-posix} from the Nausicaa/Stubs package.

Unless otherwise specified, for each set of features there are three
libraries:

@table @library
@item foreign posix ---
@itemx foreign glibc ---
@itemx foreign linux ---
The high--level interface: slower but user friendly.  We should really
import these libraries by prefixing the identifiers; for example:

@example
(import (rnrs)
  (prefix (foreign posix fd) posix:))
@end example

@item foreign posix --- primitives
@itemx foreign glibc --- primitives
@itemx foreign linux --- primitives
The middle--level interface; does marshaling of arguments and return
values.  In this documentation, all the bindings from these libraries
are prefixed with @samp{primitive-}, but they are exported
@strong{without} this prefix.

@item foreign posix --- platform
@itemx foreign glibc --- platform
@itemx foreign linux --- platform
The low--level interface: Faster but raw.  In this documentation, all
the bindings from these libraries are prefixed with @samp{platform-},
but they are exported @strong{without} this prefix.
@end table

@c page
@node posix api
@section Interface organisation


For all the functions only a brief description is given: We have to use
the foreign function's documentation to have all the details.  Unless
otherwise specified, the interface adheres to the following pattern for
function @func{x}:

@deffn Function x @var{arg} ...
@deffnx Parameter x-function
@deffnx Function primitive-x @var{arg} ...
@deffnx Function platform-x @var{c-arg} ...
This is an interface for the @cfunc{x} foreign function.

@func{x} and @func{primitive-x} do something with the arguments, which
are regular Scheme values.  If successful they return values
representing the result; in case of error they raise an @samp{&errno}
condition.

@func{x} does the job by applying to the arguments the current value of
the @func{x-function} parameter, which must be a function.  The
parameter is initialised to @func{primitive-x}.

@func{platform-x} is the direct wrapper for the foreign function.  It
accepts C language level arguments (like C strings), and returns 2
values: the return value from the foreign function call and the value of
@samp{errno} right after the call.

Notice that, for almost all the functions, the value of @samp{errno} is
meaningful only if the return value from the foreign function call
indicates an error; @samp{errno} may be non--zero even if the function
call was successful.

For the meaning of the C level arguments we have to read the foreign
function's original documentation.
@end deffn


This interface gives us 3 choices:

@enumerate
@item
To call directly the foreign function using the @func{platform-x}
wrapper; in this case we are responsible to convert the Scheme arguments
to the appropriate C language level values (beware to non--garbage
collected values!).

@item
To call the Scheme adapter @func{primitive-x}; this gives us: automatic
conversion of arguments, exceptions in case of errors, automatic
retrying in case the foreign function call is interrupted by an
@samp{EINTR} signal.

@item
To call the high--level, parameterised, @func{x} interface; this gives
us everything @func{primitive-x} does and additionally allows us to
replace the primitive function with a version that returns controlled
values, or raises an error, and/or logs the operation.  This feature can
be used to test Scheme code execution paths that handle exceptions.
@end enumerate


Example of usage of failing primitive fork function:

@example
(define (fake-fork)
  (raise-errno-error 'fork EINVAL))

(parametrise ((primitive-fork-function fake-fork))
  ---
  (fork)
  ---)
@end example

@c page
@node posix memory
@section Memory management


The @library{foreign posix memory} library provides an @api{} to
allocate and release memory for the Nausicaa/POSIX libraries.  It is
built upon the following Nausicaa/Scheme libraries:

@example
(foreign ffi memory)
@end example

@noindent
but it is designed in such a way that we can replace it with our own
library at package installation time.

All the following functions must raise an exception if the operation
fails.


@defun malloc @var{number-of-bytes}
Allocate a block of memory @var{number-of-bytes} wide and return a
pointer to it.
@end defun


@defun calloc @var{count} @var{element-size}
Allocate a block of wide enough to hold @var{count} elements each of
@var{element-size}, return a pointer to it.  All the bytes in the block
are reset to zero.
@end defun


@defun realloc @var{pointer} @var{new-number-of-bytes}
Reallocate the memory block referenced by @var{pointer} to be
@var{new-number-of-bytes} wide and return a pointer to it.
@end defun


@defun free @var{pointer}
Release a block of memory allocated with @func{malloc}, @func{calloc} or
@func{realloc}.
@end defun


@c page
@node posix marshaling
@section Marshaling arguments and return values


The @library{foreign posix marshaling} library provides an @api{} for
marshaling between C language arguments and return values and Scheme
objects.  It is built upon the following Nausicaa/Scheme libraries:

@example
(parameters)
(compensations)
(deferred-exceptions)
(foreign ffi cstrings)
@end example

@noindent
but it is designed in such a way that we can replace it with our own
library at package installation time.  Notice that it is @strong{not}
mandatory for this library to make use of @library{foreign posix
memory}.  @ref{posix memory, Memory management}


@deffn Syntax with-marshaling @ameta{body}
Enclose a section of code in which marshaling will be performed.  All
the functions exported by @library{foreign posix marshaling} must be
invoked in a @meta{body}.

This macro takes care of tracking the resources allocated to marshal
values and to release them upon exiting the @meta{body}, whether via a
normal exit or an exception invocation.
@end deffn

@c ------------------------------------------------------------

@subsubheading C language strings


@defun marshal-string->cstring @var{str}
Convert a Scheme string to an @acronym{UTF8}--coded, zero--terminated, C
language string.  Return the pointer to the string.
@end defun


@defun marshal-cstring->string @var{cstr}
Convert an @acronym{UTF8}--coded, zero--terminated, C language string to
a Scheme string object.  Return the Scheme object.
@end defun


@defun marshal-argv->strings @var{argv}
Convert the null--terminated array of strings referenced by the
@var{argv} pointer to a list of Scheme strings.  @nauref{cstrings argv,
Converting arrays of strings}
@end defun

@c page
@node posix environment
@section Environment variables


Unless otherwise specified, the following bindings are exported by the
libraries:

@example
(foreign posix environment)
(foreign posix environment primitives)
(foreign posix environment platform)
@end example

@noindent
@glibcref{Environment Access,Environment Access} @nauref{naulib
environment, Accessing environment variables}


@deffn Function getenv @var{varname}
@deffnx Parameter getenv-function
@deffnx Function primitive-getenv @var{varname}
@deffnx Function platform-getenv @var{varname-cstr}
Return the current value of the environment variable @var{varname}, as a
Scheme string.  @var{varname} must be a Scheme string or symbol.  If the
variable is not set, the return value if @false{}; if the variable is
set to the empty string, the return value is the empty string.
@end deffn


@deffn Function setenv @var{varname} @var{value}
@deffnx Function setenv @var{varname} @var{value} @var{replace}
@deffnx Parameter setenv-function
@deffnx Function primitive-setenv @var{varname} @var{value}
@deffnx Function primitive-setenv @var{varname} @var{value} @var{replace}
@deffnx Function platform-setenv @var{varname} @var{value} @var{replace}
Set a new value for the environment variable @var{varname}.
@var{varname} and @var{value} must be Scheme strings or symbols.  If the
environment already contains @var{varname}, then @var{replace} controls
the action: if true the value is replaced, if @false{} it is left alone.
@end deffn


@deffn Function environ
@deffnx Parameter environ-function
@deffnx Function primitive-environ
@deffnx Function platform-environ
Direct access to the process' environment variables.  @func{environ} and
@func{primitive-environ} return a list of strings, each of the form
@samp{NAME=VALUE} where @samp{NAME} is the name of an environment
variable and @samp{VALUE} its value.

@func{platform-environ} returns a pointer to an array of pointers, each
referencing a C string with the format @samp{NAME=VALUE}.  The pointer
is suitable to be used as argument to @func{marshal-argv->strings}
(@pxref{posix marshaling}) and @func{arg->strings} (@nauref{cstrings
argv, Converting arrays of strings}).
@end deffn


@defun environ-table
Internally invoke @func{environ} and convert the list of strings into a
hashtable; return the hashtable.  The keys are Scheme symbols
representing the defined environment variables, the values are Scheme
symbols representing the environment variables' values.
@end defun


@defun environ->table @var{environ}
@defunx table->environ @var{table}
Convert between a list of strings in ``environ'' format and a hashtable.
@end defun


@defun clearenv
Remove all the entries from the process' environment.

This binding is exported by the @library{glibc environment} library.
@end defun


@deffn Function unsetenv @var{varname}
@deffnx Parameter unsetenv-function
@deffn Function primitive-unsetenv @var{varname}
@deffn Function platform-unsetenv @var{varname-cstr}
Remove the entry for @var{varname} from the environment.  @var{varname}
must be a Scheme string or symbol.
@end deffn

@c page
@node file
@chapter File system


The bindings described in this chapter are exported by @library{foreign
posix file} and @library{foreign posix file platform}.  Additionally if
we have installed the Stubs library for @posix{}, we can import the
@library{foreign posix file stub} library; see the Nausicaa/Stubs
project for details.

@menu
* file working directory::      The working directory.
* file directory access::       Accessing directory entries.
* file links::                  Hard and symbolic links.
* file remove::                 Removing files and directories.
* file rename::                 Renaming files and directories.
* file mkdir::                  Creating directories.
* file attr::                   File attributes.
* file temp::                   Temporary files.
@end menu

@c page
@node file working directory
@section The working directory


@glibcref{Working Directory,Working Directory}


@deffn Function getcwd
@deffnx Function primitive-getcwd
@deffnx Parameter getcwd-function
@deffnx Function platform-getcwd
Return a string representing the current working directory.
@end deffn


@defun pwd
An alias for @func{getcwd}.
@end defun


@deffn Function chdir @var{pathname}
@deffnx Function primitive-chdir @var{pathname}
@deffnx Parameter chdir-function
@deffnx Function platform-chdir @var{pathname}
Change the current directory to the selected @var{pathname}, which must
be a Scheme string or symbol.  If an error occurs changing directory
(because of access permissions): an exception is raised.
@end deffn


@deffn Function fchdir @var{fd}
@deffnx Function primitive-fchdir @var{fd}
@deffnx Parameter fchdir-function
@deffnx Function platform-fchdir @var{fd}
Change the current directory to the one associated to the file
descriptor @var{fd}.
@end deffn


@c page
@node file directory access
@section Accessing directory entries


@glibcref{Accessing Directories,Accessing Directories}


@menu
* file directory access types:: Type definitions.
* file directory access open::  Accessing a directory stream.
* file directory access read::  Reading a directory stream.
* file directory access seek::  Random access to a directory stream.
@end menu


@c page
@node file directory access types
@subsection Type definitions


The following bindings are exported from @library{posix sizeof}.

@glibcref{Directory Entries,Format of a directory entry}


@defvar sizeof-struct-dirent
@defvarx alignof-struct-dirent
@defvarx strideof-struct-dirent
Size, alignment and array stride of @code{struct dirent} types.
@end defvar


@deffn Syntax struct-dirent-d_name-ref @var{pointer}
Getter for the @code{d_name} field of a @code{struct dirent} type.
@end deffn


@c page
@node file directory access open
@subsection Accessing a directory stream


@glibcref{Opening a Directory,Opening a directory stream}
@glibcref{Reading/Closing Directory,Reading and closing a directory
stream}


@deffn Function opendir @var{pathname}
@deffnx Function primitive-opendir @var{pathname}
@deffnx Parameter opendir-function
@deffnx Function platform-opendir @var{pathname}
Open and return a stream associated to the directory selected by the
string or symbol @var{pathname}.
@end deffn


@deffn Function fdopendir @var{fd}
@deffnx Function primitive-fdopendir @var{fd}
@deffnx Parameter fdopendir-function
@deffnx Function platform-fdopendir @var{fd}
Open and return a stream associated to the directory selected by the
file descriptor @var{fd}.
@end deffn


@defun opendir/compensated @var{pathname}
@defunx fdopendir/compensated @var{fd}
@defunx opendir/c @var{pathname}
@defunx fdopendir/c @var{fd}
Like @func{opendir} and @func{fdopendir}, but push the appropriate call
to @func{closedir} on the dynamic environment of the current
compensation stack.  @nauref{compensations, Compensation stacks}
@end defun


@deffn Function closedir @var{stream}
@deffnx Function primitive-closedir @var{stream}
@deffnx Parameter closedir-function
@deffnx Function platform-closedir @var{stream}
Close the directory @var{stream} previously opened with @func{opendir}
or @func{fdopendir}.

@quotation
@emph{Note:} Applying this function to a stream that was opened with
@func{fdopendir}, closes the underlying file descriptor, too.  This is
weird but I have tested it with @file{libc-2.5.so}, so believe me.

This means that we have to avoid closing the file descriptor with
@func{close} (as it is very obscurely written in the @gnu{} C Library
documentation).
@end quotation
@end deffn


@deffn Function dirfd @var{stream}
@deffnx Function primitive-dirfd @var{stream}
@deffnx Parameter dirfd-function
@deffnx Function platform-dirfd @var{stream}
Return the file descriptor associated to the directory @var{stream}
previously opened with @func{opendir} or @func{fdopendir}.
@end deffn


Usage examples:

@example
(let ((stream #f))
  (dynamic-wind
    (lambda ()
      (set! stream (opendir "/home/marco/share/sounds")))
    (lambda ()
      ---)
    (lambda ()
      (closedir stream))))

(with-compensations
  (let ((stream (opendir "/home/marco/share/sounds")))
    ---))
@end example


@c page
@node file directory access read
@subsection Reading a directory stream


@glibcref{Reading/Closing Directory,Reading and closing a directory stream}


@deffn Function readdir @var{stream}
@deffnx Function primitive-readdir @var{stream}
@deffnx Parameter readdir-function
@deffnx Function platform-readdir @var{stream}
Return a pointer to a statically allocated @code{struct dirent}
describing the next entry from the directory @var{stream}, previously
opened with @func{opendir} or @func{fdopendir}.

Notice that the returned strings are the names of the entries relative
to the uplevel directory.  No slash and no directory part are in there.
@end deffn


@defun directory-list @var{pathname}
@defunx directory-list/fd @var{fd}
High level functions that open the directory selected by the string or
symbol @var{pathname} or file descriptor @var{fd}, read all the entries
and return a list of string holding the entry names.
@end defun


As a usage example for the low level function, let's see how
@func{directory-list} is implemented:

@example
(define (directory-list pathname)
  (with-compensations
    (let ((dir    (opendir/compensated pathname))
          (layout '()))
      (do ((entry (readdir dir) (readdir dir)))
          ((pointer-null? entry)
           layout)
        (set! layout
              (cons (cstring->string
                     (struct-dirent-d_name-ref entry))
                    layout))))))
@end example

@noindent
to read a directory and sort the entries:

@example
(list-sort string<? (directory-list "/home/marco"))
@end example

@noindent
to read a directory using the file descriptor and the @gnu{} flag
@code{O_NOATIME}:

@example
(with-compensations
  (letrec ((fd (compensate
                   (open the-root
                         (if (number? O_NOATIME)
                             (bitwise-ior O_RDONLY
                                          O_NOATIME)
                           O_RDONLY)
                         0)
                 (with
                  (close fd)))))
    (directory-list/fd fd)))
@end example


@c page
@node file directory access seek
@subsection Random access to a directory stream


For the following bindings: the @code{platform-} functions return a
@strong{single} value, they do not use @code{errno} to signal errors.


@deffn Function rewinddir @var{stream}
@deffnx Function primitive-rewinddir @var{stream}
@deffnx Parameter rewinddir-function
@deffnx Function platform-rewinddir @var{stream}
Rewind the directory @var{stream} previously opened with @func{opendir}
or @func{fdopendir}.
@end deffn


@deffn Function telldir @var{stream}
@deffnx Function primitive-telldir @var{stream}
@deffnx Parameter telldir-function
@deffnx Function platform-telldir @var{stream}
Return an exact integer representing the current position in the
directory @var{stream} previously opened with @func{opendir} or
@func{fdopendir}.

Notice that returned values look like arbitrary integers, they do not
follow a predictable sequence.
@end deffn


@deffn Function seekdir @var{stream} @var{position}
@deffnx Function primitive-seekdir @var{stream} @var{position}
@deffnx Parameter seekdir-function
@deffnx Function platform-seekdir @var{stream} @var{position}
Seek to @var{position} the directory @var{stream} previously opened with
@func{opendir} or @func{fdopendir}.  @var{position} must be a value
previously returned by @func{telldir}.
@end deffn


@c page
@node file links
@section Hard and symbolic links


@glibcref{Hard Links,Hard Links}
@glibcref{Symbolic Links,Symbolic Links}


@deffn Function link @var{oldname} @var{newname}
@deffnx Function primitive-link @var{oldname} @var{newname}
@deffnx Parameter link-function
@deffnx Function platform-link @var{oldname} @var{newname}
Link to the new name specified by the string or symbol @var{newname} the
file selected by the string or symbol @var{oldname}.
@end deffn


@deffn Function symlink @var{oldname} @var{newname}
@deffnx Function primitive-symlink @var{oldname} @var{newname}
@deffnx Parameter symlink-function
@deffnx Function platform-symlink @var{oldname} @var{newname}
Link to the new name specified by the string or symbol @var{newname} the
file selected by the string or symbol @var{oldname}.
@end deffn


@deffn Function realpath @var{pathname}
@deffnx Function primitive-realpath @var{pathname}
@deffnx Parameter realpath-function
@deffnx Function platform-realpath @var{pathname}
Return a string representing the real pathname of the symbolic link
selected by the string or symbol @var{pathname}.
@end deffn


@c page
@node file remove
@section Removing files and directories


@glibcref{Deleting Files,Deleting Files}


@deffn Function unlink @var{pathname}
@deffnx Function primitive-unlink @var{pathname}
@deffnx Parameter unlink-function
@deffnx Function platform-unlink @var{pathname}
Remove the file selected by the string or symbol @var{pathname}.
@end deffn


@deffn Function remove @var{pathname}
@deffnx Function primitive-remove @var{pathname}
@deffnx Parameter remove-function
@deffnx Function platform-remove @var{pathname}
Remove the file selected by the string or symbol @var{pathname}.
@end deffn


@deffn Function rmdir @var{pathname}
@deffnx Function primitive-rmdir @var{pathname}
@deffnx Parameter rmdir-function
@deffnx Function platform-rmdir @var{pathname}
Remove the directory selected by the string or symbol @var{pathname}.
The directory has to be empty.
@end deffn


@c page
@node file rename
@section Renaming files and directories


@glibcref{Renaming Files,Renaming Files}


@deffn Function rename @var{oldname} @var{newname}
@deffnx Function primitive-rename @var{oldname} @var{newname}
@deffnx Parameter rename-function
@deffnx Function platform-rename @var{oldname} @var{newname}
Rename the file selected by the string or symbol @var{oldname} to the
pathname selected by the string or symbol @var{newname}.
@end deffn


@c page
@node file mkdir
@section Creating directories


@glibcref{Creating Directories,Creating Directories}


@deffn Function mkdir @var{pathname}
@deffnx Function primitive-mkdir @var{pathname}
@deffnx Parameter mkdir-function
@deffnx Function platform-mkdir @var{pathname}
Create a new directory with pathname selected by the string or symbol
@var{pathname}.
@end deffn


@c page
@node file attr
@section File attributes


@glibcref{File Attributes,File Attributes}


@menu
* file attr stat::              File attributes.
* file attr owner::             Changing owner and group.
* file attr mode::              Changing file permissions.
* file attr access::            Testing access.
* file attr size::              Size of files.
@end menu


@c page
@node file attr stat
@subsection File attributes


For some reason the stat functions are not loadable, as all the other
symbols, from the C language standard library.  So the bindings
described in this section are exported by the @library{posix file stat}
library which is usable only if the Stubs library for @posix{} features
is installed on the system.  See the Nausicaa/Stubs project for details.


@menu
* file attr stat record::       Acquiring the file attributes.
* file attr stat type::         Type inspection.
* file attr stat perms::        Access permissions inspection.
@end menu


@c page
@node file attr stat record
@subsubsection Acquiring the file attributes


@glibcref{Attribute Meanings,The meaning of the File Attributes}
@glibcref{Reading Attributes,Reading Attributes}


@deftp {Record Type} struct-stat
Type of record used to hold fields from a @code{struct stat}.  List of
fields follows:

@example
mode            ino
dev             nlink
uid             gid
size
atime           atime_usec
mtime           mtime_usec
ctime           ctime_usec
blocks          blksize
@end example

@noindent
all the fields are immutable, we have to refer to the original
documentation of @code{struct stat} for their meaning.

Some field are not available on every platform in the foreign
@code{struct stat}, in this case the associated field in the
@code{struct-stat} record should be set to @false{}.  For example
@code{atime_usec}, @code{mtime_usec}, @code{ctime_usec} are not
available on some common platforms.
@end deftp


@defun make-struct-stat @var{mode} @var{ino} @var{dev} @var{nlink} @var{uid} @var{gid} @var{size} @var{atime} @var{atime_usec} @var{mtime} @var{mtime_usec} @var{ctime} @var{ctime_usec} @var{blocks} @var{blksize}
Build and return a new @code{struct-stat} record.
@end defun


@defun struct-stat? @var{obj}
Return @true{} if @var{obj} is a @code{struct-stat} record.
@end defun


@defun struct-stat-mode @var{struct-stat}
@defunx struct-stat-ino @var{struct-stat}
@defunx struct-stat-dev @var{struct-stat}
@defunx struct-stat-nlink @var{struct-stat}
@defunx struct-stat-uid @var{struct-stat}
@defunx struct-stat-gid @var{struct-stat}
@defunx struct-stat-size @var{struct-stat}
@defunx struct-stat-atime @var{struct-stat}
@defunx struct-stat-atime_usec @var{struct-stat}
@defunx struct-stat-mtime @var{struct-stat}
@defunx struct-stat-mtime_usec @var{struct-stat}
@defunx struct-stat-ctime @var{struct-stat}
@defunx struct-stat-ctime_usec @var{struct-stat}
@defunx struct-stat-blocks @var{struct-stat}
@defunx struct-stat-blksize @var{struct-stat}
Getters for the fields of a @code{struct-stat} record.
@end defun


@defun struct-stat->record @var{pointer}
Given a pointer to a block of memory holding a foreign @code{struct
stat}, build and return a @code{struct-stat} record.  All the fields
that are not available in the foreign structure are set to @false{}.
@end defun


@deffn Function stat @var{pathname}
@deffnx Function primitive-stat @var{pathname}
@deffnx Parameter stat-function
@deffnx Function platform-stat @var{pathname} @var{pointer}
Return a @code{struct-stat} record filled with attributes of the file or
directory selected by the string or symbol @var{pathname}.
@end deffn


@deffn Function fstat @var{fd}
@deffnx Function primitive-fstat @var{fd}
@deffnx Parameter fstat-function
@deffnx Function platform-fstat @var{fd} @var{pointer}
Return a @code{struct-stat} record filled with attributes of the file or
directory selected by the file descriptor @var{fd}.
@end deffn


@deffn Function lstat @var{pathname}
@deffnx Function primitive-lstat @var{pathname}
@deffnx Parameter lstat-function
@deffnx Function platform-lstat @var{pathname} @var{pointer}
Return a @code{struct-stat} record filled with attributes of the
symbolic link selected by the string or symbol @var{pathname}.
@end deffn


@c page
@node file attr stat type
@subsubsection Type inspection


The integer in the @code{mode} field of a @code{struct-stat} record can
be inspected with the following functions.


@defun S_ISDIR @var{mode}
@defunx S_ISCHR @var{mode}
@defunx S_ISBLK @var{mode}
@defunx S_ISREG @var{mode}
@defunx S_ISFIFO @var{mode}
@defunx S_ISLNK @var{mode}
@defunx S_ISSOCK @var{mode}
Return non--zero if the file or directory associated with the integer
@var{mode} is of the named type, otherwise return zero.
@end defun


@defun S_TYPEISMQ @var{struct-stat-pointer}
@defunx S_TYPEISSEM @var{struct-stat-pointer}
@defunx S_TYPEISSHM @var{struct-stat-pointer}
Return non--zero if the file or directory associated with the
@code{strut stat} referenced by the pointer is of the named type,
otherwise return zero.
@end defun


@defun file-is-directory? @var{obj}
@defunx file-is-character-special? @var{obj}
@defunx file-is-block-special? @var{obj}
@defunx file-is-regular? @var{obj}
@defunx file-is-fifo? @var{obj}
@defunx file-is-socket? @var{obj}
Return @true{} if @var{obj} is associated to a file of the named type,
@false{} otherwise.  @var{obj} can be a file descriptor or a string or
symbol representing a pathname.  The @code{mode} field is acquired with
a call to @func{fstat} or @func{stat}.

There is no way to distinguish between an integer representing a file
descriptor and an integer representing the @code{mode} field, so
@var{obj} @strong{cannot} be a mode field.
@end defun


@defun file-is-symbolic-link? @var{pathname}
Return @true{} if @var{pathname} is associated to a symbolic link,
@false{} otherwise.  @var{pathname} must be a string or symbol
representing a pathname.  The @code{mode} field is acquired with a call
to @func{lstat}.
@end defun


@defun file-is-message-queue? @var{obj}
@defunx file-is-semaphore? @var{obj}
@defunx file-is-shared-memory? @var{obj}
Return @true{} if @var{obj} is associated to a file of the named type,
@false{} otherwise.  @var{obj} can be a file descriptor or a string or
symbol representing a pathname.  These predicates require access to the
full @code{struct stat}, so they are implemented with the low level
@func{platform-stat} and @func{platform-fstat}.
@end defun


@c page
@node file attr stat perms
@subsubsection Access permissions inspection


Access permissions can be inspected with a bitwise combination between
the @code{mode} field and the permissions constants, @ref{fd constants
perms}.  For example, the following evaluates to @false{} if
@file{/bin/ls} is readable by its owner:

@example
(= 0 (bitwise-and S_IRUSR
                  (struct-stat-mode (stat "/bin/ls"))))
@end example

@noindent
while the following evaluates to @false{} if @file{/bin/ls} is readable
both by its owner and group:

@example
(= 0 (bitwise-and (bitwise-ior S_IRUSR S_IRGRP)
                  (struct-stat-mode (stat "/bin/ls"))))
@end example


@defun file-user-readable? @var{obj}
@defunx file-user-writable? @var{obj}
@defunx file-user-executable? @var{obj}
@defunx file-group-readable? @var{obj}
@defunx file-group-writable? @var{obj}
@defunx file-group-executable? @var{obj}
@defunx file-other-readable? @var{obj}
@defunx file-other-writable? @var{obj}
@defunx file-other-executable? @var{obj}
@defunx file-setuid? @var{obj}
@defunx file-setgid? @var{obj}
@defunx file-sticky? @var{obj}
Return @true{} if the named permissions bit is set, @false{} otherwise.

@var{obj} can a file descriptor or a string or symbol representing a
pathname.  For a file descriptor: the @code{mode} field is acquired with
a call to @func{fstat}.  For a pathname: the @code{mode} field is
acquired with a call to @func{stat}.
@end defun


@defun lfile-user-readable? @var{pathname}
@defunx lfile-user-writable? @var{pathname}
@defunx lfile-user-executable? @var{pathname}
@defunx lfile-group-readable? @var{pathname}
@defunx lfile-group-writable? @var{pathname}
@defunx lfile-group-executable? @var{pathname}
@defunx lfile-other-readable? @var{pathname}
@defunx lfile-other-writable? @var{pathname}
@defunx lfile-other-executable? @var{pathname}
@defunx lfile-setuid? @var{pathname}
@defunx lfile-setgid? @var{pathname}
@defunx lfile-sticky? @var{pathname}
Return @true{} if the named permissions bit is set, @false{} otherwise.
@var{pathname} must be a string or symbol representing a pathname and
the the @code{mode} field is acquired with @func{lstat}.
@end defun


@defun file-permissions @var{obj}
@defunx lfile-permissions @var{obj}
Return an exact integer representing the access permissions bits from
the @code{mode} field of a @code{struct-stat} record.

For @func{file-permissions}: @var{obj} can be a file descriptor or a
pathname in the form of a string or symbol; the mode is acquired with a
call to @func{fstat} or @func{stat}.

For @func{file-permissions}: @var{obj} must be a pathname in the form of
a string or symbol; the mode is acquired with a call to @func{lstat}.

The returned values can be examined and manipulated using the @code{S_*}
constants (@ref{fd constants perms}), and also used as argument for a
call to @func{chmod} or @func{fchmod}.
@end defun


@c page
@node file attr owner
@subsection File owner and group


@glibcref{File Owner,File Owner}


@deffn Function chown @var{pathname} @var{owner-id} @var{group-id}
@deffnx Function primitive-chown @var{pathname} @var{owner-id} @var{group-id}
@deffnx Parameter chown-function
@deffnx Function platform-chown @var{pathname} @var{owner-id} @var{group-id}
Change the file owner and group to the given numeric identifiers.
@var{pathname} must be a string or symbol representing a pathname.
@end deffn


@deffn Function fchown @var{fd} @var{owner-id} @var{group-id}
@deffnx Function primitive-fchown @var{fd} @var{owner-id} @var{group-id}
@deffnx Parameter fchown-function
@deffnx Function platform-fchown fchown @var{fd} @var{owner-id} @var{group-id}
Change the file owner and group to the given numeric identifiers.
@var{fd} must be a file descriptor.
@end deffn


@c page
@node file attr mode
@subsection Changing file permissions


The @var{mask} argument for the following function must be an exact
integer representing access permissions bits.  The value can be composed
as bitwise combination of the constants described at @ref{fd constants
perms}.

@glibcref{Setting Permissions,Assigning File Permissions}


@deffn Function umask @var{mask}
@deffnx Function primitive-umask @var{mask}
@deffnx Parameter umask-function
@deffnx Function platform-umask @var{mask}
Set the umask to @var{mask} and return the old @var{mask}.  To query the
current mask without changing it:

@example
(let ((m (umask 0)))
  (umask m)
  m)
@end example

@noindent
or use @func{getumask}, which has exactly this implementation.
@end deffn


@defun getumask
Return the current umask.
@end defun


@deffn Function chmod @var{pathname} @var{mask}
@deffnx Function primitive-chmod @var{pathname} @var{mask}
@deffnx Parameter chmod-function
@deffnx Function platform-chmod @var{pathname} @var{mask}
Change the file access permissions bits to the given numeric mask.
@var{pathname} must be a string or symbol representing a pathname.
@end deffn


@deffn Function fchmod @var{fd} @var{mask}
@deffnx Function primitive-fchmod @var{fd} @var{mask}
@deffnx Parameter fchmod-function
@deffnx Function platform-fchmod @var{fd} @var{mask}
Change the file access permissions bits to the given numeric mask.
@var{fd} must be a file descriptor.
@end deffn


@c page
@node file attr access
@subsection Testing access


@glibcref{Testing File Access,Testing permission to access a file}


@deffn Function access @var{pathname} @var{mask}
@deffnx Function primitive-access @var{pathname} @var{mask}
@deffnx Parameter access-function
@deffnx Function platform-access @var{pathname} @var{mask}
Return @true{} if the process has permission to access the file selected
by the string or symbol @var{pathname} as specified by @var{mask}.
Return @false{} otherwise.

@var{mask} can be the bitwise combination of: @code{F_OK}, @code{R_OK},
@code{W_OK}, @code{X_OK}.
@end deffn


@defvar F_OK
@defvarx R_OK
@defvarx W_OK
@defvarx X_OK
Constants representing requests for access permission testing with
@func{access}.  These bindings are exported by @library{posix sizeof}.
@end defvar


@c page
@node file attr size
@subsection Size of files


@deffn Function file-size @var{obj}
@deffnx Function primitive-file-size @var{obj}
@deffnx Parameter file-size-function
Return the file of the selected file.  @var{obj} can be a file
descriptor or a pathname in the form of a symbol or string.

This function is implemented using @func{lseek} as described in @ref{fd
seek,Setting the file position}.
@end deffn


@deffn Function ftruncate @var{obj} @var{length}
@deffnx Function primitive-ftruncate @var{obj} @var{length}
@deffnx Parameter ftruncate-function
@deffnx Function platform-ftruncate @var{obj} @var{length}
Set to @var{length} the size of the selected file.  @var{obj} can be a
file descriptor or a pathname in the form of a symbol or string.
@end deffn


@c page
@node file temp
@section Temporary files


@glibcref{Temporary Files,Temporary Files}


@deffn Function tmpnam
@deffnx Function primitive-tmpnam
@deffnx Parameter tmpnam-function
@deffnx Function platform-tmpnam
Return a file pathname that, at the time of the call, does not exist on
the system.
@end deffn


@deffn Function mktemp @var{template}
@deffnx Function primitive-mktemp @var{template}
@deffnx Parameter mktemp-function
@deffnx Function platform-mktemp @var{template}
Return a file pathname that, at the time of the call, does not exist on
the system.  The pathname is built modifying the string or symbol
@var{template}, which must include the @code{XXXXXX} sequence of
characters.
@end deffn


@deffn Function mkstemp @var{template}
@deffnx Function primitive-mkstemp @var{template}
@deffnx Parameter mkstemp-function
@deffnx Function platform-mkstemp @var{template}
Return 2 values: a file descriptor and a file pathname.  The pathname is
built modifying the string or symbol @var{template}, which must include
the @code{XXXXXX} sequence of characters.

Usage example:

@example
(let-values (((fd pathname) (mkstemp "/tmp/XXXXXX")))
  ---
  (close fd)
  (delete-file pathname))
@end example
@end deffn


@c page
@node time
@chapter Date and time


Unless otherwise specified, the bindings documented in this chapter are
exported by the @library{posix time} library.


@menu
* time structs::                Data structures.
* time clock::                  Processor time.
@end menu


@c page
@node time structs
@section Data structures


The bindings documented in this section are exported by the
@library{posix sizeof} library.


@defvar sizeof-struct-timeval
@defvarx alignof-struct-timeval
@defvarx strideof-struct-timeval
These are: the number of bytes required to hold a @code{struct timeval};
the alignment of this structure when embedded into another structure;
the number of bytes between two elements in an array of these
structures.
@end defvar


@deffn Syntax struct-timeval-tv_sec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timeval-tv_sec-ref @var{pointer} @var{value}
@deffnx Syntax struct-timeval-tv_usec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timeval-tv_usec-ref @var{pointer} @var{value}
Peekers and pokers for the fields of a @code{struct timeval}.
@end deffn


@defvar sizeof-struct-timespec
@defvarx alignof-struct-timespec
@defvarx strideof-struct-timespec
These are: the number of bytes required to hold a @code{struct timespec};
the alignment of this structure when embedded into another structure;
the number of bytes between two elements in an array of these
structures.
@end defvar


@deffn Syntax struct-timespec-tv_sec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timespec-tv_sec-ref @var{pointer} @var{value}
@deffnx Syntax struct-timespec-tv_nsec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timespec-tv_nsec-ref @var{pointer} @var{value}
Peekers and pokers for the fields of a @code{struct timespec}.
@end deffn


@c page
@node time clock
@section Processor time


If we have installed the Nausicaa/Stubs library for @posix{} functions:
we can import the @library{posix time stub} library, which exports the
following bindings.

@glibcref{CPU Time,CPU Time Inquiry}

@glibcref{Processor Time,Processor Time Inquiry}


@defvar CLOCKS_PER_SEC
The number of clock ticks per second measured by the @func{clock}
function.  This binding is exported by the @library{posix sizeof}
library.
@end defvar


@deffn Function clock
@deffnx Function primitive-clock
@deffnx Parameter clock-function
@deffnx Function platform-clock
Return the calling process' current @cpu{} time, converted to a native
@code{double} number.
@end deffn


@deffn Function times
@deffnx Function primitive-times
@deffnx Parameter times-function
@deffnx Function platform-times @var{pointer}
Store the processor time informations into a record of type
@code{struct-tms} and return 2 values: the calling process @cpu{} time
converted to a @code{double} number, the @code{struct-tms} record.

@func{platform-times} is an interface to to a foreign function that
wraps the platform @cfunc{times} function.  It accepts as argument a
pointer to an array of 4 @code{double} elements which are filled with
the fields of a @code{struct tms} with the following mapping:

@multitable {array element} {struct field}
@headitem array element @tab struct field
@item 0 @tab tms_utime
@item 1 @tab tms_ctime
@item 2 @tab tms_sutime
@item 3 @tab tms_sctime
@end multitable

Like all the platform functions, @func{platform-times} returns 2 values:
the return value of the foreing function normalised to a floating point
value, the value of @code{errno} right after the function call.
@end deffn


@deffn {Record Type} struct-tms
A Scheme record used to hold normalised results of @func{times}
invocations.  It has a field for each field of @code{struct tms}.
@end deffn


@defun make-struct-tms @var{utime} @var{stime} @var{cutime} @var{cstime}
Build and return a new @code{struct-tms} record.
@end defun


@defun struct-tms-tms_utime-ref @var{tms-record}
@defunx struct-tms-tms_stime-ref @var{tms-record}
@defunx struct-tms-tms_cutime-ref @var{tms-record}
@defunx struct-tms-tms_cstime-ref @var{tms-record}
Getters for the fields of @code{struct-tms} records.  All the returned
values are floating point numbers.
@end defun


@c page
@node fd
@chapter File descriptors


File descriptor arguments and return values are handled at the Scheme
level as exact integers.  The main libraries are @library{posix fd} and
@library{posix fd platform}.

@menu
* fd constants::                Variables holding constant values.
* fd open close::               Opening and closing.
* fd read write::               Reading and writing.
* fd seek::                     Setting the file position.
* fd sync::                     Synchronisation.
* fd control::                  Control operations.
* fd dup::                      Duplicating file descriptors.
* fd lock::                     File locks.
* fd pipe::                     Pipes and FIFOs.
* fd custom::                   Custom Scheme ports.
@end menu


@c page
@node fd constants
@section Variables holding constant values


@menu
* fd constants status::         File status flags.
* fd constants perms::          Permissions.
* fd constants control::        File control flags.
* fd constants seek::           File positions.
* fd constants lock::           Locking.
@end menu


@c page
@node fd constants status
@subsection File status flags


All the bindings described here are exported by the library
@library{posix sizeof}.

Read the original documentation @glibcref{File Status Flags, File Status
Flags} If a value is not defined on the underlying platform: the
corresponding variable is set to @false{}.


@defvar O_RDONLY
@defvarx O_WRONLY
@defvarx O_RDWR
File access modes to be used with @func{open}.
@end defvar


@defvar O_EXEC
@defvarx O_READ
@defvarx O_WRITE
These are @gnu{} only values.  @code{O_EXEC} is used with @func{open} to
open a file for execution.  @code{O_READ} and @code{O_WRITE} are like
@code{O_RDONLY} and @code{O_WRONLY}.
@end defvar


@defvar O_ACCMODE
To be used with @func{fcntl} to query the open access mode of file
descriptors.
@end defvar


@defvar O_CREAT
@defvarx O_EXCL
@defvarx O_APPEND
@defvarx O_NONBLOCK
@defvarx O_NOCTTY
Open--time flags to be used with @func{open}.
@end defvar


@defvar O_NDELAY
@acronym{BSD} only alias for @code{O_NONBLOCK}.
@end defvar


@defvar O_IGNORE_CTTY
@defvarx O_NOLINK
@defvarx O_NOTRANS
@gnu{} only file name translation flags to be used with @func{open}.
@end defvar


@defvar O_TRUNC
Open--time action flags to be used with @func{open}.
@end defvar


@defvar O_SHLOCK
@defvarx O_EXLOCK
@acronym{BSD} only flags to be used with @func{open}.
@end defvar


@defvar O_ASYNC
@defvarx O_FSYNC
@defvarx O_SYNC
@acronym{BSD} only flags to be used with @func{open}.
@end defvar


@defvar O_NOATIME
@gnu{} only flag to be used with @func{open}.
@end defvar


@c page
@node fd constants perms
@subsection Permissions


All the bindings described here are exported by the library
@library{posix sizeof}.

@glibcref{Permission Bits,The mode bits for access permission}


@defvar S_IRUSR
@defvarx S_IWUSR
@defvarx S_IXUSR
Permissions bits for file owner access.
@end defvar

@defvar S_IRGRP
@defvarx S_IWGRP
@defvarx S_IXGRP
Permissions bits for group access.
@end defvar

@defvar S_IROTH
@defvarx S_IWOTH
@defvarx S_IXOTH
Permissions bits for other users access.
@end defvar

@defvar S_IRWXU
Theis is the bitwise combination of permissions bits for user access.
It could be defined as:

@example
(define S_IRWXU
  (bitwise-ior S_IRUSR S_IWUSR S_IXUSR))
@end example
@end defvar


@defvar S_IRWXG
Theis is the bitwise combination of permissions bits for group access.
It could be defined as:

@example
(define S_IRWXG
  (bitwise-ior S_IRGRP S_IWGRP S_IXGRP))
@end example
@end defvar


@defvar S_IRWXO
Theis is the bitwise combination of permissions bits for other users
access.  It could be defined as:

@example
(define S_IRWXO
  (bitwise-ior S_IROTH S_IWOTH S_IXOTH))
@end example
@end defvar


@defvar S_ISUID
@defvarx S_ISGID
@defvarx S_ISVTX
These are the setuid, setgid and ``sticky bit'' values.
@end defvar


@c page
@node fd constants control
@subsection File control flags


All the bindings described here are exported by the library
@library{posix sizeof}.  The following variables hold constants to be
used as @var{operation} argument in calls to @func{fcntl}.


@defvar F_GETFL
@defvarx F_SETFL
Set/get the status of a file.
@end defvar


@defvar F_DUPFD
Duplicate the file descriptor.
@end defvar


@defvar F_GETFD
@defvarx F_SETFD
Set/get the status of a file descriptor.
@end defvar


@defvar F_SETLK
@defvarx F_GETLK
@defvarx F_SETLKW
Set/get a file lock.  @code{F_SETLKW} sets a file lock, but waits for
completion.
@end defvar


@defvar F_GETOWN
@defvarx F_SETOWN
Set/get process to receive @code{SIGIO} signals.
@end defvar


@defvar FD_CLOEXEC
State that the file descriptor has to be closed if an @cfunc{exec} is
performed.
@end defvar


@c page
@node fd constants seek
@subsection File positions


All the bindings described here are exported by the library
@library{posix sizeof}.


@defvar SEEK_SET
@defvarx SEEK_CUR
@defvarx SEEK_END
File positions for the @var{whence} argument to @func{lseek}.
@end defvar


@c page
@node fd constants lock
@subsection Locking


All the bindings described here are exported by the library
@library{posix sizeof}.


@defvar F_RDLCK
@defvarx F_WRLCK
@defvarx F_UNLCK
Flags for file descriptor locking.
@end defvar


@c page
@node fd open close
@section Opening and closing


@glibcref{Opening and Closing Files,Opening and Closing Files}


@deffn Function open @var{pathname} @var{open-mode} @var{permissions}
@deffnx Function primitive-open @var{pathname} @var{open-mode} @var{permissions}
@deffnx Parameter open-function
@deffnx Function platform-open @var{pathname} @var{open-mode} @var{permissions}
Open with @var{open-mode} the file selected by @var{pathname} and return
a file descriptor.  If the file is created, it is created with
access @var{permissions}.

@var{pathname} must be a Scheme string or symbol.

@var{open-mode} must be an exact integer, and it can be built with
@func{bitwise-ior} from the following constants: one among
@code{O_RDWR}, @code{O_RDONLY} and @code{O_WRONLY} and optionally
@code{O_TRUNC}, @code{O_EXCL}, @code{O_NONBLOCK}.

@var{permissions} must be an exact integer and it is best given as an
octal number or a bitwise combination of constants, @ref{fd constants
perms}.  It can be zero if we are not interested in creating a new file.
Here are octal number examples of the most common values, where:
@code{r} stands for readable, @code{w} for writable, @code{x} for
executable:

@multitable {#o755} {user perms} {group perms} {other perms}
@headitem mode @tab user perms @tab group perms @tab other perms
@item @code{#o640}
@tab @code{rw-}
@tab @code{r--}
@tab @code{---}
@item @code{#o400}
@tab @code{r--}
@tab @code{---}
@tab @code{---}
@item @code{#o644}
@tab @code{rw-}
@tab @code{r--}
@tab @code{r--}
@item @code{#o755}
@tab @code{rwx}
@tab @code{r-x}
@tab @code{r-x}
@end multitable

Here is the table for the octal digits:

@multitable {digit} {mode} {digit} {mode}
@headitem digit @tab mode @tab digit @tab mode
@item 0 @tab @code{---} @tab 4 @tab @code{r--}
@item 1 @tab @code{--x} @tab 5 @tab @code{r-x}
@item 2 @tab @code{-w-} @tab 6 @tab @code{rw-}
@item 3 @tab @code{-wx} @tab 7 @tab @code{rwx}
@end multitable

Example:

@example
(let ((fd (open "/tmp/marco/name.ext"
                (bitwise-ior O_CREAT O_EXCL O_WRONLY)
                #o640)))
  ---)
@end example

@noindent
with symbolic permissions bits (more portable):

@example
(let ((fd (open "/tmp/marco/name.ext"
                (bitwise-ior O_CREAT O_EXCL O_WRONLY)
                (bitwise-ior S_IRUSR S_IWUSR
                             S_IRGRP))))
  ---)
@end example
@end deffn


@deffn Function close @var{fd}
@deffnx Function primitive-close @var{fd}
@deffnx Parameter close-function
@deffnx Function platform-close @var{fd}
Close the file descriptor @var{fd}.
@end deffn


@c page
@node fd read write
@section Reading and writing


The bindings @func{read} and @func{write} defined below have the same
names of the @func{read} and @func{write} defined by @rnrs{6}.  So when
importing @library{posix fd} we have to make use of some augmented
import specification.  For example the following avoids importing the
@rnrs{6} procedures:

@example
(import (except (r6rs) read write)
  (posix fd))
@end example

@noindent
and the following prefixes with @code{posix:} all the bindings from
@library{posix fd}:

@example
(import (r6rs)
  (prefix (posix fd) posix:))
@end example

@glibcref{I/O Primitives,Input and Output Primitives}


@subsubheading Reading


@deffn Function read @var{fd} @var{pointer} @var{buffer-size}
@deffnx Function primitive-read @var{fd} @var{pointer} @var{buffer-size}
@deffnx Parameter read-function
@deffnx Function platform-read @var{fd} @var{pointer} @var{buffer-size}
Read at most @var{buffer-size} bytes from @var{fd}, starting at the
current file position, and store them in the buffer referenced by
@var{pointer}.  The file position is advanced.  Return the number of
bytes actually read.
@end deffn


@deffn Function pread @var{fd} @var{pointer} @var{buffer-size} @var{offset}
@deffnx Function primitive-pread @var{fd} @var{pointer} @var{buffer-size} @var{offset}
@deffnx Parameter pread-function
@deffnx Function platform-pread @var{fd} @var{pointer} @var{buffer-size} @var{offset}
Read at most @var{buffer-size} bytes from @var{fd}, starting at
@var{offset} from the beginning of the file, and store them in the
buffer referenced by @var{pointer}.  The file position is left
untouched.  Return the number of bytes actually read.
@end deffn


@subsubheading Writing


@deffn Function write @var{fd} @var{pointer} @var{buffer-size}
@deffnx Function primitive-write @var{fd} @var{pointer} @var{buffer-size}
@deffnx Parameter write-function
@deffnx Function platform-write @var{fd} @var{pointer} @var{buffer-size}
Write to @var{fd}, starting at the current file position, at most
@var{buffer-size} bytes from the buffer referenced by @var{pointer}.
The file position is advanced.  Return the number of bytes actually
written.
@end deffn


@deffn Function pwrite @var{fd} @var{pointer} @var{buffer-size} @var{offset}
@deffnx Function primitive-pwrite @var{fd} @var{pointer} @var{buffer-size} @var{offset}
@deffnx Parameter pwrite-function
@deffnx Function platform-pwrite @var{fd} @var{pointer} @var{buffer-size} @var{offset}
Write to @var{fd}, starting at @var{offset} from the beginning of the
file, at most @var{buffer-size} bytes from the buffer referenced by
@var{pointer}.  The file position is left untouched.  Return the number
of bytes actually written.
@end deffn


@c page
@node fd seek
@section Setting the file position


@glibcref{File Position Primitive,Setting the File Position of a Descriptor}


@deffn Function lseek @var{fd} @var{offset} @var{whence}
@deffnx Function primitive-lseek @var{fd} @var{offset} @var{whence}
@deffnx Paramter primitive-lseek-function
@deffnx Function platform-lseek @var{fd} @var{offset} @var{whence}
Move the file position of @var{fd} at @var{offset} from the position
selected with @var{whence}, which must the value of a variable among
@code{SEEK_SET}, @code{SEEK_CUR}, @code{SEEK_END}.  Return the number of
bytes from the beginning of the file to the selected file position.

@quotation
@emph{Note:} It seems that @cfunc{lseek} cannot be interrupted by
@code{EINTR}.
@end quotation
@end deffn


We can use the return value to acquire the current file position with:

@example
(lseek fd 0 SEEK_CUR)
@end example

@noindent
which will leave the file position unchanged.  We can determine the file
size with:

@example
(define (file-size-from-descriptor fd)
  (with-compensations
    (letrec ((pos (compensate
                      (lseek fd 0 SEEK_CUR)
                    (with
                     (lseek fd pos SEEK_SET)))))
       (lseek fd 0 SEEK_END))))
@end example


@c page
@node fd sync
@section Synchronisation


@glibcref{Synchronizing I/O,Synchronizing I/O}


@deffn Function sync
@deffnx Function primitive-sync
@deffnx Parameter sync-function
@deffnx Function platform-sync
Synchronise data for all the file descriptors with the underlying
devices.  Does not return until the operation is terminated.
@end deffn


@deffn Function fsync @var{fd}
@deffnx Function primitive-fsync @var{fd}
@deffnx Parameter fsync-function
@deffnx Function platform-fsync @var{fd}
Synchronise data for @var{fd} with the underlying device.
@end deffn


@deffn Function fdatasync @var{fd}
@deffnx Function primitive-fdatasync @var{fd}
@deffnx Parameter fdatasync-function
@deffnx Function platform-fdatasync @var{fd}
Flushes the output buffer of @var{fd} to the underlying device.  This
function does not synchronise the file meta data (like the access time).
@end deffn



@c page
@node fd control
@section Control operations


@deffn Function fcntl @var{fd} @var{operation} @var{arg}
@deffnx Function primitive-fcntl @var{fd} @var{operation} @var{arg}
@deffnx Parameter fcntl-function
@deffnx Function platform-fcntl @var{fd} @var{operation} @var{arg}
Perform @var{operation} on @var{fd} using @var{arg}.  @var{operation}
and @var{arg} must be exact integers.  @ref{fd constants control} for
the list of the supported operations.

@func{primitive-fcntl} assumes that if the return value is @code{-1} an
error occurred.

Notice that if @var{arg} has to be a pointer (like when requesting a
lock on the file), we have to use @func{pointer->integer} to convert the
pointer value to an integer.  Example:

@example
(fcntl fd F_SETLK (pointer->integer lock-struct))
@end example

@glibcref{Control Operations,Control Operations on Files}
@end deffn


@deffn Function ioctl @var{fd} @var{operation} @var{arg}
@deffnx Function primitive-ioctl @var{fd} @var{operation} @var{arg}
@deffnx Parameter ioctl-function
@deffnx Function platform-ioctl @var{fd} @var{operation} @var{arg}
Perform @var{operation} on @var{fd} using @var{arg}.  @var{operation}
and @var{arg} must be exact integers.  @ref{fd constants control} for
the list of the supported operations.

@func{primitive-ioctl} assumes that if the return value is @code{-1} an
error occurred.

@glibcref{IOCTLs, I/O Control Operations}
@end deffn


@c page
@node fd dup
@section Duplicating file descriptors


@glibcref{Duplicating Descriptors,Duplicating Descriptors}


@deffn Function dup @var{fd}
@deffnx Function primitive-dup @var{fd}
@deffnx Parameter dup-function
@deffnx Function platform-dup @var{fd}
Duplicate @var{fd}, return the new file descriptor.
@end deffn


@deffn Function dup2 @var{old-fd} @var{new-fd}
@deffnx Function primitive-dup2 @var{old-fd} @var{new-fd}
@deffnx Parameter dup2-function
@deffnx Function platform-dup2 @var{old-fd} @var{new-fd}
Copy @var{old-fd} to @var{new-fd}.
@end deffn


@c page
@node fd lock
@section File locks


Locking is performed by @func{fcntl} with the @code{F_GETLK},
@code{F_SETLK} and @code{F_SETLKW} operations.  When locking, the third
argument to @func{fcntl} must be a pointer to a structure of type
@code{struct flock}.

@glibcref{File Locks,File Locks}


@defvar sizeof-struct-flock
@defvarx alignof-struct-flock
@defvarx strideof-struct-flock
These are: the number of bytes required to hold a structure of type
@code{struct flock}; the alignment of the structure when embedded in
another structure; the number of bytes between two elements in an array
of structures.
@end defvar


@deffn Syntax struct-flock-l_type-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_type-ref @var{pointer}
@deffnx Syntax struct-flock-l_whence-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_whence-ref @var{pointer}
@deffnx Syntax struct-flock-l_start-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_start-ref @var{pointer}
@deffnx Syntax struct-flock-l_len-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_len-ref @var{pointer}
@deffnx Syntax struct-flock-l_pid-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_pid-ref @var{pointer}
Peekers and pokers for the fields of a @code{struct flock}.
@end deffn


@example
(define p (malloc sizeof-struct-flock))

(fcntl fd F_SETLK p)

--- ;; do something

(fcntl fd F_UNLCK p)
@end example


@c page
@node fd pipe
@section Pipes and FIFOs


@deffn Function pipe
@deffnx Function primitive-pipe
@deffnx Parameter pipe-function
@deffnx Function platform-pipe @var{pointer}
Open a pipe: a pair of file descriptors linked together.  Return 2
values: the reading and writing file descriptors (again: the reading fd
is the first).

@glibcref{Creating a Pipe,Creating a Pipe}
@end deffn


@deffn Function mkfifo @var{pathname} @var{mode}
@deffnx Function primitive-mkfifo mkfifo @var{pathname} @var{mode}
@deffnx Parameter mkfifo-function
@deffnx Function platform-mkfifo @var{pathname} @var{mode}
Create a named pipe pseudofile: a special file that can be used for
interprocess communication.  @glibcref{FIFO Special Files,FIFO Special
Files}

The Scheme string or symbol @var{pathname} selects the file pathname.
@var{mode} is a numeric access permissions mode like the one used by
@func{open}.
@end deffn


The following is a meaningless example of @acronym{FIFO} usage; we have
to remember that the bindings forms in a @func{let} have no guaranteed
evaluation order, so if we need to open the two ports in a specified
order we have to use @func{let*}:

@example
(with-compensations
    (compensate
        (mkfifo pathname #o600)
      (with
       (delete-file pathname)))
  (let* ((in (open pathname (bitwise-ior O_NONBLOCK O_RDONLY) 0))
         (ou (open pathname O_WRONLY 0)))
    (letrec ((inp (compensate
                      (fd->textual-input-port  in)
                    (with
                     (close-port inp))))
             (oup (compensate
                      (fd->textual-output-port ou)
                    (with
                     (close-port oup)))))
      (put-string oup "ciao\n")
      (flush-output-port oup)
      (get-string-n inp 5))))
@end example


@c page
@node fd custom
@section Custom Scheme ports


@defun fd->binary-input-port @func{fd}
@defunx fd->binary-output-port @func{fd}
@defunx fd->binary-input/output-port @func{fd}
@defunx fd->textual-input-port @func{fd}
@defunx fd->textual-output-port @func{fd}
@defunx fd->textual-input/output-port @func{fd}
Wrap the given file descriptor with a Scheme port; return the port.
Closing the Scheme port closes the file descriptor too.
@end defun


@defun pipe-binary-ports
@defunx pipe-textual-ports
Invoke @func{pipe} then wrap the file descriptors with Scheme ports.
Return 2 values: the reading port and the writing port.

Position handling (seeking) is not implemented for pipe ports.
@end defun


@subsubheading Everyone should mind his own buffers


Unfortunately there are Scheme implementations that insist in
implementing buffering for custom ports.  One can say that they are
called ``custom'' to let the customers (that is us) decide how to handle
the underlying device, buffering included.  This is not the opinion of
some Scheme implementers.

So with some implementations we have to turn off buffering and turn on
non-blocking mode for the device.


@subsubheading Do it yourself


If we feel the need to implement our own wrappers, we may find useful to
know that a custom read function can be implemented like this:

@example
(define (custom-binary-read fd bv start count)
  (with-compensations
    (let* ((p   (malloc-block/c count))
           (len (read fd p count)))
      (do ((i 0 (+ 1 i)))
          ((= i len)
           len)
        (bytevector-u8-set! bv (+ start i)
                            (peek-unsigned-char p i))))))

(define (custom-textual-read fd str start count)
  (with-compensations
    (let* ((p   (malloc-block/c count))
           (len (read fd p count)))
      (do ((i 0 (+ 1 i)))
          ((= i len)
           len)
        (string-set! str (+ start i)
                     (integer->char (peek-unsigned-char p i)))))))
@end example

@noindent
and a custom write function can be implemented like this:

@example
(define (custom-binary-write fd bv start count)
  (with-compensations
    (let* ((p   (malloc-block/c count)))
      (do ((i 0 (+ 1 i)))
          ((= i count)
           (write fd p count))
        (poke-char! p i (bytevector-u8-ref bv (+ start i)))))))

(define (custom-textual-write fd str start count)
  (with-compensations
    (let* ((p   (malloc-block/c count)))
      (do ((i 0 (+ 1 i)))
          ((= i count)
           (write fd p count))
        (poke-char! p i
           (char->integer (string-ref str (+ start i))))))))
@end example

Then the following implementations are possible:

@example
(define (fd->binary-input-port fd)
  (make-custom-binary-input-port
   "fd input port"
   (lambda (bv start count)
     (custom-binary-read fd bv start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->binary-output-port fd)
  (make-custom-binary-output-port
   "fd output port"
   (lambda (bv start count)
     (custom-binary-write fd bv start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->binary-input/ouput-port fd)
  (make-custom-binary-input-port
   "fd input/output port"
   (lambda (bv start count)
     (custom-binary-read fd bv start count))
   (lambda (bv start count)
     (custom-binary-write fd bv start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->textual-input-port fd)
  (make-custom-textual-input-port
   "fd input port"
   (lambda (str start count)
     (custom-textual-read fd str start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->textual-output-port fd)
  (make-custom-textual-output-port
   "fd output port"
   (lambda (str start count)
     (custom-textual-write fd str start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->textual-input/ouput-port fd)
  (make-custom-textual-input-port
   "fd input/output port"
   (lambda (str start count)
     (custom-textual-read fd str start count))
   (lambda (str start count)
     (custom-textual-write fd str start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (pipe-binary-ports)
  (let-values (((in ou) (pipe)))
    (values (make-custom-binary-input-port
             "fd pipe binary reading port"
             (lambda (bv start count)
               (custom-binary-read in bv start count))
             #f
             #f
             (lambda ()
               (close in)))
            (make-custom-binary-output-port
             "fd pipe binary writing port"
             (lambda (bv start count)
               (custom-binary-write ou bv start count))
             #f
             #f
             (lambda ()
               (close ou))))))

(define (pipe-textual-ports)
  (let-values (((in ou) (pipe)))
    (values (make-custom-textual-input-port
             "fd pipe textual reading port"
             (lambda (bv start count)
               (custom-textual-read in bv start count))
             #f
             #f
             (lambda ()
               (close in)))
            (make-custom-textual-output-port
             "fd pipe textual writing port"
             (lambda (bv start count)
               (custom-textual-write ou bv start count))
             #f
             #f
             (lambda ()
               (close ou))))))
@end example


@c page
@node process
@chapter Processes


The bindings described in this chapter are exported by @library{posix
process} and @library{posix process platform}.


@menu
* process id::                  Process identification.
* process fork::                Creating a process.
* process exec::                Executing a file.
* process wait::                Process completion.
@end menu


@c page
@node process id
@section Process identification


@glibcref{Process Identification,Process Identification}

@quotation
@emph{Note:} It seems that the following functions cannot fail.
@end quotation


@defun getpid
@defunx platform-getpid
Return the process id of the current process.
@end defun


@defun getppid
@defunx platform-getppid
Return the process id of the parent process.
@end defun


@c page
@node process fork
@section Creating a process


@glibcref{Creating a Process,Creating a Process}

@quotation
@emph{Note:} Access to @cfunc{vfork} is not implemented because it is
impossible to know what the Scheme implementation does.
@end quotation


@deffn Function fork
@deffnx Function primitive-fork
@deffnx Parameter fork-function
@deffnx Function platform-fork
Create a new process by forking the current one.  If successful
@func{fork} returns zero in the child process and the child process' id
in the parent process.
@end deffn


@c page
@node process exec
@section Executing a file


@glibcref{Executing a File,Executing a File}


@deffn Function execv @var{pathname} @var{args}
@deffnx Function primitive-execv @var{pathname} @var{args}
@deffnx Parameter execv-function
@deffnx Function platform-execv @var{c-pathname} @var{argv}
Execute the file selected by the string or symbol @var{pathname} using
the list of strings or symbols @var{args} as command line arguments.  By
convention the first value of @var{args} must be the name (with no
directory pathname) of the executed process.  If successful a new
process is executed and these functions do not return.

Usage example:

@example
(when (= 0 (fork))
  (execv '/bin/ls '(ls "-l" /bin)))
@end example

@noindent
notice that command line options like @code{-l} have to be strings, not
symbols, to prevent the Scheme implementation to raise an error (because
the first char @code{-} is reserved for numeric datums).  To test an
error handling path:

@example
(parameterize ((primitive-execv-function
                (lambda args
                  (raise-errno-error 'execv EINVAL))))
   (guard (exc ---)
     ---
     (execv '/bin/ls '(ls))
     ---))
@end example
@end deffn

@c ------------------------------------------------------------

@deffn Function execve @var{pathname} @var{args} @var{envs}
@deffnx Function primitive-execve @var{pathname} @var{args} @var{envs}
@deffnx Parameter execve-function
@deffnx Function platform-execve @var{c-pathname} @var{argv} @var{envv}
Execute the file selected by the string or symbol @var{pathname} using
the list of strings or symbols @var{args} as command line arguments.  By
convention the first value of @var{args} must be the name (with no
directory path) of the executed process.

@var{envs} must be a list of strings or symbols used to set the process
execution environment.

If successful a new process is executed and these functions do not
return.

Usage example:

@example
(when (= 0 (fork))
  (execve '/usr/bin/du
          '(du /bin/ls)
          '("BLOCK_SIZE=human-readable")))
@end example

@noindent
notice that command line options like @code{-l} have to be strings, not
symbols, to prevent the Scheme implementation to raise an error (because
the first char @code{-} is reserved for numeric datums).  To test an
error handling path:

@example
(parameterize ((primitive-execve-function
               (lambda args
                 (raise-errno-error 'execve EINVAL))))
  (guard (exc ---)
    (execve '/usr/bin/du
            '(du /bin/ls)
            '("BLOCK_SIZE=human-readable"))))
@end example
@end deffn

@c ------------------------------------------------------------

@deffn Function execvp @var{pathname} @var{args}
@deffnx Function primitive-execvp @var{pathname} @var{args}
@deffnx Parameter execvp-function
@deffnx Function platform-execvp @var{c-pathname} @var{argv}
These functions are like the @func{execv} ones, except that
@var{pathname} can be the name of a file that is searched in the current
@env{PATH} search path.
@end deffn


@deffn Function system @var{command}
@deffnx Function primitive-system @var{command}
@deffnx Parameter system-function
@deffnx Function platform-system @var{command}
Run @var{command} using the system shell.
@end deffn


@c page
@node process wait
@section Process completion


@cindex @code{WNOHANG}
@cindex @code{WUNTRACED}
@cindex @code{WCONTINUED}

For the following functions: the @var{options} argument can be zero or a
@func{bitwise-ior} of @code{WNOHANG}, @code{WUNTRACED} and
@code{WCONTINUED} which are exported by @library{posix sizeof}.

@glibcref{Process Completion,Process Completion}


@deffn Function primitive-waitpid @var{pid} @var{options}
@deffnx Parameter waitpid-function
@deffnx Function platform-waitpid @var{pid} @var{pointer} @var{options}
Wait for a single process or a set of processes in a group.  For the
full documentation we have to refer to the documentation of the foreign
function @cfunc{waitpid}.
@end deffn


@defun waitpid @var{pid} @var{options}
A wrapper for @func{primitive-watipid} that tracks a specific child
process.
@end defun


@defun waitpid/any @var{options}
A wrapper for @func{primitive-watipid} that tracks all the child
processes.
@end defun


@defun waitpid/any-my-group @var{options}
A wrapper for @func{primitive-watipid} that tracks all the child
processes in the same group of the caller.
@end defun


@defun waitpid/group @var{gpid} @var{options}
A wrapper for @func{primitive-watipid} that tracks all the child
processes in the group with id @var{gpid}.
@end defun


@subsubheading Inspecting the termination status


Using the @acronym{FFI} of Scheme implementations there is no way to
analyse the status value returned by the waitpid functions, but if we
have installed the @posix{} Nausicaa/Stubs foreign library, we can
import the @library{posix process stub} library to use the following
bindings.


@deftp {Record Type} process-term-status-record
Holds a field for each property in the process termination status value.
@end deftp


@defun make-process-term-status @var{status}
Build and return a @code{process-term-status-record} initialised with
the bits in @var{status}, which must be the status return value of a
waitpid function.
@end defun


@defun make-process-term-status-record @var{WIFEXITED} @var{WEXITSTATUS} @var{WIFSIGNALED} @var{WTERMSIG} @var{WCOREDUMP} @var{WIFSTOPPED} @var{WSTOPSIG}
Build and return a @code{process-term-status-record} directly
initialised with boolean values.  This can be used to construct a fake
status record for testing purposes.
@end defun


@defun process-term-status? @var{obj}
Return @true{} if @var{obj} is a @code{process-term-status-record}
record.
@end defun


@defun WIFEXITED? @var{status-record}
@defunx WEXITSTATUS? @var{status-record}
@defunx WIFSIGNALED? @var{status-record}
@defunx WTERMSIG? @var{status-record}
@defunx WCOREDUMP? @var{status-record}
@defunx WIFSTOPPED? @var{status-record}
@defunx WSTOPSIG? @var{status-record}
Return @true{} or @false{} if the property is set or unset in the status
record.  @glibcref{Process Completion Status, Process Completion Status}
@end defun


@defun platform-WIFEXITED @var{status}
@defunx platform-WEXITSTATUS @var{status}
@defunx platform-WIFSIGNALED @var{status}
@defunx platform-WTERMSIG @var{status}
@defunx platform-WCOREDUMP @var{status}
@defunx platform-WIFSTOPPED @var{status}
@defunx platform-WSTOPSIG @var{status}
These are wrappers for the macros that extract a value from the
@var{status} integer returned by the waitpid functions.  They can be
used to query the status without building a record.
@end defun


@c page
@node job
@chapter Job control


The bindings described in this chapter are exported by @library{posix
job} and @library{posix job platform}.


@menu
* job terminal::                Terminal identification.
* job group::                   Process group functions.
* job access::                  Terminal access.
@end menu


@c page
@node job terminal
@section Terminal identification


@glibcref{Identifying the Terminal,Identifying the Controlling Terminal}


@deffn Function ctermid
@deffnx Function primitive-ctermid
@deffnx Parameter ctermid-function
@deffnx Function platform-ctermid @var{pointer}
Return a string representing the pathname of the controlling terminal
for this process.

@var{pointer} can be null or a pointer to a buffer of @code{L_ctermid}
bytes in which the foreign function will store the terminal file
pathname as a C string.  @code{L_ctermid} is exported by @library{posix
sizeof}.
@end deffn


@c page
@node job group
@section Process group functions


@glibcref{Process Group Functions,Process Group Functions}


@deffn Function setsid
@deffnx Function primitive-setsid
@deffnx Parameter setsid-function
@deffnx Function platform-setsid
Create a new session and return an integer representing the new process
group id.
@end deffn


@deffn Function getsid @var{pid}
@deffnx Function primitive-getsid @var{pid}
@deffnx Parameter getsid-function
@deffnx Function platform-getsid @var{pid}
Return the group id of the session leader of the process with @var{pid}.
@end deffn


@deffn Function getpgrp
@deffnx Function primitive-getpgrp
@deffnx Parameter getpgrp-function
@deffnx Function platform-getpgrp
Return the process group id of the group to which the current process
belongs.
@end deffn


@deffn Function setpgid @var{pid} @var{pgid}
@deffnx Function primitive-setpgid @var{pid} @var{pgid}
@deffnx Parameter setpgid-function
@deffnx Function platform-setpgid @var{pid} @var{pgid}
Put the process @var{pid} in the group @var{pgid}.
@end deffn


@c page
@node job access
@section Terminal access


@glibcref{Terminal Access Functions,Functions for Controlling Terminal
Access}


@deffn Function tcgetpgrp @var{fd}
@deffnx Function primitive-tcgetpgrp @var{fd}
@deffnx Parameter tcgetpgrp-function
@deffnx Function platform-tcgetpgrp @var{fd}
Return the process group id of the foreground process group associated
with the terminal open on descriptor @var{fd}.
@end deffn


@deffn Function tcsetpgrp @var{fd} @var{pgid}
@deffnx Function primitive-tcsetpgrp @var{fd} @var{pgid}
@deffnx Parameter tcsetpgrp-function
@deffnx Function platform-tcsetpgrp @var{fd} @var{pgid}
Set a terminal's foreground process group id.
@end deffn


@deffn Function tcgetsid @var{fd}
@deffnx Function primitive-tcgetsid @var{fd}
@deffnx Parameter tcgetsid-function
@deffnx Function platform-tcgetsid @var{fd}
Return the process group id of the session for which the open on
descriptor @var{fd} is the controlling terminal.
@end deffn


@c page
@node users
@chapter Users and groups


The bindings described in this chapter are exported by the
@library{posix users} library.


@menu
* users
@end menu

@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
