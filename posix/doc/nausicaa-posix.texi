\input texinfo.tex
@c %**start of header
@setfilename nausicaa-posix.info
@settitle POSIX for Nausicaa
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro


@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@macro rsixref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@end macro

@macro rfiveref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r5rs}
@end macro

@macro ikarusref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,ikarus}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@macro bibref{TAG}
@samp{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @posix{} for Nausicaa

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@posix{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-posix

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2008, 2009

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a
distribution of libraries for @rnrs{6} Scheme exposing the @posix{}
interface to the Scheme language level; some @gnu{} C Library extensions
are also exposed.  It is built on top of the Nausicaa/Scheme libraries,
making use of its foreign-functions interface; some libraries depend
upon the C language library @samp{libnausicaa-posix} from the
Nausicaa/Stubs package.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/nausicaa/downloads}

@noindent
the project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/tree/master}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-posix: (nausicaa-posix).     @posix{} library for
                                        @rnrs{6} Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview.
* api::                         Interface organisation.
* environment::                 Environment variables.
* file::                        File system.
* stat::                        Inspecting file attributes.
* time::                        Date and time.
* fd::                          File descriptors.
* process::                     Processes.
* job::                         Job control.
* users::                       Users and groups.
* strings::                     More C string functions.
* streams::                     Stream functions.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

File system

* file working directory::      The working directory.
* file directory access::       Accessing directory entries.
* file links::                  Hard and symbolic links.
* file remove::                 Removing files and directories.
* file rename::                 Renaming files and directories.
* file mkdir::                  Creating directories.
* file attr::                   Changing file attributes.
* file temp::                   Temporary files.

Accessing directory entries

* file directory access types:: Type definitions.
* file directory access open::  Accessing a directory stream.
* file directory access read::  Reading a directory stream.
* file directory access seek::  Random access to a directory stream.

Changing file attributes

* file attr owner::             Changing owner and group.
* file attr mode::              Changing file permissions.
* file attr access::            Testing access.
* file attr size::              Size of files.

Inspecting file attributes

* stat constants::              Constant values.
* stat record::                 Acquiring the file attributes.
* stat api::                    Interface functions.
* stat type::                   Type inspection.
* stat perms::                  Access permissions inspection.

Date and time

* time structs::                Data structures.
* time clock::                  Processor time.

File descriptors

* fd constants::                Bindings for constant values.
* fd open close::               Opening and closing.
* fd read write::               Reading and writing.
* fd seek::                     Setting the file position.
* fd sync::                     Synchronisation.
* fd control::                  Control operations.
* fd dup::                      Duplicating file descriptors.
* fd lock::                     File locks.
* fd pipe::                     Pipes and FIFOs.
* fd custom::                   Custom Scheme ports.

Bindings for constant values

* fd constants status::         File status flags.
* fd constants perms::          Permissions.
* fd constants control::        File control flags.
* fd constants seek::           File positions.
* fd constants lock::           Locking.

Processes

* process record::              Record types.
* process id::                  Process identification.
* process fork::                Creating a process.
* process exec::                Executing a file.
* process wait::                Process completion.

Job control

* job terminal::                Terminal identification.
* job group::                   Process group functions.
* job access::                  Terminal access.

Users and groups

* users persona::               Process' persona.

@end detailmenu
@end menu

@end ifnottex

@c page
@node overview
@chapter Overview


@value{PACKAGE} is a distribution of libraries for @rnrs{6} Scheme
exposing the @posix{} interface to the Scheme language level; some
@gnu{} C Library extensions are also exposed.  It is built on top of the
Nausicaa/Scheme libraries, making use of its foreign-functions
interface; some libraries depend upon the C language library
@samp{libnausicaa-posix} from the Nausicaa/Stubs package.

Unless otherwise specified, for each set of features there are three
libraries:

@table @library
@item foreign posix ---
@itemx foreign glibc ---
@itemx foreign linux ---
The high--level interface: Slower but user friendly.  We should really
import these libraries by prefixing the identifiers; for example:

@example
(import (rnrs)
  (prefix (foreign posix fd) posix:))
@end example

@item foreign posix --- primitives
@itemx foreign glibc --- primitives
@itemx foreign linux --- primitives
The middle--level interface; does marshaling of arguments and return
values.  In this documentation, all the bindings from these libraries
are prefixed with @samp{primitive:}, but they are exported
@strong{without} this prefix.

@item foreign posix --- platform
@itemx foreign glibc --- platform
@itemx foreign linux --- platform
The low--level interface: Faster but raw.  In this documentation, all
the bindings from these libraries are prefixed with @samp{platform:},
but they are exported @strong{without} this prefix.
@end table

Additionally, the @library{foreign posix sizeof} library exports
bindings for constant values (like @samp{O_CREAT}) and data structure
accessors and mutators.

@c page
@node api
@chapter Interface organisation


For all the functions only a brief description is given: We have to use
the foreign function's own documentation to have all the details.
Unless otherwise specified, the interface adheres to the following
pattern for function @func{x}:

@deffn Function x @var{arg} ...
@deffnx Parameter x-function
@deffnx Function primitive:x @var{arg} ...
@deffnx Function platform:x @var{c-arg} ...
This is an interface for the @cfunc{x} foreign function.

@func{x} and @func{primitive:x} do something with the arguments, which
are regular Scheme values.  They take the same arguments and return the
same return values.  If successful they return values representing the
result; in case of error they raise an @samp{&errno} condition.

@func{x} does the job by applying to the arguments the current value of
the @func{x-function} parameter, which must be a function.  The
parameter is initialised to @func{primitive:x}.

@func{platform:x} is the direct wrapper for the foreign function.  It
accepts C language level arguments (like C strings), and returns 2
values: the return value from the foreign function call and the value of
@samp{errno} right after the call.

Notice that, for almost all the functions, the value of @samp{errno} is
meaningful only if the return value from the foreign function call
indicates an error; @samp{errno} may be non--zero even if the function
call was successful.

For the meaning of the C level arguments we have to read the foreign
function's original documentation.
@end deffn


This interface gives us 3 choices:

@enumerate
@item
To call directly the foreign function using the @func{platform:x}
wrapper; in this case we are responsible to convert the Scheme arguments
to the appropriate C language level values (beware to non--garbage
collected values!).

@item
To call the Scheme adapter @func{primitive:x}; this gives us: automatic
conversion of arguments, exceptions in case of errors, automatic
retrying in case the foreign function call is interrupted by an
@samp{EINTR} signal.

@item
To call the high--level, parameterised, @func{x} interface; this gives
us everything @func{primitive:x} does and additionally allows us to
replace the primitive function with a version that returns controlled
values, or raises an error, and/or logs the operation.  This feature can
be used to test Scheme code execution paths that handle exceptions.
@end enumerate


Example of usage of failing primitive fork function:

@example
(define (fake-fork)
  (raise-errno-error 'fork EINVAL))

(parametrise ((primitive:fork-function fake-fork))
  ---
  (fork)
  ---)
@end example

@c page
@node environment
@chapter Environment variables


Unless otherwise specified, the following bindings are exported by the
libraries:

@example
(foreign posix environment)
(foreign posix environment primitives)
(foreign posix environment platform)
@end example

@noindent
@glibcref{Environment Access,Environment Access}.  @nauref{naulib
environment, Accessing environment variables}.


@deffn Function getenv @var{varname}
@deffnx Parameter getenv-function
@deffnx Function primitive:getenv @var{varname}
@deffnx Function platform:getenv @var{varname-cstr}
Return the current value of the environment variable @var{varname}, as a
Scheme string.  @var{varname} must be a Scheme string or symbol.  If the
variable is not set, the return value if @false{}; if the variable is
set to the empty string, the return value is the empty string.
@end deffn


@deffn Function setenv @var{varname} @var{value}
@deffnx Function setenv @var{varname} @var{value} @var{replace}
@deffnx Parameter setenv-function
@deffnx Function primitive:setenv @var{varname} @var{value}
@deffnx Function primitive:setenv @var{varname} @var{value} @var{replace}
@deffnx Function platform:setenv @var{varname} @var{value} @var{replace}
Set a new value for the environment variable @var{varname}.
@var{varname} and @var{value} must be Scheme strings or symbols.  If the
environment already contains @var{varname}, then @var{replace} controls
the action: if true the value is replaced, if @false{} it is left alone.
@end deffn


@deffn Function environ
@deffnx Parameter environ-function
@deffnx Function primitive:environ
@deffnx Function platform:environ
Direct access to the process' environment variables.  @func{environ} and
@func{primitive:environ} return a list of strings, each of the form
@samp{NAME=VALUE} where @samp{NAME} is the name of an environment
variable and @samp{VALUE} its value.

@func{platform:environ} returns a pointer to an array of pointers, each
referencing a C string with the format @samp{NAME=VALUE}.  The pointer
is suitable to be used as argument to @func{arg->strings}
(@nauref{cstrings argv, Converting arrays of strings}).
@end deffn


@defun environ-table
Internally invoke @func{environ} and convert the list of strings into a
hashtable; return the hashtable.  The keys are Scheme symbols
representing the defined environment variables, the values are Scheme
symbols representing the environment variables' values.
@end defun


@defun environ->table @var{environ}
@defunx table->environ @var{table}
Convert between a list of strings in ``environ'' format and a hashtable.
@end defun

@c ------------------------------------------------------------

@subsubheading @gnu{} C library functions

The following bindings are exported by the libraries:

@example
(foreign glibc environment)
(foreign glibc environment primitives)
(foreign glibc environment platform)
@end example


@deffn Function clearenv
@deffnx Function primitive:clearenv
@deffnx Function platform:clearenv
Remove all the entries from the process' environment.
@end deffn


@deffn Function unsetenv @var{varname}
@deffnx Function primitive:unsetenv @var{varname}
@deffnx Function platform:unsetenv @var{varname-cstr}
Remove the entry for @var{varname} from the environment.  @var{varname}
must be a Scheme string or symbol.
@end deffn


@deffn Function putenv @var{assignment}
@deffnx Function primitive:putenv @var{assignment}
@deffnx Function platform:putenv @var{assignment-cstr}
Put the variable assignment described by the Scheme string or symbol
@var{assignment} in the environment.  @var{assignment} must have the
format @samp{NAME=VALUE}.
@end deffn


@defun putenv* @var{name} @var{value}
@defunx primitive:putenv* @var{name} @var{value}
Append the Scheme strings or symbols @var{name} and @var{value} to form
a single strings with @samp{=} in the middle; then put the resulting
variable assignment in the environment.
@end defun

@c page
@node file
@chapter File system


Unless otherwise specified, the bindings described in this chapter are
exported by the following libraries:

@example
(foreign posix file)
(foreign posix file primitives)
(foreign posix file platform)
@end example

@noindent
additionally if we have installed the Nausicaa/Stubs library for
@posix{}, we can import the @library{foreign posix file stub} library;
see the Nausicaa/Stubs project for details.

@menu
* file working directory::      The working directory.
* file directory access::       Accessing directory entries.
* file links::                  Hard and symbolic links.
* file remove::                 Removing files and directories.
* file rename::                 Renaming files and directories.
* file mkdir::                  Creating directories.
* file attr::                   Changing file attributes.
* file temp::                   Temporary files.
* file time::                   Setting file times.
@end menu

@c page
@node file working directory
@section The working directory


The following functions manage the process' current directory.
@glibcref{Working Directory,Working Directory}.


@deffn Function getcwd
@deffnx Parameter getcwd-function
@deffnx Function primitive:getcwd
@deffnx Function platform:getcwd
Return a string representing the current working directory.
@end deffn


@defun pwd
An alias for @func{getcwd}.
@end defun


@deffn Function chdir @var{pathname}
@deffnx Parameter chdir-function
@deffnx Function primitive:chdir @var{pathname}
@deffnx Function platform:chdir @var{pathname}
Change the current directory to the selected @var{pathname}, which must
be a Scheme string or symbol.  If an error occurs changing directory,
because of access permissions: An exception is raised.
@end deffn


@deffn Function fchdir @var{fd}
@deffnx Parameter fchdir-function
@deffnx Function primitive:fchdir @var{fd}
@deffnx Function platform:fchdir @var{fd}
Change the current directory to the one associated to the file
descriptor @var{fd}.
@end deffn

@c page
@node file directory access
@section Accessing directory entries


The functions described in this section handle accessing directories.
@glibcref{Accessing Directories,Accessing Directories}.

@menu
* file directory access types:: Type definitions.
* file directory access open::  Accessing a directory stream.
* file directory access read::  Reading a directory stream.
* file directory access seek::  Random access to a directory stream.
@end menu

@c page
@node file directory access types
@subsection Type definitions


The following bindings are exported from @library{foreign posix sizeof}.
@glibcref{Directory Entries,Format of a directory entry}.


@defvr Constant sizeof-struct-dirent
@defvrx Constant alignof-struct-dirent
@defvrx Constant strideof-struct-dirent
Size, alignment and array stride of @code{struct dirent} types.
@end defvr


@deffn Syntax struct-dirent-d_name-ref @var{pointer}
Getter for the @code{d_name} field of a @code{struct dirent} type.
Evaluates to a pointer to the first byte of the @code{char d_name[]}
array.
@end deffn

@c page
@node file directory access open
@subsection Accessing a directory stream


The following functions manage opening and closing of special
@dfn{stream} objects used to access directory contents.
@glibcref{Opening a Directory,Opening a directory stream}.
@glibcref{Reading/Closing Directory,Reading and closing a directory
stream}.

Usage examples:

@example
(let ((stream #f))
  (dynamic-wind
    (lambda ()
      (set! stream (opendir "/home/marco/share/sounds")))
    (lambda ()
      ---)
    (lambda ()
      (closedir stream))))

(with-compensations
  (let ((stream (opendir/c "/home/marco/share/sounds")))
    ---))
@end example


@deffn Function opendir @var{pathname}
@deffnx Parameter opendir-function
@deffnx Function primitive:opendir @var{pathname}
@deffnx Function platform:opendir @var{pathname}
Open and return a stream associated to the directory selected by the
Scheme string or symbol @var{pathname}.
@end deffn


@deffn Function fdopendir @var{fd}
@deffnx Parameter fdopendir-function
@deffnx Function primitive:fdopendir @var{fd}
@deffnx Function platform:fdopendir @var{fd}
Open and return a stream associated to the directory selected by the
file descriptor @var{fd}.
@end deffn


@deffn Function closedir @var{stream}
@deffnx Parameter closedir-function
@deffnx Function primitive:closedir @var{stream}
@deffnx Function platform:closedir @var{stream}
Close the directory @var{stream} previously opened with @func{opendir}
or @func{fdopendir}.

@quotation
@strong{NOTE} Applying this function to a stream that was opened with
@func{fdopendir}, closes the underlying file descriptor, too.  This is
weird but I have tested it with @file{libc-2.5.so}, so believe me.

This means that we have to avoid closing the file descriptor with
@func{close} (as it is very obscurely written in the @gnu{} C Library
documentation).
@end quotation
@end deffn


@defun opendir/compensated @var{pathname}
@defunx fdopendir/compensated @var{fd}
@defunx opendir/c @var{pathname}
@defunx fdopendir/c @var{fd}
Like @func{opendir} and @func{fdopendir}, but push the appropriate call
to @func{closedir} on the dynamic environment of the current
compensation stack.  @nauref{compensations, Compensation stacks}
@end defun


@deffn Function dirfd @var{stream}
@deffnx Parameter dirfd-function
@deffnx Function primitive:dirfd @var{stream}
@deffnx Function platform:dirfd @var{stream}
Return the file descriptor associated to the directory @var{stream}
previously opened with @func{opendir} or @func{fdopendir}.
@end deffn

@c page
@node file directory access read
@subsection Reading a directory stream


The following functions manage reading special @dfn{stream} objects used
to access directory contents.  @glibcref{Reading/Closing
Directory,Reading and closing a directory stream}.

As a usage example for the low level functions, let's see how
@func{directory-list} is implemented:

@example
(define (directory-list pathname)
  (with-compensations
    (let ((dir    (opendir/c pathname))
          (layout '()))
      (do ((entry (readdir dir) (readdir dir)))
          ((pointer-null? entry)
           layout)
        (set! layout
              (cons (cstring->string
                       (struct-dirent-d_name-ref entry))
                    layout))))))
@end example

@noindent
to read a directory and sort the entries:

@example
(list-sort string<? (directory-list "/home/marco"))
@end example

@noindent
to read a directory using the file descriptor and the @gnu{} flag
@code{O_NOATIME}:

@example
(with-compensations
  (letrec ((fd (compensate
                   (open the-root
                         (if (number? O_NOATIME)
                             (bitwise-ior O_RDONLY
                                          O_NOATIME)
                           O_RDONLY)
                         0)
                 (with
                  (close fd)))))
    (directory-list/fd fd)))
@end example


@deffn Function readdir @var{stream}
@deffnx Parameter readdir-function
@deffnx Function primitive:readdir @var{stream}
@deffnx Function platform:readdir @var{stream}
Return a pointer to a statically allocated @code{struct dirent}
describing the next entry from the directory @var{stream}, previously
opened with @func{opendir} or @func{fdopendir}.

Notice that the returned strings are the names of the entries relative
to the uplevel directory.  No slash and no parent directory part are in
there.
@end deffn


@defun directory-list @var{pathname}
@defunx directory-list/fd @var{fd}
High level functions that open the directory selected by the Scheme
string or symbol @var{pathname} or file descriptor @var{fd}, read all
the entries and return a list of Scheme strings holding the entry names.
@end defun

@c page
@node file directory access seek
@subsection Random access to a directory stream


The following function handle seeking the current position in the
special @dfn{stream} objects used to access directory contents.
@glibcref{Random Access Directory, Random Access in a Directory Stream}.

For the following bindings: The @code{platform:} functions return a
@strong{single} value, they do not use @code{errno} to signal errors.


@deffn Function rewinddir @var{stream}
@deffnx Parameter rewinddir-function
@deffnx Function primitive:rewinddir @var{stream}
@deffnx Function platform:rewinddir @var{stream}
Rewind the directory @var{stream} previously opened with @func{opendir}
or @func{fdopendir}.
@end deffn


@deffn Function telldir @var{stream}
@deffnx Parameter telldir-function
@deffnx Function primitive:telldir @var{stream}
@deffnx Function platform:telldir @var{stream}
Return an exact integer representing the current position in the
directory @var{stream} previously opened with @func{opendir} or
@func{fdopendir}.

Notice that returned values look like arbitrary integers, they do not
follow a predictable sequence.
@end deffn


@deffn Function seekdir @var{stream} @var{position}
@deffnx Parameter seekdir-function
@deffnx Function primitive:seekdir @var{stream} @var{position}
@deffnx Function platform:seekdir @var{stream} @var{position}
Seek to @var{position} the directory @var{stream} previously opened with
@func{opendir} or @func{fdopendir}.  @var{position} must be a value
previously returned by @func{telldir}.
@end deffn

@c page
@node file links
@section Hard and symbolic links


The following functions manage hard and symbolic links to files.
@glibcref{Hard Links,Hard Links}.  @glibcref{Symbolic Links,Symbolic
Links}.


@deffn Function link @var{old-pathname} @var{new-pathname}
@deffnx Parameter link-function
@deffnx Function primitive:link @var{old-pathname} @var{new-pathname}
@deffnx Function platform:link @var{old-pathname} @var{new-pathname}
Link to the new name specified by the Scheme string or symbol
@var{new-pathname}, the file selected by the Scheme string or symbol
@var{old-pathname}.
@end deffn


@deffn Function symlink @var{old-pathname} @var{new-pathname}
@deffnx Parameter symlink-function
@deffnx Function primitive:symlink @var{old-pathname} @var{new-pathname}
@deffnx Function platform:symlink @var{old-pathname} @var{new-pathname}
Link to the new name specified by the Scheme string or symbol
@var{new-pathname}, the file selected by the Scheme string or symbol
@var{old-pathname}.
@end deffn


@deffn Function realpath @var{pathname}
@deffnx Parameter realpath-function
@deffnx Function primitive:realpath @var{pathname}
@deffnx Function platform:realpath @var{pathname}
Return a string representing the real pathname of the symbolic link
selected by the Scheme string or symbol @var{pathname}.
@end deffn

@c page
@node file remove
@section Removing files and directories


The following functions manage removal of files and directories from a
file system.  @glibcref{Deleting Files,Deleting Files}.


@deffn Function unlink @var{pathname}
@deffnx Parameter unlink-function
@deffnx Function primitive:unlink @var{pathname}
@deffnx Function platform:unlink @var{pathname}
Remove the file selected by the Scheme string or symbol @var{pathname}.
@end deffn


@deffn Function remove @var{pathname}
@deffnx Parameter remove-function
@deffnx Function primitive:remove @var{pathname}
@deffnx Function platform:remove @var{pathname}
Remove the file selected by the Scheme string or symbol @var{pathname}.
@end deffn


@deffn Function rmdir @var{pathname}
@deffnx Parameter rmdir-function
@deffnx Function primitive:rmdir @var{pathname}
@deffnx Function platform:rmdir @var{pathname}
Remove the directory selected by the Scheme string or symbol
@var{pathname}.  The directory has to be empty.
@end deffn

@c page
@node file rename
@section Renaming files and directories


The following functions manage renaming of files and directories from a
file system.  @glibcref{Renaming Files,Renaming Files}.


@deffn Function rename @var{old-pathname} @var{new-pathname}
@deffnx Parameter rename-function
@deffnx Function primitive:rename @var{old-pathname} @var{new-pathname}
@deffnx Function platform:rename @var{old-pathname} @var{new-pathname}
Rename the file selected by the string or symbol @var{old-pathname} to
the pathname selected by the string or symbol @var{new-pathname}.
@end deffn

@c page
@node file mkdir
@section Creating directories


The following functions manage creating new directories.
@glibcref{Creating Directories, Creating Directories}.


@deffn Function mkdir @var{pathname}
@deffnx Parameter mkdir-function
@deffnx Function primitive:mkdir @var{pathname}
@deffnx Function platform:mkdir @var{pathname}
Create a new directory with pathname selected by the Scheme string or
symbol @var{pathname}.
@end deffn

@c page
@node file attr
@section Changing file attributes


The functions described in this section manage file and directory
attributes.  @glibcref{File Attributes, File Attributes}.

@menu
* file attr owner::             Changing owner and group.
* file attr mode::              Changing file permissions.
* file attr access::            Testing access.
* file attr size::              Size of files.
@end menu

@c page
@node file attr owner
@subsection File owner and group


The following functions manage file ownership attributes.
@glibcref{File Owner, File Owner}.


@deffn Function chown @var{pathname} @var{owner-id} @var{group-id}
@deffnx Parameter chown-function
@deffnx Function primitive:chown @var{pathname} @var{owner-id} @var{group-id}
@deffnx Function platform:chown @var{pathname-cstr} @var{owner-id} @var{group-id}
Change the file owner and group to the given numeric identifiers.
@var{pathname} must be a Scheme string or symbol representing a
pathname.
@end deffn


@deffn Function fchown @var{fd} @var{owner-id} @var{group-id}
@deffnx Parameter fchown-function
@deffnx Function primitive:fchown @var{fd} @var{owner-id} @var{group-id}
@deffnx Function platform:fchown fchown @var{fd} @var{owner-id} @var{group-id}
Change the file owner and group to the given numeric identifiers.
@var{fd} must be a file descriptor.
@end deffn

@c page
@node file attr mode
@subsection Changing file permissions


The following functions manage file access permissions.
@glibcref{Setting Permissions, Assigning File Permissions}.

The @var{mask} argument must be an exact integer representing access
permissions bits.  @ref{fd constants perms} for details about composing
the the mask value as a bitwise combination of predefined constants.


@deffn Function umask @var{mask}
@deffnx Parameter umask-function
@deffnx Function primitive:umask @var{mask}
@deffnx Function platform:umask @var{mask}
Set the umask to @var{mask} and return the old mask value.  To query the
current mask without changing it:

@example
(let ((m (umask 0)))
  (umask m)
  m)
@end example

@noindent
or use @func{getumask}, which has exactly this implementation.
@end deffn


@defun getumask
@defunx primitive:getumask
Return the current umask.
@end defun


@deffn Function chmod @var{pathname} @var{mask}
@deffnx Parameter chmod-function
@deffnx Function primitive:chmod @var{pathname} @var{mask}
@deffnx Function platform:chmod @var{pathname-cstr} @var{mask}
Change the file access permissions bits to the given numeric mask.
@var{pathname} must be a Scheme string or symbol representing a
pathname.
@end deffn


@deffn Function fchmod @var{fd} @var{mask}
@deffnx Parameter fchmod-function
@deffnx Function primitive:fchmod @var{fd} @var{mask}
@deffnx Function platform:fchmod @var{fd} @var{mask}
Change the file access permissions bits to the given numeric mask.
@var{fd} must be a file descriptor.
@end deffn

@c page
@node file attr access
@subsection Testing access


The following functions manage testing if the process has access
permissions for a file or directory.  @glibcref{Testing File Access,
Testing permission to access a file}.

Example:

@example
(access "file.ext" (bitwise-ior R_OK W_OK))
@end example


@deffn Function access @var{pathname} @var{mask}
@deffnx Parameter access-function
@deffnx Function primitive:access @var{pathname} @var{mask}
@deffnx Function platform:access @var{pathname-cstr} @var{mask}
Return @true{} if the process has permission to access the file selected
by the Scheme string or symbol @var{pathname} as specified by
@var{mask}; return @false{} otherwise.

@var{mask} can be the bitwise combination of: @code{F_OK}, @code{R_OK},
@code{W_OK}, @code{X_OK}.
@end deffn


@defvr Constant F_OK
@defvrx Constant R_OK
@defvrx Constant W_OK
@defvrx Constant X_OK
Constants representing requests for access permission testing with
@func{access}.  These bindings are exported by @library{foreign posix
sizeof}.
@end defvr

@c page
@node file attr size
@subsection Size of files


@deffn Function file-size @var{fd/pathname}
@deffnx Parameter file-size-function
@deffnx Function primitive:file-size @var{fd/pathname}
Return the size of the selected file.  @var{fd/pathname} can be a file
descriptor or a pathname in the form of a Scheme string or symbol.

This function is implemented using @func{lseek} as described in @ref{fd
seek, Setting the file position}.
@end deffn


@deffn Function ftruncate @var{fd/pathname} @var{length}
@deffnx Parameter ftruncate-function
@deffnx Function primitive:ftruncate @var{fd/pathname} @var{length}
@deffnx Function platform:ftruncate @var{fd/pathname-cstr} @var{length}
Set to @var{length} the size of the selected file.  @var{fd/pathname}
can be a file descriptor or a pathname in the form of a Scheme string or
symbol.
@end deffn

@c page
@node file temp
@section Temporary files


The following functions manage the creation of temporary files and
directories.  @glibcref{Temporary Files, Temporary Files}.

Usage example:

@example
(let-values (((fd pathname) (mkstemp "/tmp/XXXXXX")))
  ---
  (close fd)
  (delete-file pathname))
@end example


@deffn Function tmpnam
@deffnx Parameter tmpnam-function
@deffnx Function primitive:tmpnam
@deffnx Function platform:tmpnam
Return a file pathname that, at the time of the call, does not exist on
the system.
@end deffn


@deffn Function mktemp @var{template}
@deffnx Parameter mktemp-function
@deffnx Function primitive:mktemp @var{template}
@deffnx Function platform:mktemp @var{template-cstr}
Return a file pathname that, at the time of the call, does not exist on
the system.  The pathname is built from the Scheme string or symbol
@var{template}, which must include the @code{XXXXXX} sequence of
characters (six times @code{X}).  @var{template} is @strong{not}
mutated.
@end deffn


@deffn Function mkstemp @var{template}
@deffnx Parameter mkstemp-function
@deffnx Function primitive:mkstemp @var{template}
@deffnx Function platform:mkstemp @var{template-cstr}
Return two values: a file descriptor and a file pathname.  The pathname
is built from the Scheme string or symbol @var{template}, which must
include the @code{XXXXXX} sequence of characters (six times @code{X}).
@var{template} is @strong{not} mutated.
@end deffn

@c page
@node file time
@section Setting file times


@deffn Function utime @var{pathname}
@deffnx Function utime @var{pathname} @var{access-time} @var{modification-time}
@deffnx Parameter utime-function
@deffnx Function primitive:utime @var{pathname} @var{access-time} @var{modification-time}
@deffnx Function primitive:utime @var{pathname} @var{access-time} @var{modification-time}
@deffnx Function platform:utime @var{pathname-cstr} @var{utimbuf-pointer}
Set the access and modification times for the file selected by
@var{pathname}, which must be a Scheme string or symbol.  If
@var{access-time} and @var{modification-time} are not given, set the
times to the current time.

@quotation
@strong{NOTE} The @acronym{SUS}@footnote{Single @acronym{UNIX}
Specification.

@center @url{http://www.unix.org/single_unix_specification/}
} states that an implementation may choose not to set the access time of
the file, even though it is requested by the @cfunc{utime} call.
@end quotation
@end deffn



@c page
@node stat
@chapter Inspecting file attributes


Unless otherwise specified, the bindings described in this section are
exported by the following libraries:

@example
(foreign posix stat)
(foreign posix stat primitives)
(foreign posix stat platform)
(foreign posix stat record-types)
@end example

@noindent
full support for the C language @cfunc{stat} function requires loading
the @file{libnausicaa-posix.so} library.

@menu
* stat constants::              Constant values and structure accessors.
* stat record::                 Acquiring the file attributes.
* stat api::                    Interface functions.
* stat type::                   Type inspection.
* stat perms::                  Access permissions inspection.
@end menu

@c page
@node stat constants
@section Constant values and structures accessors


The following bindings are exported by the @library{foreign posix stat
platform} library; this is because @code{struct stat} is somewhat
``special'', so we relay on the @file{libnausicaa-posix.so} stub library
to deal with it.


@defvr Constant sizeof-struct-stat
The size of the @code{struct stat} data structure in bytes.  This
binding is exported by @library{foreign posix stat platform}.
@end defvr


@defun struct-stat-st_mode-ref @var{stat-pointer}
@defunx struct-stat-st_ino-ref @var{stat-pointer}
@defunx struct-stat-st_dev-ref @var{stat-pointer}
@defunx struct-stat-st_nlink-ref @var{stat-pointer}
@defunx struct-stat-st_uid-ref @var{stat-pointer}
@defunx struct-stat-st_gid-ref @var{stat-pointer}
@defunx struct-stat-st_size-ref @var{stat-pointer}
@defunx struct-stat-st_atime-ref @var{stat-pointer}
@defunx struct-stat-st_atime_usec-ref @var{stat-pointer}
@defunx struct-stat-st_mtime-ref @var{stat-pointer}
@defunx struct-stat-st_mtime_usec-ref @var{stat-pointer}
@defunx struct-stat-st_ctime-ref @var{stat-pointer}
@defunx struct-stat-st_ctime_usec-ref @var{stat-pointer}
@defunx struct-stat-st_blocks-ref @var{stat-pointer}
@defunx struct-stat-st_blksize-ref @var{stat-pointer}
Accessors for the named field of a @code{struct stat}.  Notice that some
field may be undefined on some platform (examples: @code{st_atime_usec},
@code{st_mtime_usec}, @code{st_ctime_usec}), in this case the return
value is zero.
@end defun

@c page
@node stat record
@section Acquiring the file attributes


The following bindings are exported by the @library{foreign posix stat
record-types} library.  The informations about a file or directory can
be stored in a Scheme record.  @glibcref{Attribute Meanings, The meaning
of the File Attributes}.


@deftp {Record Type Name} <struct-stat>
@deftpx {Record Type Descriptor} <struct-stat-rtd>
Type of record used to hold fields from a @code{struct stat}.  List of
fields follows:

@example
mode            ino
dev             nlink
uid             gid
size
atime           atime_usec
mtime           mtime_usec
ctime           ctime_usec
blocks          blksize
@end example

@noindent
all the fields are immutable; we have to refer to the original
documentation of @code{struct stat} for their meaning.

Some fields are not available on every platform in the foreign
@code{struct stat} data structure; in this case the associated field in
the @class{struct-stat} record should be set to @false{}.  For example
@code{atime_usec}, @code{mtime_usec}, @code{ctime_usec} are not
available on some common platforms.
@end deftp


@defun make-<struct-stat> @var{mode} @var{ino} @var{dev} @var{nlink} @var{uid} @var{gid} @var{size} @var{atime} @var{atime_usec} @var{mtime} @var{mtime_usec} @var{ctime} @var{ctime_usec} @var{blocks} @var{blksize}
Build and return a new @class{struct-stat} record.
@end defun


@defun <struct-stat>? @var{obj}
Return @true{} if @var{obj} is a @class{struct-stat} record.
@end defun


@defun <struct-stat>-mode @var{struct-stat}
@defunx <struct-stat>-ino @var{struct-stat}
@defunx <struct-stat>-dev @var{struct-stat}
@defunx <struct-stat>-nlink @var{struct-stat}
@defunx <struct-stat>-uid @var{struct-stat}
@defunx <struct-stat>-gid @var{struct-stat}
@defunx <struct-stat>-size @var{struct-stat}
@defunx <struct-stat>-atime @var{struct-stat}
@defunx <struct-stat>-atime_usec @var{struct-stat}
@defunx <struct-stat>-mtime @var{struct-stat}
@defunx <struct-stat>-mtime_usec @var{struct-stat}
@defunx <struct-stat>-ctime @var{struct-stat}
@defunx <struct-stat>-ctime_usec @var{struct-stat}
@defunx <struct-stat>-blocks @var{struct-stat}
@defunx <struct-stat>-blksize @var{struct-stat}
Accessors for the fields of a @class{struct-stat} record.
@end defun


@defun struct-stat->record @var{pointer}
Given a pointer to a block of memory holding a foreign @code{struct
stat}, build and return a @class{struct-stat} record.  All the fields
that are not available in the foreign structure are set to zero.
@end defun

@c page
@node stat api
@section Interface functions


The following bindings manage file attributes inspection.
@glibcref{Reading Attributes, Reading Attributes}.


@deffn Function stat @var{pathname}
@deffnx Parameter stat-function
@deffnx Function primitive:stat @var{pathname}
@deffnx Function platform:stat @var{pathname-cstr} @var{pointer}
Return a @class{struct-stat} record filled with attributes of the file or
directory selected by the Scheme string or symbol @var{pathname}.
@end deffn


@deffn Function fstat @var{fd}
@deffnx Parameter fstat-function
@deffnx Function primitive:fstat @var{fd}
@deffnx Function platform:fstat @var{fd} @var{pointer}
Return a @class{struct-stat} record filled with attributes of the file or
directory selected by the file descriptor @var{fd}.
@end deffn


@deffn Function lstat @var{pathname}
@deffnx Parameter lstat-function
@deffnx Function primitive:lstat @var{pathname}
@deffnx Function platform:lstat @var{pathname-cstr} @var{pointer}
Return a @class{struct-stat} record filled with attributes of the
symbolic link selected by the Scheme string or symbol @var{pathname}.
@end deffn

@c page
@node stat type
@section Type inspection


The integer in the @code{mode} field of a @class{struct-stat} record can
be inspected with the following functions.  Unless otherwise specified,
the following bindings are exported by the @library{foreign posix stat}
library.


@defun file-is-directory? @var{fd/pathname}
@defunx file-is-character-special? @var{fd/pathname}
@defunx file-is-block-special? @var{fd/pathname}
@defunx file-is-regular? @var{fd/pathname}
@defunx file-is-fifo? @var{fd/pathname}
@defunx file-is-socket? @var{fd/pathname}
Return @true{} if @var{fd/pathname} is associated to a file of the named
type, @false{} otherwise.  @var{fd/pathname} can be a file descriptor or
a Scheme string or symbol representing a pathname.  The @code{mode}
field of @code{struct stat} is acquired with a call to @func{fstat} or
@func{stat}.

@quotation
@strong{NOTE} There is no way to distinguish between an integer
representing a file descriptor and an integer representing the
@code{mode} field, so the argument to these functions @strong{cannot} be
a mode field.
@end quotation
@end defun


@defun file-is-symbolic-link? @var{pathname}
Return @true{} if @var{pathname} is associated to a symbolic link,
@false{} otherwise.  @var{pathname} must be a Scheme string or symbol
representing a pathname.  The @code{mode} field of @code{struct stat} is
acquired with a call to @func{lstat}.
@end defun


@defun file-is-message-queue? @var{fd/pathname}
@defunx file-is-semaphore? @var{fd/pathname}
@defunx file-is-shared-memory? @var{fd/pathname}
Return @true{} if @var{fd/pathname} is associated to a file of the named
type, @false{} otherwise.  @var{fd/pathname} can be a file descriptor or
a Scheme string or symbol representing a pathname.

Unfortunately, these predicates require access to the full @code{struct
stat}, so, at present, they are implemented with the low--level
@func{platform:stat} and @func{platform:fstat}.  This prevents using
parameterised functions like @func{stat} and @func{fstat}.
@end defun

@c ------------------------------------------------------------

@subsubheading Low--level predicates

The following bindings are exported by the libraries:

@example
(foreign posix stat)
(foreign posix stat primitives)
(foreign posix stat platform)
@end example


@defun S_ISDIR @var{mode}
@defunx S_ISCHR @var{mode}
@defunx S_ISBLK @var{mode}
@defunx S_ISREG @var{mode}
@defunx S_ISFIFO @var{mode}
@defunx S_ISLNK @var{mode}
@defunx S_ISSOCK @var{mode}
Return non--zero if the file or directory associated with the integer
@var{mode} is of the named type, otherwise return zero.
@end defun


@defun S_TYPEISMQ @var{pointer}
@defunx S_TYPEISSEM @var{pointer}
@defunx S_TYPEISSHM @var{pointer}
Return non--zero if the file or directory associated with the
@code{struct stat} referenced by @var{pointer} is of the named type,
otherwise return zero.
@end defun

@c page
@node stat perms
@section Access permissions inspection


Access permissions can be inspected with a bitwise combination between
the @code{mode} field of @code{struct stat} and the permissions
constants, @ref{fd constants perms}.  For example, the following
evaluates to @false{} if @file{/bin/ls} is readable by its owner:

@example
(= 0 (bitwise-and S_IRUSR
                  (<struct-stat>-mode (stat "/bin/ls"))))
@end example

@noindent
while the following evaluates to @false{} if @file{/bin/ls} is readable
both by its owner and group:

@example
(= 0 (bitwise-and (bitwise-ior S_IRUSR S_IRGRP)
                  (<struct-stat>-mode (stat "/bin/ls"))))
@end example

The following bindings are exported by the @library{foreign posix stat}
library.


@defun file-user-readable? @var{fd/pathname}
@defunx file-user-writable? @var{fd/pathname}
@defunx file-user-executable? @var{fd/pathname}
@defunx file-group-readable? @var{fd/pathname}
@defunx file-group-writable? @var{fd/pathname}
@defunx file-group-executable? @var{fd/pathname}
@defunx file-other-readable? @var{fd/pathname}
@defunx file-other-writable? @var{fd/pathname}
@defunx file-other-executable? @var{fd/pathname}
@defunx file-setuid? @var{fd/pathname}
@defunx file-setgid? @var{fd/pathname}
@defunx file-sticky? @var{fd/pathname}
Return @true{} if the named permission bit is set, @false{} otherwise.
@var{fd/pathname} can a file descriptor or a Scheme string or symbol
representing a pathname.  The @code{mode} field of @code{struct stat} is
acquired with a call to @func{fstat} or @func{stat}.
@end defun


@defun lfile-user-readable? @var{pathname}
@defunx lfile-user-writable? @var{pathname}
@defunx lfile-user-executable? @var{pathname}
@defunx lfile-group-readable? @var{pathname}
@defunx lfile-group-writable? @var{pathname}
@defunx lfile-group-executable? @var{pathname}
@defunx lfile-other-readable? @var{pathname}
@defunx lfile-other-writable? @var{pathname}
@defunx lfile-other-executable? @var{pathname}
@defunx lfile-setuid? @var{pathname}
@defunx lfile-setgid? @var{pathname}
@defunx lfile-sticky? @var{pathname}
Return @true{} if the named permission bit is set, @false{} otherwise.
@var{pathname} must be a Scheme string or symbol representing a
pathname.  The the @code{mode} field of @code{struct stat} is acquired
with @func{lstat}.
@end defun


@defun file-permissions @var{fd/pathname}
@defunx lfile-permissions @var{pathname}
Return an exact integer representing the access permissions bits from
the @code{mode} field of a @code{struct stat}.

For @func{file-permissions}: @var{fd/pathname} can be a file descriptor
or a pathname in the form of a Scheme string or symbol; the mode is
acquired with a call to @func{fstat} or @func{stat}.

For @func{lfile-permissions}: @var{pathname} must be a pathname in the
form of a Scheme string or symbol; the mode is acquired with a call to
@func{lstat}.

The returned value can be examined and manipulated using the @code{S_*}
constants (@pxref{fd constants perms}) and also used as argument for a
call to @func{chmod} or @func{fchmod}.
@end defun

@c page
@node time
@chapter Date and time


Unless otherwise specified, the bindings documented in this chapter are
exported by the following libraries:

@example
(foreign posix time)
(foreign posix time primitives)
(foreign posix time platform)
(foreign glibc time)
(foreign glibc time primitives)
(foreign glibc time platform)
@end example

@noindent
full support for the time functions requires loading the
@file{libnausicaa-posix.so} library.

@menu
* time structs::                Data structures.
* time clock::                  Processor time.
* time calendar::               Simple calendar time.
* time hires::                  High resolution calendar.
* time broken::                 Broken--down time.
@end menu

@c page
@node time structs
@section Data structures


The bindings documented in this section are exported by the
@library{foreign posix sizeof} library.


@defvr Constant sizeof-struct-timeval
@defvrx Constant alignof-struct-timeval
@defvrx Constant strideof-struct-timeval
These are: the number of bytes required to hold a @code{struct timeval};
the alignment of this structure when embedded into another structure;
the number of bytes between two elements in an array of these
structures.
@end defvr


@deffn Syntax struct-timeval-tv_sec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timeval-tv_sec-ref @var{pointer} @var{value}
@deffnx Syntax struct-timeval-tv_usec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timeval-tv_usec-ref @var{pointer} @var{value}
Peekers and pokers for the fields of a @code{struct timeval}.
@end deffn


@defvr Constant sizeof-struct-timespec
@defvrx Constant alignof-struct-timespec
@defvrx Constant strideof-struct-timespec
These are: the number of bytes required to hold a @code{struct timespec};
the alignment of this structure when embedded into another structure;
the number of bytes between two elements in an array of these
structures.
@end defvr


@deffn Syntax struct-timespec-tv_sec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timespec-tv_sec-ref @var{pointer} @var{value}
@deffnx Syntax struct-timespec-tv_nsec-set! @var{pointer} @var{value}
@deffnx Syntax struct-timespec-tv_nsec-ref @var{pointer} @var{value}
Peekers and pokers for the fields of a @code{struct timespec}.
@end deffn

@c page
@node time clock
@section Processor time


The following bindings are exported by the following libraries:

@example
(foreign posix time)
(foreign posix time primitives)
(foreign posix time platform)
@end example

@noindent
@glibcref{CPU Time, CPU Time Inquiry}.  @glibcref{Processor Time,
Processor Time Inquiry}.


@defvr Constant CLOCKS_PER_SEC
The number of clock ticks per second measured by the @func{clock}
function.  This binding is exported by the @library{foreign posix
sizeof} library.
@end defvr


@deffn Function clock
@deffnx Parameter clock-function
@deffnx Function primitive:clock
@deffnx Function platform:clock
Return the calling process' current @cpu{} time, converted to a native
@code{double} number.
@end deffn


@deffn Function times
@deffnx Parameter times-function
@deffnx Function primitive:times
@deffnx Function platform:times @var{pointer}
Store the processor time informations into a record of type
@code{struct-tms} and return 2 values: the calling process @cpu{} time
converted to a @code{double} number, the @code{struct-tms} record.

@func{platform:times} is an interface to to a foreign function that
wraps the platform @cfunc{times} function.  It accepts as argument a
pointer to an array of 4 @code{double} elements which are filled with
the fields of a @code{struct tms} with the following mapping:

@multitable {array element} {struct field}
@headitem array element @tab struct field
@item 0 @tab tms_utime
@item 1 @tab tms_ctime
@item 2 @tab tms_sutime
@item 3 @tab tms_sctime
@end multitable

Like all the platform functions, @func{platform:times} returns 2 values:
the return value of the foreing function normalised to a floating point
value, the value of @code{errno} right after the function call.
@end deffn


@deffn {Record Type} struct-tms
A Scheme record used to hold normalised results of @func{times}
invocations.  It has a field for each field of @code{struct tms}.
@end deffn


@defun make-struct-tms @var{utime} @var{stime} @var{cutime} @var{cstime}
Build and return a new @code{struct-tms} record.
@end defun


@defun struct-tms-tms_utime-ref @var{tms-record}
@defunx struct-tms-tms_stime-ref @var{tms-record}
@defunx struct-tms-tms_cutime-ref @var{tms-record}
@defunx struct-tms-tms_cstime-ref @var{tms-record}
Getters for the fields of @code{struct-tms} records.  All the returned
values are floating point numbers.
@end defun

@c page
@node time calendar
@section Simple calendar time


The following bindings are exported by the following libraries:

@example
(foreign posix time)
(foreign posix time primitives)
(foreign posix time platform)
@end example


@deffn Function time
@deffnx Parameter time-function
@deffnx Function primitive:time
@deffnx Function platform:time @var{pointer}
Return the current calendar time as an integer value.  It is the
``epoch'', the number of seconds elapsed since 00:00:00 on January 1,
1970, Coordinated Universal Time.
@end deffn


@deffn Function stime @var{calendar-time}
@deffnx Parameter stime-function
@deffnx Function primitive:stime @var{calendar-time}
@deffnx Function platform:stime @var{pointer}
Set the system clock using a calendar time specification.  Superuser
privileges are needed to successfully call this function.
@end deffn

@c page
@node time hires
@section High resolution calendar


The following bindings are exported by the following libraries:

@example
(foreign glibc time)
(foreign glibc time primitives)
(foreign glibc time platform)
@end example

@noindent
while the bindings required to use a @code{struct timeval} are exported
by the @library{posix sizeof} library.


@defvar sizeof-struct-timezone
@defvarx alignof-struct-timezone
@defvarx strideof-struct-timezone
Size, alignment and array stride for the @code{struct timezone} type.
These bindings are exported by @library{glibc sizeof}.
@end defvar


@deffn Syntax struct-timezone-tz_minuteswest-set! @var{pointer} @var{value}
@deffnx Syntax struct-timezone-tz_minuteswest-ref @var{pointer}
@deffnx Syntax struct-timezone-tz_dsttime-set! @var{pointer} @var{value}
@deffnx Syntax struct-timezone-tz_dsttime-ref @var{pointer}
Peekers and pokers for the fields of a @code{struct timezone}.  These
bindings are exported by @library{glibc sizeof}.
@end deffn


@deffn Function gettimeofday @var{timeval} @var{timezone}
@deffnx Parameter gettimeofday-function
@deffnx Function primitive:gettimeofday @var{timeval} @var{timezone}
@deffnx Function platform:gettimeofday @var{timeval} @var{timezone}
Fill the @code{struct timeval} and @code{struct timezone} referenced by
the @var{timeval} and @var{timezone} pointers with the current calendar
time.
@end deffn


@deffn Function settimeofday @var{timeval} @var{timezone}
@deffnx Function settimeofday @var{timeval} @var{timezone}
@deffnx Parameter primitive:settimeofday-function
@deffnx Function platform:settimeofday @var{timeval} @var{timezone}
Set the system clock to the calendar time specified by the @code{struct
timeval} and @code{struct timezone} referenced by the @var{timeval} and
@var{timezone} pointers.

Super user privileges are needed to successfully call this function.
@end deffn


@deffn Function adjtime @var{timeval-delta} @var{timeval-old-delta}
@deffnx Parameter adjtime-function
@deffnx Function primitive:adjtime @var{timeval-delta} @var{timeval-old-delta}
@deffnx Function platform:adjtime @var{timeval-delta} @var{timeval-old-delta}
Speed up or slow down the system clock in order to make a gradual
adjustment.

Super user privileges are needed to successfully call this function.
@end deffn

@c page
@node time broken
@section Broken--down time


The following bindings are exported by the following libraries:

@example
(foreign glibc time)
(foreign glibc time primitives)
(foreign glibc time platform)
@end example

@noindent
The broken--down time @api{} described here is not in the
@library{foreign posix ---} hierarchy of libraries because the
@code{time_t} value is in general not fully specified (according to the
@gnu{} C Library documentation), but it is in the @gnu{} C Library.


@defvar sizeof-struct-tm
@defvarx alignof-struct-tm
@defvarx strideof-struct-tm
Size, alignment and array stride for the @code{struct tm} type.

These bindings are exported by the @library{glibc sizeof} library.
@end defvar


@deffn Syntax struct-tm-tm_sec-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_sec-ref @var{pointer}
@deffnx Syntax struct-tm-tm_min-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_min-ref @var{pointer}
@deffnx Syntax struct-tm-tm_hour-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_hour-ref @var{pointer}
@deffnx Syntax struct-tm-tm_mday-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_mday-ref @var{pointer}
@deffnx Syntax struct-tm-tm_mon-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_mon-ref @var{pointer}
@deffnx Syntax struct-tm-tm_year-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_year-ref @var{pointer}
@deffnx Syntax struct-tm-tm_wday-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_wday-ref @var{pointer}
@deffnx Syntax struct-tm-tm_yday-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_yday-ref @var{pointer}
@deffnx Syntax struct-tm-tm_isdst-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_isdst-ref @var{pointer}
@deffnx Syntax struct-tm-tm_gmtoff-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_gmtoff-ref @var{pointer}
@deffnx Syntax struct-tm-tm_zone-set! @var{pointer} @var{value}
@deffnx Syntax struct-tm-tm_zone-ref @var{pointer}
Peekers and pokers for the @code{struct tm} type.

These bindings are exported by the @library{glibc sizeof} library.
@end deffn


@deffn Function localtime @var{time} @var{tm}
@deffnx Parameter localtime-function
@deffnx Function primitive:localtime @var{time} @var{tm}
@deffnx Function platform:localtime @var{time} @var{tm}
Despite the name, this is a wrapper for the @cfunc{localtime_r}
function.  Fill the @code{struct tm} referenced by the @var{tm} pointer
with broken down values from the calendar @var{time} (which can be the
return value of @func{time}).

For example, to get the current year:

@example
(define (gimme-year)
  (with-compensations
    (let ((*tm (malloc-block/c sizeof-struct-tm)))
      (localtime (time) *tm)
      (+ 1900 (struct-tm-tm_year-ref *tm)))))
@end example
@end deffn


@deffn Function gmtime @var{time} @var{tm}
@deffnx Parameter gmtime-function
@deffnx Function primitive:gmtime @var{time} @var{tm}
@deffnx Function platform:gmtime @var{time} @var{tm}
Like @func{localtime} but converts the given time as Coordinated
Universal Time (@acronym{UTC}).
@end deffn


@deffn Function timelocal @var{tm}
@deffnx Parameter timelocal-function
@deffnx Function primitive:timelocal @var{tm}
@deffnx Function platform:timelocal @var{tm}
Return a calendar time value from the @code{struct tm} referenced by the
@code{tm} pointer.  It is the inverse of @func{localtime}.
@end deffn


@deffn Function mktime @var{tm}
@deffnx Parameter mktime-function
@deffnx Function primitive:mktime @var{tm}
@deffnx Function platform:mktime @var{tm}
Aliases for @func{timelocal}.
@end deffn


@deffn Function timegm @var{tm}
@deffnx Parameter timegm-function
@deffnx Function primitive:timegm @var{tm}
@deffnx Function platform:timegm @var{tm}
Return a calendar time value from the @code{struct tm} referenced by the
@code{tm} pointer.  It is the inverse of @func{gmtime}.
@end deffn

@c page
@node fd
@chapter File descriptors


Unless otherwise specified, the bindings described in this chapter are
exported by the following libraries:

@example
(foreign posix fd)
(foreign posix fd primitives)
(foreign posix fd platform)
@end example

File descriptor arguments and return values are handled at the Scheme
level as exact integers.

@menu
* fd constants::                Bindings for constant values.
* fd open close::               Opening and closing.
* fd read write::               Reading and writing.
* fd seek::                     Setting the file position.
* fd sync::                     Synchronisation.
* fd control::                  Control operations.
* fd dup::                      Duplicating file descriptors.
* fd lock::                     File locks.
* fd pipe::                     Pipes and FIFOs.
* fd custom::                   Custom Scheme ports.
@end menu

@c page
@node fd constants
@section Bindings for constant values


@menu
* fd constants status::         File status flags.
* fd constants perms::          Permissions.
* fd constants control::        File control flags.
* fd constants seek::           File positions.
* fd constants lock::           Locking.
@end menu

@c page
@node fd constants status
@subsection File status flags


All the following bindings are exported by the @library{foreign posix
sizeof} library.  If a value is not defined on the underlying platform:
The corresponding binding is to @false{}.  @glibcref{File Status Flags,
File Status Flags}.


@defvr Constant O_RDONLY
@defvrx Constant O_WRONLY
@defvrx Constant O_RDWR
File access modes to be used with @func{open}.
@end defvr


@defvr Constant O_EXEC
@defvrx Constant O_READ
@defvrx Constant O_WRITE
These are @gnu{} only values.  @code{O_EXEC} is used with @func{open} to
open a file for execution.  @code{O_READ} and @code{O_WRITE} are like
@code{O_RDONLY} and @code{O_WRONLY}.
@end defvr


@defvr Constant O_ACCMODE
To be used with @func{fcntl} to query the open access mode of file
descriptors.
@end defvr


@defvr Constant O_CREAT
@defvrx Constant O_EXCL
@defvrx Constant O_APPEND
@defvrx Constant O_NONBLOCK
@defvrx Constant O_NOCTTY
Open--time flags to be used with @func{open}.
@end defvr


@defvr Constant O_NDELAY
@acronym{BSD} only alias for @code{O_NONBLOCK}.
@end defvr


@defvr Constant O_IGNORE_CTTY
@defvrx Constant O_NOLINK
@defvrx Constant O_NOTRANS
@gnu{} only file name translation flags to be used with @func{open}.
@end defvr


@defvr Constant O_TRUNC
Open--time action flags to be used with @func{open}.
@end defvr


@defvr Constant O_SHLOCK
@defvrx Constant O_EXLOCK
@acronym{BSD} only flags to be used with @func{open}.
@end defvr


@defvr Constant O_ASYNC
@defvrx Constant O_FSYNC
@defvrx Constant O_SYNC
@acronym{BSD} only flags to be used with @func{open}.
@end defvr


@defvr Constant O_NOATIME
@gnu{} only flag to be used with @func{open}.
@end defvr

@c page
@node fd constants perms
@subsection Permissions


All the following bindings are exported by the @library{foreign posix
sizeof} library.  @glibcref{Permission Bits, The mode bits for access
permission}.


@defvr Constant S_IRUSR
@defvrx Constant S_IWUSR
@defvrx Constant S_IXUSR
Permissions bits for file owner access.
@end defvr

@defvr Constant S_IRGRP
@defvrx Constant S_IWGRP
@defvrx Constant S_IXGRP
Permissions bits for group access.
@end defvr

@defvr Constant S_IROTH
@defvrx Constant S_IWOTH
@defvrx Constant S_IXOTH
Permissions bits for other users access.
@end defvr

@defvr Constant S_IRWXU
This is the bitwise combination of permissions bits for user access; it
could be defined as:

@example
(define S_IRWXU
  (bitwise-ior S_IRUSR S_IWUSR S_IXUSR))
@end example
@end defvr


@defvr Constant S_IRWXG
This is the bitwise combination of permissions bits for group access.
It could be defined as:

@example
(define S_IRWXG
  (bitwise-ior S_IRGRP S_IWGRP S_IXGRP))
@end example
@end defvr


@defvr Constant S_IRWXO
This is the bitwise combination of permissions bits for other users
access.  It could be defined as:

@example
(define S_IRWXO
  (bitwise-ior S_IROTH S_IWOTH S_IXOTH))
@end example
@end defvr


@defvr Constant S_ISUID
@defvrx Constant S_ISGID
@defvrx Constant S_ISVTX
These are the setuid, setgid and ``sticky bit'' values.
@end defvr

@c page
@node fd constants control
@subsection File control flags


All the following bindings are exported by the @library{foreign posix
sizeof} library; the values are meant to be used as @var{operation}
argument in call to @func{fcntl}.


@defvr Constant F_GETFL
@defvrx Constant F_SETFL
Set/get the status of a file.  @glibcref{Getting File Status Flags,
Getting and Setting File Status Flags}.
@end defvr


@defvr Constant F_DUPFD
Duplicate the file descriptor.  @glibcref{Duplicating Descriptors,
Duplicating Descriptors}.
@end defvr


@defvr Constant F_GETFD
@defvrx Constant F_SETFD
Set/get the status of a file descriptor.  @glibcref{Descriptor Flags,
File Descriptor Flags}.
@end defvr


@defvr Constant FD_CLOEXEC
State that the file descriptor has to be closed if an @cfunc{exec} is
performed.  @glibcref{Descriptor Flags, File Descriptor Flags}.
@end defvr


@defvr Constant F_SETLK
@defvrx Constant F_GETLK
@defvrx Constant F_SETLKW
Set/get a file lock.  @code{F_SETLKW} sets a file lock, but waits for
completion.  @glibcref{File Locks, File Locks}.
@end defvr


@defvr Constant F_GETOWN
@defvrx Constant F_SETOWN
Set/get process to receive @code{SIGIO} signals.  @glibcref{Interrupt
Output, Interrupt--Driven Output}.
@end defvr

@c page
@node fd constants seek
@subsection File positions


All the following bindings are exported by the @library{foreign posix
sizeof} library.  @glibcref{File Position Primitive, Setting the File
Position of a Descriptor}.


@defvr Constant SEEK_SET
@defvrx Constant SEEK_CUR
@defvrx Constant SEEK_END
File positions for the @var{whence} argument to @func{lseek}.
@end defvr

@c page
@node fd constants lock
@subsection Locking


All the following bindings are exported by the @library{foreign posix
sizeof} library.  @glibcref{File Locks, File Locks}.


@defvr Constant F_RDLCK
@defvrx Constant F_WRLCK
@defvrx Constant F_UNLCK
Flags for file descriptor locking.
@end defvr

@c page
@node fd open close
@section Opening and closing


The following functions manage opening and closing file descriptors.
@glibcref{Opening and Closing Files, Opening and Closing Files}.

Example:

@example
(letrec
    ((fd (compensate
             (open "/tmp/marco/name.ext"
                   (bitwise-ior O_CREAT O_EXCL O_WRONLY)
                   #o640)
           (with
            (close fd)))))
  ---)
@end example

@noindent
with symbolic permissions bits (more portable):

@example
(letrec
    ((fd (compensate
             (open "/tmp/marco/name.ext"
                   (bitwise-ior O_CREAT O_EXCL O_WRONLY)
                   (bitwise-ior S_IRUSR S_IWUSR S_IRGRP)))
           (with
            (close fd))))
  ---)
@end example

@float Table
@multitable {#o755} {user perms} {group perms} {other perms}
@headitem mode @tab user perms @tab group perms @tab other perms
@item @code{#o640}
@tab @code{rw-}
@tab @code{r--}
@tab @code{---}
@item @code{#o400}
@tab @code{r--}
@tab @code{---}
@tab @code{---}
@item @code{#o644}
@tab @code{rw-}
@tab @code{r--}
@tab @code{r--}
@item @code{#o755}
@tab @code{rwx}
@tab @code{r-x}
@tab @code{r-x}
@end multitable
@caption{Octal number examples of the most common values, where:
@code{r} stands for readable, @code{w} for writable, @code{x} for
executable.}
@end float

@float Table
@multitable {digit} {mode} {digit} {mode}
@headitem digit @tab mode @tab digit @tab mode
@item 0 @tab @code{---} @tab 4 @tab @code{r--}
@item 1 @tab @code{--x} @tab 5 @tab @code{r-x}
@item 2 @tab @code{-w-} @tab 6 @tab @code{rw-}
@item 3 @tab @code{-wx} @tab 7 @tab @code{rwx}
@end multitable
@caption{The octal digits.}
@end float


@deffn Function open @var{pathname} @var{open-mode} @var{permissions}
@deffnx Parameter open-function
@deffnx Function primitive:open @var{pathname} @var{open-mode} @var{permissions}
@deffnx Function platform:open @var{pathname} @var{open-mode} @var{permissions}
Open with @var{open-mode} the file selected by @var{pathname} and return
a file descriptor.  If the file is created, it is created with
access @var{permissions}.

@var{pathname} must be a Scheme string or symbol representing a file
pathname.

@var{open-mode} must be an exact integer, and it can be built with
@func{bitwise-ior} from the following constants: one among
@code{O_RDWR}, @code{O_RDONLY} and @code{O_WRONLY} and optionally
@code{O_TRUNC}, @code{O_EXCL}, @code{O_NONBLOCK}.

@var{permissions} must be an exact integer and it is better given as an
octal number or a bitwise combination of constants (@pxref{fd constants
perms}).  It can be zero if we are not interested in creating a new
file.
@end deffn


@deffn Function close @var{fd}
@deffnx Parameter close-function
@deffnx Function primitive:close @var{fd}
@deffnx Function platform:close @var{fd}
Close the file descriptor @var{fd}.
@end deffn

@c page
@node fd read write
@section Reading and writing


The following functions manage reading and writing with file
descriptors.  @glibcref{I/O Primitives,Input and Output Primitives}

The bindings @func{read} and @func{write} defined below have the same
names of the @func{read} and @func{write} defined by @rnrs{6}.  So when
importing the @library{foreign posix fd ---} libraries, we have to make
use of some augmented import specification.  For example the following
avoids importing the @rnrs{6} procedures:

@example
(import (except (rnrs) read write)
  (foreign posix fd))
@end example

@noindent
and the following prefixes with @samp{posix:} all the bindings from
@library{foreign posix fd}:

@example
(import (rnrs)
  (prefix (foreign posix fd) posix:))
@end example

@c ------------------------------------------------------------

@subsubheading Reading


@deffn Function read @var{fd} @var{pointer} @var{buffer-size}
@deffnx Parameter read-function
@deffnx Function primitive:read @var{fd} @var{pointer} @var{buffer-size}
@deffnx Function platform:read @var{fd} @var{pointer} @var{buffer-size}
Read at most @var{buffer-size} bytes from @var{fd}, starting at the
current file position, and store them in the buffer referenced by
@var{pointer}.  The file position is advanced.  Return the number of
bytes actually read.
@end deffn


@deffn Function pread @var{fd} @var{pointer} @var{buffer-size} @var{offset}
@deffnx Parameter pread-function
@deffnx Function primitive:pread @var{fd} @var{pointer} @var{buffer-size} @var{offset}
@deffnx Function platform:pread @var{fd} @var{pointer} @var{buffer-size} @var{offset}
Read at most @var{buffer-size} bytes from @var{fd}, starting at
@var{offset} from the beginning of the file, and store them in the
buffer referenced by @var{pointer}.  The file position is left
untouched.  Return the number of bytes actually read.
@end deffn

@c ------------------------------------------------------------

@subsubheading Writing


@deffn Function write @var{fd} @var{pointer} @var{buffer-size}
@deffnx Parameter write-function
@deffnx Function primitive:write @var{fd} @var{pointer} @var{buffer-size}
@deffnx Function platform:write @var{fd} @var{pointer} @var{buffer-size}
Write to @var{fd}, starting at the current file position, at most
@var{buffer-size} bytes from the buffer referenced by @var{pointer}.
The file position is advanced.  Return the number of bytes actually
written.
@end deffn


@deffn Function pwrite @var{fd} @var{pointer} @var{buffer-size} @var{offset}
@deffnx Parameter pwrite-function
@deffnx Function primitive:pwrite @var{fd} @var{pointer} @var{buffer-size} @var{offset}
@deffnx Function platform:pwrite @var{fd} @var{pointer} @var{buffer-size} @var{offset}
Write to @var{fd}, starting at @var{offset} from the beginning of the
file, at most @var{buffer-size} bytes from the buffer referenced by
@var{pointer}.  The file position is left untouched.  Return the number
of bytes actually written.
@end deffn

@c page
@node fd seek
@section Setting the file position


The following functions manage adjusting the current position with file
descriptors.  @glibcref{File Position Primitive, Setting the File
Position of a Descriptor}.


@deffn Function lseek @var{fd} @var{offset} @var{whence}
@deffnx Paramter primitive:lseek-function
@deffnx Function primitive:lseek @var{fd} @var{offset} @var{whence}
@deffnx Function platform:lseek @var{fd} @var{offset} @var{whence}
Move the file position of @var{fd} at @var{offset} from the position
selected with @var{whence}, which must be a value among @code{SEEK_SET},
@code{SEEK_CUR}, @code{SEEK_END} (@pxref{fd constants seek}).  Return
the number of bytes from the beginning of the file to the selected file
position.

@quotation
@strong{NOTE} It seems that @cfunc{lseek} cannot be interrupted by
@code{EINTR}.
@end quotation
@end deffn


We can use the return value to acquire the current file position with:

@example
(lseek fd 0 SEEK_CUR)
@end example

@noindent
which will leave the file position unchanged.  We can determine the file
size with:

@example
(define (file-size-from-descriptor fd)
  (with-compensations
    (letrec ((pos (compensate
                      (lseek fd 0 SEEK_CUR)
                    (with
                     (lseek fd pos SEEK_SET)))))
       (lseek fd 0 SEEK_END))))
@end example

@c page
@node fd sync
@section Synchronisation


The following functions manage synchronisation between the state of a
file descriptor and the underlying device.  @glibcref{Synchronizing I/O,
Synchronizing I/O}.


@deffn Function sync
@deffnx Parameter sync-function
@deffnx Function primitive:sync
@deffnx Function platform:sync
Synchronise data for all the file descriptors with the underlying
devices.  Does not return until the operation is terminated.
@end deffn


@deffn Function fsync @var{fd}
@deffnx Parameter fsync-function
@deffnx Function primitive:fsync @var{fd}
@deffnx Function platform:fsync @var{fd}
Synchronise data for @var{fd} with the underlying device.
@end deffn


@deffn Function fdatasync @var{fd}
@deffnx Parameter fdatasync-function
@deffnx Function primitive:fdatasync @var{fd}
@deffnx Function platform:fdatasync @var{fd}
Flushes the output buffer of @var{fd} to the underlying device.  This
function does not synchronise the file meta data (like the access time).
@end deffn

@c page
@node fd control
@section Control operations


The following functions manage miscellaneous control operation on a file
descriptor.  @glibcref{Control Operations, Control Operations on Files}.
@glibcref{IOCTLs, I/O Control Operations}.


@deffn Function fcntl @var{fd} @var{operation} @var{arg}
@deffnx Parameter fcntl-function
@deffnx Function primitive:fcntl @var{fd} @var{operation} @var{arg}
@deffnx Function platform:fcntl @var{fd} @var{operation} @var{arg}
Perform @var{operation} on @var{fd} using @var{arg}.  @var{operation}
and @var{arg} must be exact integers.  @ref{fd constants control} for
the list of the supported operations.

@func{primitive:fcntl} assumes that: If the return value of
@func{platform:fcntl} is @code{-1}, an error occurred.

@quotation
@strong{NOTE} If @var{arg} has to be a pointer (like when requesting a
lock on the file), we have to use @func{pointer->integer} to convert the
pointer value to an integer; example:

@example
(fcntl fd F_SETLK (pointer->integer lock-struct))
@end example

@noindent
this is a temporary requirement; it will be fixed in a future version of
the package by providing an alternative @func{fnctl} interface.
@end quotation
@end deffn


@deffn Function ioctl @var{fd} @var{operation} @var{arg}
@deffnx Parameter ioctl-function
@deffnx Function primitive:ioctl @var{fd} @var{operation} @var{arg}
@deffnx Function platform:ioctl @var{fd} @var{operation} @var{arg}
Perform @var{operation} on @var{fd} using @var{arg}.  @var{operation}
and @var{arg} must be exact integers.  @ref{fd constants control} for
the list of the supported operations.

@func{primitive:ioctl} assumes that: If the return value of
@func{platform:ioctl} is @code{-1}, an error occurred.
@end deffn

@c page
@node fd dup
@section Duplicating file descriptors


The following functions manage duplication of file descriptors.
@glibcref{Duplicating Descriptors,Duplicating Descriptors}.


@deffn Function dup @var{fd}
@deffnx Parameter dup-function
@deffnx Function primitive:dup @var{fd}
@deffnx Function platform:dup @var{fd}
Duplicate @var{fd}, return the new file descriptor.
@end deffn


@deffn Function dup2 @var{old-fd} @var{new-fd}
@deffnx Parameter dup2-function
@deffnx Function primitive:dup2 @var{old-fd} @var{new-fd}
@deffnx Function platform:dup2 @var{old-fd} @var{new-fd}
Copy @var{old-fd} to @var{new-fd}.
@end deffn

@c page
@node fd lock
@section File locks


Locking is performed by @func{fcntl} with the @code{F_GETLK},
@code{F_SETLK} and @code{F_SETLKW} operations.  When locking, the third
argument to @func{fcntl} must be a pointer to a structure of type
@code{struct flock}.  @glibcref{File Locks,File Locks}.

The following bindings are exported by the @library{foreign posix
sizeof} library.


@defvr Constant sizeof-struct-flock
@defvrx Constant alignof-struct-flock
@defvrx Constant strideof-struct-flock
These are: the number of bytes required to hold a structure of type
@code{struct flock}; the alignment of the structure when embedded in
another structure; the number of bytes between two elements in an array
of structures.
@end defvr



@deffn Syntax struct-flock-l_type-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_type-ref @var{pointer}
@deffnx Syntax struct-flock-l_whence-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_whence-ref @var{pointer}
@deffnx Syntax struct-flock-l_start-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_start-ref @var{pointer}
@deffnx Syntax struct-flock-l_len-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_len-ref @var{pointer}
@deffnx Syntax struct-flock-l_pid-set! @var{pointer} @var{value}
@deffnx Syntax struct-flock-l_pid-ref @var{pointer}
Peekers and pokers for the fields of a @code{struct flock}.
@end deffn


@example
(with-compensations
  (let* ((fd ---)
         (p  (malloc-block/c sizeof-struct-flock))
         (i  (pointer->integer p)))
    (fcntl fd F_SETLK i)
    ---
    (fcntl fd F_UNLCK i)))
@end example

@c page
@node fd pipe
@section Pipes and FIFOs


The following functions manage creation of pipes and @acronym{FIFO}s.
@glibcref{Creating a Pipe, Creating a Pipe}.  @glibcref{FIFO Special
Files, FIFO Special Files}.

This is a meaningless example of @acronym{FIFO} usage; we have to
remember that the binding forms in a @func{let} have no guaranteed
evaluation order, so if we need to open the two ports in a specified
order we have to use @func{let*}:

@example
(with-compensations
    (compensate
        (mkfifo pathname #o600)
      (with
       (delete-file pathname)))
  (let* ((in (open pathname
                   (bitwise-ior O_NONBLOCK O_RDONLY)
                   0))
         (ou (open pathname O_WRONLY 0)))
    (letrec ((inp (compensate
                      (fd->textual-input-port  in)
                    (with
                     (close-port inp))))
             (oup (compensate
                      (fd->textual-output-port ou)
                    (with
                     (close-port oup)))))
      (put-string oup "ciao\n")
      (flush-output-port oup)
      (get-string-n inp 5))))
@end example


@deffn Function pipe
@deffnx Parameter pipe-function
@deffnx Function primitive:pipe
@deffnx Function platform:pipe @var{pointer}
Open a pipe: A pair of file descriptors linked together.  Return two
values: the first is the reading file descriptor, the second is the
writing file descriptor.
@end deffn


@deffn Function mkfifo @var{pathname} @var{mode}
@deffnx Parameter mkfifo-function
@deffnx Function primitive:mkfifo mkfifo @var{pathname} @var{mode}
@deffnx Function platform:mkfifo @var{pathname-cstr} @var{mode}
Create a named pipe pseudofile: A special file that can be used for
interprocess communication.  The Scheme string or symbol @var{pathname}
selects the file pathname.  @var{mode} is a numeric access permissions
mode like the one used by @func{open}.
@end deffn

@c page
@node fd custom
@section Custom Scheme ports


The following bindings are exported by the @library{foreign posix fd}
library.


@defun fd->binary-input-port @var{fd}
@defunx fd->binary-output-port @var{fd}
@defunx fd->binary-input/output-port @var{fd}
@defunx fd->textual-input-port @var{fd}
@defunx fd->textual-output-port @var{fd}
@defunx fd->textual-input/output-port @var{fd}
Wrap the given file descriptor with a Scheme port; return the port.
Closing the Scheme port closes the file descriptor too.
@end defun


@defun pipe-binary-ports
@defunx pipe-textual-ports
Invoke @func{pipe} then wrap the file descriptors with Scheme ports.
Return 2 values: the reading port and the writing port.

Position handling (seeking) is @strong{not} implemented for pipe ports.
@end defun

@c ------------------------------------------------------------

@subsubheading Everyone should mind his own buffers


Unfortunately there are Scheme implementations that insist in
implementing buffering for custom ports.  One can say that they are
called ``custom'' to let the customers (that is us) decide how to handle
the underlying device, buffering included.  This is not the opinion of
some Scheme implementers.

So with some implementations we have to turn off buffering and turn on
non-blocking mode for the device.


@subsubheading Do it yourself


If we feel the need to implement our own wrappers, we may find useful to
know that a custom read function can be implemented like this:

@example
(define (custom-binary-read fd bv start count)
  (with-compensations
    (let* ((p   (malloc-block/c count))
           (len (read fd p count)))
      (do ((i 0 (+ 1 i)))
          ((= i len)
           len)
        (bytevector-u8-set! bv (+ start i)
                            (peek-unsigned-char p i))))))

(define (custom-textual-read fd str start count)
  (with-compensations
    (let* ((p   (malloc-block/c count))
           (len (read fd p count)))
      (do ((i 0 (+ 1 i)))
          ((= i len)
           len)
        (string-set! str (+ start i)
                     (integer->char (peek-unsigned-char p i)))))))
@end example

@noindent
and a custom write function can be implemented like this:

@example
(define (custom-binary-write fd bv start count)
  (with-compensations
    (let ((p (malloc-block/c count)))
      (do ((i 0 (+ 1 i)))
          ((= i count)
           (write fd p count))
        (poke-char! p i (bytevector-u8-ref bv (+ start i)))))))

(define (custom-textual-write fd str start count)
  (with-compensations
    (let ((p (malloc-block/c count)))
      (do ((i 0 (+ 1 i)))
          ((= i count)
           (write fd p count))
        (poke-char! p i
           (char->integer (string-ref str (+ start i))))))))
@end example

Then the following implementations are possible:

@example
(define (fd->binary-input-port fd)
  (make-custom-binary-input-port
   "fd input port"
   (lambda (bv start count)
     (custom-binary-read fd bv start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->binary-output-port fd)
  (make-custom-binary-output-port
   "fd output port"
   (lambda (bv start count)
     (custom-binary-write fd bv start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->binary-input/ouput-port fd)
  (make-custom-binary-input-port
   "fd input/output port"
   (lambda (bv start count)
     (custom-binary-read fd bv start count))
   (lambda (bv start count)
     (custom-binary-write fd bv start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->textual-input-port fd)
  (make-custom-textual-input-port
   "fd input port"
   (lambda (str start count)
     (custom-textual-read fd str start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->textual-output-port fd)
  (make-custom-textual-output-port
   "fd output port"
   (lambda (str start count)
     (custom-textual-write fd str start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (fd->textual-input/ouput-port fd)
  (make-custom-textual-input-port
   "fd input/output port"
   (lambda (str start count)
     (custom-textual-read fd str start count))
   (lambda (str start count)
     (custom-textual-write fd str start count))
   (lambda ()
     (lseek fd 0 SEEK_CUR))
   (lambda (pos)
     (lseek fd pos SEEK_SET))
   (lambda ()
     (close fd))))

(define (pipe-binary-ports)
  (let-values (((in ou) (pipe)))
    (values (make-custom-binary-input-port
             "fd pipe binary reading port"
             (lambda (bv start count)
               (custom-binary-read in bv start count))
             #f
             #f
             (lambda ()
               (close in)))
            (make-custom-binary-output-port
             "fd pipe binary writing port"
             (lambda (bv start count)
               (custom-binary-write ou bv start count))
             #f
             #f
             (lambda ()
               (close ou))))))

(define (pipe-textual-ports)
  (let-values (((in ou) (pipe)))
    (values (make-custom-textual-input-port
             "fd pipe textual reading port"
             (lambda (bv start count)
               (custom-textual-read in bv start count))
             #f
             #f
             (lambda ()
               (close in)))
            (make-custom-textual-output-port
             "fd pipe textual writing port"
             (lambda (bv start count)
               (custom-textual-write ou bv start count))
             #f
             #f
             (lambda ()
               (close ou))))))
@end example


@c page
@node process
@chapter Processes


Unless otherwise specified, the bindings described in this chapter are
exported by the following libraries:

@example
(foreign posix process)
(foreign posix process primitives)
(foreign posix process platform)
@end example

@menu
* process record::              Record types.
* process id::                  Process identification.
* process fork::                Creating a process.
* process exec::                Executing a file.
* process wait::                Process completion.
@end menu

@c page
@node process record
@section Record types


The following bindings are exported by the @library{foreign posix
process record-types} library.  @glibcref{Process Completion Status,
Process Completion Status}.


@deftp {Record Type Name} <process-term-status>
@deftpx {Record Type Descriptor} <process-term-status-rtd>
Record type describing the details of a process termination.  It has the
following fields:

@example
WIFEXITED               WEXITSTATUS
WIFSIGNALED             WTERMSIG
WCOREDUMP               WIFSTOPPED
WSTOPSIG
@end example
@end deftp


@defun make-<process-term-status> @var{WIFEXITED} @var{WEXITSTATUS} @var{WIFSIGNALED} @var{WTERMSIG} @var{WCOREDUMP} @var{WIFSTOPPED} @var{WSTOPSIG}
Build and return a new record of type @class{process-term-status}.
@end defun


@defun process-term-status->record @var{status}
Given the exact integer @var{status} representing a process' termination
status, build and return a record of type @class{process-term-status}.
@end defun


@defun WIFEXITED? @var{status-record}
@defunx WEXITSTATUS? @var{status-record}
@defunx WIFSIGNALED? @var{status-record}
@defunx WTERMSIG? @var{status-record}
@defunx WCOREDUMP? @var{status-record}
@defunx WIFSTOPPED? @var{status-record}
@defunx WSTOPSIG? @var{status-record}
Field accessors for records of type @class{process-term-status}.  The
values are all booleans.
@end defun

@c page
@node process id
@section Process identification


The following functions inspect the process identifier.
@glibcref{Process Identification, Process Identification}

@c @quotation
@c @strong{NOTE} It seems that the following functions cannot fail.
@c @end quotation


@deffn Function getpid
@deffnx Parameter getpid-function
@deffnx Function primitive:getpid
@deffnx Function platform:getpid
Return the process id of the current process.  This function cannot
fail, so @func{platform:getpid} returns a single value.
@end deffn


@deffn Function getppid
@deffnx Parameter getppid-function
@deffnx Functionx primitive:getppid
@deffnx Functionx platform:getppid
Return the process id of the parent process.  This function cannot fail,
so @func{platform:getppid} returns a single value.
@end deffn

@c page
@node process fork
@section Creating a process


The following functions manage process forking.  @glibcref{Creating a
Process, Creating a Process}.

@quotation
@strong{NOTE} Access to @cfunc{vfork} is not implemented because it is
impossible to know what the underlying Scheme implementation does.
@end quotation


@deffn Function fork
@deffnx Parameter fork-function
@deffnx Function primitive:fork
@deffnx Function platform:fork
Create a new process by forking the current one.  If successful
@func{fork} returns zero in the child process and the child process' id
in the parent process.
@end deffn

@c page
@node process exec
@section Executing a file


The following functions manage process forking.  @glibcref{Executing a
File, Executing a File}.


@deffn Function execv @var{pathname} @var{args}
@deffnx Parameter execv-function
@deffnx Function primitive:execv @var{pathname} @var{args}
@deffnx Function platform:execv @var{pathname-cstr} @var{argv}
Execute the file selected by the Scheme string or symbol @var{pathname}
using the list of Scheme strings or symbols @var{args} as command line
arguments.  By convention the first value of @var{args} must be the name
(with no directory pathname) of the executed process.  If successful a
new process is executed and these functions do not return.

Usage example:

@example
(when (= 0 (fork))
  (execv '/bin/ls '(ls "-l" /bin)))
@end example

@noindent
notice that command line options like @code{-l} have to be strings (not
symbols) to prevent a syntax error (because the first char @samp{-} is
reserved for numeric datums).
@end deffn


@deffn Function execve @var{pathname} @var{args} @var{envs}
@deffnx Parameter execve-function
@deffnx Function primitive:execve @var{pathname} @var{args} @var{envs}
@deffnx Function platform:execve @var{pathname-cstr} @var{argv} @var{envv}
Execute the file selected by the Scheme string or symbol @var{pathname}
using the list of Scheme strings or symbols @var{args} as command line
arguments.  By convention the first value of @var{args} must be the name
(with no directory part) of the executed process.

@var{envs} must be a list of Scheme strings or symbols used to set the
process execution environment.

If successful a new process is executed and these functions do not
return.

Usage example:

@example
(when (= 0 (fork))
  (execve '/usr/bin/du
          '(du /bin/ls)
          '("BLOCK_SIZE=human-readable")))
@end example

@noindent
notice that command line options like @code{-l} have to be strings (not
symbols) to prevent a syntax error (because the first char @samp{-} is
reserved for numeric datums).
@end deffn


@deffn Function execvp @var{pathname} @var{args}
@deffnx Parameter execvp-function
@deffnx Function primitive:execvp @var{pathname} @var{args}
@deffnx Function platform:execvp @var{pathname-str} @var{argv}
These functions are like the @func{execv} ones, except that
@var{pathname} can be the name of a file that is searched in the current
@env{PATH} search path.
@end deffn


@deffn Function system @var{command}
@deffnx Parameter system-function
@deffnx Function primitive:system @var{command}
@deffnx Function platform:system @var{command-cstr}
Run @var{command} using the system shell.
@end deffn

@c page
@node process wait
@section Process completion


@cindex @code{WNOHANG}
@cindex @code{WUNTRACED}
@cindex @code{WCONTINUED}

The following functions manage waiting for spawned processes.
@glibcref{Process Completion, Process Completion}.

The @var{options} argument can be zero or a @func{bitwise-ior} of
@code{WNOHANG}, @code{WUNTRACED} and @code{WCONTINUED} which are
exported by @library{foreign posix sizeof}.

The following @code{waitpid} functions return a process termination
status in the form of an exact integer.  Such integer can be analysed
with the functions described in @ref{process record, Record types}.


@deffn Parameter waitpid-function
@deffnx Function primitive:waitpid @var{pid} @var{options}
@deffnx Function platform:waitpid @var{pid} @var{pointer} @var{options}
Wait for a single process or a set of processes in a group.  For the
full documentation we have to refer to the documentation of the foreign
function @cfunc{waitpid}.
@end deffn


@defun waitpid @var{pid} @var{options}
A wrapper for the function in the @func{watipid-function} parameter that
tracks a specific child process.
@end defun


@defun waitpid/any @var{options}
A wrapper for the function in the @func{watipid-function} parameter that
tracks all the child processes.
@end defun


@defun waitpid/any-my-group @var{options}
A wrapper for the function in the @func{watipid-function} parameter that
tracks all the child processes in the same group of the caller.
@end defun


@defun waitpid/group @var{gpid} @var{options}
A wrapper for the function in the @func{watipid-function} parameter that
tracks all the child processes in the group with id @var{gpid}.
@end defun


@defun platform:WIFEXITED @var{status}
@defunx platform:WEXITSTATUS @var{status}
@defunx platform:WIFSIGNALED @var{status}
@defunx platform:WTERMSIG @var{status}
@defunx platform:WCOREDUMP @var{status}
@defunx platform:WIFSTOPPED @var{status}
@defunx platform:WSTOPSIG @var{status}
These are wrappers for the macros that extract a value from the
@var{status} integer returned by the waitpid functions.  They can be
used to query the status without building a record.
@end defun

@c page
@node job
@chapter Job control


Unless otherwise specified, the bindings described in this chapter are
exported by the following libraries:

@example
(foreign posix job)
(foreign posix job primitives)
(foreign posix job platform)
@end example

@menu
* job terminal::                Terminal identification.
* job group::                   Process group functions.
* job access::                  Terminal access.
@end menu

@c page
@node job terminal
@section Terminal identification


The following functions manage identification of the terminal of the
process.  @glibcref{Identifying the Terminal, Identifying the
Controlling Terminal}.


@deffn Function ctermid
@deffnx Parameter ctermid-function
@deffnx Function primitive:ctermid
@deffnx Function platform:ctermid @var{pointer}
Return a string representing the pathname of the controlling terminal
for this process.

@var{pointer} can be @func{pointer-null} or a pointer to a buffer of
@code{L_ctermid} bytes in which the foreign function will store the
terminal file pathname as a C string.  @code{L_ctermid} is exported by
@library{foreign posix sizeof}.
@end deffn

@c page
@node job group
@section Process group functions


The following functions manage process groups and sessions.
@glibcref{Process Group Functions, Process Group Functions}.


@deffn Function setsid
@deffnx Parameter setsid-function
@deffnx Function primitive:setsid
@deffnx Function platform:setsid
Create a new session and return an integer representing the new process
group id.
@end deffn


@deffn Function getsid @var{pid}
@deffnx Parameter getsid-function
@deffnx Function primitive:getsid @var{pid}
@deffnx Function platform:getsid @var{pid}
Return the group id of the session leader of the process with @var{pid}.
@end deffn


@deffn Function getpgrp
@deffnx Parameter getpgrp-function
@deffnx Function primitive:getpgrp
@deffnx Function platform:getpgrp
Return the process group id of the group to which the current process
belongs.
@end deffn


@deffn Function setpgid @var{pid} @var{pgid}
@deffnx Parameter setpgid-function
@deffnx Function primitive:setpgid @var{pid} @var{pgid}
@deffnx Function platform:setpgid @var{pid} @var{pgid}
Put the process @var{pid} in the group @var{pgid}.
@end deffn

@c page
@node job access
@section Terminal access


The following functions manage process access to the controlling
terminal.  @glibcref{Terminal Access Functions, Functions for
Controlling Terminal Access}.


@deffn Function tcgetpgrp @var{fd}
@deffnx Parameter tcgetpgrp-function
@deffnx Function primitive:tcgetpgrp @var{fd}
@deffnx Function platform:tcgetpgrp @var{fd}
Return the process group id of the foreground process group associated
with the terminal open on descriptor @var{fd}.
@end deffn


@deffn Function tcsetpgrp @var{fd} @var{pgid}
@deffnx Parameter tcsetpgrp-function
@deffnx Function primitive:tcsetpgrp @var{fd} @var{pgid}
@deffnx Function platform:tcsetpgrp @var{fd} @var{pgid}
Set a terminal's foreground process group id.
@end deffn


@deffn Function tcgetsid @var{fd}
@deffnx Parameter tcgetsid-function
@deffnx Function primitive:tcgetsid @var{fd}
@deffnx Function platform:tcgetsid @var{fd}
Return the process group id of the session for which the file descriptor
@var{fd} is the controlling terminal.
@end deffn

@c page
@node users
@chapter Users and groups


Unless otherwise specified, the bindings described in this chapter are
exported by the following libraries:

@example
(foreign posix users)
(foreign posix users primitives)
(foreign posix users platform)
@end example

@menu
* users persona::               Process' persona.
@end menu

@c page
@node users persona
@section Process' persona


@glibcref{Reading Persona, Reading the Persona of a Process}

@c page
@node strings
@chapter More C string functions


Unless otherwise specified, the functions described in this chapter are
exported by the following libraries:

@example
(foreign glibc cstrings platform)
@end example

@noindent
the purpose of this interface is to alloc some string processing without
conversion from C strings to Scheme strings.

@menu
* strings search::              Searching.
@end menu

@c page
@node strings search
@section Searching


@defun memchr @var{pointer} @var{byte} @var{size}
Finds the first occurrence of @var{byte} in the initial @var{size} bytes
starting at @var{pointer}.  Return a pointer to the located byte or a
null pointer if @var{uchar} was not found.
@end defun


@c page
@node streams
@chapter Stream functions


Unless otherwise specified, the bindings described in this chapter  are
exported by the following libraries:

@example
(foreign glibc streams)
(foreign glibc streams primitives)
(foreign glibc streams platform)
@end example

@menu
* streams constants::           Constants.
* streams errors::              Detecting errors on streams.
* streams open close::          Opening and closing.
* streams writing::             Writing to streams.
* streams reading::             Reading from streams.
* streams unreading::           Unreading to streams.
* streams seeking::             Stream positioning.
* streams fd::                  Streams and file descriptors.
* streams unlocked::            Unlocked stream operations.
* streams extended::            Extended stream operations.
* streams lines::               Reading lines.
@end menu

@c page
@node streams constants
@section Constants


The following bindings are exported by the @library{foreign posix
sizeof} library.  Notice that the seek constants @code{SEEK_SET},
@code{SEEK_CUR} and @code{SEEK_END}) are also exported by the same
library.  @ref{fd constants seek, File positions}


@defvr Constant EOF
The value of @code{EOF}.  @glibcref{EOF and Errors,EOF}
@end defvr

@c page
@node streams errors
@section Detecting errors on streams


The following functions manage error detection on streams operations.
@glibcref{EOF and Errors, End--Of--File and Errors}.


@deffn Function ferror @var{stream}
@deffnx Parameter ferror-function
@deffnx Function primitive:-ferror @var{stream}
@deffnx Function platform:ferror @var{stream}
Return @true{} if the error indicator of @var{stream} is set, @false{}
otherwise.  @func{platform:ferror} returns a single value: The return
value of the foreign function call.
@end deffn


@defun clearerr @var{stream}
@defunx primitive:clearerr @var{stream}
@defunx platform:clearerr @var{stream}
Clear the error and end--of--file indicators for @var{stream}.
@end defun

@c page
@node streams open close
@section Opening and closing


The following functions manage opening and closing of streams.
@glibcref{Opening Streams, Opening Streams}.  @glibcref{Closing Streams,
Closing Streams}.


@deffn Function fopen @var{pathname} @var{mode}
@deffnx Parameter fopen-function
@deffnx Function primitive:fopen @var{pathname} @var{mode}
@deffnx Function platform:fopen @var{pathname-cstr} @var{mode}
Open a file selected by @var{pathname} with the given mode and return a
pointer to the stream.  @var{pathname} and @var{mode} must be Scheme
strings or symbols.
@end deffn


@deffn Function fclose @var{stream}
@deffnx Parameter fclose-function
@deffnx Function primitive:fclose @var{stream}
@deffnx Function platform:fclose @var{stream}
Close the previously opened @var{stream}.
@end deffn


@deffn Function fcloseall
@deffnx Parameter fcloseall-function
@deffnx Function primitive:fcloseall
@deffnx Function platform:fcloseall
Close all the open streams of the process.
@end deffn

@c page
@node streams writing
@section Writing to streams


The following functions manage writing data to streams.  @glibcref{Block
Input/Output, Block Input/Output}.  @glibcref{Flushing Buffers, Flushing
Buffers}.


@deffn Function fwrite @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Parameter fwrite-function
@deffnx Function primitive:fwrite @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Function platform:fwrite @var{pointer} @var{size} @var{count} @var{stream}
Write up to @var{count} elements of @var{size} bytes from the block of
memory referenced by @var{pointer} to @var{stream}.  If successful
return @var{count}.
@end deffn


@deffn Function fputc @var{char} @var{stream}
@deffnx Parameter fputc-function
@deffnx Function primitive:fputc @var{char} @var{stream}
@deffnx Function platform:fputc @var{char} @var{stream}
Write a character to @var{stream}.  @var{char} must be a Scheme
character with scalar value in the range @code{[0, 255]}; the scalar
value is computed with @func{char->integer}.  If successful return the
scalar representing @var{char}.
@end deffn


@deffn Function fputs @var{string} @var{stream}
@deffnx Parameter fputs-function
@deffnx Function primitive:fputs @var{string} @var{stream}
@deffnx Function platform:fputs @var{cstring} @var{stream}
Write a string to @var{stream}.  @var{string} must be a Scheme string or
symbol.  If successful return the scalar representing @var{char}.
@end deffn


@deffn Function fflush @var{stream}
@deffnx Parameter fflush-function
@deffnx Function primitive:fflush @var{stream}
@deffnx Function platform:fflush @var{stream}
Flush the contents of the buffer to the underlying device.
@end deffn

@c page
@node streams reading
@section Reading from streams


The following functions manage reading data from streams.
@glibcref{Block Input/Output, Block Input/Output}.


@deffn Function fread @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Parameter fread-function
@deffnx Function primitive:fread @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Function platform:fread @var{pointer} @var{size} @var{count} @var{stream}
Read up to @var{count} elements of @var{size} bytes from @var{stream}
and store them in the block of memory referenced by @var{pointer}.
Return the number of objects actually read (which may be less than
@var{count}).
@end deffn


@deffn Function fgetc @var{stream}
@deffnx Parameter fgetc-function
@deffnx Function primitive:fgetc @var{stream}
@deffnx Function platform:fgetc @var{stream}
Read a single character from @var{stream}.  Return a Scheme character.
@end deffn


@deffn Function fgets @var{pointer} @var{count} @var{stream}
@deffnx Parameter fgets-function
@deffnx Function primitive:fgets @var{pointer} @var{count} @var{stream}
@deffnx Function platform-fgets @var{pointer} @var{count} @var{stream}
Read a line from @var{stream} and store it in the buffer of @var{count}
bytes referenced by @var{pointer}.  Return @var{pointer}.
@end deffn

@c page
@node streams unreading
@section Unreading to streams


The following functions manage ``unreading'' data from streams.
@glibcref{How Unread, Using @code{ungetc} To Do Unreading}.


@deffn Function ungetc @var{char} @var{stream}
@deffnx Parameter ungetc-function
@deffnx Function primitive:ungetc @var{char} @var{stream}
@deffnx Function platform:ungetc @var{c-char} @var{stream}
Unread a character to @var{stream}.  @var{char} must be a Scheme
character with scalar value in the range @code{[0, 255]}; the scalar
value is computed with @func{char->integer}.
@end deffn

@c page
@node streams seeking
@section Stream positioning


The following functions manage seeking the current position in streams.
@glibcref{File Positioning, File Positioning}.

Notice that the seek constants @code{SEEK_SET}, @code{SEEK_CUR} and
@code{SEEK_END} are exported by the @library{foreign posix sizeof}
library.  @ref{fd constants seek, File positions}


@deffn Function feof @var{stream}
@deffnx Parameter feof-function
@deffnx Function primitive:feof @var{stream}
@deffnx Function platform:feof @var{stream}
Return @true{} if the end--of--file indicator of @var{stream} is set,
otherwise @false{}.
@end deffn


@deffn Function fseek @var{stream} @var{offset} @var{whence}
@deffnx Parameter fseek-function
@deffnx Function primitive:fseek @var{stream} @var{offset} @var{whence}
@deffnx Function platform:fseek @var{stream} @var{offset} @var{whence}
Change the file position of @var{stream} to @var{offset} from
@var{whence}.
@end deffn


@deffn Function ftell @var{stream}
@deffnx Parameter ftell-function
@deffnx Function primitive:ftell @var{stream}
@deffnx Function platform:ftell @var{stream}
@func{ftell} returns the current file position of @var{stream}.
@end deffn


@deffn Function rewind @var{stream}
@deffnx Parameter rewind-function
@deffnx Function primitive:rewind @var{stream}
@deffnx Function platform:rewind @var{stream}
Change the file position of @var{stream} to the beginning of the file.
@end deffn

@c page
@node streams fd
@section Streams and file descriptors


The following functions manage conversion of streams to and from raw
file descriptors.  @glibcref{Descriptors and Streams, Descriptors and
Streams}.


@deffn Function fdopen @var{fd} @var{open-mode}
@deffnx Parameter fdopen-function
@deffnx Function primitive:fdopen @var{fd} @var{open-mode}
@deffnx Function platform:fdopen @var{fd} @var{open-mode}
Build and return a new stream wrapping file descriptor @var{fd}.
@var{open-mode} must be a Scheme string or symbol representing the open
mode of @var{fd}; it can have the same values accepted by @func{fopen}.
@end deffn


@deffn Function fileno @var{stream}
@deffnx Parameter fileno-function
@deffnx Function primitive:fileno @var{stream}
@deffnx Function platform:fileno @var{stream}
Return the file descriptor wrapped by @var{stream}, an exact integer.
@end deffn

@c page
@node streams unlocked
@section Unlocked stream operations


The following functions manage operation on streams without locking for
exclusive access; they are like the corresponding non--@code{_unlocked}
variants, but they do not implicitly lock the stream.

@c ------------------------------------------------------------

@subsubheading Errors


@deffn Function ferror_unlocked @var{stream}
@deffnx Parameter ferror_unlocked-function
@deffnx Function primitive:ferror_unlocked @var{stream}
@deffnx Function platform:ferror_unlocked @var{stream}
Like @func{ferror}.
@end deffn


@defun clearerr_unlocked @var{stream}
@defunx primitive:clearerr_unlocked @var{stream}
@defunx platform:clearerr_unlocked @var{stream}
Like @func{clearerr}.
@end defun

@c ------------------------------------------------------------

@subsubheading Writing


@deffn Function fwrite_unlocked @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Parameter fwrite_unlocked-function
@deffnx Function primitive:fwrite_unlocked @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Function platform:fwrite_unlocked @var{pointer} @var{size} @var{count} @var{stream}
Like @func{fwrite}.
@end deffn


@deffn Function fputc_unlocked @var{char} @var{stream}
@deffnx Parameter fputc_unlocked-function
@deffnx Function primitive:fputc_unlocked @var{c-char} @var{stream}
@deffnx Function platform:fputc_unlocked @var{c-char} @var{stream}
Like @func{fputc}.
@end deffn


@deffn Function fputs_unlocked @var{string} @var{stream}
@deffnx Parameter fputs_unlocked-function
@deffnx Function primitive:fputs_unlocked @var{cstring} @var{stream}
@deffnx Function platform:fputs_unlocked @var{cstring} @var{stream}
Like @func{fputs}.
@end deffn


@deffn Function fflush_unlocked @var{stream}
@deffnx Parameter fflush_unlocked-function
@deffnx Function primitive:fflush_unlocked @var{stream}
@deffnx Function platform:fflush_unlocked @var{stream}
Like @func{fflush}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Reading


@deffn Function fread_unlocked @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Parameter fread_unlocked-function
@deffnx Function primitive:fread_unlocked @var{pointer} @var{size} @var{count} @var{stream}
@deffnx Function platform:fread_unlocked @var{pointer} @var{size} @var{count} @var{stream}
Like @func{fread}.
@end deffn


@deffn Function fgetc_unlocked @var{stream}
@deffnx Parameter fgetc_unlocked-function
@deffnx Function primitive:fgetc_unlocked @var{stream}
@deffnx Function platform:fgetc_unlocked @var{stream}
Like @func{fgetc}.
@end deffn


@deffn Function fgets_unlocked @var{pointer} @var{count} @var{stream}
@deffnx Parameter fgets_unlocked-function
@deffnx Function primitive:fgets_unlocked @var{pointer} @var{count} @var{stream}
@deffnx Function platform:fgets_unlocked @var{pointer} @var{count} @var{stream}
Like @func{fgets}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Seeking


@deffn Function feof_unlocked @var{stream}
@deffnx Parameter feof_unlocked-function
@deffnx Function primitive:feof_unlocked @var{stream}
@deffnx Function platform:feof_unlocked @var{stream}
Like @func{feof}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Streams an file descriptors


@deffn Function fileno_unlocked @var{stream}
@deffnx Parameter fileno_unlocked-function
@deffnx Function primitive:fileno_unlocked @var{stream}
@deffnx Function platform:fileno_unlocked @var{stream}
Like @func{fileno}.
@end deffn

@c page
@node streams extended
@section Extended stream operations


The following functions implement extended operations on streams.

@c ------------------------------------------------------------

@subsubheading Inspection


@deffn Function freadable @var{stream}
@deffnx Parameter freadable-function
@deffnx Function primitive:freadable @var{stream}
@deffnx Function platform:freadable @var{stream}
Return @true{} if @var{stream} was opened for reading, otherwise return
@false{}.
@end deffn


@deffn Function fwritable @var{stream}
@deffnx Parameter fwritable-function
@deffnx Function primitive:fwritable @var{stream}
@deffnx Function platform:fwritable @var{stream}
Return @true{} if @var{stream} was opened for writing, otherwise return
@false{}.
@end deffn


@deffn Function freading @var{stream}
@deffnx Parameter freading-function
@deffnx Function primitive:freading @var{stream}
@deffnx Function platform:freading @var{stream}
Return @true{} if @var{stream} was last read from, otherwise return
@false{}.
@end deffn


@deffn Function fwriting @var{stream}
@deffnx Parameter fwriting-function
@deffnx Function primitive:fwriting @var{stream}
@deffnx Function platform:fwriting @var{stream}
Return @true{} if @var{stream} was last written to, otherwise return
@false{}.
@end deffn


@deffn Function fwide @var{stream} @var{mode}
@deffnx Parameter fwide-function
@deffnx Function primitive:fwide @var{stream} @var{mode}
@deffnx Function platform:fwide @var{stream} @var{mode}
Set or query the orientation of @var{stream}.  @var{mode} must be an
exact integer.

@itemize
@item
If @var{mode} is zero and the return value is positive: @var{stream} is
oriented for wide characters.

@item
If @var{mode} is zero and the return value is negative: @var{stream} is
oriented for narrow characters.

@item
If @var{mode} is positive: @var{stream} is configured for wide
characters.

@item
If @var{mode} is negative: @var{stream} is configured for narrow
characters.
@end itemize
@end deffn

@c ------------------------------------------------------------

@subsubheading Miscellaneous


@deffn Function fpurge @var{stream}
@deffnx Parameter fpurge-function
@deffnx Function primitive:fpurge @var{stream}
@deffnx Function platform:fpurge @var{stream}
Discard the contents of the buffer.
@end deffn

@c page
@node streams lines
@section Reading lines


The following functions manage reading lines from streams.
@glibcref{Line Input, Line--Oriented Input}.


@deffn Function getline @var{stream}
@deffnx Parameter getline-function
@deffnx Function primitive:getline @var{stream}
@deffnx Function platform:getline @var{pointer-pointer} @var{pointer-count} @var{stream}
Read characters from @var{stream} until a newline is found, then returns
a string holding those characters and a terminating newline.

If end--of--file is encountered before the newline, but some characters
where read: The acquired characters are stored in a string
@strong{without} terminating newline, and the string is returned.

If end--of--file is encountered before the newline, and no characters
where read: An empty string is returned.

If an error occurs while reading: An exception is raised.
@end deffn


@deffn Function getdelim @var{stream} @var{delimiter}
@deffnx Parameter getdelim-function
@deffnx Function primitive:getdelim @var{stream} @var{delimiter}
@deffnx Function platform:getdelim @var{pointer-pointer} @var{pointer-count} @var{delimiter} @var{stream}
Like @func{getline} but reads characters until @var{delimiter} is found.
@var{delimiter} must be a Scheme character with an integer
representation in the range @code{[0, 255]}.
@end deffn


As a usage example, the following code reads one line at a time from a
file and accumulates them in the @code{lines} variables:

@smallexample
(import (rnrs)
  (receive)
  (compensations)
  (foreign memory)
  (foreign cstrings)
  (foreign errno)
  (foreign ffi peekers-and-pokers)
  (foreign glibc streams)
  (prefix (foreign glibc streams platform) platform:))

(let* ((pathname the-pathname))
  (with-compensations
    (letrec* ((S           (compensate
                               (fopen pathname "w+")
                             (with
                              (fclose S))))
              (*pointer    (malloc-small/c))
              (*count      (malloc-small/c))
              (getp        (lambda ()
                             (pointer-ref-c-pointer *pointer 0)))
              (free        (lambda ()
                             (let ((p (getp)))
                               (unless (pointer-null? p)
                                 (primitive-free p)))))
              (lines       '()))
      (let loop ()
        (receive (result errno)
            (platform:getline *pointer *count S)
          (cond ((ferror S)
                 (free)
                 (raise-errno-error 'reading-line errno S))
;;; here EOF was found, return the result
                ((= -1 result)
                 (free)
                 (reverse lines))
;;; accumulate the result
                (else
                 (set! lines
                       (cons (cstring->string (getp) result)
                             lines))
                 (loop))))))))
@end smallexample

@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
