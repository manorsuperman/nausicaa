# Makefile.end --
#
# Library of rules.

#page
## ------------------------------------------------------------
## Installing source files.
## ------------------------------------------------------------

# Find the list of directories under "libraries".
sls_FIND_DIRS		= cd $(sls_SRCDIR) ; $(FIND) . -type d

# Find the reversed list of directories under "libraries".
sls_FIND_DIRS_REV	= cd $(sls_SRCDIR); \
		ls -1d $(DIRECTORIES) | $(SORT) --reverse

# Find  all  the source  files.   Only  the  .sls files  are
# considered for compilation and installation.
sls_FIND_FILES		= cd $(sls_SRCDIR) ; $(FIND) . -type f	\
			-and -name '*.sls'		\
			-and -print

## ------------------------------------------------------------

sls_SRCDIR		= $(srcdir)/libraries

# We sort  the list of  directories so that  when installing
# them  we can create  the parents  first (useless  with the
# "install"  program from GNU  Coreutils, but  we do  it the
# same).
sls_DIRECTORIES			= $(sort $(shell $(sls_FIND_DIRS)))

# The reversed  list of  directories allows us  to uninstall
# the children first: the children directories have a longer
# pathname.
sls_REVERSED_DIRECTORIES	= $(shell $(sls_FIND_DIRS_REV))

sls_SOURCES			= $(shell $(sls_FIND_FILES))
sls_INSTLST			= $(sls_SOURCES)
sls_INSTDIR			= $(ikarus_PKGLIBDIR)

.PHONY: sls-install sls-uninstall

ifeq ($(strip $(nausicaa_ENABLE_SLS)),yes)

sls-install:
	$(INSTALL_DIR) $(foreach d,$(sls_DIRECTORIES),$(DESTDIR)$(sls_INSTDIR)/$(d))
	cd $(sls_SRCDIR); $(foreach f,$(sls_SOURCES),\
		$(INSTALL_DATA) $(f) $(DESTDIR)$(sls_INSTDIR)/$(dir $(f));)

sls-uninstall:
	-@$(RM) $(addprefix $(DESTDIR)$(sls_INSTDIR)/,$(FILES))
	-@$(RMDIR) $(addprefix $(DESTDIR)$(sls_INSTDIR)/,$(REVERSED_DIRECTORIES))

else
sls-install sls-uninstall:
endif

## ------------------------------------------------------------

install:		sls-install
uninstall:		sls-uninstall

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Compiling of source files.
## ------------------------------------------------------------

fasl_SRCDIR		= $(sls_SRCDIR)
fasl_BUILDDIR		= $(builddir)/fasl.d

fasl_FASL_EXTENSION	= .ikarus-fasl

## ------------------------------------------------------------

# Find the FASL files that currently exists in the source
# directory.
fasl_FIND_FASL_SRCDIR	= \
	cd $(fasl_SRCDIR) ; \
	$(FIND) . -type f -and -name "*$(fasl_FASL_EXTENSION)" -and -print

# Find the FASL files that currently exists in the build
# directory.
fasl_FIND_FASL_BUILDDIR	= \
	cd $(fasl_BUILDDIR) ; \
	$(FIND) . -type f -and -name "*$(fasl_FASL_EXTENSION)" -and -print

fasl_COMPILE_SCRIPT	= compile-all.sps
fasl_COMPILE_ENV	= IKARUS_LIBRARY_PATH=$(fasl_SRCDIR)
fasl_COMPILE_COMMAND	= $(IKARUS) --compile-dependencies
fasl_COMPILE_RUN	= $(fasl_COMPILE_ENV) $(fasl_COMPILE_COMMAND) $(fasl_COMPILE_SCRIPT)

## ------------------------------------------------------------

fasl_FASL_FILES		= $(shell $(fasl_FIND_FASL_SRCDIR))
fasl_TARGETS		= $(shell $(fasl_FIND_FASL_BUILDDIR))

fasl_INSTLST		= $(fasl_TARGETS)
fasl_INSTDIR		= $(sls_INSTDIR)

## ------------------------------------------------------------

.PHONY: fasl fasl-clean fasl-clean-fasl-in-srcdir
.PHONY: fasl-install fasl-uninstall

ifeq ($(strip $(nausicaa_ENABLE_FASL)),yes)

## Notice  that,  by default,  GNU  tar  preserves the  file
## modification times  so the FASL times will  be newer than
## the corresponding .sls times.
##
## When these files are installed: loading will work fine if
## we give  the appropriate preserve flags  to the "install"
## program.
fasl: $(fasl_BUILDDIR)
	cd $(fasl_SRCDIR) ; test -f $(fasl_COMPILE_SCRIPT) && $(fasl_COMPILE_RUN)
	$(fasl_FIND_FASL_SRCDIR) | \
	$(TAR) --create  --file=- --files-from=- | \
	$(TAR) --directory=$(PWD)/$(fasl_BUILDDIR) --extract --verbose --file=-
	$(MAKE) fasl-clean-fasl-in-srcdir

$(fasl_BUILDDIR):
	-@test -d $(fasl_BUILDDIR) || $(MKDIR) $(fasl_BUILDDIR)

fasl-clean: fasl-clean-fasl-in-srcdir
	$(RM) $(fasl_BUILDDIR)/*

fasl-clean-fasl-in-srcdir:
	-cd $(fasl_SRCDIR); $(RM) $(fasl_FASL_FILES)

fasl-install:
	$(INSTALL_DIR) $(foreach d,$(sls_DIRECTORIES),$(DESTDIR)$(fasl_INSTDIR)/$(d))
	cd $(fasl_BUILDDIR); $(foreach f,$(fasl_TARGETS),\
		$(INSTALL_DATA) $(f) $(DESTDIR)$(fasl_INSTDIR)/$(dir $(f));)

fasl-uninstall:
	cd $(fasl_BUILDDIR); $(foreach f,$(fasl_TARGETS),\
		$(INSTALL_DATA) $(f) $(DESTDIR)$(fasl_INSTDIR)/$(dir $(f));)
	-@$(RMDIR) $(addprefix $(DESTDIR)$(fasl_INSTDIR)/,$(REVERSED_DIRECTORIES))

else
fasl fasl-clean fasl-clean-fasl-in-srcdir:
fasl-install fasl-uninstall:
endif

## ------------------------------------------------------------

.PHONY: compile compile-clean

compile:	fasl
compile-clean:	fasl-clean

all:		fasl
clean:		fasl-clean

install:	fasl-install
uninstall:	fasl-uninstall

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Tests.
## ------------------------------------------------------------

nau_test_SRCDIR		= $(srcdir)/tests
nau_test_FILES		= $(wildcard $(nau_test_SRCDIR)/test-*.sls)

# We DO  NOT include the  fasl build directory in  the path.
# This is on purpose.
nau_test_ENV		= IKARUS_LIBRARY_PATH=$(srcdir)/libraries:$(srcdir)/tests
nau_test_RUN		= $(nau_test_ENV) $(SCHEME_SCRIPT)

nau_test_SELECTED_FILES	= $(wildcard $(nau_test_SRCDIR)/test-$(FILE).sls)

.PHONY: tests test check test-file

tests test check:
	$(foreach f,$(nau_test_FILES),$(nau_test_RUN) $(f);)

test-file:
	$(foreach f,$(nau_test_SELECTED_FILES),$(nau_test_RUN) $(f);)

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Documentation: Texinfo format.
## ------------------------------------------------------------

# It  is allright  if the  package has  no  documentation in
# Texinfo format.   The rules below will take  care of doing
# nothing if no .texi files are found.

doc_texinfo_SRCDIR	= $(srcdir)/doc
doc_texinfo_BUILDDIR	= $(builddir)/doc-texinfo.d

doc_texinfo_SOURCES	= $(wildcard $(doc_texinfo_SRCDIR)/*.texi)
doc_texinfo_info_TARGETS= $(foreach f,$(doc_texinfo_SOURCES:.texi=.info),\
			  $(addprefix $(doc_texinfo_BUILDDIR)/,$(notdir $(f))))
doc_texinfo_html_TARGETS= $(foreach f,$(doc_texinfo_SOURCES:.texi=.html),\
			  $(addprefix $(doc_texinfo_BUILDDIR)/,$(notdir $(f))))

doc_texinfo_TARGETS	= $(doc_texinfo_info_TARGETS) $(doc_texinfo_html_TARGETS)
doc_texinfo_CLEANFILES	= $(doc_texinfo_TARGETS)

doc_texinfo_info_INSTLST= $(doc_texinfo_info_TARGETS)
doc_texinfo_info_INSTDIR= $(infodir)

doc_texinfo_html_INSTLST= $(doc_texinfo_html_TARGETS)
doc_texinfo_html_INSTDIR= $(pkghtmldir)

## ------------------------------------------------------------

.PHONY: doc-texinfo doc-texinfo-clean doc-texinfo-builddir
.PHONY: doc-texinfo-install doc-texinfo-uninstall doc-texinfo-version

.PHONY: doc-texinfo-info doc-texinfo-info-install doc-texinfo-info-uninstall
.PHONY: doc-texinfo-html doc-texinfo-html-install doc-texinfo-html-uninstall

ifeq ($(strip $(nausicaa_ENABLE_DOC)),yes)

doc-texinfo:		doc-texinfo-info          doc-texinfo-html
doc-texinfo-install:	doc-texinfo-info-install  doc-texinfo-html-install
doc-texinfo-uninstall:	doc-texinfo-info-uinstall doc-texinfo-html-uinstall

doc-texinfo-builddir:
	-@test -d $(doc_texinfo_BUILDDIR) || $(MKDIR) $(doc_texinfo_BUILDDIR)

doc-texinfo-clean:
	-$(RM) $(doc_texinfo_CLEANFILES)

doc-texinfo-version: $(doc_texinfo_BUILDDIR)/version.texiinc

$(doc_texinfo_BUILDDIR)/version.texiinc:
	printf '@macro version{}\n%s\n@end macro' $(PACKAGE_VERSION) >$(@)

## ------------------------------------------------------------
## Info format.

ifeq ($(strip $(nausicaa_ENABLE_INFO_DOC)),yes)

doc-texinfo-info: doc-texinfo-builddir doc-texinfo-version $(doc_texinfo_info_TARGETS)

$(doc_texinfo_info_TARGETS): $(doc_texinfo_BUILDDIR)/%.info : $(doc_texinfo_SRCDIR)/%.texi
	$(MAKEINFO) $(MAKEINFO_INFO_FLAGS) -o $(@) $(<)

doc-texinfo-info-install:
ifneq ($(strip $(wildcard $(doc_texinfo_info_INSTLST))),)
	$(INSTALL_DIR) $(DESTDIR)$(doc_texinfo_info_INSTDIR)
	$(INSTALL_DATA) $(doc_texinfo_info_INSTLST) $(DESTDIR)$(doc_texinfo_info_INSTDIR)
endif

doc-texinfo-info-uninstall:
ifneq ($(strip $(wildcard $(doc_texinfo_info_INSTLST))),)
	-@$(RM) $(addprefix $(DESTDIR)$(doc_texinfo_info_INSTDIR)/,$(foreach f,$(doc_texinfo_info_INSTLST),$(notdir $(f))))
	-@$(RMDIR) $(DESTDIR)$(doc_texinfo_info_INSTDIR)
endif

endif		# nausicaa_ENABLE_INFO_DOC == yes

## ------------------------------------------------------------
## HTML format.

ifeq ($(strip $(nausicaa_ENABLE_HTML_DOC)),yes)

doc-texinfo-html: doc-texinfo-builddir doc-texinfo-version $(doc_texinfo_html_TARGETS)

$(doc_texinfo_html_TARGETS): $(doc_texinfo_BUILDDIR)/%.html : $(doc_texinfo_SRCDIR)/%.texi
	$(MAKEINFO) $(MAKEINFO_HTML_FLAGS) -o $(@) $(<)

doc-texinfo-html-install:
ifneq ($(strip $(wildcard $(doc_texinfo_html_INSTLST))),)
	$(INSTALL_DIR) $(DESTDIR)$(doc_texinfo_html_INSTDIR)
	$(INSTALL_DATA) $(doc_texinfo_html_INSTLST) $(DESTDIR)$(doc_texinfo_html_INSTDIR)
endif

doc-texinfo-html-uninstall:
ifneq ($(strip $(wildcard $(doc_texinfo_html_INSTLST))),)
	-@$(RM) $(addprefix $(DESTDIR)$(doc_texinfo_html_INSTDIR)/,$(foreach f,$(doc_texinfo_html_INSTLST),$(notdir $(f))))
	-@$(RMDIR) $(DESTDIR)$(doc_texinfo_html_INSTDIR)
endif

endif		# nausicaa_ENABLE_HTML_DOC == yes

## ------------------------------------------------------------

else
doc-texinfo doc-texinfo-clean doc-texinfo-builddir:
doc-texinfo-install doc-texinfo-uninstall:
endif		# nausicaa_ENABLE_DOC == yes

doc:		doc-texinfo
doc-clean:	doc-texinfo-clean
doc-install:	doc-texinfo-install
doc-uninstall:	doc-texinfo-uninstall

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Binary distribution: common variables.
## ------------------------------------------------------------

ifeq ($(strip $(nausicaa_COMPRESSOR)),bzip2)
bindist_PACKAGE_EXTENSION	= .tar.bz2
bindist_TAR_COMPRESS_FLAG	= --bzip2
else
bindist_PACKAGE_EXTENSION	= .tar.gz
bindist_TAR_COMPRESS_FLAG	= --gzip
endif

# This is the file  name of the binary distribution tarball.
# Notice that there is no directory part.
bindist_PACKAGE_NAME	= $(package_PREFIX)$(bindist_PACKAGE_EXTENSION)

# This is  the root directory for  temporary installation of
# files
bindist_PACKAGE_TOP_BUILDDIR	= $(TMPDIR)/$(PKG_ID)

# This is where the produced tarball will be finally stored.
bindist_BUILDDIR		= $(PWD)/$(builddir)/bindist.d

# This is the full pathname of the tarball.
bindist_TARBALL_PATHNAME	= $(bindist_BUILDDIR)/$(bindist_PACKAGE_NAME)

# The flags to hand to "tar" when building the tarball.
bindist_TAR_FLAGS		= --create $(bindist_TAR_COMPRESS_FLAG) --verbose

# By executing this command we get a list of the files in
# the bindist tarball.
bindist_LIST	= $(TAR) --list $(bindist_TAR_COMPRESS_FLAG) --file=$(bindist_TARBALL_PATHNAME)

## ------------------------------------------------------------

.PHONY: bindist bindist-clean bindist-builddir bindist-top-builddir
.PHONY: bindist-clean-top-builddir bindist-clean-builddir

bindist: bindist-clean bindist-builddir
	$(MAKE) install DESTDIR=$(bindist_PACKAGE_TOP_BUILDDIR)
	cd $(bindist_PACKAGE_TOP_BUILDDIR); \
	$(TAR) $(bindist_TAR_FLAGS) --file=$(bindist_TARBALL_PATHNAME) .
	$(MAKE) bindist-clean-top-builddir


bindist-clean: bindist-clean-top-builddir bindist-clean-builddir

bindist-top-builddir:
	test -d $(bindist_PACKAGE_TOP_BUILDDIR) || $(MKDIR) $(bindist_PACKAGE_TOP_BUILDDIR)

bindist-clean-top-builddir:
	-$(RM) $(bindist_PACKAGE_TOP_BUILDDIR)

bindist-builddir:
	test -d $(bindist_BUILDDIR) || $(MKDIR) $(bindist_BUILDDIR)

bindist-clean-builddir:
	-$(RM) $(bindist_BUILDDIR)

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Slackware packaging: common variables.
## ------------------------------------------------------------

# This is  the file name  of the Slackware  package.  Notice
# that there is no directory part.
slack_PACKAGE_NAME	= $(package_PREFIX).tgz

# This  is the  package prefix,  it  is used  to remove  the
# package.
slack_PACKAGE_PREFIX	= $(package_PREFIX)

# This is  the root directory for  temporary installation of
# files.
slack_PACKAGE_TOP_BUILDDIR	= $(TMPDIR)/$(PKG_ID)

# This  is the  root directory  for building  packages.  The
# rules for standard packages will set it to:
#
#   $(slack_PACKAGE_TOP_BUILDDIR)
#
# the rules for local packages will set it to:
#
#   $(slack_PACKAGE_TOP_BUILDDIR)/$(prefix)
#
slack_PACKAGE_BUILDDIR	?=

# This is where the produced package will be finally stored.
slack_BUILDDIR		= $(PWD)/$(builddir)/slackware.d

# This is  the pathname of the  Slackware packages registry.
# The standard package rules will set it to:
#
#   $(slack_REGISTRY_DIR)
#
# while the local package rules will set it to:
#
#   $(prefix)$(slack_REGISTRY_DIR)
#
slack_REGISTRY		?= 
slack_REGISTRY_DIR	= /var/log/packages

# Try  to  read from  the  system  the  name of  an  already
# installed package.  It is used to upgrade.
slack_INSTALLED_PACKAGE	= \
	$(firstword $(notdir $(wildcard $(slack_REGISTRY)/$(package_NAME)-*)))

## ------------------------------------------------------------

# This is the environment for the Slackware package handling
# tools.
slack_ENV		?=

slack_MAKEPKG_PROGRAM	= @slack_MAKEPKG_PROGRAM@
slack_MAKEPKG_FLAGS	?= --chown y
slack_MAKEPKG		= $(slack_ENV) $(slack_MAKEPKG_PROGRAM) $(slack_MAKEPKG_FLAGS)

slack_INSTALLPKG_PROGRAM= @slack_INSTALLPKG_PROGRAM@
slack_INSTALLPKG_FLAGS	?=
slack_INSTALLPKG	= $(slack_ENV) $(slack_INSTALLPKG_PROGRAM) $(slack_INSTALLPKG_FLAGS)

slack_REMOVEPKG_PROGRAM	= @slack_REMOVEPKG_PROGRAM@
slack_REMOVEPKG_FLAGS	?=
slack_REMOVEPKG		= $(slack_ENV) $(slack_REMOVEPKG_PROGRAM) $(slack_REMOVEPKG_FLAGS)

slack_UPGRADEPKG_PROGRAM= @slack_UPGRADEPKG_PROGRAM@
slack_UPGRADEPKG_FLAGS	?= --verbose --reinstall
slack_UPGRADEPKG	= $(slack_ENV) $(slack_UPGRADEPKG_PROGRAM) $(slack_UPGRADEPKG_FLAGS)

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Slackware packaging: private building rules.
## ------------------------------------------------------------

# The following rules are meant  to be invoked only by other
# rules.
#
# Notice  that,  by  default,  GNU tar  preserves  the  file
# modification times  so the FASL  times will be  newer than
# the corresponding .sls times in the Slackware package.

.PHONY: private-slackware        private-slackware-install
.PHONY: private-slackware-remove private-slackware-upgrade

private-slackware: slackware-clean slackware-builddir
	$(MAKE) install DESTDIR=$(slack_PACKAGE_TOP_BUILDDIR)
	$(INSTALL_DIR) $(slack_PACKAGE_BUILDDIR)/install
	$(INSTALL_DATA) $(builddir)/meta.d/slackware/slack-desc $(slack_PACKAGE_BUILDDIR)/install
	$(MAKE) slackware-aux
	cd $(slack_PACKAGE_BUILDDIR); \
	$(slack_MAKEPKG) $(slack_PACKAGE_NAME); \
	$(MV) $(slack_PACKAGE_NAME) $(slack_BUILDDIR)

private-slackware-install:
	cd $(slack_BUILDDIR); \
	$(slack_INSTALLPKG) $(slack_PACKAGE_NAME)

private-slackware-remove:
	$(slack_REMOVEPKG) $(slack_PACKAGE_PREFIX)

private-slackware-upgrade:
	cd $(slack_BUILDDIR); \
	$(slack_UPGRADEPKG) $(slack_INSTALLED_PACKAGE)%$(slack_PACKAGE_NAME)

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Slackware packaging: auxiliary rules.
## ------------------------------------------------------------

.PHONY: slackware-builddir slackware-aux

slackware-builddir:
	-test -d $(slack_BUILDDIR) || $(MKDIR) $(slack_BUILDDIR)

slackware-top-builddir:
	-test -d $(slack_PACKAGE_TOP_BUILDDIR) || $(MKDIR) $(slack_PACKAGE_TOP_BUILDDIR)

# This is for auxiliary rules: it is freely available to the
# user.  It  will be  invoked just before  running "makepkg"
# (see the 'slackware' rule).
slackware-aux:

## ------------------------------------------------------------

.PHONY: slackware-clean slackware-clean-top-builddir slackware-clean-builddir

slackware-clean: slackware-clean-top-builddir slackware-clean-builddir

slackware-clean-top-builddir:
	-$(RM) $(slack_PACKAGE_TOP_BUILDDIR)

slackware-clean-builddir:
	-$(RM) $(slack_BUILDDIR)

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Slackware packaging: standard package build.
## ------------------------------------------------------------

slackware_STANDARD_ENV	= \
	PATH=/sbin:$(PATH)					\
	slack_PACKAGE_BUILDDIR=$(slack_PACKAGE_TOP_BUILDDIR)	\
	slack_REGISTRY=$(slack_REGISTRY_DIR)

## ------------------------------------------------------------

.PHONY: slackware        slackware-install
.PHONY: slackware-remove slackware-upgrade

slackware:
	$(MAKE) private-slackware		$(slackware_STANDARD_ENV)
	$(MAKE) slackware-clean-top-builddir	$(slackware_STANDARD_ENV)

slackware-install:
	$(MAKE) private-slackware-install	$(slackware_STANDARD_ENV)

slackware-remove:
	$(MAKE) private-slackware-remove	$(slackware_STANDARD_ENV)

slackware-upgrade:
	$(MAKE) private-slackware-upgrade	$(slackware_STANDARD_ENV)

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Slackware packaging: local package build.
## ------------------------------------------------------------

slackware_LOCAL_ENV	= \
	PATH=/sbin:$(PATH)						\
	slack_PACKAGE_BUILDDIR=$(slack_PACKAGE_TOP_BUILDDIR)/$(prefix)	\
	slack_REGISTRY=$(prefix)$(slack_REGISTRY_DIR)			\
	slack_ENV=ROOT=$(prefix)

## ------------------------------------------------------------

.PHONY: local-slackware        local-slackware-install
.PHONY: local-slackware-remove local-slackware-upgrade

local-slackware:
	$(MAKE) private-slackware		$(slackware_LOCAL_ENV)
	$(MAKE) slackware-clean-top-builddir	$(slackware_LOCAL_ENV)

local-slackware-install:
	$(MAKE) private-slackware-install	$(slackware_LOCAL_ENV)

local-slackware-remove:
	$(MAKE) private-slackware-remove	$(slackware_LOCAL_ENV)

local-slackware-upgrade:
	$(MAKE) private-slackware-upgrade	$(slackware_LOCAL_ENV)

## ------------------------------------------------------------

.PHONY: abi abu

abi:
	$(MAKE) all
	$(SUDO) $(MAKE) local-slackware local-slackware-install
abu:
	$(MAKE) all
	$(SUDO) $(MAKE) local-slackware local-slackware-upgrade

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## RedHat packaging: common variables.
## ------------------------------------------------------------

# This is the file name  of the RedHat package.  Notice that
# there is no directory part.
redhat_PACKAGE_NAME	= $(package_PREFIX).rpm

# This  is the  package prefix,  it  is used  to remove  the
# package.
redhat_PACKAGE_PREFIX	= $(package_PREFIX)

# This is  the root directory for  temporary installation of
# files.
redhat_PACKAGE_TOP_BUILDDIR	= $(TMPDIR)/$(PKG_ID)

# This is the root directory for building packages.
redhat_PACKAGE_BUILDDIR	?= $(redhat_PACKAGE_TOP_BUILDDIR)/BUILD

# This is where the produced package will be finally stored.
redhat_BUILDDIR		= $(PWD)/$(builddir)/redhat.d

# Try  to  read from  the  system  the  name of  an  already
# installed package.  It is used to upgrade.
redhat_INSTALLED_PACKAGE	=

## ------------------------------------------------------------

# This is the environment for the RedHat package handling
# tools.
redhat_ENV		?=

redhat_CORE_PROGRAM	= @redhat_CORE_PROGRAM@
redhat_BUILD_PROGRAM	= @redhat_BUILD_PROGRAM@

redhat_BUILD		= $(redhat_BUILD_PROGRAM) -v -bb

redhat_SPEC_FILE	= $(PKG_ID).spec
redhat_GENERIC_SPEC	= meta.d/redhat/spec-file
redhat_SPECIFIC_SPEC	= meta.d/redhat/$(redhat_SPEC_FILE)

## ------------------------------------------------------------

.PHONY: redhat

redhat: bindist redhat-clean
	$(INSTALL_DIR) $(redhat_PACKAGE_TOP_BUILDDIR)
	$(INSTALL_DIR) $(redhat_PACKAGE_TOP_BUILDDIR)/BUILD/$(package_ARCH)
	$(INSTALL_DIR) $(redhat_PACKAGE_TOP_BUILDDIR)/SPECS
	$(CP) $(redhat_GENERIC_SPEC) $(redhat_SPECIFIC_SPEC)
	$(bindist_LIST) | $(SED) -e 's/^\.//' -e 's%^/$$%%' >> $(redhat_SPECIFIC_SPEC)
	$(INSTALL_DATA) $(redhat_SPECIFIC_SPEC) $(redhat_PACKAGE_TOP_BUILDDIR)/SPECS
	$(MAKE) install DESTDIR=$(redhat_PACKAGE_BUILDDIR)
	cd $(redhat_PACKAGE_TOP_BUILDDIR); $(redhat_BUILD) SPECS/$(redhat_SPEC_FILE)

redhat-clean:
	-$(RM) $(redhat_PACKAGE_BUILDDIR)


## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## End.
## ------------------------------------------------------------

.PHONY: echo-variable echo-list-variable

# Use this to echo a variable to stdout; example:
# 
#	$ make echo-variable VARIABLE=slack_PACKAGE_NAME
#
echo-variable:
	@echo $($(VARIABLE))

# Use this to  echo a variable to stdout  interpreting it as
# list of strings; example:
# 
#	$ make echo-list-variable VARIABLE=FILES
#
echo-list-variable:
	@$(foreach f,$($(VARIABLE)),echo $(f);)



### end of file
# Local Variables:
# mode: makefile
# fill-column: 60
# End:
