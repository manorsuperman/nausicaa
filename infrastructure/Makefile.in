# Makefile --
#


#page
## ------------------------------------------------------------
## Module install functions.
## ------------------------------------------------------------

# Synopsis:
#
#   $(eval $(call ds-module-install-data,<PREFIX>,<ENABLE_VAR>))
#
# Description:
#
#   If <ENABLE_VAR>  is set  to 'yes': declare  the rules to  install, a
#   module of data files.
#
#     The list of files to install must be in "$(<PREFIX>_INSTLST)" and
#   the installation directory must be in "$(<PREFIX>_INSTDIR)".
#
define ds-module-install-data

.PHONY: $(1)-install

$(1)-install:
ifeq ($$(strip $$($(2))),yes)
ifneq ($$(strip $$($(1)_INSTLST)),)
	$$(INSTALL_DIR) $$(DESTDIR)$$($(1)_INSTDIR)
	$$(foreach f,$$($(1)_INSTLST),\
	$$(INSTALL_DATA) $$(f) $$(DESTDIR)$$($(1)_INSTDIR);)
endif
endif

layout_DIRECTORIES	+= $$(DESTDIR)$$($(1)_INSTDIR)
layout_FILES		+= $$(foreach f,$$($(1)_INSTLST),$$(DESTDIR)$$($(1)_INSTDIR)/$$(notdir $$(f)))

endef

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Global variables and default values.
## ------------------------------------------------------------

PACKAGE_NAME		= @PACKAGE_NAME@
PACKAGE_VERSION		= @PACKAGE_VERSION@
PKG_ID			= @PKG_ID@

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Configuration variables.
## ------------------------------------------------------------

# If set to 'yes' documentation files will be produced and
# installed.
ds_config_ENABLE_DOC		= @ds_config_ENABLE_DOC@

# If set to 'yes' Info documentation files will be produced
# and installed.
ds_config_ENABLE_DOC_INFO	= @ds_config_ENABLE_DOC_INFO@

# If set to 'yes' HTML documentation files will be produced
# and installed.
ds_config_ENABLE_DOC_HTML	= @ds_config_ENABLE_DOC_HTML@

# Compressor to be used when creating a tarball; it is used
# by the binary distribution rules.  Supported values:
#
#   bzip2		selects the Bzip2 compressor
#   gzip		selects the Gzip compressor
#
# if a different value is set, the compressor will default
# to 'gzip'.
# 
ds_config_COMPRESSOR		?= gzip

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Nausicaa configuration variables.
## ------------------------------------------------------------

# If set to 'yes' source files will be installed.
nausicaa_ENABLE_SLS	= @nausicaa_ENABLE_SLS@

# If set to 'yes' fasl files will be produced and installed.
nausicaa_ENABLE_FASL	= @nausicaa_ENABLE_FASL@

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Nausicaa pre-configuration of binary package variables.
## ------------------------------------------------------------

ifeq ($(strip $(package_BUILD_VERSION)),)
package_BUILD_VERSION	= 1nau
endif

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Binary package distribtion building variables.
## ------------------------------------------------------------

# The variable 'package_BUILD_VERSION'  should be defined in
# "Makefile.custom".  If  not we set a default  that does no
# harm.
ifeq ($(strip $(package_BUILD_VERSION)),)
package_BUILD_VERSION	= 1
endif

package_NAME		= $(PACKAGE_NAME)
package_VERSION		= $(PACKAGE_VERSION)

package_ARCH		= \
	$(firstword $(subst -, ,$(shell ../../infrastructure/config.guess)))
ifeq ($(strip $(package_ARCH)),)
package_ARCH		= noarch
endif

package_PREFIX		= \
$(package_NAME)-$(package_VERSION)-$(package_ARCH)-$(package_BUILD_VERSION)

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Directories.
## ------------------------------------------------------------

ifeq ($(strip $(TMPDIR)),)
TMPDIR		= /tmp
endif

## ------------------------------------------------------------

# The  other modules  will assume  that this  is  a relative
# directory  pathname, and  the full  pathname can  be built
# with: '$(PWD)/$(srcdir)'.
srcdir			= @srcdir@

# The  other modules  will assume  that this  is  a relative
# directory  pathname, and  the full  pathname can  be built
# with: '$(PWD)/$(builddir)'.
builddir		= @builddir@

## ------------------------------------------------------------

prefix			= @prefix@
exec_prefix		= @exec_prefix@

bindir			= @bindir@
datarootdir		= @datarootdir@
datadir			= @datadir@
docdir			= @datarootdir@/doc
htmldir			= @htmldir@
includedir		= @includedir@
infodir			= @infodir@
libdir			= @libdir@
libexecdir		= @libexecdir@
localstatedir		= @localstatedir@
mandir			= @mandir@
sbindir			= @sbindir@
sharedstatedir		= @sharedstatedir@
sysconfdir		= @sysconfdir@

PKG_DIR			= @PKG_DIR@
pkgdatadir		= @pkgdatadir@
pkgdocdir		= @pkgdocdir@
pkgexampledir		= @pkgexampledir@
pkginfodir		= @pkginfodir@
pkghtmldir		= @pkghtmldir@
pkgincludedir		= @pkgincludedir@
pkglibdir		= @pkglibdir@
pkglibexecdir		= @pkglibexecdir@
pkgsysconfdir		= @pkgsysconfdir@

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Nausicaa directories.
## ------------------------------------------------------------

ikarus_PKGLIBDIR	= $(libdir)/ikarus

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Common programs.
## ------------------------------------------------------------

BASH_PROGRAM	= @BASH_PROGRAM@
SHELL		= @SHELL@
@SET_MAKE@
MAKE_SILENT	= $(MAKE) --silent

BZIP		= @BZIP@
CAT		= @CAT@
CP		= @CP@ --force --verbose --preserve=mode,timestamp --
FIND		= @FIND@
GREP		= @GREP@
GAWK		= @GAWK@
GZIP		= @GZIP@
M4		= @M4@
MAKEINFO	= @MAKEINFO@
MKDIR		= @MKDIR@ --parents --verbose
MV		= @MV@ --verbose --
RM		= @RM@ --force --recursive --verbose --
RM_FILE		= @RM@ --force --verbose --
RM_SILENT	= @RM@ --force --recursive --
RMDIR		= @RMDIR@ --parents --ignore-fail-on-non-empty --
SED		= @SED@
SORT		= @SORT@
SUDO		= @SUDO@
SYMLINK		= @SYMLINK@ --symbolic
TAR		= @TAR@

## ------------------------------------------------------------

INSTALL			= @INSTALL@
INSTALL_DIR_MODE	?= 0755
INSTALL_BIN_MODE	?= 0555
INSTALL_DATA_MODE	?= 0444
INSTALL_LIB_MODE	?= 0444

INSTALL_DIR		= $(INSTALL) -p -m $(INSTALL_DIR_MODE) -d
INSTALL_BIN		= $(INSTALL) -p -m $(INSTALL_BIN_MODE)
INSTALL_DATA		= $(INSTALL) -p -m $(INSTALL_DATA_MODE)

## ------------------------------------------------------------

MAKEINFO_FLAGS		= --no-split -I$(doc_texinfo_SRCDIR) -I$(doc_texinfo_BUILDDIR)
MAKEINFO_INFO_FLAGS	= $(MAKEINFO_FLAGS)
MAKEINFO_HTML_FLAGS	= $(MAKEINFO_FLAGS) --html

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Nausicaa programs.
## ------------------------------------------------------------

IKARUS			= @IKARUS@
SCHEME_SCRIPT		= @SCHEME_SCRIPT@

SORT_UNIQUE		= $(SORT) --unique
SORT_REVERSE		= $(SORT) --reverse
SORT_REVERSE_UNIQUE	= $(SORT) --reverse --unique

SPLIT_LIST_TO_ROWS	= $(SED) -e 's/ /\n/g'

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Main phony rules.
## ------------------------------------------------------------

.PHONY: all clean realclean clean-builddir

all:
clean:
realclean:	clean

clean-builddir:
	-@printf '*** The build directory is: %s\n' $(builddir)
	-@read -p '*** Are you sure to clean it? (yes/no) ' ANSWER; \
	test "$${ANSWER}" = yes && $(RM) $(builddir)/*

## ------------------------------------------------------------

.PHONY: install uninstall

install:
uninstall: uninstall-script-run

## ------------------------------------------------------------

.PHONY: layout layout-dirs layout-files

layout: layout-dirs layout-files
layout-dirs:
	@echo $(layout_DIRECTORIES)		| \
	$(SPLIT_LIST_TO_ROWS)			| \
	$(SORT_UNIQUE)

layout-files:
	@$(foreach f,$(sort $(layout_FILES)),echo $(f);)

## ------------------------------------------------------------

.PHONY: doc doc-clean doc-install

doc:
doc-clean:
doc-install:

all:		doc
clean:		doc-clean
install:	doc-install

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Uninstall script rules.
## ------------------------------------------------------------

uninstall_script_BUILDDIR	= $(builddir)/uninstall.d
uninstall_script_TARGET		= $(uninstall_script_BUILDDIR)/uninstall.sh
uninstall_script_INSTLST	= $(uninstall_script_TARGET)
uninstall_script_INSTDIR	= $(pkglibexecdir)

.PHONY: uninstall-script uninstall-script-clean uninstall-script-builddir
.PHONY: uninstall-script-install uninstall-script-uninstall
.PHONY: uninstall-script-run

# The uninstall  script is NOT registered  into the "layout_DIRECTORIES"
# and "layout_FILES" variables: this way we  can append it to the end of
# the script.

uninstall-script: uninstall-script-builddir
	@{								\
	  echo -e '#!/bin/sh\n#\n# Executing this script will remove the package:\n#\n#\t$(PKG_ID)\n#\n# *** WARNING ***\n#\n# Do not run  this script if you use a  package management\n# system,  like the  one of  Slackware Linux.  Rely  on it\n# for package removal.  This script is only for emergency.\n\nset -e\n';			\
	  echo -e '$(RM_FILE) \\';					\
	  $(foreach f,$(sort $(layout_FILES)),echo -e '\t$(f) \\';)	\
	  echo -e '\n$(RMDIR) \\';					\
	  echo $(layout_DIRECTORIES)				| \
		$(SPLIT_LIST_TO_ROWS)				| \
		$(SORT_REVERSE_UNIQUE)				| \
		{ while read; do echo -e "\\t$${REPLY} \\" ; done; };	\
	  echo -e '\n$(RM_FILE) $(DESTDIR)$(uninstall_script_INSTDIR)/uninstall.sh';\
	  echo '$(RMDIR) $(DESTDIR)$(pkglibexecdir)';			\
	  echo -e '\n### end of file';					\
	} >$(uninstall_script_TARGET)

uninstall-script-builddir:
	-@test -d $(uninstall_script_BUILDDIR) || $(MKDIR) $(uninstall_script_BUILDDIR)

uninstall-script-clean:
	-$(RM) $(uninstall_script_TARGET)

uninstall-script-install:
	$(INSTALL_DIR) $(DESTDIR)$(uninstall_script_INSTDIR)
	$(INSTALL_BIN) $(uninstall_script_TARGET) $(DESTDIR)$(uninstall_script_INSTDIR)

uninstall-script-uninstall:
	$(RM) $(DESTDIR)$(uninstall_script_INSTDIR)/$(notdir $(uninstall_script_TARGET))
	$(RMDIR) $(DESTDIR)$(uninstall_script_INSTDIR)

uninstall-script-run:
	$(SHELL) $(uninstall_script_TARGET)

## ------------------------------------------------------------

all:		uninstall-script
clean:		uninstall-script-clean
install:	uninstall-script-install
uninstall:	uninstall-script-uninstall

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Library source files.
## ------------------------------------------------------------

sls_SRCDIR	= $(srcdir)/libraries
sls_BUILDDIR	= $(builddir)/fasl.d
sls_INSTDIR	= $(ikarus_PKGLIBDIR)

fasl_COMPILE_SCRIPT	= $(sls_SRCDIR)/compile-all.sps
fasl_COMPILE_ENV	= IKARUS_LIBRARY_PATH=$(sls_BUILDDIR)
fasl_COMPILE_COMMAND	= $(IKARUS) --compile-dependencies
fasl_COMPILE_RUN	= $(fasl_COMPILE_ENV) $(fasl_COMPILE_COMMAND) $(fasl_COMPILE_SCRIPT)

## ------------------------------------------------------------

.PHONY: sls-debug
.PHONY: fasl fasl-clean fasl-builddir fasl-install
.PHONY: sls-install fasl-install

fasl-builddir: $(sls_BUILDDIR)

fasl-clean:
	$(RM) $(sls_BUILDDIR)/*

$(sls_BUILDDIR):
	-@test -d $(sls_BUILDDIR) || $(MKDIR) $(sls_BUILDDIR)

sls-install fasl-install:

## Notice  that, by  default, GNU  tar preserves  the  file modification
## times so  the FASL  times will be  newer than the  corresponding .sls
## times.  When these files are  installed: loading will work fine if we
## give the appropriate preserve flags to the "install" program.
ifeq ($(strip $(nausicaa_ENABLE_FASL)),yes)
fasl: fasl-builddir
	( cd $(sls_SRCDIR);				\
	  $(FIND) . -name '*.sls' -and -print		| \
	  $(TAR) --create --files-from=- --file=-; )	| \
	$(TAR) --directory=$(sls_BUILDDIR) --extract --file=-
	test -f $(fasl_COMPILE_SCRIPT) && $(fasl_COMPILE_RUN)
else
fasl:
endif

## ------------------------------------------------------------

# Synopsis:
#
#   $(eval $(call nausicaa-library,<PREFIX>,<SRCDIR>,<INSTDIR>))
#
define nausicaa-library
sls_$(1)_SRCDIR		= $$(sls_SRCDIR)/$(2)
sls_$(1)_BUILDDIR	= $$(sls_BUILDDIR)/$(2)
sls_$(1)_SOURCES	= $$(wildcard $$(sls_$(1)_SRCDIR)/*.sls)
sls_$(1)_TARGETS	= $$(wildcard $$(sls_$(1)_BUILDDIR)/*.ikarus-fasl)

sls_$(1)_INSTLST	= $$(sls_$(1)_SOURCES)
sls_$(1)_INSTDIR	= $(3)
fasl_$(1)_INSTLST	= $$(sls_$(1)_TARGETS)
fasl_$(1)_INSTDIR	= $(3)

$$(eval $$(call ds-module-install-data,sls_$(1),nausicaa_ENABLE_SLS))
$$(eval $$(call ds-module-install-data,fasl_$(1),nausicaa_ENABLE_FASL))

.PHONY: sls_$(1)-debug

sls_$(1)-debug:
	@echo '$(1),$(2),$(3)'

sls-install:	sls_$(1)-install
fasl-install:	fasl_$(1)-install
sls-debug:	sls_$(1)-debug
endef

# The Makefile  function "nausicaa-library" needs to be  called once for
# each  source   directory  under  "$(sls_SRCDIR)".    For  each  source
# directory under "$(sls_SRCDIR)" there  will be a build directory under
# "$(sls_BUILDDIR)".
#
# The 1st  argument of  the call  must be a  unique identifier  for both
# Makefile  variables and  Makefile rules:  the identifier  is  built by
# converting all the '-' to '_' in the name of the source directory.
#
# The 2nd argument is the pathname of the source directory.
#
# The  3rd argument is  the pathname  of the  install directory  for the
# source files in the source directory.
#
# *WARNING*  Leave  the  function  call  written  as  a  single  line!!!
# Splitting it introduces white spaces that break things.
# 
$(foreach dir,$(shell $(FIND) $(sls_SRCDIR) -type d),\
$(eval $(call nausicaa-library,$(subst -,_,$(notdir $(dir))),$(subst $(sls_SRCDIR),,$(dir)),$(sls_INSTDIR)$(subst $(sls_SRCDIR),,$(dir)))))

## ------------------------------------------------------------ 

all:		fasl
clean:		fasl-clean
install:	sls-install fasl-install

## ------------------------------------------------------------

#page
## ------------------------------------------------------------
## Testing.
## ------------------------------------------------------------

nau_test_SRCDIR		= $(srcdir)/tests
nau_test_FILES		= $(wildcard $(nau_test_SRCDIR)/test-*.sps)

# We DO  NOT include the  fasl build directory in  the path.
# This is on purpose.
nau_test_ENV		= IKARUS_LIBRARY_PATH=$(srcdir)/libraries:$(srcdir)/tests
nau_test_RUN		= $(nau_test_ENV) $(SCHEME_SCRIPT)

nau_test_SELECTED_FILES	= $(wildcard $(nau_test_SRCDIR)/test-$(FILE).sps)

.PHONY: tests test check test-file

tests test check:
	$(foreach f,$(nau_test_FILES),$(nau_test_RUN) $(f);)

test-file:
	$(foreach f,$(nau_test_SELECTED_FILES),$(nau_test_RUN) $(f);)


## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Documentation: Texinfo format main rules.
## ------------------------------------------------------------

doc_texinfo_SRCDIR	= $(srcdir)/doc
doc_texinfo_BUILDDIR	= $(builddir)/doc-texinfo.d

doc_texinfo_SOURCES	= $(wildcard $(doc_texinfo_SRCDIR)/*.texi)
doc_texinfo_TARGETS	= $(doc_texinfo_info_TARGETS) $(doc_texinfo_html_TARGETS)
doc_texinfo_CLEANFILES	= $(doc_texinfo_TARGETS)

## ------------------------------------------------------------

.PHONY: doc-texinfo doc-texinfo-clean doc-texinfo-builddir
.PHONY: doc-texinfo-install doc-texinfo-version

ifeq ($(strip $(ds_config_ENABLE_DOC)),yes)
doc-texinfo:		doc-texinfo-info           doc-texinfo-html
doc-texinfo-install:	doc_texinfo_info-install   doc_texinfo_html-install
else
doc-texinfo doc-texinfo-install:
endif

doc-texinfo-builddir:
	-@test -d $(doc_texinfo_BUILDDIR) || $(MKDIR) $(doc_texinfo_BUILDDIR)

doc-texinfo-clean:
	-$(RM) $(doc_texinfo_CLEANFILES)

doc-texinfo-version: $(doc_texinfo_BUILDDIR)/version.texiinc

$(doc_texinfo_BUILDDIR)/version.texiinc:
	echo -e '@macro version{}\n$(PACKAGE_VERSION)\n@end macro' >$(@)

doc:		doc-texinfo
doc-clean:	doc-texinfo-clean
doc-install:	doc-texinfo-install

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Documentation: Texinfo format Info rules.
## ------------------------------------------------------------

doc_texinfo_info_TARGETS= $(foreach f,$(doc_texinfo_SOURCES:.texi=.info),\
			  $(addprefix $(doc_texinfo_BUILDDIR)/,$(notdir $(f))))

doc_texinfo_info_INSTLST= $(doc_texinfo_info_TARGETS)
doc_texinfo_info_INSTDIR= $(infodir)

## ------------------------------------------------------------

.PHONY: doc-texinfo-info doc-texinfo-info-install

ifeq ($(strip $(ds_config_ENABLE_DOC_INFO)),yes)

doc-texinfo-info: doc-texinfo-builddir doc-texinfo-version $(doc_texinfo_info_TARGETS)

$(doc_texinfo_info_TARGETS): $(doc_texinfo_BUILDDIR)/%.info : $(doc_texinfo_SRCDIR)/%.texi
	$(MAKEINFO) $(MAKEINFO_INFO_FLAGS) -o $(@) $(<)

endif		# ds_config_ENABLE_INFO_DOC == yes

$(eval $(call ds-module-install-data,doc_texinfo_info,ds_config_ENABLE_DOC_INFO))

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Documentation: Texinfo format HTML rules.
## ------------------------------------------------------------

doc_texinfo_html_TARGETS= $(foreach f,$(doc_texinfo_SOURCES:.texi=.html),\
			  $(addprefix $(doc_texinfo_BUILDDIR)/,$(notdir $(f))))

doc_texinfo_html_INSTLST= $(doc_texinfo_html_TARGETS)
doc_texinfo_html_INSTDIR= $(pkghtmldir)

## ------------------------------------------------------------

.PHONY: doc-texinfo-html doc-texinfo-html-install

ifeq ($(strip $(ds_config_ENABLE_DOC_HTML)),yes)

doc-texinfo-html: doc-texinfo-builddir doc-texinfo-version $(doc_texinfo_html_TARGETS)

$(doc_texinfo_html_TARGETS): $(doc_texinfo_BUILDDIR)/%.html : $(doc_texinfo_SRCDIR)/%.texi
	$(MAKEINFO) $(MAKEINFO_HTML_FLAGS) -o $(@) $(<)

endif		# ds_config_ENABLE_HTML_DOC == yes

$(eval $(call ds-module-install-data,doc_texinfo_html,ds_config_ENABLE_DOC_HTML))

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Binary distribution.
## ------------------------------------------------------------

ifeq ($(strip $(nausicaa_COMPRESSOR)),bzip2)
bindist_PACKAGE_EXTENSION	= .tar.bz2
bindist_TAR_COMPRESS_FLAG	= --bzip2
else
bindist_PACKAGE_EXTENSION	= .tar.gz
bindist_TAR_COMPRESS_FLAG	= --gzip
endif

# This is the file  name of the binary distribution tarball.
# Notice that there is no directory part.
bindist_PACKAGE_NAME	= $(package_PREFIX)$(bindist_PACKAGE_EXTENSION)

# This is  the root directory for  temporary installation of
# files
bindist_PACKAGE_TOP_BUILDDIR	= $(TMPDIR)/$(PKG_ID)

# This is where the produced tarball will be finally stored.
bindist_BUILDDIR		= $(PWD)/$(builddir)/bindist.d

# This is the full pathname of the tarball.
bindist_TARBALL_PATHNAME	= $(bindist_BUILDDIR)/$(bindist_PACKAGE_NAME)

# The flags to hand to "tar" when building the tarball.
bindist_TAR_FLAGS		= --create $(bindist_TAR_COMPRESS_FLAG) --verbose

# By executing this command we get a list of the files in
# the bindist tarball.
bindist_LIST	= $(TAR) --list $(bindist_TAR_COMPRESS_FLAG) --file=$(bindist_TARBALL_PATHNAME)

## ------------------------------------------------------------

.PHONY: bindist bindist-clean bindist-builddir bindist-top-builddir
.PHONY: bindist-clean-top-builddir bindist-clean-builddir

bindist: bindist-clean bindist-builddir uninstall-script
	$(MAKE) install DESTDIR=$(bindist_PACKAGE_TOP_BUILDDIR)
	$(MAKE) uninstall-script-install DESTDIR=$(bindist_PACKAGE_TOP_BUILDDIR)
	cd $(bindist_PACKAGE_TOP_BUILDDIR); \
	$(TAR) $(bindist_TAR_FLAGS) --file=$(bindist_TARBALL_PATHNAME) .
	$(MAKE) bindist-clean-top-builddir

bindist-clean: bindist-clean-top-builddir bindist-clean-builddir

bindist-top-builddir:
	test -d $(bindist_PACKAGE_TOP_BUILDDIR) || $(MKDIR) $(bindist_PACKAGE_TOP_BUILDDIR)

bindist-clean-top-builddir:
	-$(RM) $(bindist_PACKAGE_TOP_BUILDDIR)

bindist-builddir:
	test -d $(bindist_BUILDDIR) || $(MKDIR) $(bindist_BUILDDIR)

bindist-clean-builddir:
	-$(RM) $(bindist_BUILDDIR)

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Slackware packaging: common variables.
## ------------------------------------------------------------

# This is  the file name  of the Slackware  package.  Notice
# that there is no directory part.
slack_PACKAGE_NAME	= $(package_PREFIX).tgz

# This  is the  package prefix,  it  is used  to remove  the
# package.
slack_PACKAGE_PREFIX	= $(package_PREFIX)

# This is  the root directory for  temporary installation of
# files.
slack_PACKAGE_TOP_BUILDDIR	= $(TMPDIR)/$(PKG_ID)

# This  is the  root directory  for building  packages.  The
# rules for standard packages will set it to:
#
#   $(slack_PACKAGE_TOP_BUILDDIR)
#
# the rules for local packages will set it to:
#
#   $(slack_PACKAGE_TOP_BUILDDIR)/$(prefix)
#
slack_PACKAGE_BUILDDIR	?=

# This is where the produced package will be finally stored.
slack_BUILDDIR		= $(PWD)/$(builddir)/slackware.d

# This is  the pathname of the  Slackware packages registry.
# The standard package rules will set it to:
#
#   $(slack_REGISTRY_DIR)
#
# while the local package rules will set it to:
#
#   $(prefix)$(slack_REGISTRY_DIR)
#
slack_REGISTRY		?= 
slack_REGISTRY_DIR	= /var/log/packages

# Try  to  read from  the  system  the  name of  an  already
# installed package.  It is used to upgrade.
slack_INSTALLED_PACKAGE	= \
	$(firstword $(notdir $(wildcard $(slack_REGISTRY)/$(package_NAME)-*)))

# This is the environment for the Slackware package handling
# tools.
slack_ENV		?=

slack_MAKEPKG_PROGRAM	= @slack_MAKEPKG_PROGRAM@
slack_MAKEPKG_FLAGS	?= --chown y
slack_MAKEPKG		= $(slack_ENV) $(slack_SUDO) $(slack_MAKEPKG_PROGRAM) $(slack_MAKEPKG_FLAGS)

slack_INSTALLPKG_PROGRAM= @slack_INSTALLPKG_PROGRAM@
slack_INSTALLPKG_FLAGS	?=
slack_INSTALLPKG	= $(slack_ENV) $(slack_SUDO) $(slack_INSTALLPKG_PROGRAM) $(slack_INSTALLPKG_FLAGS)

slack_REMOVEPKG_PROGRAM	= @slack_REMOVEPKG_PROGRAM@
slack_REMOVEPKG_FLAGS	?=
slack_REMOVEPKG		= $(slack_ENV) $(slack_SUDO) $(slack_REMOVEPKG_PROGRAM) $(slack_REMOVEPKG_FLAGS)

slack_UPGRADEPKG_PROGRAM= @slack_UPGRADEPKG_PROGRAM@
slack_UPGRADEPKG_FLAGS	?= --verbose --reinstall
slack_UPGRADEPKG	= $(slack_ENV) $(slack_SUDO) $(slack_UPGRADEPKG_PROGRAM) $(slack_UPGRADEPKG_FLAGS)

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Slackware packaging: private building rules.
## ------------------------------------------------------------

# The following rules are meant  to be invoked only by other
# rules.
#
# Notice  that,  by  default,  GNU tar  preserves  the  file
# modification times  so the FASL  times will be  newer than
# the corresponding .sls times in the Slackware package.

.PHONY: private-slackware        private-slackware-install
.PHONY: private-slackware-remove private-slackware-upgrade

private-slackware: slackware-clean slackware-builddir
	$(MAKE) install DESTDIR=$(slack_PACKAGE_TOP_BUILDDIR)
	$(INSTALL_DIR) $(slack_PACKAGE_BUILDDIR)/install
	$(INSTALL_DATA) $(builddir)/meta.d/slackware/slack-desc $(slack_PACKAGE_BUILDDIR)/install
	$(MAKE) slackware-aux
	cd $(slack_PACKAGE_BUILDDIR); \
	$(slack_MAKEPKG) $(slack_PACKAGE_NAME); \
	$(slack_SUDO) $(MV) $(slack_PACKAGE_NAME) $(slack_BUILDDIR)

private-slackware-install:
	cd $(slack_BUILDDIR); \
	$(slack_INSTALLPKG) $(slack_PACKAGE_NAME)

private-slackware-remove:
	$(slack_REMOVEPKG) $(slack_PACKAGE_PREFIX)

private-slackware-upgrade:
	cd $(slack_BUILDDIR); \
	$(slack_UPGRADEPKG) $(slack_INSTALLED_PACKAGE)%$(slack_PACKAGE_NAME)

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Slackware packaging: auxiliary rules.
## ------------------------------------------------------------

.PHONY: slackware-builddir slackware-aux

slackware-builddir:
	-test -d $(slack_BUILDDIR) || $(MKDIR) $(slack_BUILDDIR)

slackware-top-builddir:
	-test -d $(slack_PACKAGE_TOP_BUILDDIR) || $(MKDIR) $(slack_PACKAGE_TOP_BUILDDIR)

# This is for auxiliary rules: it is freely available to the
# user.  It  will be  invoked just before  running "makepkg"
# (see the 'slackware' rule).
slackware-aux:

## ------------------------------------------------------------

.PHONY: slackware-clean slackware-clean-top-builddir slackware-clean-builddir

slackware-clean: slackware-clean-top-builddir slackware-clean-builddir

slackware-clean-top-builddir:
	-$(slack_SUDO) $(RM) $(slack_PACKAGE_TOP_BUILDDIR)

slackware-clean-builddir:
	-$(slack_SUDO) $(RM) $(slack_BUILDDIR)

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Slackware packaging: standard package build.
## ------------------------------------------------------------

slackware_STANDARD_ENV	= \
	PATH=/sbin:$(PATH)					\
	slack_PACKAGE_BUILDDIR=$(slack_PACKAGE_TOP_BUILDDIR)	\
	slack_REGISTRY=$(slack_REGISTRY_DIR)

## ------------------------------------------------------------

.PHONY: slackware        slackware-install
.PHONY: slackware-remove slackware-upgrade

slackware:
	$(MAKE) private-slackware		$(slackware_STANDARD_ENV)
	$(MAKE) slackware-clean-top-builddir	$(slackware_STANDARD_ENV)

slackware-install:
	$(MAKE) private-slackware-install	$(slackware_STANDARD_ENV)

slackware-remove:
	$(MAKE) private-slackware-remove	$(slackware_STANDARD_ENV)

slackware-upgrade:
	$(MAKE) private-slackware-upgrade	$(slackware_STANDARD_ENV)

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## Slackware packaging: local package build.
## ------------------------------------------------------------

slackware_LOCAL_ENV	= \
	PATH=/sbin:$(PATH)						\
	slack_PACKAGE_BUILDDIR=$(slack_PACKAGE_TOP_BUILDDIR)/$(prefix)	\
	slack_REGISTRY=$(prefix)$(slack_REGISTRY_DIR)			\
	slack_ENV=ROOT=$(prefix)

## ------------------------------------------------------------

.PHONY: local-slackware        local-slackware-install
.PHONY: local-slackware-remove local-slackware-upgrade

local-slackware:
	$(MAKE) private-slackware		$(slackware_LOCAL_ENV)
	$(MAKE) slackware-clean-top-builddir	$(slackware_LOCAL_ENV)

local-slackware-install:
	$(MAKE) private-slackware-install	$(slackware_LOCAL_ENV)

local-slackware-remove:
	$(MAKE) private-slackware-remove	$(slackware_LOCAL_ENV)

local-slackware-upgrade:
	$(MAKE) private-slackware-upgrade	$(slackware_LOCAL_ENV)

## ------------------------------------------------------------

.PHONY: abi abu

abi:
	$(MAKE) all
	$(MAKE) local-slackware local-slackware-install slack_SUDO=$(SUDO)
abu:
	$(MAKE) all
	$(MAKE) local-slackware local-slackware-upgrade slack_SUDO=$(SUDO)


## ------------------------------------------------------------ 


#page
## ------------------------------------------------------------
## RedHat packaging: common variables.
## ------------------------------------------------------------

# This is the file name  of the RedHat package.  Notice that
# there is no directory part.
redhat_PACKAGE_NAME	= $(package_PREFIX).rpm

# This  is the  package prefix,  it  is used  to remove  the
# package.
redhat_PACKAGE_PREFIX	= $(package_PREFIX)

# This is  the root directory for  temporary installation of
# files.
redhat_PACKAGE_TOP_BUILDDIR	= $(TMPDIR)/$(PKG_ID)

# This is the root directory for building packages.
redhat_PACKAGE_BUILDDIR	?= $(redhat_PACKAGE_TOP_BUILDDIR)/BUILD

# This is where the produced package will be finally stored.
redhat_BUILDDIR		= $(PWD)/$(builddir)/redhat.d

# Try  to  read from  the  system  the  name of  an  already
# installed package.  It is used to upgrade.
redhat_INSTALLED_PACKAGE	=

## ------------------------------------------------------------

# This is the environment for the RedHat package handling
# tools.
redhat_ENV		?=

redhat_CORE_PROGRAM	= @redhat_CORE_PROGRAM@

redhat_BUILD_PROGRAM	= @redhat_BUILD_PROGRAM@
redhat_BUILD_FLAGS	= -v --buildroot $(redhat_PACKAGE_BUILDDIR) -bb
redhat_BUILD		= $(redhat_ENV) $(redhat_BUILD_PROGRAM) $(redhat_BUILD_FLAGS)


redhat_SPEC_FILE	= $(PKG_ID).spec
redhat_GENERIC_SPEC	= meta.d/redhat/spec-file
redhat_SPECIFIC_SPEC	= meta.d/redhat/$(redhat_SPEC_FILE)

## ------------------------------------------------------------

.PHONY: redhat

redhat: bindist redhat-clean
	$(INSTALL_DIR) $(redhat_PACKAGE_TOP_BUILDDIR)
	$(INSTALL_DIR) $(redhat_PACKAGE_TOP_BUILDDIR)/BUILD
	$(INSTALL_DIR) $(redhat_PACKAGE_TOP_BUILDDIR)/SPECS
	$(INSTALL_DIR) $(redhat_PACKAGE_TOP_BUILDDIR)/RPMS/i386
	$(INSTALL_DIR) $(redhat_PACKAGE_TOP_BUILDDIR)/RPMS/$(package_ARCH)
	$(CP) $(redhat_GENERIC_SPEC) $(redhat_SPECIFIC_SPEC)
	$(bindist_LIST) | \
	$(SED) -e 's%^\./%/%' -e '\%^/$$%d' \
		>> $(redhat_SPECIFIC_SPEC)
	$(INSTALL_DATA) $(redhat_SPECIFIC_SPEC) $(redhat_PACKAGE_TOP_BUILDDIR)/SPECS
	$(MAKE) install DESTDIR=$(redhat_PACKAGE_BUILDDIR)
	cd $(redhat_PACKAGE_TOP_BUILDDIR)/SPECS; $(redhat_BUILD) $(redhat_SPEC_FILE)

redhat-clean:
	-$(RM) $(redhat_PACKAGE_BUILDDIR)

## ------------------------------------------------------------ 

#page
## ------------------------------------------------------------
## End of makefile.
## ------------------------------------------------------------

.PHONY: echo-variable echo-list-variable

# Use this to echo a variable to stdout; example:
# 
#	$ make echo-variable VARIABLE=slack_PACKAGE_NAME
#
echo-variable:
	@echo $($(VARIABLE))

# Use this to  echo a variable to stdout  interpreting it as
# list of strings; example:
# 
#	$ make echo-list-variable VARIABLE=FILES
#
echo-list-variable:
	@$(foreach f,$($(VARIABLE)),echo $(f);)

## ------------------------------------------------------------ 



### end of file
