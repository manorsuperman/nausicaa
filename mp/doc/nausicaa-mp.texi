\input texinfo.tex
@c %**start of header
@setfilename nausicaa-mp.info
@settitle Nausicaa/MP
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro

@c ------------------------------------------------------------
@c Software related macros.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro mpfr{}
@acronym{MPFR}
@end macro

@macro mpfi{}
@acronym{MPFI}
@end macro

@macro mpc{}
@acronym{MPC}
@end macro

@macro mpfrcx{}
@acronym{MPFRCX}
@end macro

@macro mpfrx{}
@acronym{MPFRX}
@end macro

@macro mpcx{}
@acronym{MPCX}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@macro glibc{}
@gnu{} C Library
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Nausicaa/MP

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@acronym{MP}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-mp

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2008, 2009, 2010

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a set of
Scheme libraries implementing an interface to the following C language
libraries for multiple precision integers and floating--point numbers:

@table @asis
@item @gmp{}
GNU Multiple Precision arithmetic library.

@item @mpfr{}
Multiple Precision Floating--Point Reliable library.

@item @mpfi{}
Multiple Precision Floating--Point Interval library.

@item @mpc{}
Multiple Precision Complex library.

@item @mpfrcx{}
Multiple Precision Real and Complex Polynomial library.
@end table

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}); the project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/tree/master}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``@gnu{} Free
Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-mp: (nausicaa-mp).   Nausicaa/MP library for @rnrs{6} Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* constants::                   Constant values.
* accessors::                   Accessing foreign structures.
* gmp::                         Multiple precision integers.
* mpfr::                        Multiple precision reliable floats.
* mpfi::                        Multiple precision interval numbers.
* mpc::                         Multiple precision complex numbers.
* mpfrcx::                      Multiple precision polynomials.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Multiple precision integers

* gmp mpz::                     Multiple precision integers.
* gmp mpq::                     Multiple precision rationals.
* gmp mpf::                     Multiple precision floats.
* gmp random::                  Generating random integers.

Multiple precision integers

* gmp mpz basic::               Basic example.
* gmp mpz dynwind::             Using dynamic wind.
* gmp mpz compensations::       Compensating memory allocation.
* gmp mpz factory::             Object factory.
* gmp mpz string::              Conversion to string.

Multiple precision rationals

* gmp mpq basic::               Basic example.
* gmp mpq dynwind::             Using dynamic wind.
* gmp mpq compensations::       Compensating memory allocation.
* gmp mpq factory::             Object factory.
* gmp mpq string::              Conversion to string.

Multiple precision floats

* gmp mpf basic::               Basic example.
* gmp mpf dynwind::             Using dynamic wind.
* gmp mpf compensations::       Compensating memory allocation.
* gmp mpf factory::             Object factory.
* gmp mpf string::              Conversion to string.

Multiple precision reliable floats

* mpfr basic::                  Basic example.
* mpfr dynwind::                Using dynamic wind.
* mpfr compensations::          Compensating memory allocation.
* mpfr factory::                Object factory.
* mpfr string::                 Conversion to string.

Multiple precision interval numbers

* mpfi basic::                  Basic example.
* mpfi dynwind::                Using dynamic wind.
* mpfi compensations::          Compensating memory allocation.
* mpfi factory::                Object factory.
* mpfi string::                 Conversion to string.

Multiple precision complex numbers

* mpc basic::                  Basic example.
* mpc dynwind::                Using dynamic wind.
* mpc compensations::          Compensating memory allocation.
* mpc factory::                Object factory.
* mpc string::                 Conversion to string.

Multiple precision polynomials

* mpfrcx intro::                Introduction.
* mpfrcx init::                 Initialisation functions.
* mpfrcx basic::                Basic example.
* mpfrcx dynwind::              Using dynamic wind.
* mpfrcx compensations::        Compensating memory allocation.
* mpfrcx string::               Conversion to string.

@end detailmenu
@end menu

@end ifnottex

@c page
@node overview
@chapter Overview of the package


@value{PACKAGE} implements a binding to various multiple precision
numbers C language libraries for the Scheme implementations supported by
Nausicaa.  The bindings make use of the foreign--functions interface
from the Nausicaa/Scheme package.  The installed libraries are:

@example
(foreign math mp sizeof)
(foreign math mp mpz)
(foreign math mp mpq)
(foreign math mp mpf)
(foreign math mp mpfr)
(foreign math mp mpfi)
(foreign math mp mpc)
(foreign math mp mpfrcx)
(foreign math mp random)
@end example

The bindings attempt to be one--to--one maps between foreign functions
and Scheme functions, so the original documentation of the foreign
libraries applies to the bindings, too.

This document gives only a brief description of some functions, and
focuses on providing some usage example to get a feeling about how to
manage resources allocation in a Scheme program.

The original libraries can be found at the following sites (@aurl{} last
verified Mon Dec 21, 2009):

@center @url{http://gmplib.org/}

@center @url{http://www.mpfr.org/}

@center @url{http://gforge.inria.fr/projects/mpfi/}

@center @url{http://www.multiprecision.org/index.php?prog=mpc}

@center @url{http://www.multiprecision.org/index.php?prog=mpfrcx}

@c page
@node constants
@chapter Constant values


Unless otherwise specified, the following bindings are exported by the
@library{foreign math mp sizeof} library.


@defvr Constant sizeof-gmp_randalg_t
@defvrx Constant sizeof-gmp_randstate_t
@defvrx Constant sizeof-mp_exp_t
@defvrx Constant sizeof-mp_limb_t
@defvrx Constant sizeof-mp_prec_t
@defvrx Constant sizeof-mp_rnd_t
@defvrx Constant sizeof-mp_size_t
@defvrx Constant sizeof-mpc_t
@defvrx Constant sizeof-mpc_rnd_t
@defvrx Constant sizeof-mpf_t
@defvrx Constant sizeof-mpfi_t
@defvrx Constant sizeof-mpfr_prec_t
@defvrx Constant sizeof-mpfr_rnd_t
@defvrx Constant sizeof-mpfr_sign_t
@defvrx Constant sizeof-mpfr_t
@defvrx Constant sizeof-mpq_t
@defvrx Constant sizeof-mpz_t
@defvrx Constant sizeof-mpfrx_t
@defvrx Constant sizeof-mpcx_t
These variables hold the number of bytes required to store in memory the
named foreign data type.  For example @samp{sizeof-mpc_rnd_t} is the
number of bytes required to hold the @samp{mpc_rnd_t} type definition of
the @mpc{} library.

Of special importance are:

@example
sizeof-mpz_t
sizeof-mpq_t
sizeof-mpf_t
sizeof-mpfr_t
sizeof-mpfi_t
sizeof-mpc_t
sizeof-mpfrx_t
sizeof-mpcx_t
@end example

@noindent
which are the sizes of the data structures representing multiple
precision numbers and polynomials.
@end defvr


@defun sizeof-mpz_t-array @var{number-of-elements}
@defunx sizeof-mpq_t-array @var{number-of-elements}
@defunx sizeof-mpf_t-array @var{number-of-elements}
@defunx sizeof-mpfr_t-array @var{number-of-elements}
@defunx sizeof-mpfi_t-array @var{number-of-elements}
@defunx sizeof-mpc_t-array @var{number-of-elements}
@defunx sizeof-mpfrx_t-array @var{number-of-elements}
@defunx sizeof-mpcx_t-array @var{number-of-elements}
Return the size of the block of memory required to hold an array of the
named type and given number of elements.
@end defun


@defvr Constant alignof-gmp_randalg_t
@defvrx Constant alignof-gmp_randstate_t
@defvrx Constant alignof-mp_exp_t
@defvrx Constant alignof-mp_limb_t
@defvrx Constant alignof-mp_prec_t
@defvrx Constant alignof-mp_rnd_t
@defvrx Constant alignof-mp_size_t
@defvrx Constant alignof-mpc_t
@defvrx Constant alignof-mpc_rnd_t
@defvrx Constant alignof-mpf_t
@defvrx Constant alignof-mpfi_t
@defvrx Constant alignof-mpfr_prec_t
@defvrx Constant alignof-mpfr_rnd_t
@defvrx Constant alignof-mpfr_sign_t
@defvrx Constant alignof-mpfr_t
@defvrx Constant alignof-mpq_t
@defvrx Constant alignof-mpz_t
@defvrx Constant alignof-mpfrx_t
@defvrx Constant alignof-mpcx_t
Alignments of data types in data structures.
@end defvr


@defvr Constant strideof-gmp_randalg_t
@defvrx Constant strideof-gmp_randstate_t
@defvrx Constant strideof-mp_exp_t
@defvrx Constant strideof-mp_limb_t
@defvrx Constant strideof-mp_prec_t
@defvrx Constant strideof-mp_rnd_t
@defvrx Constant strideof-mp_size_t
@defvrx Constant strideof-mpc_t
@defvrx Constant strideof-mpc_rnd_t
@defvrx Constant strideof-mpf_t
@defvrx Constant strideof-mpfi_t
@defvrx Constant strideof-mpfr_prec_t
@defvrx Constant strideof-mpfr_rnd_t
@defvrx Constant strideof-mpfr_sign_t
@defvrx Constant strideof-mpfr_t
@defvrx Constant strideof-mpq_t
@defvrx Constant strideof-mpz_t
@defvrx Constant strideof-mpfrx_t
@defvrx Constant strideof-mpcx_t
Array stride of data types.
@end defvr


@defvr Constant GMP_RAND_ALG_DEFAULT
@defvrx Constant GMP_RAND_ALG_LC
@defvrx Constant GMP_RNDD
@defvrx Constant GMP_RNDN
@defvrx Constant GMP_RNDU
@defvrx Constant GMP_RNDZ
@defvrx Constant MPFI_FLAGS_BOTH_ENDPOINTS_EXACT
@defvrx Constant MPFI_FLAGS_BOTH_ENDPOINTS_INEXACT
@defvrx Constant MPFI_FLAGS_LEFT_ENDPOINT_INEXACT
@defvrx Constant MPFI_FLAGS_RIGHT_ENDPOINT_INEXACT
@defvrx Constant MPFR_EMAX_DEFAULT
@defvrx Constant MPFR_EMIN_DEFAULT
@defvrx Constant MPFR_PREC_MAX
@defvrx Constant MPFR_PREC_MIN
@defvrx Constant MPFR_VERSION
@defvrx Constant MPC_VERSION
These variables hold various constants required by the foreign
libraries.  Of special importance are the rounding modes for @mpfr{}:

@example
GMP_RNDN GMP_RNDD GMP_RNDU GMP_RNDZ
@end example
@end defvr


@deftp Constant MPC_RNDNN
@deftpx Constant MPC_RNDNZ
@deftpx Constant MPC_RNDNU
@deftpx Constant MPC_RNDND
@deftpx Constant MPC_RNDZN
@deftpx Constant MPC_RNDZZ
@deftpx Constant MPC_RNDZU
@deftpx Constant MPC_RNDZD
@deftpx Constant MPC_RNDUN
@deftpx Constant MPC_RNDUZ
@deftpx Constant MPC_RNDUU
@deftpx Constant MPC_RNDUD
@deftpx Constant MPC_RNDDN
@deftpx Constant MPC_RNDDZ
@deftpx Constant MPC_RNDDU
@deftpx Constant MPC_RNDDD
Rounding modes for @mpc{}.  These bindings are exported by the
@library{foreign math mp mpc} library.
@end deftp

@c page
@node accessors
@chapter Accessing foreign structures


The following syntaxes allow us to access fields of the multiple
precision numbers data structures; unles otherwise specified, they are
exported by @library{foreign math mp sizeof} library.

Notice that, with the exception of @mpfrcx{}, for normal usage of the
libraries, we are @strong{not} meant to use these accessors.


@deffn Syntax struct-mpq-num-ref @var{struct-pointer}
@deffnx Syntax struct-mpq-den-ref @var{struct-pointer}
Return a pointer referencing the numerator or denominator fields in a
@samp{mpq_t} number, which are @samp{mpz_t} numbers.
@end deffn


@deffn Syntax struct-mpfr-prec-set! @var{struct-pointer} @var{value}
@deffnx Syntax struct-mpfr-prec-ref @var{struct-pointer}
Accessors for the @samp{_mpfr_prec} field of @samp{mpfr_t}.
@end deffn

@deffn Syntax struct-mpfr-sign-set! @var{struct-pointer} @var{value}
@deffnx Syntax struct-mpfr-sign-ref @var{struct-pointer}
Accessors for the @samp{_mpfr_sign} field of @samp{mpfr_t}.
@end deffn


@deffn Syntax struct-mpfr-exp-set! @var{struct-pointer} @var{value}
@deffnx Syntax struct-mpfr-exp-ref @var{struct-pointer}
Accessors for the @samp{_mpfr_exp} field of @samp{mpfr_t}.
@end deffn


@deffn Syntax struct-mpfr-d-set! @var{struct-pointer} @var{value}
@deffnx Syntax struct-mpfr-d-ref @var{struct-pointer}
Accessors for the @samp{_mpfr_d} field of @samp{mpfr_t}.
@end deffn


@deffn Syntax struct-mpfi-left-ref @var{struct-pointer}
@deffnx Syntax struct-mpfi-right-ref @var{struct-pointer}
Return a pointer referencing the @samp{left} or @samp{right} fields in a
@samp{mpfi_t} structure.  These fields are structures of type
@samp{mpfr_t}.
@end deffn


@deffn Syntax struct-mpc-re-ref @var{struct-pointer}
@deffnx Syntax struct-mpc-im-ref @var{struct-pointer}
Return a pointer referencing the @samp{re} or @samp{im} fields in a
@samp{mpc_t} structure.  These fields are structures of type
@samp{mpfr_t}.
@end deffn


@deffn Syntax struct-mpcx_t-size-set! @var{pointer} @var{value}
@deffnx Syntax struct-mpcx_t-size-ref @var{pointer}
@deffnx Syntax struct-mpcx_t-deg-set! @var{pointer} @var{value}
@deffnx Syntax struct-mpcx_t-deg-ref @var{pointer}
@deffnx Syntax struct-mpcx_t-prec-set! @var{pointer} @var{value}
@deffnx Syntax struct-mpcx_t-prec-ref @var{pointer}
@deffnx Syntax struct-mpcx_t-coeff-set! @var{pointer} @var{value}
@deffnx Syntax struct-mpcx_t-coeff-ref @var{pointer}
Accessors and mutators for the fields of a @code{mpcx_t} type.
@end deffn


@deffn Syntax struct-mpfrx_t-size-set! @var{pointer} @var{value}
@deffnx Syntax struct-mpfrx_t-size-ref @var{pointer}
@deffnx Syntax struct-mpfrx_t-deg-set! @var{pointer} @var{value}
@deffnx Syntax struct-mpfrx_t-deg-ref @var{pointer}
@deffnx Syntax struct-mpfrx_t-prec-set! @var{pointer} @var{value}
@deffnx Syntax struct-mpfrx_t-prec-ref @var{pointer}
@deffnx Syntax struct-mpfrx_t-coeff-set! @var{pointer} @var{value}
@deffnx Syntax struct-mpfrx_t-coeff-ref @var{pointer}
Accessors and mutators for the fields of a @code{mpfrx_t} type.
@end deffn


@deffn Syntax struct-mpfrx_t-coeff-ptr-ref @var{pointer} @var{index}
@deffnx Syntax struct-mpcx_t-coeff-ptr-ref @var{pointer} @var{index}
Given a @var{pointer} to the array of coefficients, return a pointer to
the coefficient at @var{index}.  These bindings are exported by the
@library{foreign math mp mpfrcx} library.
@end deffn


@deffn Syntax array-ref-c-mpz_t @ameta{pointer} @ameta{index}
@deffnx Syntax array-ref-c-mpq_t @ameta{pointer} @ameta{index}
@deffnx Syntax array-ref-c-mpf_t @ameta{pointer} @ameta{index}
@deffnx Syntax array-ref-c-mpfr_t @ameta{pointer} @ameta{index}
@deffnx Syntax array-ref-c-mpc_t @ameta{pointer} @ameta{index}
@deffnx Syntax array-ref-c-mpfi_t @ameta{pointer} @ameta{index}
@deffnx Syntax array-ref-c-mpfrx_t @ameta{pointer} @ameta{index}
@deffnx Syntax array-ref-c-mpcx_t @ameta{pointer} @ameta{index}
Return pointer to the element at @meta{index} in the array referenced by
@meta{pointer}.
@end deffn


@deffn Syntax sizeof-mpz_t-array @ameta{number-of-elements}
@deffnx Syntax sizeof-mpq_t-array @ameta{number-of-elements}
@deffnx Syntax sizeof-mpf_t-array @ameta{number-of-elements}
@deffnx Syntax sizeof-mpfr_t-array @ameta{number-of-elements}
@deffnx Syntax sizeof-mpc_t-array @ameta{number-of-elements}
@deffnx Syntax sizeof-mpfi_t-array @ameta{number-of-elements}
@deffnx Syntax sizeof-mpfrx_t-array @ameta{number-of-elements}
@deffnx Syntax sizeof-mpcx_t-array @ameta{number-of-elements}
Return the number of bytes required to hold an array of
@meta{number-of-elements} of the specified structures.
@end deffn

@c page
@node gmp
@chapter Multiple precision integers


The @gmp{} library implements multiple precision integers, rational
numbers and basic floating point numbers.

@menu
* gmp mpz::                     Multiple precision integers.
* gmp mpq::                     Multiple precision rationals.
* gmp mpf::                     Multiple precision floats.
* gmp random::                  Generating random integers.
@end menu

@c page
@node gmp mpz
@section Multiple precision integers


The integer numbers @api{} is exported by the @library{foreign math mp
mpz} library.  We discuss multiple ways to handle memory allocation.

@menu
* gmp mpz basic::               Basic example.
* gmp mpz dynwind::             Using dynamic wind.
* gmp mpz compensations::       Compensating memory allocation.
* gmp mpz factory::             Object factory.
* gmp mpz string::              Conversion to string.
@end menu

@c page
@node gmp mpz basic
@subsection Basic example


To use @samp{mpz_t} numbers we basically have to do:

@example
(import (rnrs)
  (foreign memory)
  (foreign math mp mpz)
  (foreign math mp sizeof))

(let ((a (malloc sizeof-mpz_t))
      (b (malloc sizeof-mpz_t))
      (c (malloc sizeof-mpz_t)))
  (mpz_init a)
  (mpz_init b)
  (mpz_init c)

  (mpz_set_si a 10)
  (mpz_set_si b 5)
  (mpz_add c a b)

  (mpz_clear a)
  (mpz_clear b)
  (primitive-free a)
  (primitive-free b)

  (do-something-with c)

  (mpz_clear c)
  (primitive-free c))
@end example

@c page
@node gmp mpz dynwind
@subsection Using dynamic wind


Scheme provides the @func{dynamic-wind} syntax to allow evaluation of
@dfn{in guard} and @dfn{out guard} thunks for each evaluation of a third
``body'' thunk.  We can leverage this mechanism to handle safe
allocation and release of @samp{mpz_t} numbers as follows:

@example
(let ((A #f))
  (dynamic-wind
      (lambda ()
        (set! A (malloc sizeof-mpz_t))
        (mpz_init A))
      (lambda ()
        (do-something-with A))
      (lambda ()
        (mpz_clear A)
        (primitive-free A))))
@end example

@noindent
of course we can wrap this mechanism into a macro:

@example
(define-syntax with-mpz
  (syntax-rules ()
    ((_ () ?form0 ?form ...)
     (begin ?form0 ?form ...))
    ((_ (?id0 ?id ...) ?form0 ?form ...)
     (let ((?id0 #f))
       (dynamic-wind
           (lambda ()
             (set! ?id0 (malloc sizeof-mpz_t))
             (mpz_init ?id0))
           (lambda ()
             (with-mpz (?id ...) ?form0 ?form ...))
           (lambda ()
             (mpz_clear ?id0)
             (primitive-free ?id0)))))))
@end example

@noindent
with which we can do:

@example
(with-mpz (a b c)
  (mpz_set_si a 10)
  (mpz_set_si b 5)
  (mpz_add c a b)
  (do-something-with c))
@end example

@c page
@node gmp mpz compensations
@subsection Compensating memory allocation


The @library{compensations} library from Nausicaa/Scheme exports the
compensation stacks @api{} as a mean to automatically release
synchronous resources, even in case of raised exceptions.
@nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpz)
  (foreign math mp sizeof))
@end example

@noindent
to allocate a @samp{mpz_t} number with a compensation we can use the
following function:

@example
(define (mpz/c)
  (letrec ((p (compensate
                  ;; "p" is not yet bound here
                  (malloc sizeof-mpz_t)
                (with
                 (mpz_clear p)
                 (primitive-free p)))))
    (mpz_init p)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(with-compensations
  (let ((c (mpz/c)))
    (with-compensations
      (let ((a (mpz/c))
            (b (mpz/c)))
        (mpz_set_si a 10)
        (mpz_set_si b 5)
        (mpz_add c a b)))
    (do-something-with c)))
@end example

The advantage of compensations, over the @func{dynamic-wind} solution,
is that we can nest at will allocation of numbers, without keeping track
of them in an enclosing form.

@c page
@node gmp mpz factory
@subsection Object factory


The @library{foreign memory} library from Nausicaa/Scheme exports the
object factory @api{} as a mean to automatically allocate, initialise,
finalise and release synchronous resources, even in case of raised
exceptions.  @nauref{memory cache, Caching memory blocks}

We can use this library along with the @library{compensations} library
also from Nausicaa/Scheme.  @nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpz)
  (foreign math mp sizeof))
@end example

@noindent
we can define an object factory for @samp{mpz_t} numbers with:

@example
(define mpz-factory
  (make-caching-object-factory mpz_init mpz_clear
                               sizeof-mpz_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpz)
  (letrec ((p (compensate
                  (mpz-factory)
                (with
                 (mpz-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
  (let ((c (mpz)))

    (with-compensations
      (let ((a (mpz))
            (b (mpz)))
        (mpz_set_si a 10)
        (mpz_set_si b 5)
        (mpz_add c a b)))

    (do-something-with c)))
@end example

The advantage of factories, over plain compensations, is that a factory
caches allocated memory blocks.

@c page
@node gmp mpz string
@subsection Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @samp{mpz_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (foreign memory)
  (foreign cstrings)
  (foreign math mp mpz))
@end example

@noindent
the following function does a basic conversion from an @samp{mpz_t} to a
string:

@example
(define (mpz->string o)
  (let ((str #f))
    (dynamic-wind
        (lambda ()
          (set! str (mpz_get_str pointer-null 10 o)))
        (lambda ()
          (cstring->string str))
        (lambda ()
          (primitive-free str)))))
@end example

@noindent
where using @samp{pointer-null} as first argument to @func{mpz_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which default to the standard C language functions).

@c page
@node gmp mpq
@section Multiple precision rationals


The rational numbers @api{} is exported by the @library{foreign math mp
mpq} library.  We discuss multiple ways to handle memory allocation.

@menu
* gmp mpq basic::               Basic example.
* gmp mpq dynwind::             Using dynamic wind.
* gmp mpq compensations::       Compensating memory allocation.
* gmp mpq factory::             Object factory.
* gmp mpq string::              Conversion to string.
@end menu

@c page
@node gmp mpq basic
@subsection Basic example


To use @samp{mpq_t} numbers we basically have to do:

@example
(import (rnrs)
  (foreign memory)
  (foreign math mp mpq)
  (foreign math mp sizeof))

(let ((a (malloc sizeof-mpq_t))
      (b (malloc sizeof-mpq_t))
      (c (malloc sizeof-mpq_t)))
  (mpq_init a)
  (mpq_init b)
  (mpq_init c)

  (mpq_set_si a 6 10)
  (mpq_canonicalize a)
  (mpq_set_si b 6 5)
  (mpq_add c a b)

  (mpq_clear a)
  (mpq_clear b)
  (primitive-free a)
  (primitive-free b)

  (do-something-with c)

  (mpq_clear c)
  (primitive-free c))
@end example

@noindent
where the first argument to @func{mpq_set_si} is the numerator, the
second is the denominator.

@c page
@node gmp mpq dynwind
@subsection Using dynamic wind


Scheme provides the @func{dynamic-wind} syntax to allow evaluation of
@dfn{in guard} and @dfn{out guard} thunks for each evaluation of a third
``body'' thunk.  We can leverage this mechanism to handle safe
allocation and release of @samp{mpq_t} numbers as follows:

@example
(let ((A #f))
  (dynamic-wind
      (lambda ()
        (set! A (malloc sizeof-mpq_t))
        (mpq_init A))
      (lambda ()
        (do-something-with A))
      (lambda ()
        (mpq_clear A)
        (primitive-free A))))
@end example

@noindent
of course we can wrap this mechanism into a macro:

@example
(define-syntax with-mpq
  (syntax-rules ()
    ((_ () ?form0 ?form ...)
     (begin ?form0 ?form ...))
    ((_ (?id0 ?id ...) ?form0 ?form ...)
     (let ((?id0 #f))
       (dynamic-wind
           (lambda ()
             (set! ?id0 (malloc sizeof-mpq_t))
             (mpq_init ?id0))
           (lambda ()
             (with-mpq (?id ...) ?form0 ?form ...))
           (lambda ()
             (mpq_clear ?id0)
             (primitive-free ?id0)))))))
@end example

@noindent
with which we can do:

@example
(with-mpq (a b c)
  (mpq_set_si a 6 10)
  (mpq_canonicalize a)
  (mpq_set_si b 6 5)
  (mpq_add c a b)
  (do-something-with c))
@end example

@c page
@node gmp mpq compensations
@subsection Compensating memory allocation


The @library{compensations} library from Nausicaa/Scheme exports the
compensation stacks @api{} as a mean to automatically release
synchronous resources, even in case of raised exceptions.
@nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpq)
  (foreign math mp sizeof))
@end example

@noindent
to allocate a @samp{mpq_t} number with a compensation we can use the
following function:

@example
(define (mpq/c)
  (letrec ((p (compensate
                   ;; "p" is not yet bound here
                   (malloc sizeof-mpq_t)
                (with
                 (mpq_clear p)
                 (primitive-free p)))))
    (mpq_init p)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(with-compensations
  (let ((c (mpq/c)))

    (with-compensations
      (let ((a (mpq/c))
            (b (mpq/c)))
        (mpq_set_si a 6 10)
        (mpq_canonicalize a)
        (mpq_set_si b 6 5)
        (mpq_add c a b)))

    (do-something-with c)))
@end example

The advantage of compensations, over the @func{dynamic-wind} solution,
is that we can nest at will allocation of numbers, without keeping track
of them in an enclosing form.

@c page
@node gmp mpq factory
@subsection Object factory


The @library{foreign memory} library from Nausicaa/Scheme exports the
object factory @api{} as a mean to automatically allocate, initialise,
finalise and release synchronous resources, even in case of raised
exceptions.  @nauref{memory cache, Caching memory blocks}

We can use this library along with the @library{compensations} library
also from Nausicaa/Scheme.  @nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpq)
  (foreign math mp sizeof))
@end example

@noindent
we can define an object factory for @samp{mpq_t} numbers with:

@example
(define mpq-factory
  (make-caching-object-factory mpq_init mpq_clear
                               sizeof-mpq_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpq)
  (letrec ((p (compensate
                  (mpq-factory)
                (with
                 (mpq-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
   (let ((c (mpq))
         (a (mpq))
         (b (mpq)))
     (mpq_set_si a 6 10)
     (mpq_canonicalize a)
     (mpq_set_si b 6 5)
     (mpq_add c a b)
     (do-something-with c)))
@end example

The advantage of factories, over plain compensations, is that a factory
caches allocated memory blocks.

@c page
@node gmp mpq string
@subsection Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @samp{mpq_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (foreign memory)
  (foreign cstrings)
  (foreign math mp mpq))
@end example

@noindent
the following function does a basic conversion from an @samp{mpq_t} to a
string:

@example
(define (mpq->string o)
  (let ((str #f))
    (dynamic-wind
        (lambda ()
          (set! str (mpq_get_str pointer-null 10 o)))
        (lambda ()
          (cstring->string str))
        (lambda ()
          (primitive-free str)))))
@end example

@noindent
where using @samp{pointer-null} as first argument to @func{mpq_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which default to the standard C language functions).

@c page
@node gmp mpf
@section Multiple precision floats


The floating point numbers @api{} is exported by the @library{foreign
math mp mpf} library.  We discuss multiple ways to handle memory
allocation.

@menu
* gmp mpf basic::               Basic example.
* gmp mpf dynwind::             Using dynamic wind.
* gmp mpf compensations::       Compensating memory allocation.
* gmp mpf factory::             Object factory.
* gmp mpf string::              Conversion to string.
@end menu

@c page
@node gmp mpf basic
@subsection Basic example


To use @samp{mpf_t} numbers we basically have to do:

@example
(import (rnrs)
  (foreign memory)
  (foreign math mp mpf)
  (foreign math mp sizeof))

(let ((a (malloc sizeof-mpf_t))
      (b (malloc sizeof-mpf_t))
      (c (malloc sizeof-mpf_t)))
  (mpf_init a)
  (mpf_init b)
  (mpf_init c)

  (mpf_set_si a 10)
  (mpf_set_si b 5)
  (mpf_add c a b)

  (mpf_clear a)
  (mpf_clear b)
  (primitive-free a)
  (primitive-free b)

  (do-something-with c)

  (mpf_clear c)
  (primitive-free c))
@end example

@c page
@node gmp mpf dynwind
@subsection Using dynamic wind


Scheme provides the @func{dynamic-wind} syntax to allow evaluation of
@dfn{in guard} and @dfn{out guard} thunks for each evaluation of a third
``body'' thunk.  We can leverage this mechanism to handle safe
allocation and release of @samp{mpf_t} numbers as follows:

@example
(let ((A #f))
  (dynamic-wind
      (lambda ()
        (set! A (malloc sizeof-mpf_t))
        (mpf_init A))
      (lambda ()
        (do-something-with A))
      (lambda ()
        (mpf_clear A)
        (primitive-free A))))
@end example

@noindent
of course we can wrap this mechanism into a macro:

@example
(define-syntax with-mpf
  (syntax-rules ()
    ((_ () ?form0 ?form ...)
     (begin ?form0 ?form ...))
    ((_ (?id0 ?id ...) ?form0 ?form ...)
     (let ((?id0 #f))
       (dynamic-wind
           (lambda ()
             (set! ?id0 (malloc sizeof-mpf_t))
             (mpf_init ?id0))
           (lambda ()
             (with-mpf (?id ...) ?form0 ?form ...))
           (lambda ()
             (mpf_clear ?id0)
             (primitive-free ?id0)))))))
@end example

@noindent
with which we can do:

@example
(with-mpf (a b c)
  (mpf_set_si a 10)
  (mpf_set_si b 5)
  (mpf_add c a b)
  (do-something-with c))
@end example

@c page
@node gmp mpf compensations
@subsection Compensating memory allocation


The @library{compensations} library from Nausicaa/Scheme exports the
compensation stacks @api{} as a mean to automatically release
synchronous resources, even in case of raised exceptions.
@nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpf)
  (foreign math mp sizeof))
@end example

@noindent
to allocate a @samp{mpf_t} number with a compensation we can use the
following function:

@example
(define (mpf/c)
  (letrec ((p (compensate
                  ;; "p" is not yet bound here
                  (malloc sizeof-mpf_t)
                (with
                 (mpf_clear p)
                 (primitive-free p)))))
    (mpf_init p)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(with-compensations
  (let ((c (mpf/c)))
    (with-compensations
      (let ((a (mpf/c))
            (b (mpf/c)))
        (mpf_set_si a 10)
        (mpf_set_si b 5)
        (mpf_add c a b)))
    (do-something-with c)))
@end example

The advantage of compensations, over the @func{dynamic-wind} solution,
is that we can nest at will allocation of numbers, without keeping track
of them in an enclosing form.

@c page
@node gmp mpf factory
@subsection Object factory


The @library{foreign memory} library from Nausicaa/Scheme exports the
object factory @api{} as a mean to automatically allocate, initialise,
finalise and release synchronous resources, even in case of raised
exceptions.  @nauref{memory cache, Caching memory blocks}

We can use this library along with the @library{compensations} library
also from Nausicaa/Scheme.  @nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpf)
  (foreign math mp sizeof))
@end example

@noindent
we can define an object factory for @samp{mpf_t} numbers with:

@example
(define mpf-factory
  (make-caching-object-factory mpf_init mpf_clear
                               sizeof-mpf_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpf)
  (letrec ((p (compensate
                  (mpf-factory)
                (with
                 (mpf-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
  (let ((c (mpf)))

    (with-compensations
      (let ((a (mpf))
            (b (mpf)))
        (mpf_set_si a 10)
        (mpf_set_si b 5)
        (mpf_add c a b)))

    (do-something-with c)))
@end example

The advantage of factories, over plain compensations, is that a factory
caches allocated memory blocks.

@c page
@node gmp mpf string
@subsection Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @samp{mpf_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign cstrings)
  (foreign math mp mpf))
@end example

@noindent
the following function does a basic conversion from an @samp{mpf_t} to a
string:

@example
(define (mpf->string o)
  (with-compensations
    (letrec*
        ((l     (malloc-small/c))
         (str   (compensate
                    (mpf_get_str pointer-null l 10 0 o)
                  (with
                   (primitive-free str))))
         (s     (cstring->string str))
         (x     (let ((x (pointer-ref-c-signed-long l 0)))
                  (if (char=? #\- (string-ref s 0))
                      (+ 1 x)
                    x)))
         (i     (substring s 0 x))
         (f     (substring s x (strlen str))))
      (string-append i "." f))))
@end example

@noindent
where using @samp{pointer-null} as first argument to @func{mpf_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which default to the standard C language functions).

@c page
@node gmp random
@section Generating random integers


@gmp{} exports an @api{} to generate random unsigned integers of type
@samp{unsigned long}; the @library{foreign math mp random} library
exports an @api{} for this feature.

As a usage example, let's start a program with:

@example
(import (rnrs)
  (begin0)
  (compensations)
  (foreign memory)
  (foreign math mp random)
  (foreign math mp sizeof))
@end example

@noindent
then, using compensations to handle the randomness state:

@example
(with-compensations
  (letrec
      ((state (compensate
                  (malloc sizeof-gmp_randstate_t)
                (with
                 (gmp_randclear state)
                 (primitive-free state)))))
    (gmp_randinit_default state)
    (gmp_randseed_ui state 123)
    (gmp_urandomb_ui state 10)
    (gmp_urandomm_ui state 10)))
@end example

@c page
@node mpfr
@chapter Multiple precision reliable floats


The reliable floating point numbers @api{} is exported by the
@library{foreign math mp mpfr} library.  We discuss multiple ways to
handle memory allocation.

@menu
* mpfr basic::                  Basic example.
* mpfr dynwind::                Using dynamic wind.
* mpfr compensations::          Compensating memory allocation.
* mpfr factory::                Object factory.
* mpfr string::                 Conversion to string.
@end menu

@c page
@node mpfr basic
@section Basic example


To use @samp{mpfr_t} numbers we basically have to do:

@example
(import (rnrs)
  (foreign memory)
  (foreign math mp mpfr)
  (foreign math mp sizeof))

(let ((a (malloc sizeof-mpfr_t))
      (b (malloc sizeof-mpfr_t))
      (c (malloc sizeof-mpfr_t)))
  (mpfr_init a)
  (mpfr_init b)
  (mpfr_init c)

  (mpfr_set_d  a 10.4 GMP_RNDN)
  (mpfr_set_si b  5   GMP_RNDN)
  (mpfr_add c  a  b   GMP_RNDN)

  (mpfr_clear a)
  (mpfr_clear b)
  (primitive-free a)
  (primitive-free b)

  (do-something-with c)

  (mpfr_clear c)
  (primitive-free c))
@end example

@c page
@node mpfr dynwind
@section Using dynamic wind


Scheme provides the @func{dynamic-wind} syntax to allow evaluation of
@dfn{in guard} and @dfn{out guard} thunks for each evaluation of a third
``body'' thunk.  We can leverage this mechanism to handle safe
allocation and release of @samp{mpfr_t} numbers as follows:

@example
(let ((A #f))
  (dynamic-wind
      (lambda ()
        (set! A (malloc sizeof-mpfr_t))
        (mpfr_init A))
      (lambda ()
        (do-something-with A))
      (lambda ()
        (mpfr_clear A)
        (primitive-free A))))
@end example

@noindent
of course we can wrap this mechanism into a macro:

@example
(define-syntax with-mpfr
  (syntax-rules ()
    ((_ () ?form0 ?form ...)
     (begin ?form0 ?form ...))
    ((_ (?id0 ?id ...) ?form0 ?form ...)
     (let ((?id0 #f))
       (dynamic-wind
           (lambda ()
             (set! ?id0 (malloc sizeof-mpfr_t))
             (mpfr_init ?id0))
           (lambda ()
             (with-mpfr (?id ...) ?form0 ?form ...))
           (lambda ()
             (mpfr_clear ?id0)
             (primitive-free ?id0)))))))
@end example

@noindent
with which we can do:

@example
(with-mpfr (a b c)
  (mpfr_set_d  a 10.4 GMP_RNDN)
  (mpfr_set_si b  5   GMP_RNDN)
  (mpfr_add c  a  b   GMP_RNDN)
  (do-something-with c))
@end example

@c page
@node mpfr compensations
@section Compensating memory allocation


The @library{compensations} library from Nausicaa/Scheme exports the
compensation stacks @api{} as a mean to automatically release
synchronous resources, even in case of raised exceptions.
@nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpfr)
  (foreign math mp sizeof))
@end example

@noindent
to allocate a @samp{mpfr_t} number with a compensation we can use the
following function:

@example
(define (mpfr/c)
  (letrec ((p (compensate
                  ;; "p" is not yet bound here
                  (malloc sizeof-mpfr_t)
                (with
                 (mpfr_clear p)
                 (primitive-free p)))))
    (mpfr_init p)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(with-compensations
  (let ((c (mpfr/c)))
    (with-compensations
      (let ((a (mpfr/c))
            (b (mpfr/c)))
        (mpfr_set_d  a 10.4 GMP_RNDN)
        (mpfr_set_si b  5   GMP_RNDN)
        (mpfr_add c  a  b   GMP_RNDN)))
    (do-something-with c)))
@end example

The advantage of compensations, over the @func{dynamic-wind} solution,
is that we can nest at will allocation of numbers, without keeping track
of them in an enclosing form.

@c page
@node mpfr factory
@section Object factory


The @library{foreign memory} library from Nausicaa/Scheme exports the
object factory @api{} as a mean to automatically allocate, initialise,
finalise and release synchronous resources, even in case of raised
exceptions.  @nauref{memory cache, Caching memory blocks}

We can use this library along with the @library{compensations} library
also from Nausicaa/Scheme.  @nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpfr)
  (foreign math mp sizeof))
@end example

@noindent
we can define an object factory for @samp{mpfr_t} numbers with:

@example
(define mpfr-factory
  (make-caching-object-factory mpfr_init mpfr_clear
                               sizeof-mpfr_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpfr)
  (letrec ((p (compensate
                  (mpfr-factory)
                (with
                 (mpfr-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
  (let ((c (mpfr)))

    (with-compensations
      (let ((a (mpfr))
            (b (mpfr)))
        (mpfr_set_d  a 10.4 GMP_RNDN)
        (mpfr_set_si b  5   GMP_RNDN)
        (mpfr_add c  a  b   GMP_RNDN)))

    (do-something-with c)))
@end example

The advantage of factories, over plain compensations, is that a factory
caches allocated memory blocks.

@c page
@node mpfr string
@section Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @samp{mpfr_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (foreign memory)
  (foreign cstrings)
  (foreign math mp mpfr))
@end example

@noindent
the following function does a basic conversion from an @samp{mpfr_t} to a
string:

@example
(define (mpfr->string o)
  (with-compensations
    (letrec*
        ((l (malloc-small/c))
         (str (compensate
                  (mpfr_get_str pointer-null l 10 0 o GMP_RNDN)
                (with
                 (primitive-free str))))
         (s (cstring->string str))
         (x (let ((x (pointer-ref-c-signed-long l 0)))
              (if (char=? #\- (string-ref s 0))
                  (+ 1 x)
                x)))
         (i (substring s 0 x))
         (f (substring s x (strlen str))))
      (string-append i "." f))))
@end example

@noindent
where using @samp{pointer-null} as first argument to @func{mpfr_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which default to the standard C language functions).

@c page
@node mpfi
@chapter Multiple precision interval numbers


The interval floating point numbers @api{} is exported by the
@library{foreign math mp mpfi} library.  We discuss multiple ways to
handle memory allocation.

@menu
* mpfi basic::                  Basic example.
* mpfi dynwind::                Using dynamic wind.
* mpfi compensations::          Compensating memory allocation.
* mpfi factory::                Object factory.
* mpfi string::                 Conversion to string.
@end menu

@c page
@node mpfi basic
@section Basic example


To use @samp{mpfi_t} numbers we basically have to do:

@example
(import (rnrs)
  (foreign memory)
  (foreign mp mpfi)
  (foreign mp sizeof))

(let ((a (malloc sizeof-mpfi_t))
      (b (malloc sizeof-mpfi_t))
      (c (malloc sizeof-mpfi_t)))
  (mpfi_init a)
  (mpfi_init b)
  (mpfi_init c)

  (mpfi_set_d  a 10.4)
  (mpfi_set_si b  5)
  (mpfi_add c  a  b)

  (mpfi_clear a)
  (mpfi_clear b)
  (primitive-free a)
  (primitive-free b)

  (do-something-with c)

  (mpfi_clear c)
  (primitive-free c))
@end example

@c page
@node mpfi dynwind
@section Using dynamic wind


Scheme provides the @func{dynamic-wind} syntax to allow evaluation of
@dfn{in guard} and @dfn{out guard} thunks for each evaluation of a third
``body'' thunk.  We can leverage this mechanism to handle safe
allocation and release of @samp{mpfi_t} numbers as follows:

@example
(let ((A #f))
  (dynamic-wind
      (lambda ()
        (set! A (malloc sizeof-mpfi_t))
        (mpfi_init A))
      (lambda ()
        (do-something-with A))
      (lambda ()
        (mpfi_clear A)
        (primitive-free A))))
@end example

@noindent
of course we can wrap this mechanism into a macro:

@example
(define-syntax with-mpfi
  (syntax-rules ()
    ((_ () ?form0 ?form ...)
     (begin ?form0 ?form ...))
    ((_ (?id0 ?id ...) ?form0 ?form ...)
     (let ((?id0 #f))
       (dynamic-wind
           (lambda ()
             (set! ?id0 (malloc sizeof-mpfi_t))
             (mpfi_init ?id0))
           (lambda ()
             (with-mpfi (?id ...) ?form0 ?form ...))
           (lambda ()
             (mpfi_clear ?id0)
             (primitive-free ?id0)))))))
@end example

@noindent
with which we can do:

@example
(with-mpfi (a b c)
  (mpfi_set_d  a 10.4)
  (mpfi_set_si b  5)
  (mpfi_add c  a  b)
  (do-something-with c))
@end example

@c page
@node mpfi compensations
@section Compensating memory allocation


The @library{compensations} library from Nausicaa/Scheme exports the
compensation stacks @api{} as a mean to automatically release
synchronous resources, even in case of raised exceptions.
@nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpfi)
  (foreign math mp sizeof))
@end example

@noindent
to allocate a @samp{mpfi_t} number with a compensation we can use the
following function:

@example
(define (mpfi/c)
  (letrec ((p (compensate
                  ;; "p" is not yet bound here
                  (malloc sizeof-mpfi_t)
                (with
                 (mpfi_clear p)
                 (primitive-free p)))))
    (mpfi_init p)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(with-compensations
  (let ((c (mpfi/c)))
    (with-compensations
      (let ((a (mpfi/c))
            (b (mpfi/c)))
        (mpfi_set_d  a 10.4)
        (mpfi_set_si b  5)
        (mpfi_add c  a  b)))
    (do-something-with c)))
@end example

The advantage of compensations, over the @func{dynamic-wind} solution,
is that we can nest at will allocation of numbers, without keeping track
of them in an enclosing form.

@c page
@node mpfi factory
@section Object factory


The @library{foreign memory} library from Nausicaa/Scheme exports the
object factory @api{} as a mean to automatically allocate, initialise,
finalise and release synchronous resources, even in case of raised
exceptions.  @nauref{memory cache, Caching memory blocks}

We can use this library along with the @library{compensations} library
also from Nausicaa/Scheme.  @nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpfi)
  (foreign math mp sizeof))
@end example

@noindent
we can define an object factory for @samp{mpfi_t} numbers with:

@example
(define mpfi-factory
  (make-caching-object-factory mpfi_init mpfi_clear
                               sizeof-mpfi_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpfi)
  (letrec ((p (compensate
                  (mpfi-factory)
                (with
                 (mpfi-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
  (let ((c (mpfi)))

    (with-compensations
      (let ((a (mpfi))
            (b (mpfi)))
        (mpfi_set_d  a 10.4)
        (mpfi_set_si b  5)
        (mpfi_add c  a  b)))

    (do-something-with c)))
@end example

The advantage of factories, over plain compensations, is that a factory
caches allocated memory blocks.

@c page
@node mpfi string
@section Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @samp{mpfi_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (formations)
  (foreign memory)
  (foreign cstrings)
  (foreign math mp mpfi))
@end example

@noindent
the following function does a basic conversion from an @samp{mpfi_t} to a
string:

@example
(define mpfr->string
  (case-lambda
   ((o)
    (mpfr->string o 5))
   ((o digits)
    (with-compensations
      (letrec*
          ((l (malloc-small/c))
           (str (compensate
                    (mpfr_get_str pointer-null l 10 0 o GMP_RNDN)
                  (with
                   (primitive-free str))))
           (s (cstring->string str))
           (x (let ((x (pointer-ref-c-signed-long l 0)))
                (if (char=? #\- (string-ref s 0))
                    (+ 1 x)
                  x)))
           (i (substring s 0 x))
           (f (substring s x (strlen str))))
        (substring (string-append i "." f) 0 digits))))))

(define mpfi->string-interval
  (case-lambda
   ((o)
    (mpfi->string-interval o 5))
   ((o digits)
    (format "[~a, ~a]"
      (mpfr->string (struct-mpfi-left-ref  o) digits)
      (mpfr->string (struct-mpfi-right-ref o) digits)))))

(define (mpfi->string o)
  (with-compensations
    (letrec ((fr (compensate
                     (malloc sizeof-mpfr_t)
                   (with
                    (mpfr_clear fr)
                    (primitive-free fr)))))
      (mpfr_init fr)
      (mpfi_get_fr fr o)
      (mpfr->string o))))
@end example

@noindent
where using @samp{pointer-null} as first argument to @func{mpfr_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which default to the standard C language functions).

@c page
@node mpc
@chapter Multiple precision complex numbers


The complex floating point numbers @api{} is exported by the
@library{foreign math mp mpc} library.  We discuss multiple ways to
handle memory allocation.

@defun mpc_init @var{pointer}
@mpc{} version 0.7+ does not export a @cfunc{mpc_init} function, so
@library{foreign math mp mpc} defines one like this:

@example
(define (mpc_init p)
  (mpc_init2 p 256))
@end example
@end defun

@menu
* mpc basic::                  Basic example.
* mpc dynwind::                Using dynamic wind.
* mpc compensations::          Compensating memory allocation.
* mpc factory::                Object factory.
* mpc string::                 Conversion to string.
@end menu

@c page
@node mpc basic
@section Basic example


To use @samp{mpc_t} numbers we basically have to do:

@example
(import (rnrs)
  (foreign memory)
  (foreign math mp mpc)
  (foreign math mp sizeof))

(let ((a (malloc sizeof-mpc_t))
      (b (malloc sizeof-mpc_t))
      (c (malloc sizeof-mpc_t)))
  (mpc_init a)
  (mpc_init b)
  (mpc_init c)

  (mpc_set_d_d   a 10.4 8.9 MPC_RNDNN)
  (mpc_set_si_si b  5   1.2 MPC_RNDNN)
  (mpc_add c a b MPC_RNDNN)

  (mpc_clear a)
  (mpc_clear b)
  (primitive-free a)
  (primitive-free b)

  (do-something-with c)

  (mpc_clear c)
  (primitive-free c))
@end example

@c page
@node mpc dynwind
@section Using dynamic wind


Scheme provides the @func{dynamic-wind} syntax to allow evaluation of
@dfn{in guard} and @dfn{out guard} thunks for each evaluation of a third
``body'' thunk.  We can leverage this mechanism to handle safe
allocation and release of @samp{mpc_t} numbers as follows:

@example
(let ((A #f))
  (dynamic-wind
      (lambda ()
        (set! A (malloc sizeof-mpc_t))
        (mpc_init A))
      (lambda ()
        (do-something-with A))
      (lambda ()
        (mpc_clear A)
        (primitive-free A))))
@end example

@noindent
of course we can wrap this mechanism into a macro:

@example
(define-syntax with-mpc
  (syntax-rules ()
    ((_ () ?form0 ?form ...)
     (begin ?form0 ?form ...))
    ((_ (?id0 ?id ...) ?form0 ?form ...)
     (let ((?id0 #f))
       (dynamic-wind
           (lambda ()
             (set! ?id0 (malloc sizeof-mpc_t))
             (mpc_init ?id0))
           (lambda ()
             (with-mpc (?id ...) ?form0 ?form ...))
           (lambda ()
             (mpc_clear ?id0)
             (primitive-free ?id0)))))))
@end example

@noindent
with which we can do:

@example
(with-mpc (a b c)
  (mpc_set_d_d   a 10.4 8.9 MPC_RNDNN)
  (mpc_set_si_si b  5   1.2 MPC_RNDNN)
  (mpc_add c a b MPC_RNDNN)
  (do-something-with c))
@end example

@c page
@node mpc compensations
@section Compensating memory allocation


The @library{compensations} library from Nausicaa/Scheme exports the
compensation stacks @api{} as a mean to automatically release
synchronous resources, even in case of raised exceptions.
@nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpc)
  (foreign math mp sizeof))
@end example

@noindent
to allocate a @samp{mpc_t} number with a compensation we can use the
following function:

@example
(define (mpc/c)
  (letrec ((p (compensate
                  ;; "p" is not yet bound here
                  (malloc sizeof-mpc_t)
                (with
                 (mpc_clear p)
                 (primitive-free p)))))
    (mpc_init p)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(with-compensations
  (let ((c (mpc/c)))
    (with-compensations
      (let ((a (mpc/c))
            (b (mpc/c)))
        (mpc_set_d_d   a 10.4 8.9 MPC_RNDNN)
        (mpc_set_si_si b  5   1.2 MPC_RNDNN)
        (mpc_add c a b MPC_RNDNN)
    (do-something-with c)))))
@end example

The advantage of compensations, over the @func{dynamic-wind} solution,
is that we can nest at will allocation of numbers, without keeping track
of them in an enclosing form.

@c page
@node mpc factory
@section Object factory


The @library{foreign memory} library from Nausicaa/Scheme exports the
object factory @api{} as a mean to automatically allocate, initialise,
finalise and release synchronous resources, even in case of raised
exceptions.  @nauref{memory cache, Caching memory blocks}

We can use this library along with the @library{compensations} library
also from Nausicaa/Scheme.  @nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpc)
  (foreign math mp sizeof))
@end example

@noindent
we can define an object factory for @samp{mpc_t} numbers with:

@example
(define mpc-factory
  (make-caching-object-factory mpc_init mpc_clear
                               sizeof-mpc_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpc)
  (letrec ((p (compensate
                  (mpc-factory)
                (with
                 (mpc-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
  (let ((c (mpc)))

    (with-compensations
      (let ((a (mpc))
            (b (mpc)))
        (mpc_set_d_d   a 10.4 8.9 MPC_RNDNN)
        (mpc_set_si_si b  5   1.2 MPC_RNDNN)
        (mpc_add c a b MPC_RNDNN)

    (do-something-with c)))
@end example

The advantage of factories, over plain compensations, is that a factory
caches allocated memory blocks.

@c page
@node mpc string
@section Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @samp{mpc_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (formations)
  (foreign memory)
  (foreign cstrings)
  (foreign math mp mpc))
@end example

@noindent
the following function does a basic conversion from an @samp{mpc_t} to a
string:

@example
(define (mpfr->string o)
  (with-compensations
    (letrec*
        ((l (malloc-small/c))
         (str (compensate
                  (mpfr_get_str pointer-null l 10 0 o MPC_RNDNN)
                (with
                 (primitive-free str))))
         (s (cstring->string str))
         (x (let ((x (pointer-ref-c-signed-long l 0)))
              (if (char=? #\- (string-ref s 0))
                  (+ 1 x)
                x)))
         (i (substring s 0 x))
         (f (substring s x (strlen str))))
      (string-append i "." f))))

(define (mpc->string o digits)
  (let ((im (mpfr->string (struct-mpc-im-ref o))))
    (format "~a~a~ai"
      (substring (mpfr->string (struct-mpc-re-ref o)) 0 digits)
      (if (char=? #\- (string-ref im 0))
          ""
        #\+))))
@end example

@noindent
where using @samp{pointer-null} as first argument to @func{mpc_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which default to the standard C language functions).

@c page
@node mpfrcx
@chapter Multiple precision polynomials


The polynomials @api{} is exported by the @library{foreign math mp
mpfrcx} library.  We discuss multiple ways to handle memory allocation.

@menu
* mpfrcx intro::                Introduction.
* mpfrcx init::                 Initialisation functions.
* mpfrcx basic::                Basic example.
* mpfrcx dynwind::              Using dynamic wind.
* mpfrcx compensations::        Compensating memory allocation.
* mpfrcx string::               Conversion to string.
@end menu

@c page
@node mpfrcx intro
@section Introduction


As of version 0.2 of @mpfrcx{}, the @api{} and the documentation is
still under development; here we discuss some details which is not
documented but whose knowledge is mandatory to use the library at the C
language level.

The following program shows how to initialise three polynomials with
real coefficients, set the coefficients of two of them and perform
addition; using the @gnu{} C Compiler, we can produce an executable
with:

@example
gcc -std=c99 -Wall                          \
    -L/usr/local/lib -lmpfr -lmpc -lmpfrcx  \
    -o poly-add poly-add.c
@end example

@noindent
the program prints the resulting polynomial coefficients.

@example
#include <stdio.h>
#include <stdlib.h>
#include <mpfr.h>
#include <mpc.h>
#include <mpfrcx.h>

int
main (void)
@{
  mpfrx_t       a, b, c;
  mpfrx_init(a, 5, 50); a->deg = 4;
  mpfrx_init(b, 5, 50); b->deg = 4;
  mpfrx_init(c, 5, 50); c->deg = 4;
  @{
    mpfr_set_d(a->coeff[0], 0.1, GMP_RNDN);
    mpfr_set_d(a->coeff[1], 0.2, GMP_RNDN);
    mpfr_set_d(a->coeff[2], 0.3, GMP_RNDN);
    mpfr_set_d(a->coeff[3], 0.4, GMP_RNDN);
    mpfr_set_d(a->coeff[4], 0.5, GMP_RNDN);

    mpfr_set_d(b->coeff[0], 1., GMP_RNDN);
    mpfr_set_d(b->coeff[1], 2., GMP_RNDN);
    mpfr_set_d(b->coeff[2], 3., GMP_RNDN);
    mpfr_set_d(b->coeff[3], 4., GMP_RNDN);
    mpfr_set_d(b->coeff[4], 5., GMP_RNDN);

    mpfrx_add(c, a, b);

    for (int i=0; i<5; ++i)
      mpfr_printf("%Rf\n", c->coeff[i]);
  @}
  mpfrx_clear(a);
  mpfrx_clear(b);
  mpfrx_clear(c);
  exit(EXIT_SUCCESS);
@}
@end example

We see that calling @cfunc{mpfrx_init} is not enough to initialise
values of type @code{mpfrx_t}: we also have to explicitly set the degree
of the polynomial be mutating the @code{deg} field.  Access to the
coefficients is possible neither through C functions nor through C
macros, we have to access directly the @code{coeff} field.

In the @code{coeff} array: the item of index @math{0} is the coefficient
of degree zero of the polynomial, the item of index @math{1} is the
coefficient of degree @math{1} of the polynomial, etc.

@c page
@node mpfrcx init
@section Initialisation functions


We have to select the appropriate way to initialise the polynomials;
among several possibilities, @value{PACKAGE} proposes the following
functions.  They exist as templates to be customised.


@deffn Parameter mpfrcx-precision
Holds the ``current'' initialisation precision for @code{mpfrx_t} and
@code{mpcx_t} polynomials.  It is initialised to @math{50}.
@end deffn


@defun mpfrx_init* @var{poly} @var{coeffs} @var{setter}
@defunx mpfrx_init* @var{poly} @var{coeffs} @var{setter} @var{degree}
Initialises an already allocated real polynomial and sets the
coefficients from the real numbers in the Scheme vector @var{coeffs}.

@example
(define mpfrx_init*
  (case-lambda

   ((poly coeffs setter)
    (mpfrx_init* poly coeffs setter
                 (- (vector-length coeffs) 1)))

   ((poly coeffs setter degree)
    (mpfrx_init poly (+ 1 degree) (mpfrcx-precision))
    (struct-mpfrx_t-deg-set! poly degree)
    (do ((i 0 (+ 1 i)))
        ((= i degree))
      (setter (struct-mpfrx_t-coeff-ptr-ref poly i)
              (vector-ref coeffs i)
              GMP_RNDN)))))
@end example
@end defun


@defun mpcx_init* @var{poly} @var{coeffs} @var{setter}
@defunx mpcx_init* @var{poly} @var{coeffs} @var{setter} @var{degree}
Initialises an already allocated complex polynomial and sets the
coefficients from the real numbers in the Scheme vector @var{coeffs}.

@example
(define mpcx_init*
  (case-lambda

   ((poly coeffs setter)
    (mpcx_init* poly coeffs setter
                (- (vector-length coeffs) 1)))

   ((poly coeffs setter degree)
    (mpcx_init poly (+ 1 degree) (mpfrcx-precision))
    (struct-mpcx_t-deg-set! poly degree)
    (do ((i 0 (+ 1 i)))
        ((= i degree))
      (setter (struct-mpcx_t-coeff-ptr-ref poly i)
              (vector-ref coeffs i)
              GMP_RNDN)))))
@end example
@end defun

@c page
@node mpfrcx basic
@section Basic example


To use @samp{mpfrx_t} polynomials we basically have to do:

@example
(import (rnrs)
  (foreign memory)
  (foreign math mp mpfr)
  (foreign math mp mpfrx)
  (foreign math mp sizeof))

(let ((a (malloc sizeof-mpfrx_t))
      (b (malloc sizeof-mpfrx_t))
      (c (malloc sizeof-mpfrx_t)))

  (mpfrx_init* a '#( 1.2 3.4 5.6 7.8 9.0) mpfr_set_d)
  (mpfrx_init* b '#(-1. -3. -5. -7. -9.)  mpfr_set_d)
  (mpfrx_init c 5 50)

  (mpfrx_add c a b)

  (mpfrx_clear a)
  (mpfrx_clear b)
  (primitive-free a)
  (primitive-free b)

  (do-something-with c)

  (mpfrx_clear c)
  (primitive-free c))
@end example

@c page
@node mpfrcx dynwind
@section Using dynamic wind


Scheme provides the @func{dynamic-wind} syntax to allow evaluation of
@dfn{in guard} and @dfn{out guard} thunks for each evaluation of a third
``body'' thunk.  We can leverage this mechanism to handle safe
allocation and release of @samp{mpfrx_t} numbers as follows:

@example
(let ((A #f))
  (dynamic-wind
      (lambda ()
        (set! A (malloc sizeof-mpfr_t))
        (mpfrx_init A 5 50))
      (lambda ()
        (do-something-with A))
      (lambda ()
        (mpfrx_clear A)
        (primitive-free A))))
@end example

@noindent
of course we can wrap this mechanism into a more sophisticated macro:

@example
(define-syntax with-mpfrx
  (syntax-rules ()

    ((_ () ?form0 ?form ...)
     (begin ?form0 ?form ...))

    ((_ ((?id ?degree) ?init ...) ?form0 ?form ...)
     (let ((?id #f))
       (dynamic-wind
           (lambda ()
             (set! ?id (malloc sizeof-mpfrx_t))
             (mpfrx_init ?id (+ 1 ?degree) (mpfrcx-precision)))
           (lambda ()
             (with-mpfrx (?init ...) ?form0 ?form ...))
           (lambda ()
             (mpfrx_clear ?id)
             (primitive-free ?id)))))

    ((_ ((?id ?coeffs ?setter) ?init ...) ?form0 ?form ...)
     (let ((?id #f))
       (dynamic-wind
           (lambda ()
             (set! ?id (malloc sizeof-mpfrx_t))
             (mpfrx_init* ?id ?coeffs ?setter))
           (lambda ()
             (with-mpfrx (?init ...) ?form0 ?form ...))
           (lambda ()
             (mpfrx_clear ?id)
             (primitive-free ?id)))))))
@end example

@noindent
with which we can do:

@example
(with-mpfrx ((a '#(1.2 3.4 5.6 7.8 9.0) mpfr_set_d)
             (b '#(-1. -3. -5. -7. -9.) mpfr_set_d)
             (c 4))
  (mpfrx_add c a b)
  (do-something-with c))
@end example

@c page
@node mpfrcx compensations
@section Compensating memory allocation


The @library{compensations} library from Nausicaa/Scheme exports the
compensation stacks @api{} as a mean to automatically release
synchronous resources, even in case of raised exceptions.
@nauref{compensations, Compensation stacks}

Let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpfrx)
  (foreign math mp sizeof))
@end example

@noindent
to allocate a @samp{mpfrx_t} number with a compensation we can use the
following functions:

@example
(define (mpfrx/c degree)
  (letrec ((p (compensate
                  (malloc sizeof-mpfrx_t)
                (with
                 (mpfrx_clear p)
                 (primitive-free p)))))
    (mpfrx_init p (+ 1 degree) (mpfrcx-precision))
    p))

(define (mpfrx*/c coeffs setter)
  (letrec ((p (compensate
                  (malloc sizeof-mpfrx_t)
                (with
                 (mpfrx_clear p)
                 (primitive-free p)))))
    (mpfrx_init* p coeffs setter)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(with-compensations
   (let ((c (mpfrx/c 4)))
     (with-compensations
       (let ((a (mpfrx*/c '#(1.2 3.4 5.6 7.8 9.0) mpfr_set_d))
             (b (mpfrx*/c '#(-1. -3. -5. -7. -9.) mpfr_set_d)))
         (mpfrx_add c a b)))
     (do-something-with c)))
@end example

The advantage of compensations, over the @func{dynamic-wind} solution,
is that we can nest at will allocation of numbers, without keeping track
of them in an enclosing form.

@c page
@node mpfrcx string
@section Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @samp{mpfrx_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (foreign memory)
  (foreign cstrings)
  (foreign math mp mpfr)
  (foreign math mp mpfrcx))
@end example

@noindent
the following functions do a basic conversion from an @samp{mpfrx_t} to
a string:

@example
(define (mpfr->string o digits)
  (with-compensations
    (letrec*
        ((l (malloc-small/c))
         (str (compensate
                  (mpfr_get_str pointer-null l 10 digits
                                o GMP_RNDN)
                (with
                 (primitive-free str))))
         (s (cstring->string str))
         (x (let ((x (pointer-ref-c-signed-long l 0)))
              (if (char=? #\- (string-ref s 0))
                  (+ 1 x)
                x)))
         (i (substring s 0 x))
         (f (substring s x (strlen str))))
      (string-append i "." f))))

(define (mpfrx->string poly digits)
  (let-values (((port getter) (open-string-output-port)))
    (let ((degree (struct-mpfrx_t-deg-ref poly)))
      (display #\( port)
      (display degree port)
      (display #\; port)
      (do ((i degree (- i 1)))
          ((= i -1)
           (display #\) port)
           (getter))
        (display #\space port)
        (display (mpfr->string
                    (struct-mpfrx_t-coeff-ptr-ref poly i)
                    digits)
                 port)))))
@end example

@noindent
where using @samp{pointer-null} as first argument to @func{mpfr_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which default to the standard C language functions).

@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node references
@appendix Bibliography and references


The @gmp{} library can be found at:

@center @url{http://gmplib.org/}

@noindent
the @mpfr{} library can be found at:

@center @url{http://www.mpfr.org/}

@noindent
the @mpfi{} library can be found at:

@center @url{http://gforge.inria.fr/projects/mpfi/}

@noindent
the @mpc{} library can be found at:

@center @url{http://www.multiprecision.org/mpc/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
