\input texinfo.tex
@c %**start of header
@setfilename nausicaa-mp.info
@settitle Nausicaa/MP
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro

@c ------------------------------------------------------------
@c Software related macros.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro mpfr{}
@acronym{MPFR}
@end macro

@macro mpfi{}
@acronym{MPFI}
@end macro

@macro mpc{}
@acronym{MPC}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@macro glibc{}
@gnu{} C Library
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Nausicaa/MP

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@acronym{MP}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-mp

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2008, 2009

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a set of
Scheme libraries implementing an interface to the following C language
libraries for multiple precision integers and floating--point numbers:

@table @asis
@item @gmp{}
GNU Multiple Precision arithmetic library.

@item @mpfr{}
Multiple Precision Floating--Point Reliable library.

@item @mpfi{}
Multiple Precision Floating--Point Interval library.

@item @mpc{}
Multiple Precision Complex library.
@end table

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}); the project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/tree/master}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``@gnu{} Free
Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-mp: (nausicaa-mp).   Nausicaa/MP library for @rnrs{6} Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* constants::                   Constant values.
* accessors::                   Accessing foreign structures.
* gmp::                         Multiple precision integers.
* mpfr::                        Multiple precision reliable floats.
* mpfi::                        Multiple precision interval numbers.
* mpc::                         Multiple precision complex numbers.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


@value{PACKAGE} implements a binding to various multiple precision
numbers libraries for the @rnrs{6} Scheme implementations supported by
Nausicaa.  The bindings make use of the foreign functions interface from
the Nausicaa/Scheme package.  The installed libraries are:

@example
(foreign math mp sizeof)
(foreign math mp mpz)
(foreign math mp mpq)
(foreign math mp mpf)
(foreign math mp mpfr)
(foreign math mp mpfi)
(foreign math mp mpc)
(foreign math mp random)
@end example

The bindings attempt to be one--to--one mappings between foreign and
Scheme functions.  So the original documentation of the foreign
libraries applies to the bindings, too.

This document gives only a brief description of some functions, and
focuses on providing some usage example to get a feeling about how to
manage resources allocation in a Scheme program.

See the relevant chapters for instructions on loading @value{PACKAGE}
libraries.

@c page
@node constants
@chapter Constant values


The following bindings are exported by the @library{foreign math mp
sizeof} library.


@defvr Constant sizeof-gmp_randalg_t
@defvrx Constant sizeof-gmp_randstate_t
@defvrx Constant sizeof-mp_exp_t
@defvrx Constant sizeof-mp_limb_t
@defvrx Constant sizeof-mp_prec_t
@defvrx Constant sizeof-mp_rnd_t
@defvrx Constant sizeof-mp_size_t
@defvrx Constant sizeof-mpc_t
@defvrx Constant sizeof-mpc_rnd_t
@defvrx Constant sizeof-mpf_t
@defvrx Constant sizeof-mpfi_t
@defvrx Constant sizeof-mpfr_prec_t
@defvrx Constant sizeof-mpfr_rnd_t
@defvrx Constant sizeof-mpfr_sign_t
@defvrx Constant sizeof-mpfr_t
@defvrx Constant sizeof-mpq_t
@defvrx Constant sizeof-mpz_t
These variables hold the number of bytes required to hold in memory the
named foreign data type.

For example @samp{sizeof-mpc_rnd_t} is the number of bytes required to
hold the @samp{mpc_rnd_t} type definition of the @mpc{} library.

Of special importance are:

@example
sizeof-mpz_t
sizeof-mpq_t
sizeof-mpf_t
sizeof-mpfr_t
sizeof-mpfi_t
sizeof-mpc_t
@end example

@noindent
which are the sizes of the data structures that represent multiple
precision numbers.
@end defvr


@defvr Constant GMP_RAND_ALG_DEFAULT
@defvrx Constant GMP_RAND_ALG_LC
@defvrx Constant GMP_RNDD
@defvrx Constant GMP_RNDN
@defvrx Constant GMP_RNDU
@defvrx Constant GMP_RNDZ
@defvrx Constant MPFI_FLAGS_BOTH_ENDPOINTS_EXACT
@defvrx Constant MPFI_FLAGS_BOTH_ENDPOINTS_INEXACT
@defvrx Constant MPFI_FLAGS_LEFT_ENDPOINT_INEXACT
@defvrx Constant MPFI_FLAGS_RIGHT_ENDPOINT_INEXACT
@defvrx Constant MPFR_EMAX_DEFAULT
@defvrx Constant MPFR_EMIN_DEFAULT
@defvrx Constant MPFR_PREC_MAX
@defvrx Constant MPFR_PREC_MIN
@defvrx Constant MPFR_VERSION
These variables hold various constants required by the foreign
libraries.  Of special importance are the rounding modes for @mpfr{}:

@example
GMP_RNDN
GMP_RNDD
GMP_RNDU
GMP_RNDZ
@end example

@noindent
and the rounding modes for @mpc{}:

@example
MPC_RNDNN       MPC_RNDZN       MPC_RNDUN       MPC_RNDDN
MPC_RNDNZ       MPC_RNDZZ       MPC_RNDUZ       MPC_RNDDZ
MPC_RNDNU       MPC_RNDZU       MPC_RNDUU       MPC_RNDDU
MPC_RNDND       MPC_RNDZD       MPC_RNDUD       MPC_RNDDD
@end example
@end defvr

@c page
@node accessors
@chapter Accessing foreign structures


The following syntaxes allow us to access fields of the multiple
precision numbers data structures, they are exported by @library{foreign
math mp sizeof} library.  Notice that for normal usage we are
@strong{not} meant to use these accessors.


@deffn Syntax struct-mpq-num-ref @var{struct-pointer}
@deffnx Syntax struct-mpq-den-ref @var{struct-pointer}
Return a pointer referencing the numerator or denominator fields in a
@samp{mpq_t} number, which are @samp{mpz_t} numbers.
@end deffn


@deffn Syntax struct-mpfr-prec-set! @var{struct-pointer} @var{value}
@deffnx Syntax struct-mpfr-prec-ref @var{struct-pointer}
Accessors for the @samp{_mpfr_prec} field of @samp{mpfr_t}.
@end deffn

@deffn Syntax struct-mpfr-sign-set! @var{struct-pointer} @var{value}
@deffnx Syntax struct-mpfr-sign-ref @var{struct-pointer}
Accessors for the @samp{_mpfr_sign} field of @samp{mpfr_t}.
@end deffn


@deffn Syntax struct-mpfr-exp-set! @var{struct-pointer} @var{value}
@deffnx Syntax struct-mpfr-exp-ref @var{struct-pointer}
Accessors for the @samp{_mpfr_exp} field of @samp{mpfr_t}.
@end deffn


@deffn Syntax struct-mpfr-d-set! @var{struct-pointer} @var{value}
@deffnx Syntax struct-mpfr-d-ref @var{struct-pointer}
Accessors for the @samp{_mpfr_d} field of @samp{mpfr_t}.
@end deffn


@deffn Syntax struct-mpfi-left-ref @var{struct-pointer}
@deffnx Syntax struct-mpfi-right-ref @var{struct-pointer}
Return a pointer referencing the @samp{left} or @samp{right} fields in a
@samp{mpfi_t} structure.  These fields are structures of type
@samp{mpfr_t}.
@end deffn


@deffn Syntax struct-mpc-re-ref @var{struct-pointer}
@deffnx Syntax struct-mpc-im-ref @var{struct-pointer}
Return a pointer referencing the @samp{re} or @samp{im} fields in a
@samp{mpc_t} structure.  These fields are structures of type
@samp{mpfr_t}.
@end deffn

@c page
@node gmp
@chapter Multiple precision integers


The @gmp{} library implements multiple precision integers, rational
numbers and basic floating point numbers.

@menu
* gmp mpz::                     Multiple precision integers.
* gmp mpq::                     Multiple precision rationals.
* gmp mpf::                     Multiple precision floats.
@end menu

@c page
@node gmp mpz
@section Multiple precision integers


The integer numbers @api{} is exported by the @library{foreign math mp
mpz} library.  To use @samp{mpz_t} numbers we basically have to do:

@example
(import (rnrs)
  (foreign ffi memory)
  (foreign math mp mpz)
  (foreign math mp sizeof))

(let ((a (malloc sizeof-mpz_t))
      (b (malloc sizeof-mpz_t))
      (c (malloc sizeof-mpz_t)))
  (mpz_init a)
  (mpz_init b)
  (mpz_init c)

  (mpz_set_si a 10)
  (mpz_set_si b 5)
  (mpz_add c a b)

  (mpz_clear a)
  (mpz_clear b)
  (primitive-free a)
  (primitive-free b)
  c)
@end example

More advanced memory handling and usage examples are in the following
sections.

@menu
* gmp mpz compensation::        Compensating memory allocation.
* gmp mpz factory::             Object factory.
* gmp mpz string::              Conversion to string.
@end menu

@c page
@node gmp mpz compensation
@subsection Compensating memory allocation


The @library{compensation} library from Nausicaa/Scheme exports the
compensation stacks @api{} as a mean to automatically release
synchronous resources, even in case of raised exceptions.
@nauref{compensations, Compensation stacks}

So let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign ffi memory)
  (foreign math mp mpz)
  (foreign math mp sizeof))
@end example

@noindent
to allocate a @samp{mpz_t} number with a compensation we can use the
following function:

@example
(define (mpz/c)
  (letrec ((p (compensate
                   (malloc sizeof-mpz_t)
                   (mpz_init p)
                (with
                 (mpz_clear p)
                 (primitive-free p)))))
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(with-compensations
  (let ((c (mpz/c)))

    (with-compensations
      (let ((a (mpz/c))
            (b (mpz/c)))
        (mpz_set_si a 10)
        (mpz_set_si b 5)
        (mpz_add c a b)))

    (do-something-with c)))
@end example

@c page
@node gmp mpz factory
@subsection Object factory


The @library{foreign memory} library from Nausicaa/Scheme exports the
object factory @api{} as a mean to automatically allocate, initialise,
finalise and release synchronous resources, even in case of raised
exceptions.  @nauref{memory cache, Caching memory blocks}

We can use this library along with the @library{compensations} library
also from Nausicaa/Scheme.  @nauref{compensations, Compensation stacks}

So let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign ffi memory)
  (foreign math mp mpz)
  (foreign math mp sizeof))
@end example

We can define an object factory for @samp{mpz_t} numbers with:

@example
(define mpz-factory
  (make-caching-object-factory mpz_init mpz_clear
                               sizeof-mpz_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpz)
  (letrec ((p (compensate
                  (mpz-factory)
                (with
                 (mpz-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
  (let ((c (mpz)))

    (with-compensations
      (let ((a (mpz))
            (b (mpz)))
        (mpz_set_si a 10)
        (mpz_set_si b 5)
        (mpz_add c a b)))

    (do-something-with c)))
@end example

@c page
@node gmp mpz string
@subsection Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @samp{mpz_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (foreign ffi)
  (foreign ffi memory)
  (foreign ffi cstrings)
  (foreign math mp mpz)
  (foreign math mp sizeof))
@end example

The following function does a basic conversion from an @samp{mpz_t} to a
string:

@example
(define (mpz->string o)
  (let ((str (mpz_get_str pointer-null 10 o)))
    (begin0
        (cstring->string str)
      (primitive-free str))))
@end example

@noindent
where using @samp{pointer-null} as first argument to @func{mpz_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which defaults to the standard C language functions).

The same with compensations:

@example
(define (mpz->string o)
  (with-compensations
    (letrec
        ((str (compensate
                  (mpz_get_str pointer-null 10 o)
                (with
                 (primitive-free str)))))
      (cstring->string str))))
@end example

@c page
@node gmp mpq
@section Multiple precision rationals


The rational numbers @api{} is exported by the @library{foreign math mp
mpq} library.  To use @samp{mpq_t} numbers we basically have to do:

@example
(import (rnrs)
  (foreign ffi memory)
  (foreign math mp mpq)
  (foreign math mp sizeof))

(let ((a (malloc sizeof-mpq_t))
      (b (malloc sizeof-mpq_t))
      (c (malloc sizeof-mpq_t)))
  (mpq_init a)
  (mpq_init b)
  (mpq_init c)

  (mpq_set_si a 6 10)
  (mpq_canonicalize a)
  (mpq_set_si b 6 5)
  (mpq_add c a b)

  (mpq_clear a)
  (mpq_clear b)
  (primitive-free a)
  (primitive-free b)
  c)
@end example

@noindent
where the first argument to @func{mpq_set_si} is the numerator, the
second the denominator.

More advanced memory handling and usage examples are in the following
sections.

@menu
* gmp mpq compensation::        Compensating memory allocation.
* gmp mpq factory::             Object factory.
* gmp mpq string::              Conversion to string.
@end menu

@c page
@node gmp mpq compensation
@subsection Compensating memory allocation


The @library{compensations} library from Nausicaa/Scheme exports the
compensation stacks @api{} as a mean to automatically release
synchronous resources, even in case of raised exceptions.
@nauref{compensations, Compensation stacks}

So let's start a program with:

@example
(import (rnrs)
  (compensations)
  (foreign memory)
  (foreign math mp mpq)
  (foreign math mp sizeof))
@end example

@noindent
to allocate a @samp{mpq_t} number with a compensation we can use the
following function:

@example
(define (mpq/c)
  (letrec ((p (compensate
                   (malloc sizeof-mpq_t)
                   (mpq_init p)
                (with
                 (mpq_clear p)
                 (primitive-free p)))))
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(with-compensations
  (let ((c (mpq/c)))

    (with-compensations
      (let ((a (mpq/c))
            (b (mpq/c)))
        (mpq_set_si a 6 10)
        (mpq_canonicalize a)
        (mpq_set_si b 6 5)
        (mpq_add c a b)))

    (do-something-with c)))
@end example

@c page
@node gmp mpq factory
@subsection Object factory


The @library{foreign memory} library from Nausicaa/Scheme exports the
object factory @api{} as a mean to automatically allocate, initialise,
finalise and release synchronous resources, even in case of raised
exceptions.  @nauref{memory cache, Caching memory blocks}

We can use this library along with the @library{compensations} library
also from Nausicaa/Scheme.  @nauref{compensations, Compensation stacks}

So let's start a program with:

@example
(import (rnrs)
  (foreign ffi memory)
  (compensations)
  (mp mpq)
  (mp sizeof))
@end example

We can define an object factory for @code{mpq_t} numbers with:

@example
(define mpq-factory
  (make-caching-object-factory mpq_init mpq_clear
                               sizeof-mpq_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpq)
  (letrec ((p (compensate
                  (mpq-factory)
                (with
                 (mpq-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
   (let ((c (mpq))
         (a (mpq))
         (b (mpq)))
     (mpq_set_si a 6 10)
     (mpq_canonicalize a)
     (mpq_set_si b 6 5)
     (mpq_add c a b)

     (do-something-with c)))
@end example


@c page
@node gmp mpq string
@subsection Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @code{mpq_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (mp mpq)
  (mp sizeof))
@end example

The following function does a basic conversion from an @code{mpq_t} to a
string:

@example
(define (mpq->string o)
  (let ((str (mpq_get_str pointer-null 10 o)))
    (begin0
        (cstring->string str)
      (primitive-free str))))
@end example

@noindent
where using @code{pointer-null} as first argument to @func{mpq_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which defaults to the standard C language functions).

The same with compensations:

@example
(define (mpq->string o)
  (with-compensations
    (letrec
        ((str (compensate
                  (mpq_get_str pointer-null 10 o)
                (with
                 (primitive-free str)))))
      (cstring->string str))))
@end example


@c page
@node gmp mpf
@section Multiple precision floats


The floating point numbers @api{} is exported by the @library{mp mpf}
library.  To use @code{mpf_t} numbers we basically have to do:

@example
(import (rnrs)
  (uriel ffi)
  (mp mpf)
  (mp sizeof))

(let ((a (malloc sizeof-mpf_t))
      (b (malloc sizeof-mpf_t))
      (c (malloc sizeof-mpf_t)))
  (mpf_init a)
  (mpf_init b)
  (mpf_init c)

  (mpf_set_si a 10)
  (mpf_set_si b 5)
  (mpf_add c a b)

  (mpf_clear a)
  (mpf_clear b)
  (primitive-free a)
  (primitive-free b)
  c)
@end example

More advanced memory handling and usage examples are in the following
sections.

@menu
* gmp mpf compensation::        Compensating memory allocation.
* gmp mpf factory::             Object factory.
* gmp mpf string::              Conversion to string.
@end menu


@c page
@node gmp mpf compensation
@subsection Compensating memory allocation


The @library{uriel lang} library exports the compensation stacks @api{}
as a mean to automatically release synchronous resources, even in case
of raised exceptions.  @nauref{compensations, Compensation stacks}

So let's start a program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (mp mpf)
  (mp sizeof))
@end example

To allocate a @code{mpf_t} number with a compensation we can use the
following function:

@example
(define (compensated-mpf)
  (letrec ((p (compensate
                   (malloc sizeof-mpf_t)
                (with
                 (mpf_clear p)
                 (priitive-free p)))))
    (mpf_init p)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(let ((c (malloc sizeof-mpf_t)))
  (mpf_init c)
  (with-compensations
    (let ((a (compensated-mpf))
          (b (compensated-mpf)))
      (mpf_set_si a 10)
      (mpf_set_si b 5)
      (mpf_add c a b)
      c)))
@end example


@c page
@node gmp mpf factory
@subsection Object factory


The @library{uriel lang} library exports the object factory @api{} as a
mean to automatically allocate, initialise, finalise and release
synchronous resources, even in case of raised exceptions.
@nauref{memory cache, Caching memory blocks}

So let's start a program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (mp mpf)
  (mp sizeof))
@end example

We can define an object factory for @code{mpf_t} numbers with:

@example
(define mpf-factory
  (make-caching-object-factory mpf_init mpf_clear
                               sizeof-mpf_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpf)
  (letrec ((p (compensate
                  (mpf-factory)
                (with
                 (mpf-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
   (let ((c (mpf))
         (a (mpf))
         (b (mpf)))
     (mpf_set_si a 10)
     (mpf_set_si b 5)
     (mpf_add c a b)

     (do-something-with c)))
@end example


@c page
@node gmp mpf string
@subsection Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @code{mpf_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (srfi format)
  (mp mpf)
  (mp sizeof))
@end example

The following function does a basic conversion from an @code{mpf_t} to a
string:

@example
(define (mpf->string o)
  (with-compensations
    (letrec*
        ((l (malloc-small/c))
         (str (compensate
                  (mpf_get_str pointer-null l 10 0 o)
                (with
                 (primitive-free str))))
         (s (cstring->string str))
         (x (let ((x (pointer-ref-c-signed-long l 0)))
              (if (char=? #\- (string-ref s 0))
                  (+ 1 x)
                x)))
         (i (substring s 0 x))
         (f (substring s x (strlen str))))
      (format "~a.~a" i f))))
@end example

@noindent
where using @code{pointer-null} as first argument to @func{mpf_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which defaults to the standard C language functions).


@c page
@node mpfr
@chapter Multiple precision reliable floats


The reliable floating point numbers @api{} is exported by the
@library{mp mpfr} library.  To use @code{mpfr_t} numbers we basically
have to do:

@example
(import (rnrs)
  (uriel ffi)
  (mp mpfr)
  (mp sizeof))

  (let ((a (malloc sizeof-mpfr_t))
        (b (malloc sizeof-mpfr_t))
        (c (malloc sizeof-mpfr_t)))
    (mpfr_init a)
    (mpfr_init b)
    (mpfr_init c)

    (mpfr_set_d  a 10.4 GMP_RNDN)
    (mpfr_set_si b  5   GMP_RNDN)
    (mpfr_add c  a  b   GMP_RNDN)

    (mpfr_clear a)
    (mpfr_clear b)
    (primitive-free a)
    (primitive-free b)
    c)
@end example

More advanced memory handling and usage examples are in the following
sections.

@menu
* mpfr compensation::           Compensating memory allocation.
* mpfr factory::                Object factory.
* mpfr string::                 Conversion to string.
@end menu


@c page
@node mpfr compensation
@section Compensating memory allocation


The @library{uriel lang} library exports the compensation stacks @api{}
as a mean to automatically release synchronous resources, even in case
of raised exceptions.  @nauref{compensations, Compensation stacks}

So let's start a program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (mp mpfr)
  (mp sizeof))
@end example

To allocate a @code{mpfr_t} number with a compensation we can use the
following function:

@example
(define (compensated-mpfr)
  (letrec ((p (compensate
                   (malloc sizeof-mpfr_t)
                (with
                 (mpfr_clear p)
                 (priitive-free p)))))
    (mpfr_init p)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(let ((c (malloc sizeof-mpfr_t)))
  (mpfr_init c)
  (with-compensations
    (let ((a (compensated-mpfr))
          (b (compensated-mpfr)))
      (mpfr_set_si a 10)
      (mpfr_set_si b 5)
      (mpfr_add c a b)
      c)))
@end example


@c page
@node mpfr factory
@section Object factory


The @library{uriel lang} library exports the object factory @api{} as a
mean to automatically allocate, initialise, finalise and release
synchronous resources, even in case of raised exceptions.
@nauref{memory cache, Caching memory blocks}

So let's start a program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (mp mpfr)
  (mp sizeof))
@end example

We can define an object factory for @code{mpfr_t} numbers with:

@example
(define mpfr-factory
  (make-caching-object-factory mpfr_init mpfr_clear
                               sizeof-mpfr_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpfr)
  (letrec ((p (compensate
                  (mpfr-factory)
                (with
                 (mpfr-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
   (let ((c (mpfr))
         (a (mpfr))
         (b (mpfr)))
     (mpfr_set_si a 10)
     (mpfr_set_si b 5)
     (mpfr_add c a b)

     (do-something-with c)))
@end example


@c page
@node mpfr string
@section Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @code{mpfr_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (srfi format)
  (mp mpfr)
  (mp sizeof))
@end example

The following function does a basic conversion from an @code{mpfr_t} to a
string:

@example
(define (mpfr->string o)
  (with-compensations
    (letrec*
        ((l (malloc-small/c))
         (str (compensate
                  (mpfr_get_str pointer-null l 10 0 o GMP_RNDN)
                (with
                 (primitive-free str))))
         (s (cstring->string str))
         (x (let ((x (pointer-ref-c-signed-long l 0)))
              (if (char=? #\- (string-ref s 0))
                  (+ 1 x)
                x)))
         (i (substring s 0 x))
         (f (substring s x (strlen str))))
      (format "~a.~a" i f))))
@end example

@noindent
where using @code{pointer-null} as first argument to @func{mpfr_get_str}
will make it allocate memory using the @gmp{} allocation functions
(which defaults to the standard C language functions).



@c page
@node mpfi
@chapter Multiple precision interval numbers


The interval floating point numbers @api{} is exported by the
@library{mp mpfi} library.  To use @code{mpfi_t} numbers we basically
have to do:

@example
(import (rnrs)
  (uriel ffi)
  (mp mpfi)
  (mp sizeof))

  (let ((a (malloc sizeof-mpfi_t))
        (b (malloc sizeof-mpfi_t))
        (c (malloc sizeof-mpfi_t)))
    (mpfi_init a)
    (mpfi_init b)
    (mpfi_init c)

    (mpfi_set_d  a 10.4)
    (mpfi_set_si b  5)
    (mpfi_add c  a  b)

    (mpfi_clear a)
    (mpfi_clear b)
    (primitive-free a)
    (primitive-free b)
    c)
@end example

More advanced memory handling and usage examples are in the following
sections.

@menu
* mpfi compensation::           Compensating memory allocation.
* mpfi factory::                Object factory.
* mpfi string::                 Conversion to string.
@end menu


@c page
@node mpfi compensation
@section Compensating memory allocation


The @library{uriel lang} library exports the compensation stacks @api{}
as a mean to automatically release synchronous resources, even in case
of raised exceptions.  @nauref{compensations, Compensation stacks}

So let's start a program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (mp mpfi)
  (mp sizeof))
@end example

To allocate a @code{mpfi_t} number with a compensation we can use the
following function:

@example
(define (compensated-mpfi)
  (letrec ((p (compensate
                   (malloc sizeof-mpfi_t)
                (with
                 (mpfi_clear p)
                 (priitive-free p)))))
    (mpfi_init p)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(let ((c (malloc sizeof-mpfi_t)))
  (mpfi_init c)
  (with-compensations
    (let ((a (compensated-mpfi))
          (b (compensated-mpfi)))
      (mpfi_set_si a 10)
      (mpfi_set_si b 5)
      (mpfi_add c a b)
      c)))
@end example


@c page
@node mpfi factory
@section Object factory


The @library{uriel lang} library exports the object factory @api{} as a
mean to automatically allocate, initialise, finalise and release
synchronous resources, even in case of raised exceptions.
@nauref{memory cache, Caching memory blocks}

So let's start a program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (mp mpfi)
  (mp sizeof))
@end example

We can define an object factory for @code{mpfi_t} numbers with:

@example
(define mpfi-factory
  (make-caching-object-factory mpfi_init mpfi_clear
                               sizeof-mpfi_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpfi)
  (letrec ((p (compensate
                  (mpfi-factory)
                (with
                 (mpfi-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
   (let ((c (mpfi))
         (a (mpfi))
         (b (mpfi)))
     (mpfi_set_si a 10)
     (mpfi_set_si b 5)
     (mpfi_add c a b)

     (do-something-with c)))
@end example


@c page
@node mpfi string
@section Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @code{mpfi_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (uriel ffi)
  (mp mpfi)
  (mp sizeof))
@end example

We have to notice that @mpfi{} does not export a function to convert an
@code{mpfi_t} number to a string, but we can access directly the left
and right limits of the interval as @code{mpfr_t} numbers.  So let's say
that we have defined a @func{mpfr->string} function (@ref{mpfr string}
for an example).

The following functions do a basic conversion from an @code{mpfi_t} to a
string:

@example
(define (mpfi->string-interval o)
  (format "[~a, ~a]"
    (mpfr->string (struct-mpfi-left-ref o))
    (mpfr->string (struct-mpfi-right-ref o))))

(define (mpfi->string o)
  (let ((fr (malloc sizeof-mpfr_t)))
    (mpfr_init fr)
    (mpfi_get_fr fr o)
    (begin0
        (mpfr->string o)
      (mpfr_clear fr))))
@end example

@noindent
where the second one just prints the number representing the middle of
the interval.


@c page
@node mpc
@chapter Multiple precision complex numbers


The complex floating point numbers @api{} is exported by the @library{mp
mpc} library.  To use @code{mpc_t} numbers we basically have to do:

@example
(import (rnrs)
  (uriel ffi)
  (mp mpc)
  (mp sizeof))

  (let ((a (malloc sizeof-mpc_t))
        (b (malloc sizeof-mpc_t))
        (c (malloc sizeof-mpc_t)))
    (mpc_init a)
    (mpc_init b)
    (mpc_init c)

    (mpc_set_d_d   a 10.4 8.9 MPC_RNDNN)
    (mpc_set_si_si b  5   1.2 MPC_RNDNN)
    (mpc_add c a b MPC_RNDNN)

    (mpc_clear a)
    (mpc_clear b)
    (primitive-free a)
    (primitive-free b)
    c)
@end example

More advanced memory handling and usage examples are in the following
sections.

@menu
* mpc compensation::           Compensating memory allocation.
* mpc factory::                Object factory.
* mpc string::                 Conversion to string.
@end menu


@c page
@node mpc compensation
@section Compensating memory allocation


The @library{uriel lang} library exports the compensation stacks @api{}
as a mean to automatically release synchronous resources, even in case
of raised exceptions.  @nauref{compensations, Compensation stacks}

So let's start a program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (mp mpc)
  (mp sizeof))
@end example

To allocate a @code{mpc_t} number with a compensation we can use the
following function:

@example
(define (compensated-mpc)
  (letrec ((p (compensate
                   (malloc sizeof-mpc_t)
                (with
                 (mpc_clear p)
                 (priitive-free p)))))
    (mpc_init p)
    p))
@end example

@noindent
now to add two numbers we can use a compensated allocation and
initialisation for the two operands:

@example
(let ((c (malloc sizeof-mpc_t)))
  (mpc_init c)
  (with-compensations
    (let ((a (compensated-mpc))
          (b (compensated-mpc)))
      (mpc_set_d_d   a 10.4 8.9 MPC_RNDNN)
      (mpc_set_si_si b  5   1.2 MPC_RNDNN)
      (mpc_add c a b MPC_RNDNN)
      c)))
@end example


@c page
@node mpc factory
@section Object factory


The @library{uriel lang} library exports the object factory @api{} as a
mean to automatically allocate, initialise, finalise and release
synchronous resources, even in case of raised exceptions.
@nauref{memory cache, Caching memory blocks}

So let's start a program with:

@example
(import (rnrs)
  (uriel lang)
  (uriel ffi)
  (mp mpc)
  (mp sizeof))
@end example

We can define an object factory for @code{mpc_t} numbers with:

@example
(define mpc-factory
  (make-caching-object-factory mpc_init mpc_clear
                               sizeof-mpc_t 10))
@end example

@noindent
and we can use it with compensations:

@example
(define (mpc)
  (letrec ((p (compensate
                  (mpc-factory)
                (with
                 (mpc-factory p)))))
    p))
@end example

@noindent
now to add two numbers we can do:

@example
(with-compensations
   (let ((c (mpc))
         (a (mpc))
         (b (mpc)))
     (mpc_set_d_d   a 10.4 8.9 MPC_RNDNN)
     (mpc_set_si_si b  5   1.2 MPC_RNDNN)
     (mpc_add c a b MPC_RNDNN)
     (do-something-with c)))
@end example


@c page
@node mpc string
@section Conversion to string


After having computed a result, we will probably desire to see it.  The
easiest way is to convert the @code{mpc_t} number to a string.  Let's
start the program with:

@example
(import (rnrs)
  (uriel ffi)
  (mp mpfr)
  (mp mpc)
  (mp sizeof))
@end example

We have to notice that @mpc{} does not export a function to convert an
@code{mpc_t} number to a string, but we can access directly the real and
imaginary parts of the complex as @code{mpfr_t} numbers.  So let's say
that we have defined a @func{mpfr->string} function (@ref{mpfr string}
for an example).

The following function does a basic conversion from an @code{mpc_t} to a
string:

@example
(define (mpc->string o)
   (let ((im (mpfr->string (struct-mpc-im-ref o))))
     (format "~a~a~ai"
       (mpfr->string (struct-mpc-re-ref o))
       (if (char=? #\- (string-ref im 0))
          ""
        #\+)
       im)))
@end example


@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node references
@appendix Bibliography and references


The @gmp{} library can be found at:

@center @url{http://gmplib.org/}

@noindent
the @mpfr{} library can be found at:

@center @url{http://www.mpfr.org/}

@noindent
the @mpfi{} library can be found at:

@center @url{http://gforge.inria.fr/projects/mpfi/}

@noindent
the @mpc{} library can be found at:

@center @url{http://www.multiprecision.org/mpc/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
