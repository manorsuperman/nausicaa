\input texinfo.tex
@c %**start of header
@setfilename nausicaa-srfi.info
@settitle SRFI for R6RS Scheme
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc


@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@macro bsd{}
@acronym{BSD}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro aurl{}
@acronym{URL}
@end macro

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro ram{}
@acronym{RAM}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@c Remember that @url is already used by Texinfo.
@macro urla{}
@acronym{URL}
@end macro

@c ------------------------------------------------------------
@c Software related macros.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@macro glibc{}
@gnu{} C Library
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro icmp{}
@acronym{ICMP}
@end macro

@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro https{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@macro snmp{}
@acronym{SNMP}
@end macro

@c ------------------------------------------------------------
@c Arguments macros.
@c ------------------------------------------------------------

@macro vari{ARG}
@var{\ARG\1}
@end macro

@macro varii{ARG}
@var{\ARG\2}
@end macro

@macro variii{ARG}
@var{\ARG\3}
@end macro

@macro variv{ARG}
@var{\ARG\4}
@end macro

@macro varn{ARG}
@var{\ARG\n}
@end macro

@macro vark{ARG}
@var{\ARG\k}
@end macro

@macro varj{ARG}
@var{\ARG\j}
@end macro

@c ------------------------------------------------------------

@macro meta{ARG}
<\ARG\>
@end macro

@macro metai{ARG}
@meta{\ARG\1}
@end macro

@macro metaii{ARG}
@meta{\ARG\2}
@end macro

@macro metaiii{ARG}
@meta{\ARG\3}
@end macro

@macro metaiv{ARG}
@meta{\ARG\4}
@end macro

@macro metan{ARG}
@meta{\ARG\n}
@end macro

@macro metak{ARG}
@meta{\ARG\k}
@end macro

@macro metaj{ARG}
@meta{\ARG\j}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro null{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{NAME}
@code{(\NAME\)}
@end macro

@macro module{NAME}
@code{\NAME\}
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@ignore
Separating the @srfi{}  macro from the number with a  '--' rather than a
'-' makes the expansion look ugly in menu entries under the Info reader.
IMHO this should not happen, but  it does; so we live with this, because
the main purpose of this document is to provide an Info version.
@end ignore
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@c ------------------------------------------------------------

@macro func{NAME}
@code{@sc{\NAME\}}
@end macro

@macro nil{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@macro rsixref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@end macro

@macro rfiveref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r5rs}
@end macro

@macro ikarusref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,ikarus}
@end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @srfi{} for @rnrs{6} Scheme

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@srfi{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-srfi

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2008



@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a
packaging of @srfi{}s for @rnrs{6} Scheme.  The original @srfi{}
documents are the work of many authors and are available at:

@center @url{http://srfi.schemers.org/}

@noindent
the original source code was ported to @rnrs{6} and Ikarus Scheme by
Derick Eddington with contributions by Abdulaziz Ghuloum, and is
available at:

@center @url{http::/code.launchpad.net/ikarus-libraries}

@noindent
upon inclusion in Nausicaa the code was further modified by Marco Maggi.
The code in this package is covered by the original @srfi{} license, see
the copyright notices in the source files.

This document was assembled by reformatting the original @srfi{}
documents, with changes and additions to make it fit the Nausicaa
distribution.  Each chapter includes the original copyright notice and
author citation: refer to those for copying conditions.

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'', no
Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying


@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-srfi: (nausicaa-srfi). @srfi{} for @rnrs{6} Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.

* lang-lib::                    Language extension library.
* list::                        List library.
* strings::                     The string library.
* char-set::                    Character set library.
* time::                        Time data types and procedures.
* args-fold::                   A program argument processor.
* streams::                     Streams library.
* lightweight-testing::         Lightweight testing.
* environment-variables::       Environment variables.

External documents

* format-lib:(format-lib).      Formatted output.

Appendices

* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Overview of the package

* overview credits::            Credits and copying conditions.
* overview srfi::               The @srfi{} libraries.
* overview stub::               Stub libraries.

Language extension library

* cond-expand::                 Feature based conditional expansion
                                construct.
* and-let-star::                An @func{and} with local bindings.
* receive::                     Binding to multiple values.
* cut::                         Notation for specializing parameters
                                without currying.
* rec::                         A special form for recursive evaluation.
* parameters::                  Parameter objects.
* general-cond::                A more general @func{cond} clause.

Feature based conditional expansion construct

* cond-expand license::         Original license.
* cond-expand abstract::        Abstract.
* cond-expand rationale::       Rationale.
* cond-expand spec::            Specifications.
* cond-expand features::        Feature identifiers.

An @func{and} with local bindings

* and-let-star license::        Original license.
* and-let-star abstract::       Abstract.
* and-let-star rationale::      Rationale.
* and-let-star spec::           Specification.
* and-let-star stub::           Stub library.

Binding to multiple values

* receive license::             Original license.
* receive abstract::            Abstract.
* receive rationale::           Rationale.
* receive spec::                Specification.
* receive stub::                Stub library.

Notation for specializing parameters without currying

* cut license::                 Original license.
* cut abstract::                Abstract.
* cut rationale::               Rationale.
* cut spec::                    Specification.
* cut design::                  Rationale design.
* cut ack::                     Acknowledgements.
* cut stub::                    Stub library.

A special form for recursive evaluation

* rec license::                 Original license.
* rec abstract::                Abstract.
* rec rationale::               Rationale.
* rec spec::                    Specification.
* rec ack::                     Acknowledgements.
* rec references::              References.
* rec stub::                    Stub library.

Parameter objects

* parameters license::          Document license.
* parameters abstract::         Abstract.
* parameters rationale::        Rationale.
* parameters spec::             Specification.
* parameters stub::             Stub library.

A more general @func{cond} clause

* general-cond license::        Original license.
* general-cond abstract::       Abstract.
* general-cond rationale::      Rationale.
* general-cond spec::           Specification.
* general-cond stub::           Stub library.

List library

* list license::                Original license.
* list abstract::               Abstract.
* list rationale::              Rationale.
* list discussion::             Discussion.
* list spec::                   Specifications.
* list ack::                    Acknowledgements.
* list references::             References.

Discussion

* list disc general::           General discussion.
* list disc linear update::     Linear update procedures.
* list disc improper::          Improper lists.
* list disc errors::            Errors.
* list disc not included::      Not included in this library.

Specifications

* list spec intro::             Introduction.
* list spec cons::              Constructors.
* list spec pred::              Predicates.
* list spec select::            Selectors.
* list spec misc::              Length, append, concatenate,
                                reverse, zip and count.
* list spec fold::              Fold, unfold and map.
* list spec filter::            Filtering and partitioning.
* list spec search::            Searching.
* list spec delete::            Deletion.
* list spec alist::             Association lists.
* list spec set::               Set operations on lists.
* list spec side::              Primitive side--effects.
* list spec stub::              Stub library bindings.

Constructors

* list spec cons pair::         Pair constructors.
* list spec cons list::         List constructors.

Predicates

* list spec pred kind::         Kinds of list.
* list spec pred null::         Null predicates.
* list spec pred pair::         Pair predicates.
* list spec pred cmp::          Comparison.

Fold, unfold and map

* list spec fold fold::         Folding.
* list spec fold reduce::       Reducing.
* list spec fold unfold::       Unfolding.
* list spec fold map::          Mapping.

String library

* strings license::             Original license.
* strings abstract::            Abstract.
* strings rationale::           Rationale.
* strings spec::                Specification.
* strings ack::                 Acknowledgments.
* strings references::          References.

Rationale

* strings ratio code-point::    Strings are code-point sequences.
* strings ratio i18n::          Internationalisation and
                                super-@ascii{} character types.

Specification

* strings spec intro::          Introduction.
* strings spec pred::           Predicates.
* strings spec cons::           Constructors.
* strings spec list::           List and string conversion.
* strings spec select::         Selection.
* strings spec modify::         Modification.
* strings spec compar::         Comparison.
* strings spec prefix::         Prefixes and suffixes.
* strings spec search::         Searching.
* strings spec case-map::       Alphabetic case mapping.
* strings spec append::         Reverse and append.
* strings spec fold::           Fold, unfold and map.
* strings spec replicate::      Replicate and rotate.
* strings spec misc::           Miscellaneous: intertion, parsing.
* strings spec filter::         Filtering and deleting.

Low level procedures

* strings spec parsing::        Start/end optional-argument parsing
                                and checking utilities.
* strings spec knuth::          Knuth-Morris-Pratt searching.

Character set library

* char-set license::            Original license.
* char-set abstract::           Abstract.
* char-set rationale::          Rationale.
* char-set spec::               Specification.
* char-set ack::                Acknowledgements.

Specification

* char-set spec intro::         Introduction.
* char-set spec general::       General procedures.
* char-set spec iter::          Iterating over char sets.
* char-set spec create::        Creating char sets.
* char-set spec query::         Querying char sets.
* char-set spec algebra::       Char sets algebra.
* char-set spec sets::          Standard char sets.

Time data types and procedures

* time license::                Original license.
* time abstract::               Abstract.
* time rationale::              Rationale.
* time spec::                   Specification.
* time ack::                    Acknowledgements.

Specification

* time spec intro::             Introduction.
* time spec const::             Constants.
* time spec current::           Current time and clock resolution.
* time spec timeobj::           Time object and accessors.
* time spec timeobj compar::    Time object comparison procedures.
* time spec timeobj arithm::    Time object arithmetic procedures.
* time spec dateobj::           Date object and accessors.
* time spec julian::            Time/Date/Julian Day/Modified
                                Julian Day Converters.
* time spec string::            Date to string/string to date
                                converters.

A program argument processor

* args-fold license::           Original license.
* args-fold abstract::          Abstract.
* args-fold rationale::         Rationale.
* args-fold spec::              Specification.

Streams

* streams license::             Streams document license.
* streams abstract::            Abstract.
* streams rationale::           Rationale.
* streams primitive::           The @library{streams primitive} library.
* streams primitive example::   Streams primitive library example.
* streams derived::             The @library{streams derived} library.
* streams utilities::           Utilities.
* streams examples::            Examples.
* streams ack::                 Acknowledgments.
* streams references::          References.

Examples

* streams examples infinite::   Infinite streams.
* streams examples generators:: Generators and co--routines.
* streams examples pipeline::   A pipeline of procedures.
* streams examples persistent:: Persistent data.
* streams examples passes::     Reducing two passes to one.
* streams examples pitfalls::   Pitfalls.

Lightweight testing

* lightweight-testing license::         Original license.
* lightweight-testing abstract::        Abstract.
* lightweight-testing rationale::       Rationale.
* lightweight-testing spec::            Specification.
* lightweight-testing references::      References.

Environment variables

* environment-variables license::       Original license.
* environment-variables abstract::      Abstract.
* environment-variables rationale::     Rationale.
* environment-variables spec::          Specification.
* environment-variables issues::        Issues.
* environment-variables ack::           Acknowledgements.

@end detailmenu
@end menu

@end ifnottex

@c page
@node overview
@chapter Overview of the package


@noindent
This document describes version @version{} of @value{PACKAGE}, a
packaging of @srfi{}s for @rnrs{6} Scheme.  All the libraries can be
loaded with:

@example
(import (srfi @meta{name}))
@end example

@noindent
where @meta{name} is the ``name'' of the @srfi{}, for example:

@example
(import (srfi and-let-star))
@end example

Usage notices:

@itemize
@item
Additional stub libraries are installed, and they export @strong{almost}
the same bindings of the original @srfi{}s.

@item
All the bindings documented by the original @srfi{}s are exported by the
@library{srfi ---} libraries.  This will cause conflicts for some
@srfi{}; for example @library{srfi lists} redefines @func{map} and some
other functions.  These conflicts can be solved using the @rnrs{6}
selective import features of the @func{library} form.

@item
The stub libraries resolve the conflicts by exporting the redefined
functions with the @code{srfi:} prefix applied to the name.  Refer to
the @srfi{} documentation chapters for the list of redefined bindings.

@item
Whenever a binding is defined by both the @rnrs{6} and an @srfi{}, the
binding from the @rnrs{6} library is re-exported by the @srfi{} and stub
library.  There will be no conflicts with those.
@end itemize


@menu
* overview credits::            Credits and copying conditions.
* overview srfi::               The @srfi{} libraries.
* overview stub::               Stub libraries.
@end menu


@c page
@node overview credits
@section Credits and copying conditions


@insertcopying


@c page
@node overview srfi
@section The @srfi{} libraries


The following is a list of the available @srfi{} libraries.

@table @asis
@item @ansrfi{0}
@itemx @library{srfi cond-expand}
Feature based conditional expansion construct.

@item @ansrfi{1}
@itemx @library{srfi lists}
The list library.

@item @ansrfi{2}
@itemx @library{srfi and-let-star}
An @func{and} with local bindings.

@item @ansrfi{8}
@itemx @library{srfi receive}
Binding multiple values.

@item @ansrfi{13}
@itemx @library{srfi strings}
The string library.

@item @ansrfi{14}
@itemx @library{srfi char-set}
The character sets library.

@item @ansrfi{19}
@itemx @library{srfi time}
Time data types and procedures.

@item @ansrfi{26}
@itemx @library{srfi cut}
Notation for specialising parameters without currying.

@item @ansrfi{27}
@itemx @library{srfi random}
Sources of random bits.

@item @ansrfi{31}
@itemx @library{srfi rec}
A special form for recursive evaluation.

@item @ansrfi{37}
@itemx @library{srfi args-fold}
A program arguments processor.

@item @ansrfi{39}
@itemx @library{srfi parameters}
Parameter objects.

@item @ansrfi{41}
@itemx @library{srfi streams)}
The streams library.

@item @ansrfi{42}
@itemx @library{srfi eager-comprehensions}
Extended loop constructs.

@item @ansrfi{43}
@itemx @library{srfi vectors}
The vector library.

@item @ansrfi{48}
@itemx @library{srfi format}
Intermediate format strings.

@item @ansrfi{61}
@itemx @library{srfi general-cond}
A more general @func{cond} clause.

@item @ansrfi{67}
@itemx @library{srfi compare}
Comparison functions.

@item @ansrfi{78}
@itemx @library{srfi lightweight-testing}
Library for lightweight test suites.

@item @ansrfi{98}
@itemx environment-variables
Environment variables.
@end table


@c page
@node overview stub
@section Stub libraries


Another way to import the @srfi{} bindings is to import the following
stub libraries.  See the @srfi{} documentation chapters for differences
between the bindings exported by the @library{srfi ---} libraries and
the bindings exported by the stub libraries.


@table @library
@item features-lib
Imports @library{srfi cond-expand} and exports all its bindings.

@item check-lib
Imports @library{srfi lightweight-testing} and exports all its bindings.

@item env-lib
Imports @library{srfi environment-variables} and exports all its
bindings.

@item format-lib
Imports @library{srfi format} and exports all its bindings.

@item lang-lib
Imports and re--exports bindings from the following libraries:

@example
(srfi and-let-star)
(srfi cut)
(srfi general-cond)
(srfi parameters)
(srfi receive)
@end example

@item list-lib
Imports @library{srfi lists} and exports all its bindings.

@item loop-lib
Imports @library{srfi eager-comprehensions} and exports all its
bindings.

@item string-lib
Imports @library{srfi strings} and exports all its bindings.

@item vector-lib
Imports @library{srfi vectors} and exports all its bindings.
@end table


@c page
@node lang-lib
@chapter Language extension library


The @library{lang-lib} library collects bindings from the @srfi{}s that
extend the Scheme language core features.

@menu
* cond-expand::                 Feature based conditional expansion
                                construct.
* and-let-star::                An @func{and} with local bindings.
* receive::                     Binding to multiple values.
* cut::                         Notation for specializing parameters
                                without currying.
* rec::                         A special form for recursive evaluation.
* parameters::                  Parameter objects.
* general-cond::                A more general @func{cond} clause.
@end menu


@c page
@node cond-expand
@section Feature based conditional expansion construct


@ansrfi{0} was written by Marc Feeley, the @value{PACKAGE}
implementation was written by Derick Eddington.

@menu
* cond-expand license::         Original license.
* cond-expand abstract::        Abstract.
* cond-expand rationale::       Rationale.
* cond-expand spec::            Specifications.
* cond-expand features::        Feature identifiers.
@end menu


@c page
@node cond-expand license
@subsection Original license


Copyright @copyright{} Marc Feeley 1999.  All Rights Reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it or
assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are included
on all such copies and derivative works.  However, this document itself
may not be modified in any way, such as by removing the copyright notice
or references to the Scheme Request For Implementation process or
editors, except as needed for the purpose of developing SRFIs in which
case the procedures for copyrights defined in the SRFI process must be
followed, or as required to translate it into languages other than
English.

The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.

This document and the information contained herein is provided on an
``AS IS'' basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.


@c page
@node cond-expand abstract
@subsection Abstract


@noindent
It is desirable that programs which depend on additions to standard
Scheme name those additions.  @srfi{}s provide the specifications of
these additions (``features''), and @ansrfi{0} provides the means to
actually check that these features are present in the Scheme system by
means of the @func{cond-expand} construct.  It is anticipated that there
will be two main classes of features:

@itemize
@item
sets of values and syntax bindings;

@item
reader syntax extensions;
@end itemize

@noindent
``reader syntax'' refers to aspects of the syntax described by the
grammars in the Scheme reports.

The former class of features will probably include most @srfi{}s,
exemplified by the list library specified in @ansrfi{1}.  The latter class
includes Unicode source code support and different kinds of parentheses.

Control over the presence of individual features will vary over
different Scheme systems.  A given feature may be absent or provided by
default in some Scheme systems and in others some mechanism (such as an
@func{import} clause in the code or a program configuration file, a
command line option, a dependency declaration in a module definition,
etc.) will be required for the feature to be present in the system.

Moreover, in some systems a given feature may be in effect throughout
the entire program if it is in effect anywhere at all.  Other systems
may have more precise mechanisms to control the scope of a feature (this
might be the case for example when a module system is supported).  In
general it is thus possible that a feature is in effect in some parts of
the program and not in others.  This allows conflicting @srfi{}s to be
present in a given program as long as their scope do not intersect.

@ansrfi{0} does not prescribe a particular mechanism for controlling the
presence of a feature as it is our opinion that this should be the role
of a module system.  We expect that future module system @srfi{}s will
need to extend the semantics of @ansrfi{0} for their purposes, for
example by defining feature scoping rules or by generalizing the feature
testing construct.

@c page
@node cond-expand rationale
@subsection Rationale


@noindent
Most Scheme systems extend the language with some additional features
(such as the ability to manipulate Unicode characters and strings, to do
binary I/O, or to handle asynchronous interrupts).  Such features may be
provided in a variety of ways including new procedures, new program
syntax, and extended behavior of standard procedures and special--forms.

A particular functionality may exist in several or even most Scheme
systems but its @api{} may be different (use of a procedure or
special--form, name, number of parameters, etc).  To write code that
will run on several Scheme systems, it is useful to have a common
construct to enable or disable sections of code based on the existence
or absence of a feature in the Scheme system being used.  For example,
the construct could be used to check if a particular binary I/O
procedure is present, and if not, load a portable library which
implements that procedure.

Features are identified by feature identifiers.  In order for the
semantics of this construct to be well--defined, the feature identifier
must of course refer to a feature which has a well--defined meaning.
There is thus a need for a registry, independent of this @srfi{}, to
keep track of the formal specification associated with each valid
feature--identifier.  The @srfi{} registry is used for this purpose.
It is expected that features will eventually be assigned meaningful
names (aliases) by the @srfi{} editors to make reading and writing code
less tedious than when using @code{srfi-N} feature identifiers.

Another issue is the binding time of this construct (i.e. the moment
when it operates).  It is important that the binding time be early so
that a compiler can discard the sections of code that are not needed,
and perform better static analyses.  Expressing this construct through a
procedure returning a boolean, such as:

@example
(feature-implemented? 'srfi-5)
@end example

@noindent
would not achieve this goal, as its binding time is too late
(i.e. program run--time).  A read--time construct, such as Common Lisp's
@code{#+} read-macro, is very early but would require non--trivial
changes to the reader of existing Scheme systems and the syntax is not
particularly human friendly.  Instead, a macro--expansion--time
construct is used.

The construct is restricted to the top level of a program in order to
simplify its implementation and to force a more disciplined use of the
construct (to facilitate reading and understanding programs) and to
avoid (some) misunderstandings related to the scope of features.  These
restrictions can of course be lifted by some Scheme systems or by other
@srfi{}s (in particular module system @srfi{}s).


@c page
@node cond-expand spec
@subsection Specifications


@findex cond-expand


@noindent
Syntax:

@example
<command or definition>
    --> <command>
      | <definition>
      | <syntax definition>
      | (begin <command or definition>+)
      | <conditional expansion form>
<conditional expansion form>
    --> (cond-expand <cond-expand clause>+)
      | (cond-expand <cond-expand clause>* (else <command or definition>*))
<cond-expand clause>
    --> (<feature requirement> <command or definition>*)
<feature requirement>
    --> <feature identifier>
      | (and <feature requirement>*)
      | (or <feature requirement>*)
      | (not <feature requirement>)
<feature identifier>
    --> a symbol which is the name or alias of a SRFI
@end example

The @func{cond-expand} form tests for the existence of features at
macro--expansion time.  It either expands into the body of one of its
clauses or signals an error during syntactic processing.
@func{cond-expand} expands into the body of the first clause whose
feature requirement is currently satisfied (the else clause, if present,
is selected if none of the previous clauses is selected).

A feature requirement has an obvious interpretation as a logical
formula, where the @code{<feature identifier>} variables have meaning
TRUE if the feature corresponding to the feature identifier, as
specified in the @srfi{} registry, is in effect at the location of the
@func{cond-expand} form, and FALSE otherwise.  A feature requirement is
satisfied if its formula is true under this interpretation.

Examples:

@example
(cond-expand
  [(and srfi-1 srfi-10)
   (write 1)]
  [(or srfi-1 srfi-10)
   (write 2)]
  [else])

(cond-expand
  (command-line
   (define (program-name) (car (argv)))))
@end example

The second example assumes that @func{command-line} is an alias for some
feature which gives access to command line arguments.  Note that an
error will be signaled at macro--expansion time if this feature is not
present.


@c page
@node cond-expand features
@subsection Feature identifiers


What follows is a list of features that can be queried using the
@value{PACKAGE} implementation of this library.


@table @code
@item srfi-0
@itemx srfi-1
@itemx srfi-2
@itemx srfi-6
@itemx srfi-8
@itemx srfi-13
@itemx srfi-14
@itemx srfi-26
@itemx srfi-27
@itemx srfi-31
@itemx srfi-37
@itemx srfi-38
@itemx srfi-39
@itemx srfi-41
@itemx srfi-42
@itemx srfi-43
@itemx srfi-48
@itemx srfi-61
@itemx srfi-67
@itemx srfi-78
@itemx (srfi cond-expand)
@itemx (srfi lists)
@itemx (srfi and-let*)
@itemx (srfi receive)
@itemx (srfi strings)
@itemx (srfi char-set)
@itemx (srfi time)
@itemx (srfi cut)
@itemx (srfi random)
@itemx (srfi rec)
@itemx (srfi args-fold)
@itemx (srfi sharing)
@itemx (srfi parameters)
@itemx (srfi streams)
@itemx (srfi eager-comprehensions)
@itemx (srfi vectors)
@itemx (srfi format)
@itemx (srfi general-cond)
@itemx (srfi compare)
@itemx (srfi lightweight-testing)
One feature for each @srfi{}.
@end table


@c page
@node and-let-star
@section An @func{and} with local bindings


@cindex @srfi{} and-let-star


@noindent
The @library{srfi and-let-star} library has been written by Oleg
Kiselyov as reference implementation for @ansrfi{2}.


@menu
* and-let-star license::        Original license.
* and-let-star abstract::       Abstract.
* and-let-star rationale::      Rationale.
* and-let-star spec::           Specification.
* and-let-star stub::           Stub library.
@end menu


@c page
@node and-let-star license
@subsection Original license


Copyright @copyright{} 1998 Oleg Kiselyov.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node and-let-star abstract
@subsection Abstract


Like an ordinary @func{and}, an @func{and-let*} special form evaluates
its arguments (expressions) one after another in order, till the first
one that yields @false{}.  Unlike @func{and}, however, a non--@false{}
result of one expression can be bound to a fresh variable and used in
the subsequent expressions.  @func{and-let*} is a cross--breed between
@func{let*} and @func{and}.



@c page
@node and-let-star rationale
@subsection Rationale


In case of an ordinary @func{and} formed of proper boolean expressions:

@example
(and e1 e2 ...)
@end example

@noindent
expression @var{e2}, if it gets to be evaluated, knows that @var{e1} has
returned non--@false{}.  Moreover, @var{e2} knows exactly what the
result of @var{e1} was (true) which @var{e2} can use to its advantage.
If @var{e1} however is an extended boolean expression, @var{e2} can no
longer tell which particular non--@false{} value @var{e1} has returned.
Chances are it took a lot of work to evaluate @var{e1}, and the produced
result (a number, a vector, a string, etc) may be of value to @var{e2}.
Alas, the @func{and} form merely checks that the result is not an
@false{}, and throws it away.  If @var{e2} needs it, it has to compute
that value anew.

This proposed @func{and-let*} special form lets constituent expressions
get hold of the results of already evaluated expressions, without
re--doing their work.

@func{and-let*} can be thought of as a combination of @func{let*} and
@func{and}, or a generalization of @func{cond}'s send operator,
@code{=>}.  An @func{and-let*} form can also be considered a sequence of
guarded expressions.

In a regular program, forms may produce results, bind them to variables
and let other forms use these results.  @func{and-let*} differs in that
it checks to make sure that every produced result ``makes sense'' (that
is, not an @false{}).  The first ``failure'' triggers the guard and
aborts the rest of the sequence (which presumably would not make any
sense to execute anyway).  Examples:

@example
(and-let* ([my-list     (compute-list)]
           [            (not (null? my-list))])
  (do-something my-list))

(define (look-up key alist)
  (and-let* ([x (assq key alist)])
    (cdr x)))

(or
  (and-let* ([c (read-char)]
             [  (not (eof-object? c))])
    (string-set! some-str i c)
    (set! i (+ 1 i)))
  (begin
    (do-process-eof)))

;; A more realistic example
;; Parse the 'timestamp' ::= 'token1' 'token2'
;;   token1 ::= 'YY' 'MM' 'J'
;;   token2 ::= 'GG' 'gg' "/"
(define (parse-full-timestamp token1 token2)
  (and-let* ([  (= 5 (string-length token1))]
             [  (= 5 (string-length token2))]
             [timestamp
                (OS:string->time "%m/%d/%y %H:%M"
                  (string
                    (string-ref token1 2) (string-ref token1 3) #\/
                    (string-ref token1 0) (string-ref token1 1) #\/
                    (case (string-ref token1 4)
                      ((#\8 #\9) #\9) (else #\0))
                    (string-ref token1 4) #\space
                    (string-ref token2 0) (string-ref token2 1) #\:
                    (string-ref token2 2) (string-ref token2 3)))]
             [  (positive? timestamp)])
           timestamp))
@end example

@func{and-let*} is also similar to an ``anaphoric @func{and}'' Lisp
macro@footnote{Rob Warnock, comp.lang.scheme, 26 Feb 1998 09:06:43 GMT,
Message-ID: @url{6d3bb3$3804h@@fido.asd.sgi.com}}.  @func{and-let*}
allows however more than one intermediate result, each of which
continues to be bound through the rest of the form.


@c page
@node and-let-star spec
@subsection Specification


@findex and-let*


@example
AND-LET* (CLAWS) BODY

CLAWS ::= '() | (cons CLAW CLAWS)
CLAW  ::=  (VARIABLE EXPRESSION) | (EXPRESSION) |
           BOUND-VARIABLE
@end example

@itemize
@item
The @code{CLAWS} are evaluated in the strict left--to--right order.

@item
For each @code{CLAW}, the @code{EXPRESSION} part is evaluated first (or
@code{BOUND-VARIABLE} is looked up)

@item
If the result is @false{}, @func{and-let*} immediately returns
@func{#f}.

@item
Otherwise, if the @code{claw} is of the form @code{(VARIABLE
EXPRESSION)} the @code{EXPRESSION}'s value is bound to a freshly made
@code{VARIABLE}.

@item
The @code{VARIABLE} is available for the rest of the @code{CLAWS}, and
the @code{BODY}.

@item
As usual, all @code{VARIABLE}s must be unique (like in @func{let*}).
@end itemize


@subsubheading Formal (denotational) semantics


@example
eval[ (AND-LET* (CLAW1 ...) BODY), env] =
   eval_claw[ CLAW1, env ] andalso
   eval[ (AND-LET* ( ...) BODY), ext_claw_env[CLAW1, env]]

eval[ (AND-LET* (CLAW) ), env] = eval_claw[ CLAW, env ]
eval[ (AND-LET* () FORM1 ...), env] = eval[ (BEGIN FORM1 ...), env ]
eval[ (AND-LET* () ), env] = #t

eval_claw[ BOUND-VARIABLE, env ] =
   eval[ BOUND-VARIABLE, env ]
eval_claw[ (EXPRESSION), env ] =
   eval[ EXPRESSION, env ]
eval_claw[ (VARIABLE EXPRESSION), env ] =
   eval[ EXPRESSION, env ]

ext_claw_env[ BOUND-VARIABLE, env ] = env
ext_claw_env[ (EXPRESSION), env ] =
   env-after-eval[ EXPRESSION, env ]
ext_claw_env[ (VARIABLE EXPRESSION), env ] =
   extend-env[ env-after-eval[ EXPRESSION, env ],
              VARIABLE boundto eval[ EXPRESSION, env ]]
@end example


@c page
@node and-let-star stub
@subsection Stub library


The @library{lang-lib} library imports and re--exports bindings from
@library{srfi and-let-star}.


@c page
@node receive
@section Binding to multiple values


@cindex @srfi{} receive


The @library{srfi receive} has been written by John David Stone
(Department of Mathematics and Computer Science, Grinnell College,
Grinnell, Iowa 50112, @email{stone@@cs.grinnell.edu}) as reference
implementation for @ansrfi{8}.


@menu
* receive license::             Original license.
* receive abstract::            Abstract.
* receive rationale::           Rationale.
* receive spec::                Specification.
* receive stub::                Stub library.
@end menu


@c page
@node receive license
@subsection Original license


Copyright @copyright{} 1999 John David Stone.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node receive abstract
@subsection Abstract


The only mechanism that @rnrs{5} provides for binding identifiers to the
values of a multiple--valued expression is the primitive
@func{call-with-values}.  This @srfi{} proposes a more concise, more
readable syntax for creating such bindings.

@c page
@node receive rationale
@subsection Rationale


Although @rnrs{5} supports multiple--valued expressions, it provides
only the essential procedures @func{values} and @func{call-with-values}.
It is evident that the authors expected Scheme programmers to define
other constructs in terms of these, abstracting common patterns of use.

One such pattern consists in binding an identifier to each of the values
of a multiple--valued expression and then evaluating an expression in
the scope of the bindings.  As an instance of this pattern, consider the
following excerpt from a quicksort procedure:

@example
(call-with-values
  [lambda ()
    (partition (precedes pivot) others)]
  [lambda (fore aft)
    (append (qsort fore) (cons pivot (qsort aft)))])
@end example

Here @func{partition} is a multiple--valued procedure that takes two
arguments, a predicate and a list, and returns two lists, one comprising
the list elements that satisfy the predicate, the other those that do
not.  The purpose of the expression shown is to partition the list
@var{others}, sort each of the sublists, and recombine the results into
a sorted list.

For our purposes, the important step is the binding of the identifiers
fore and aft to the values returned by @func{partition}.  Expressing the
construction and use of these bindings with the @func{call-by-values}
primitive is cumbersome: One must explicitly embed the expression that
provides the values for the bindings in a parameterless procedure, and
one must explicitly embed the expression to be evaluated in the scope of
those bindings in another procedure, writing as its parameters the
identifiers that are to be bound to the values received.

These embeddings are boilerplate, exposing the underlying binding
mechanism but not revealing anything relevant to the particular program
in which it occurs.  So the use of a syntactic abstraction that exposes
only the interesting parts (the identifiers to be bound, the
multiple--valued expression that supplies the values, and the body of
the receiving procedure) makes the code more concise and more readable:

@example
(receive (fore aft)
    [partition (precedes pivot) others]
  [append (qsort fore)
          (cons pivot (qsort aft))])
@end example

The advantages are similar to those of a @func{let}--expression over a
procedure call with a @func{lambda}--expression as its operator.  In
both cases, cleanly separating a ``header'' in which the bindings are
established from a ``body'' in which they are used makes it easier to
follow the code.


@c page
@node receive spec
@subsection Specification


@cindex @srfi{} receive api


@deffn Syntax receive @var{formals} @var{expression} @var{body}
@var{formals}, @var{expression}, and @var{body} are as described in
@rnrs{5}.  Specifically, @var{formals} can have any of three forms:

@table @code
@item (variable1 ... variablen)
The environment in which the @func{receive}--expression is evaluated is
extended by binding @var{variable1}, ..., @var{variablen} to fresh
locations.  The @var{expression} is evaluated, and its values are stored
into those locations (it is an error if @var{expression} does not have
exactly @var{n} values).

@item variable
The environment in which the @func{receive}--expression is evaluated is
extended by binding @var{variable} to a fresh location.  The
@var{expression} is evaluated, its values are converted into a newly
allocated list, and the list is stored in the location bound to
@var{variable}.

@item (variable1 ... variablen . variablen+1)
The environment in which the @func{receive}--expression is evaluated is
extended by binding @var{variable1}, ..., @var{variablen+1} to fresh
locations.  The @var{expression} is evaluated.  Its first @var{n} values
are stored into the locations bound to @var{variable1}, ...,
@var{variablen}.  Any remaining values are converted into a newly
allocated list, which is stored into the location bound to
@var{variablen+1} (it is an error if @var{expression} does not have at
least @var{n} values.
@end table

In any case, the expressions in @var{body} are evaluated sequentially in
the extended environment.  The results of the last expression in the
body are the values of the @var{receive}--expression.
@end deffn


@c page
@node receive stub
@subsection Stub library


The @library{lang-lib} library imports and re--exports bindings from
@library{srfi receive}.


@c page
@node cut
@section Notation for specializing parameters without currying


@cindex @srfi{} cut


@ansrfi{26} has been written by Sebastian Egner.


@menu
* cut license::                 Original license.
* cut abstract::                Abstract.
* cut rationale::               Rationale.
* cut spec::                    Specification.
* cut design::                  Rationale design.
* cut ack::                     Acknowledgements.
* cut stub::                    Stub library.
@end menu


@c page
@node cut license
@subsection Original license


Copyright @copyright{} 2002 Sebastian Egner.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node cut abstract
@subsection Abstract


When programming in functional style, it is frequently necessary to
specialize some of the parameters of a multi--parameter procedure.  For
example, from the binary operation @func{cons} one might want to obtain
the unary operation @code{(lambda (x) (cons 1 x))}.  This specialization
of parameters is also known as ``partial application'', ``operator
section'' or ``projection''.

The mechanism proposed here allows to write this sort of specialization
in a simple and compact way.  The mechanism is best explained by a few
examples:

@example
(cut cons (+ a 1) <>)   = (lambda (x2) (cons (+ a 1) x2))
(cut list 1 <> 3 <> 5)  = (lambda (x2 x4) (list 1 x2 3 x4 5))
(cut list)              = (lambda () (list))
(cut list 1 <> 3 <...>) = (lambda (x2 . xs) (apply list 1 x2 3 xs))
(cut <> a b)            = (lambda (f) (f a b))
@end example

As you see, the macro @func{cut} specializes some of the parameters of
its first argument.  The parameters that are to show up as formal
variables of the result are indicated by the symbol @code{<>}, pronouced
as ``slot''.  In addition, the symbol @code{<...>}, pronounced as
``rest--slot'', matches all residual arguments of a variable argument
procedure.  As you can see from the last example above, the first
argument can also be a slot, as one should expect in Scheme.

In addition to @func{cut}, there is a variant called @func{cute} (a
mnemonic for ``@func{cut} with evaluated non--slots'') which evaluates
the non--slot expressions at the time the procedure is specialized, not
at the time the specialized procedure is called.  For example:

@example
(cute cons (+ a 1) <>) = (let ([a1 (+ a 1)])
                           (lambda (x2)
                             (cons a1 x2)))
@end example

As you see from comparing this example with the first example above, the
@func{cute}--variant will evaluate @code{(+ a 1)} once, while the
@func{cut}--variant will evaluate it during every invocation of the
resulting procedure.

The mechanism proposed in this @srfi{} allows specializing any subset
of the variables of a procedure.  The result can be of fixed arity or of
variable arity.  The mechanism does not allow permutation, omission,
duplication or any other processing of the arguments; for this it is
necessary to write to use a different mechanism such as @func{lambda}.



@c page
@node cut rationale
@subsection Rationale


A particularly elegant way to deal with specialization is known as
currying (Schoenfinkel 1924, Curry 1958).  The idea of currying is to
reduce multi--argument functions to single--argument functions by
regarding an @var{n}--ary function as a unary function mapping its first
argument into an (@var{n-1})--ary function (which is curried in turn).
This point of view, apart from its theoretical elegance, allows an
extremely compact notation for specializing the first argument of a
function.  In the first example, one could simply write @code{(cons 1)}.

Yet, Scheme is not a curried language---the number of arguments passed
to a procedure must match the number of its parameters at all times.
This allows zero--arity and variable--arity procedures but in order to
specialize parameters one usually has to write down a lambda--expression
and invent some irrelevant identifiers for its formal variables (@var{x}
in the examples in the Abstract).  For this reason, the mechanism
proposed in this @srfi{} provides a simple and compact notation for
specializing any subset of the parameters of a procedure.

Note: @emph{The mechanism proposed here is not currying!}

The purpose of the mechanism proposed here is to make the benefits of
currying available within the programming language Scheme.  There are
two primary benefits of currying in practice: Higher--order types are
substantially simplified and there is a simple notation for specializing
parameters.  The type aspect is irrelevant as Scheme has latent typing.
The specialization aspect is largly covered with this @srfi{}.

Here are a few more examples for illustration:

@example
(map (cut * 2 <>) '(1 2 3 4))
(map (cut vector-set! x <> 0) indices)
(for-each (cut write <> port) exprs)
(map (cut <> x y z) (list min max))
(for-each (cut <>) thunks)
@end example



@c page
@node cut spec
@subsection Specification


@findex cut
@findex cute

The formal syntax of a specialized expression, in the style of the
Revised^5 Report on the Algorithmic Language Scheme:

@example
<cut-expression> -->  (cut  <slot-or-expr> <slot-or-expr>*)
                    | (cut  <slot-or-expr> <slot-or-expr>* <...>)
                    | (cute <slot-or-expr> <slot-or-expr>*)
                    | (cute <slot-or-expr> <slot-or-expr>* <...>)

<slot-or-expr>   -->  <>              ; a "slot"
                    | <expression>    ; a "non-slot expression"
@end example

The macro @func{cut} transforms a @code{<cut-expression>} into a
@code{<lambda expression>} with as many formal variables as there are
slots in the list @code{<slot-or-expr>*}.  The body of the resulting
@code{<lambda expression>} calls the first @code{<slot-or-expr>} with
arguments from @code{<slot-or-expr>*} in the order they appear.

In case there is a rest--slot symbol, the resulting procedure is also of
variable arity, and the body calls the first @code{<slot-or-expr>} with
all arguments provided to the actual call of the specialized procedure.

The macro @func{cute} is similar to the macro @func{cut}, except that it
first binds new variables to the result of evaluating the non--slot
expressions (in an unspecific order) and then substituting the variables
for the non--slot expressions.  In effect, @func{cut} evaluates
non--slot expressions at the time the resulting procedure is called,
whereas @func{cute} evaluates the non--slot expressions at the time the
procedure is constructed.



@c page
@node cut design
@subsection Rationale design


@subsubheading Why not real currying/uncurrying?

It is possible in Scheme to implement a macro turning a multi--argument
procedure into a nesting of single--argument procedures and back.  These
operations are usually called ``curry'' and ``uncurry'' in other
programming languages.

Yet, Scheme remains an inherently uncurried language and is not prepared
to deal with curried procedures in a convenient way.  Hence, a ``by the
book'' implementation of currying would only be useful if you apply it
in the sequence ``curry, specialize some arguments, and uncurry again'',
which is exactly the purpose of the macro @func{cut} specified in this
document.  The primary relevance of currying/uncurrying in Scheme is to
teach concepts of combinatory logic.

@c ------------------------------------------------------------

@subsubheading Why not a more general mechanism, also allowing permutation omission and duplication of arguments?

The reason is that I, the author of this @srfi{}, consider more general
mechanisms too dangerous to mix them with the mechanism proposed here.
In particular, as soon as parameters are being rearranged it is usually
necessary to be aware of the meaning of the parameters; unnamed
variables can be quite harmful then.  The mechanism proposed here is
designed to prevent this.

Please refer to the discussion threads ``OK, how about...,'' (Alan
Bawden), ``is that useful?'' (Walter C.  Pelissero), and ``l, the
ultimate curry that is not curry'' (Al Petrofsky).

@c ------------------------------------------------------------

@subsubheading Why are the macro called @func{cut}/@func{cute} and not [enter your favourite here]?

Well, the original name proposed for this @srfi{} was @func{curry}
which immediately stirred some emotions as it does not what is commonly
known as currying.  Some alternatives have been discussed, such as:

@example
section         specialise      specialize,
partial-apply   partial-call    partial-lambda,
_j              _i              $
&               srfi-26         foobar
xyz             schoenfinkelize curry-which-isnt-curry
tandoori
@end example

@noindent
and it has also been suggested to pick a five letter symbol uniformly at
random and fix this as a name.  To be fair, not all of these name have
been put forward as serious proposals, some of them were merely to
illustrate a point in the discussion.  In addition, I have played with
the game of the name quite a bit and considered other candidates not
listed here.

Despite the fact that the discussion list only represents a highly
biased random sample of people's opinion (motivation to post a message
is higher if you disagree, for example) it told me that the @srfi{}
could potentially benefit from a different name; however impractical it
may be to go for unanimous popularity.

The name @func{cut} refers to ``operator section'', as the concept is
often called in other programming languages, but I tend to remember it
as the acronym for ``Curry Upon This''. ;-) The names for the evaluating
version of @func{cut} that have been proposed were @func{cut!},
@func{cutlet}, @func{cut*}, and @func{cute}.

@c ------------------------------------------------------------

@subsubheading Is it possible to implement the @srfi{} without macros?

Not really.  As Stephan Houben has pointed out during the discussion
(refer to ``Implementing it as a procedure'') it is possible to
implement the @func{cute}--mechanism as a procedure.  Refer also to Al
Petrofsky's posting ``Problems with @emph{curry}'s formal
specification'' for details.

However, the procedural implementation comes with a slight performance
penalty and it is not possible the implement the @func{cut}--mechanism
as a procedure, too.

As both are needed, we rely on macros to implement the @srfi{}.  Why is
there another symbol for the rest--slot when @func{lambda}--expressions
use the dotted notation for variable length argument lists?  There are
two reasons.  The first one is the existence of a procedural
implementation of a related mechanism (refer to the previous paragraph).
For a procedure, however, it is not possible to have dotted notation.
The second reason is the way the hygienic macro mechanism in @rnrs{5} is
defined to deal with dotted notation, as Felix Winkelmann has pointed
out.  Refer to the discussion threads ``Improper lists in macros [WAS:
none]''.

@c ------------------------------------------------------------

@subsubheading Why is it impossible to specify when a non--slot is evaluate individually per non--slot?

@func{cut} evaluates all non--slots at the time the specialized
procedure is called and @func{cute} evaluates all non--slots at the time
the procedure is being specialized.  These are only the two extremes and
it is possible to define a syntax that allows to choose per non--slot.
However, I am convinced that the benefit of the greater flexibility is
not worth the risk of confusion.  If a piece of code really depends on
the distinction, it might be better to make this explicit through
@func{let} and @func{lambda}.

@c ------------------------------------------------------------

@subsubheading Why is @code{(cut if <> 0 1)} etc. illegal?

It is specified that a @code{<slot-or-expr>} must be either the slot
symbol or an @func{<expression>} in the sense of @rnrs{5}, Section
7.1.3.  As if is no @func{<expression>}, the above case is illegal.  The
reason why @func{cut} and @func{cute} are restricted in this sense is
the difficulty of defining the meaning of such generalized expressions.
Please refer to the discussion archive for details.


@c page
@node cut ack
@subsection Acknowledgements


An important part of this @srfi{} is based on the contribution of other
people, mostly through the discussion archive.  In particular, the
semantics and the design rationale have been greatly improved in the
course of the discussion.  I would like to thank all who have
contributed.


@c page
@node cut stub
@subsection Stub library


The @library{lang-lib} library imports and re--exports the bindings from
@library{srfi cut}.


@c page
@node rec
@section A special form for recursive evaluation


@cindex @srfi{} rec


The @library{srfi rec} library has been written by Mirko Luedde
@email{Mirko.Luedde@@SAP.com} as the reference implementation for
@ansrfi{31}.


@menu
* rec license::                 Original license.
* rec abstract::                Abstract.
* rec rationale::               Rationale.
* rec spec::                    Specification.
* rec ack::                     Acknowledgements.
* rec references::              References.
* rec stub::                    Stub library.
@end menu


@c page
@node rec license
@subsection Original license


Copyright @copyright{} 2002 Dr. Mirko Luedde.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node rec abstract
@subsection Abstract


We propose the implementation of a special form called @func{rec}.  This
form is a generalization and combination of the forms @func{rec} and
@func{named-lambda} of [Clinger1985].  It allows the simple and
non--imperative construction of self--referential expressions.

As an important special case, it extends the A. Church form
@func{lambda} such that it allows the direct definition of recursive
procedures without using further special forms like @func{let} or
@func{letrec}, without using advanced constructions like the H. B. Curry
combinator and, unlike @func{define}, without introducing variable
bindings into the external environment.



@c page
@node rec rationale
@subsection Rationale


@subheading General


Among the prominent features of the Scheme programming language as
defined in [KCR1998] are the following:

@itemize
@item
it has simple syntax;

@item
it encourages recursive definitions, e.g. by ensuring memory efficient
tail recursion;

@item
it supports non--imperative programming.
@end itemize

Nevertheless Scheme does not provide a syntax for recursive evaluations
with the properties of:

@itemize
@item
being as simple, intuitive and close to the mathematical standard
notation as possible;

@item
allowing general recursion;

@item
being non--imperative.
@end itemize

@c ------------------------------------------------------------

@subheading Example

@subsubheading Problem 1

Let us look at the factorial function.  In mathematical notation this
function is expressed as:

@example
(F : N |--> 1,            if N = 0;
            N * F(N - 1), otherwise
@end example

This expression is a term and not a definition or proposition.

We investigate some approaches to express the factorial function in
Scheme.

@itemize
@item
The simplest way perhaps is as:

@example
(define (F N)
  (if (zero? N)
      1
    (* N (F (- N 1)))))
@end example

But this expression is not a term.  It binds the factorial function to
the variable @var{f}.  The expression itself may not occur in a
syntactical context where a name of the factorial is required.

@item
We list several ways to express the factorial as a function term.

@enumerate
@item
@example
(let ()
  (define (F N)
    (if (zero? N)
        1
      (* N (F (- N 1)))))
      F)
@end example

@item
@example
(lambda (N)
  (let F ([N N])
    (if (zero? N)
        1
      (* N (F (- N 1))))))
@end example

@item
@example
(letrec ([F (lambda (N)
              (if (zero? N)
                  1
                (* N (F (- N 1)))))])
  F)
@end example

@item
@example
((lambda (F)
   (F F))
 (lambda (G)
   (lambda (N)
     (if (zero? N)
         1
       (* N ((G G) (- N 1)))))))
@end example
@end enumerate

All these expressions define the factorial anonymously, not binding it
to a variable.  However, all these expressions are more verbose than it
seems necessary and they are less intuitive than it seems desirable.
@end itemize

@c ------------------------------------------------------------

@subsubheading Solution 1

A solution to our problem was already provided in [Clinger1985] by the
form @func{named-lambda}.  An even earlier solution with a slightly
different syntax was implemented in Kent Dybvig's Chez Scheme system.
Using this special form, we can denote the factorial simply by:

@example
(named-lambda (F N)
  (if (zero? N)
      1
    (* N (F (- N 1)))))
@end example

This expression is a function term that denotes the factorial in the
appropriate brevity.

However, the form @func{named-lambda} has been dropped from later
versions of the Scheme Report.  Also it is missing in
state--of--the--art implementations such as Chez Scheme (6.0a) and
@acronym{MIT} Scheme (7.7.0).  (The latter actually knows a form
@func{named-lambda} with different semantics.)

@c ------------------------------------------------------------

@subsubheading Problem 2

The constant stream of ones can be defined via:

@example
(define S (cons 1 (delay S)))
@end example

As in the case of the factorial, we are able to define the recursive
object at the price of spending an externally bound name.  Remedying
this with let or letrec leads to similar objections as above.

@subsubheading Solution 2

@noindent
This particular case of the self--referential problem was solved by the
@func{rec} form in [Clinger1985].  This form allows writing:

@example
(rec S (cons 1 (delay S)))
@end example

This expression is non--imperative and does not introduce an external
variable binding.

Also this form has been dropped from later versions of the Scheme
Report.  Moreover, from our point of view this form alone is not capable
of solving Problem 1.  The respective definition would look like:

@example
(rec F
  (lambda (N)
    (if (zero? N)
        1
      (* N (F (- N 1))))))
@end example

This again does not seem quite as simple and intuitive as the
mathematical notation.

@c ------------------------------------------------------------

@subheading Proposal

We therefore propose to implement the @func{rec} special form in a
generalized way that combines the advantages of the @func{named-lambda}
and @func{rec} forms.  The factorial function could be written:

@example
(rec (F N)
  (if (zero? N)
      1
    (* N (F (- N 1)))))
@end example


@c page
@node rec spec
@subsection Specification


@findex rec


@subsubheading Syntax

The following production rules are to be added to those of [KCR1998] (we
reuse names of non--terminals).

@example
<derived expression> --> <rec expression>
<rec expression>     --> (rec <variable>    <expression>)
<rec expression>     --> (rec (<variable>+) <body>)
@end example

@c ------------------------------------------------------------

@subsubheading Semantics

Scheme versions such as [KCR1998] providing @func{define-syntax},
@func{syntax-rules}, @func{letrec} and @func{lambda} might implement
@func{rec} as follows.

@example
(define-syntax rec
  (syntax-rules ()
    [(rec (NAME . VARIABLES) . BODY)
     (letrec ( (NAME (lambda VARIABLES . BODY)) ) NAME)]
    [(rec NAME EXPRESSION)
     (letrec ( (NAME EXPRESSION) ) NAME)]))
@end example

@c ------------------------------------------------------------

@subsubheading Test

The following session shows in which way @func{rec} allows a
tail--recursive implementation of the factorial function.

@example
> (define F (rec (F N)
                 ((rec (G K L)
                    (if (zero? K)
                        L
                      (G (- K 1) (* K L))))
              N 1)))
> F
#<procedure>
> (F 0)
1
> (F 10)
3628800
@end example


@c page
@node rec ack
@subsection Acknowledgements


The author thanks Al Petrofsky for the final solution and Hal Abelson,
Chris Hanson and others for their input.  The work of the maintainers of
the @srfi{} forum is highly appreciated.


@c page
@node rec references
@subsection References


[Clinger1985] @emph{Draft of Report of the October 1984 Workshop on
Scheme}.  W. Clinger.  Proceedings Brandeis Workshop Oct. 22--23, 1984.
March, 1985.

@center @url{http://www.swiss.ai.mit.edu/ftpdir/scheme-mail/HTML/rrrs-1985}

@noindent
[KCR1998] @emph{Revised^5 Report on the Algorithmic Language Scheme}.
R. Kelsey, W. Clinger, J. Rees.  Higher--Order and Symbolic Computation,
volume 11, number 1, September 1998.


@c page
@node rec stub
@subsection Stub library


The @library{lang-lib} library imports and re--exports bindings from
@library{srfi rec}, with the following changes.


@itemize
@item
The @func{rec} binding from the @srfi{} is renamed to @func{recursion}.
@end itemize


@c page
@node parameters
@section Parameter objects


@cindex @srfi{} parameters


The @library{srfi parameters} library has been written by Marc Feeley as
the reference implementation for @ansrfi{39}.


@menu
* parameters license::          Document license.
* parameters abstract::         Abstract.
* parameters rationale::        Rationale.
* parameters spec::             Specification.
* parameters stub::             Stub library.
@end menu


@c page
@node parameters license
@subsection Original license


Copyright @copyright{} 2002 Marc Feeley.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node parameters abstract
@subsection Abstract


This @srfi{} defines parameter objects, the procedure
@func{make-parameter} to create parameter objects and the
@func{parameterize} special form to dynamically bind parameter objects.

In the dynamic environment, each parameter object is bound to a cell
containing the value of the parameter.  When a procedure is called the
called procedure inherits the dynamic environment from the caller.  The
@func{parameterize} special form allows the binding of a parameter
object to be changed for the dynamic extent of its body.


@c page
@node parameters rationale
@subsection Rationale


The @emph{dynamic environment} is the structure which allows the system
to find the value returned by the @rnrs{5} procedures
@func{current-input-port} and @func{current-output-port}.  The @rnrs{5}
procedures @func{with-input-from-file} and @func{with-output-to-file}
extend the dynamic environment to produce a new dynamic environment
which is in effect for the dynamic extent of the call to the thunk
passed as their last argument.

These procedures are essentially special purpose dynamic binding
operations on hidden dynamic variables (one for
@func{current-input-port} and one for @func{current-output-port}).  The
purpose of this @srfi{} is to generalize this dynamic binding mechanism
(which exists in all @rnrs{5} compliant systems) to allow the user to
introduce new dynamic variables and dynamically bind them.

General dynamic binding mechanisms exist in several implementations of
Scheme under various names, including ``fluid'' variables and parameter
objects.  The parameter objects specified in this @srfi{} are
compatible with the semantics of all implementations of Scheme we know
which currently support parameter objects (in the sense that it is
possible to implement this @srfi{} so that old code works the same as
before).  We believe Chez--Scheme was the first implementation of Scheme
to have used parameter objects.

In the presence of threads, the dynamic binding mechanism does not
behave the same way in all implementations of Scheme supporting dynamic
binding.  The issue is the relationship between the dynamic environments
of the parent and child threads when a thread is created.  In Scheme 48
the child gets a fresh dynamic environment where (typically but not
necessarily) all the bindings are to their initial value.

In MzScheme and Gambit--C the child is given a dynamic environment
inherited from the parent.  In this inherited dynamic environment the
dynamic variables have the same values as the parent's dynamic
environment.  However, in MzScheme the cells bound to the dynamic
variables in the child are distinct from those of the parent (i.e. an
assignment of a value to a dynamic variable is not visible in the other
thread).  In Gambit--C the child and parent dynamic environment share
the same cells (i.e. an assignment of a value to a dynamic variable is
visible in the other thread).  Note that in the absence of assignment to
dynamic variables the MzScheme and Gambit--C approaches are equivalent.

Given that there are semantic differences in the presence of threads and
that there are valid reasons for choosing each semantics, this @srfi{}
does not specify the semantics of parameter objects in the presence of
threads.  It is left to the implementation and other @srfi{}s which
extend this @srfi{} to specify the interaction between parameter
objects and threads.



@c page
@node parameters spec
@subsection Specification


The @emph{dynamic environment} is composed of two parts: the @emph{local
dynamic environment} and the @emph{global dynamic environment}.  The
global dynamic environment is used to lookup parameter objects that
can't be found in the local dynamic environment.  When parameter objects
are created, their initial binding is put in the global dynamic
environment (by mutation).  The local dynamic environment is only
extended by the @func{parameterize} form.

@emph{Parameter objects} are created with the @func{make-parameter}
procedure which takes one or two arguments.  The second argument is a
one argument conversion procedure.  If only one argument is passed to
@func{make-parameter} the identity function is used as a conversion
procedure.  The global dynamic environment is updated to associate the
parameter object to a new cell.  The initial content of the cell is the
result of applying the conversion procedure to the first argument of
@func{make-parameter}.

A @emph{parameter object} is a procedure which accepts zero or one
argument.  The cell bound to a particular parameter object in the
dynamic environment is accessed by calling the parameter object.  When
no argument is passed, the content of the cell is returned.  When one
argument is passed the content of the cell is updated with the result of
applying the parameter object's conversion procedure to the argument.

The @func{parameterize} special form, when given a parameter object and
a value, binds for the dynamic extent of its body the parameter object
to a new cell.  The initial content of the cell is the result of
applying the parameter object's conversion procedure to the value.  The
parameterize special form behaves analogously to let when binding more
than one parameter object (that is the order of evaluation is
unspecified and the new bindings are only visible in the body of the
parameterize special form).

Note that the conversion procedure can be used for guaranteeing the type
of the parameter object's binding and/or to perform some conversion of
the value.

Because it is possible to implement the @rnrs{5} procedures
@func{current-input-port} and @func{current-output-port} as parameter
objects and this offers added functionnality, it is required by this
@srfi{} that they be implemented as parameter objects created with
@func{make-parameter}.


@defun make-parameter @var{init} [@var{converter}]
Returns a new parameter object which is bound in the global dynamic
environment to a cell containing the value returned by the call
@code{(converter init)}.  If the conversion procedure converter is not
specified the identity function is used instead.

The parameter object is a procedure which accepts zero or one argument.
When it is called with no argument, the content of the cell bound to
this parameter object in the current dynamic environment is returned.
When it is called with one argument, the content of the cell bound to
this parameter object in the current dynamic environment is set to the
result of the call @code{(converter arg)}, where @var{arg} is the
argument passed to the parameter object, and an unspecified value is
returned.

@example
(define radix
  (make-parameter 10))

(define write-shared
  (make-parameter #f
    (lambda (x)
      (if (boolean? x)
          x
        (error "only booleans are accepted by write-shared")))))

(radix)           =>  10
(radix 2)
(radix)           =>  2
(write-shared 0)  gives an error

(define prompt
  (make-parameter 123
    (lambda (x)
      (if (string? x)
          x
        (with-output-to-string (lambda () (write x)))))))

(prompt)       =>  "123"
(prompt ">")
(prompt)       =>  ">"
@end example
@end defun


@deffn Syntax parameterize ((@var{expr1} @var{expr2}) ...) @var{body})
The expressions @var{expr1} and @var{expr2} are evaluated in an
unspecified order.  The value of the @var{expr1} expressions must be
parameter objects.  For each @var{expr1} expression and in an
unspecified order, the local dynamic environment is extended with a
binding of the parameter object @var{expr1} to a new cell whose content
is the result of the call @code{(converter val)}, where @var{val} is the
value of @var{expr2} and @var{converter} is the conversion procedure of
the parameter object.

The resulting dynamic environment is then used for the evaluation of
@var{body} (which refers to the @rnrs{5} grammar nonterminal of that
name).  The result(s) of the parameterize form are the result(s) of the
@var{body}.

With reference to thte example above:

@example
(radix)
=>  2

(parameterize ([radix 16])
  (radix))
=>  16

(radix)
=>  2

(define (f n)
  (number->string n (radix)))

(f 10)
=>  "1010"

(parameterize ([radix 8])
  (f 10))
=>  "12"

(parameterize ([radix 8]
               [prompt (f 10)])
  (prompt))
=>  "1010"
@end example
@end deffn


@c page
@node parameters stub
@subsection Stub library


The @library{lang-lib} library imports and re--exports bindings from
@library{srfi parameters}.


@c page
@node general-cond
@section A more general @func{cond} clause


@cindex @srfi{} general-cond


The @library{srfi general-cond} has been written by Taylor Campbell as
the reference implementation for @ansrfi{61}.


@menu
* general-cond license::        Original license.
* general-cond abstract::       Abstract.
* general-cond rationale::      Rationale.
* general-cond spec::           Specification.
* general-cond stub::           Stub library.
@end menu


@c page
@node general-cond license
@subsection Original license


Copyright @copyright{} 2004 Taylor Campbell.  All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node general-cond abstract
@subsection Abstract


This @srfi{} proposes an extension to the @func{cond} syntax to allow a
more general clause, one that allows binding the results of tests as in
the @code{=>} clauses and user--defined meaning of the success and
failure of tests.


@c page
@node general-cond rationale
@subsection Rationale


The present set of @func{cond} clauses is based on simple boolean
testing.  It is prohibitively inexpressive in that the condition part of
a @func{cond} clause that uses @code{=>} may pass only a single value to
the receiver, and it enforces a semantics whereby @false{} implies
failure of the condition.

Programmers frequently use different tokens to imply failure, such as in
@rnrs{5}'s I/O readers which return a distinguished ``EOF object'' to
denote failure, and a successful condition may produce more than one
useful value.  This simple extension allows any meaning of ``failure''
to be assigned on a per--clause basis, and it also allows the condition
to return multiple values to be passed to the receiver.


@c page
@node general-cond spec
@subsection Specification


@findex cond

The @code{<cond clause>} production in the formal syntax of Scheme as
written by @rnrs{5} Section 7.1.3 is extended with a new option:

@example
<cond clause> --->
    ...
  | (<generator> <guard> => <receiver>)
@end example

@noindent
where @code{<generator>}, @code{<guard>} and @code{<receiver>} are all
@code{<expression>}.

Clauses of this form have the following semantics: @code{<generator>} is
evaluated and it may return arbitrarily many values.  @code{<guard>} is
applied to an argument list containing the values in order that
@code{<generator>} returned.  If @code{<guard>} returns a true value for
that argument list, @code{<receiver>} is applied with an equivalent
argument list.  If @code{<guard>} returns a false value, however, the
clause is abandoned and the next one is tried.

@c ------------------------------------------------------------

@subsubheading Examples


This @func{port->char-list} procedure accepts an input port and returns
a list of all the characters it produces until the end.

@example
(define (port->char-list port)
  (cond ((read-char port)
         char?
         => (lambda (c)
              (cons c (port->char-list port))))
        (else '())))
@end example

Consider now a hypothetical @func{table-entry} procedure that accepts
two arguments: a table (perhaps a hash table) and a key to an entry that
may be in the table; it returns two values: a boolean that denotes
whether or not an entry with the given key was in the table and, if it
was, the value associated with the key.  Also, a hypothetical
@var{proj0} combinator (projection of argument 0) returns its 0th
argument and ignores all others.  One might conditionally branch to a
certain body of code if the table contains the desired entry like so
with the new type of @func{cond} clause:

@example
(cond ...
      ((table-entry <table> <key>)
       proj0
       => (lambda (present? value)
            ...(VALUE is bound to the value of the entry)...))
      ...)
@end example


@c page
@node general-cond stub
@subsection Stub library


The @library{lang-lib} library imports and re--exports bindings from
@library{srfi general-cond}, with the following changes.


@itemize
@item
The @func{cond} @srfi{} function is renamed to both @func{srfi:cond} and
@func{general-cond}.
@end itemize


@c page
@node list
@chapter List library


@cindex @srfi{} list library


The @library{srfi lists} library has been written by Olin Shivers
@email{shivers@@ai.mit.edu} as the reference implementation for
@ansrfi{1}etails.

@menu
* list license::                Original license.
* list abstract::               Abstract.
* list rationale::              Rationale.
* list discussion::             Discussion.
* list spec::                   Specifications.
* list ack::                    Acknowledgements.
* list references::             References.
@end menu


@c page
@node list license
@section Original license


Certain portions of this document (the specific, marked segments of text
describing the R5RS procedures) were adapted with permission from the
@rnrs{5} report.

All other text is copyright @copyright{} 1998, 1999 Olin Shivers.  All
Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node list abstract
@section Abstract


@rnrs{5} Scheme has an impoverished set of list--processing utilities,
which is a problem for authors of portable code.  This @srfi{} proposes
a coherent and comprehensive set of list--processing procedures; it is
accompanied by a reference implementation of the spec.  The reference
implementation is:

@itemize
@item
portable;

@item
efficient;

@item
completely open, public--domain source.
@end itemize


@c page
@node list rationale
@section Rationale


The set of basic list and pair operations provided by @rnrs{4}/@rnrs{5}
Scheme is far from satisfactory.  Because this set is so small and
basic, most implementations provide additional utilities, such as a
list--filtering function, or a ``left fold'' operator, and so forth.
But, of course, this introduces incompatibilities----different Scheme
implementations provide different sets of procedures.

I have designed a full--featured library of procedures for list
processing.  While putting this library together, I checked as many
Schemes as I could get my hands on.  (I have a fair amount of experience
with several of these already.)  I missed Chez (no on--line manual that
I can find) but I hit most of the other big, full--featured Schemes.
The complete list of list--processing systems I checked is:

@example
R4RS/R5RS Scheme
MIT Scheme
Gambit
RScheme
MzScheme
slib
Common Lisp
Bigloo
guile
T
APL and the SML standard basis
@end example

As a result, the library I am proposing is fairly rich.

Following this initial design phase, this library went through several
months of discussion on the @srfi{} mailing lists, and was altered in
light of the ideas and suggestions put forth during this discussion.

In parallel with designing this @api{}, I have also written a reference
implementation.  I have placed this source on the Net with an
unencumbered, ``open'' copyright.  A few notes about the reference
implementation:

@itemize
@item
Although I got procedure names and specs from many Schemes, I wrote this
code myself.  Thus, there are no entanglements.  Any Scheme implementor
can pick this library up with no worries about copyright problems, both
commercial and non--commercial systems.

@item
The code is written for portability and should be trivial to port to any
Scheme.  It has only four deviations from @rnrs{4}, clearly discussed in
the comments:

@itemize
@item
use of an error procedure;

@item
use of the @rnrs{5} values and a simple receive macro for producing and
consuming multiple return values;

@item
use of simple @code{:optional} and @func{let-optionals} macros for
optional argument parsing and defaulting;

@item
use of a simple @func{check-arg} procedure for argument checking.
@end itemize

@item
It is written for clarity and well--commented.  The current source is
768 lines of source code and 826 lines of comments and white space.

@item
It is written for efficiency.  Fast paths are provided for common cases.
Side--effecting procedures such as @func{filter!} avoid unnecessary,
redundant @func{set-cdr!} calls which would thrash a generational
garbage--collection's write barrier and the store buffers of fast
processors.  Functions reuse longest common tails from input parameters
to construct their results where possible.  Constant--space iterations
are used in preference to recursions; local recursions are used in
preference to consing temporary intermediate data structures.
@end itemize

This is not to say that the implementation can't be tuned up for a
specific Scheme implementation.  There are notes in comments addressing
ways implementors can tune the reference implementation for performance.

In short, I've written the reference implementation to make it as
painless as possible for an implementor, or a regular programmer, to
adopt this library and get good results with it.


@c page
@node list discussion
@section Discussion


@menu
* list disc general::           General discussion.
* list disc linear update::     Linear update procedures.
* list disc improper::          Improper lists.
* list disc errors::            Errors.
* list disc not included::      Not included in this library.
@end menu


@c page
@node list disc general
@subsection General discussion


A set of general criteria guided the design of this library.

I don't require ``destructive'' (what I call ``linear update'')
procedures to alter and recycle cons cells from the argument lists.
They are allowed to, but not required to.  (And the reference
implementations I have written do recycle the argument lists.)

List--filtering procedures such as @func{filter} or @func{delete} do not
disorder lists.  Elements appear in the answer list in the same order as
they appear in the argument list.  This constrains implementation, but
seems like a desirable feature, since in many uses of lists, order
matters.  (In particular, disordering an alist is definitely a bad
idea.)

Contrariwise, although the reference implementations of the
list--filtering procedures share longest common tails between argument
and answer lists, it not is part of the spec.

Because lists are an inherently sequential data structure (unlike, say,
vectors), list--inspection functions such as @func{find},
@func{find-tail}, @func{for-each}, any and every commit to a
left--to--right traversal order of their argument list.

However, constructor functions, such as @func{list-tabulate} and the
mapping procedures (@func{append-map}, @func{append-map!}, @func{map!},
@func{pair-for-each}, @func{filter-map}, @func{map-in-order}), do not
specify the dynamic order in which their procedural argument is applied
to its various values.

Predicates return useful true values wherever possible.  Thus any must
return the true value produced by its predicate, and every returns the
final true value produced by applying its predicate argument to the last
element of its argument list.

Functionality is provided both in pure and linear--update (potentially
destructive) forms wherever this makes sense.

No special status accorded Scheme's built--in equality functions.  Any
functionality provided in terms of @func{eq?}, @func{eqv?},
@func{equal?} is also available using a client--provided equality
function.

Proper design counts for more than backwards compatibility, but I have
tried, ceteris paribus, to be as backwards--compatible as possible with
existing list--processing libraries, in order to facilitate porting old
code to run as a client of the procedures in this library.  Name choices
and semantics are, for the most part, in agreement with existing
practice in many current Scheme systems.  I have indicated some
incompatibilities in the following text.

These procedures are not ``sequence generic''----i.e. procedures that
operate on either vectors and lists.  They are list--specific.  I prefer
to keep the library simple and focused.

I have named these procedures without a qualifying initial @code{list-}
lexeme, which is in keeping with the existing set of list--processing
utilities in Scheme.  I follow the general Scheme convention
(@func{vector-length}, @func{string-ref}) of placing the type--name
before the action when naming procedures----so we have @func{list-copy}
and @func{pair-for-each} rather than the perhaps more fluid, but less
consistent, @func{copy-list} or @func{for-each-pair}.

I have generally followed a regular and consistent naming scheme,
composing procedure names from a set of basic lexemes.


@c page
@node list disc linear update
@subsection Linear update procedures


Many procedures in this library have ``pure'' and ``linear update''
variants.  A ``pure'' procedure has no side--effects, and in particular
does not alter its arguments in any way.  A ``linear update'' procedure
is allowed, but not required, to side--effect its arguments in order to
construct its result.  ``Linear update'' procedures are typically given
names ending with an exclamation point.

So, for example, @code{(append!  list1 list2)} is allowed to construct
its result by simply using @func{set-cdr!} to set the cdr of the last
pair of @var{list1} to point to @var{list2}, and then returning
@var{list1} (unless @var{list1} is the empty list, in which case it
would simply return @var{list2}).  However, @func{append!} may also
elect to perform a pure append operation, this is a legal definition of
append!:

@example
(define append! append)
@end example

This is why we do not call these procedures ``destructive'', because
they aren't required to be destructive.  They are @emph{potentially}
destructive.

What this means is that you may only apply linear--update procedures to
values that you know are ``dead'', values that will never be used again
in your program.  This must be so, since you can't rely on the value
passed to a linear--update procedure after that procedure has been
called.  It might be unchanged; it might be altered.

The ``linear'' in ``linear update'' doesn't mean ``linear time'' or
``linear space'' or any sort of multiple--of--n kind of meaning.  It's a
fancy term that type theorists and pure functional programmers use to
describe systems where you are only allowed to have exactly one
reference to each variable.  This provides a guarantee that the value
bound to a variable is bound to no other variable.  So when you use a
variable in a variable reference, you ``use it up''.  Knowing that no
one else has a pointer to that value means the a system primitive is
free to side--effect its arguments to produce what is, observationally,
a pure--functional result.

In the context of this library, ``linear update'' means you, the
programmer, know there are no other live references to the value passed
to the procedure; after passing the value to one of these procedures,
the value of the old pointer is indeterminate.  Basically, you are
licensing the Scheme implementation to alter the data structure if it
feels like it; you have declared you don't care either way.

You get no help from Scheme in checking that the values you claim are
``linear'' really are.  So you better get it right.  Or play it safe and
use the non--@code{!} procedures; it doesn't do any good to compute
quickly if you get the wrong answer.

Why go to all this trouble to define the notion of ``linear update'' and
use it in a procedure spec, instead of the more common notion of a
``destructive'' operation?

First, note that destructive list--processing procedures are almost
always used in a linear--update fashion.  This is in part required by
the special case of operating upon the empty list, which can't be
side--effected.  This means that destructive operators are not pure
side--effects, they have to return a result.

Second, note that code written using linear--update operators can be
trivially ported to a pure, functional subset of Scheme by simply
providing pure implementations of the linear--update operators.

Finally, requiring destructive side--effects ruins opportunities to
parallelise these operations, and the places where one has taken the
trouble to spell out destructive operations are usually exactly the code
one would want a parallelising compiler to parallelise: the
efficiency--critical kernels of the algorithm.

Linear--update operations are easily parallelised.  Going with a
linear--update spec doesn't close off these valuable alternative
implementation techniques.  This list library is intended as a set of
low--level, basic operators, so we don't want to exclude these possible
implementations.

The linear--update procedures in this library are:

@example
alist-delete!           append!
append-map!             append-reverse!
break!                  concatenate!
delete!                 delete-duplicates!
drop-right!             filter!
lset-adjoin!            lset-diff+intersection!
lset-difference!        lset-xor!
lset-intersection!      lset-union!
map!                    partition!
remove!                 reverse!
span!                   split-at!
take!                   take-while!
@end example



@c page
@node list disc improper
@subsection Improper Lists


Scheme does not properly have a list type, just as the C language does
not have a string type.  Rather, Scheme has a binary--tuple type, from
which one can build binary trees.  There is an interpretation of Scheme
values that allows one to treat these trees as lists.  Further
complications ensue from the fact that Scheme allows side--effects to
these tuples, raising the possibility of lists of unbounded length, and
trees of unbounded depth (that is, circular data structures).

However, there is a simple view of the world of Scheme values that
considers every value to be a list of some sort.  That is, every value
is either:

@itemize
@item
a ``proper list'' (a finite, nil--terminated list) such as:

@example
(a b c)
()
(32)
@end example

@item
a ``dotted list'' (a finite, non--nil terminated list) such as:

@example
(a b c . d)
(x . y)
42
george
@end example

@item
or a ``circular list'' (an infinite, unterminated list).
@end itemize

Note that the zero--length dotted lists are simply all the non--null,
non--pair values.

This view is captured by the predicates @func{proper-list?},
@func{dotted-list?}, and @func{circular-list?}.  This list library users
should note that dotted lists are not commonly used, and are considered
by many Scheme programmers to be an ugly artifact of Scheme's lack of a
true list type.  However, dotted lists do play a noticeable role in the
syntax of Scheme, in the ``rest'' parameters used by n--ary lambdas:

@example
(lambda (x y . rest) ...)
@end example

Dotted lists are not fully supported by this list library.  Most
procedures are defined only on proper lists, that is: finite,
nil--terminated lists.  The procedures that will also handle circular or
dotted lists are specifically marked.  While this design decision
restricts the domain of possible arguments one can pass to these
procedures, it has the benefit of allowing the procedures to catch the
error cases where programmers inadvertently pass scalar values to a list
procedure by accident, e.g., by switching the arguments to a procedure
call.



@c page
@node list disc errors
@subsection Errors


Note that statements of the form ``it is an error'' merely mean ``don't
do that''.  They are no a guarantees that a conforming implementation
will ``catch'' such improper use by, for example, raising some kind of
exception.  Regrettably, @rnrs{5} Scheme requires no firmer guarantee
even for basic operators such as @func{car} and @func{cdr}, so there's
little point in requiring these procedures to do more.  Here is the
relevant section of the @rnrs{5}:

@quotation
When speaking of an error situation, this report uses the phrase ``an
error is signalled'' to indicate that implementations must detect and
report the error.  If such wording does not appear in the discussion of
an error, then implementations are not required to detect or report the
error, though they are encouraged to do so.  An error situation that
implementations are not required to detect is usually referred to simply
as ``an error''.

For example, it is an error for a procedure to be passed an argument
that the procedure is not explicitly specified to handle, even though
such domain errors are seldom mentioned in this report.  Implementations
may extend a procedure's domain of definition to include such arguments.
@end quotation


@c page
@node list disc not included
@subsection Not included in this library


The following items are not in this library:

@itemize
@item
sort routines;

@item
destructuring/pattern--matching macro;

@item
tree--processing routines.
@end itemize

@noindent
they should have their own @srfi{} specs.


@c page
@node list spec
@section Specifications


@cindex List library interface


@menu
* list spec intro::             Introduction.
* list spec cons::              Constructors.
* list spec pred::              Predicates.
* list spec select::            Selectors.
* list spec misc::              Length, append, concatenate,
                                reverse, zip and count.
* list spec fold::              Fold, unfold and map.
* list spec filter::            Filtering and partitioning.
* list spec search::            Searching.
* list spec delete::            Deletion.
* list spec alist::             Association lists.
* list spec set::               Set operations on lists.
* list spec side::              Primitive side--effects.
* list spec stub::              Stub library bindings.
@end menu


@c page
@node list spec intro
@subsection Introduction


In a Scheme system that has a module or package system, these procedures
should be contained in a module named @code{list-lib}.  The templates
given below obey the following conventions for procedure formals:

@table @code
@item list
a proper (finite, nil--terminated) list;

@item clist
a proper or circular list;

@item flist
a finite (proper or dotted) list;

@item pair
a pair;

@item x, y, d, a
any value;

@item object, value
any value;

@item n, i
a natural number (an integer >= 0);

@item proc
a procedure;

@item pred
a procedure whose return value is treated as a boolean;

@item =
a boolean procedure taking two arguments.
@end table

It is an error to pass a circular or dotted list to a procedure not
defined to accept such an argument.


@c page
@node list spec cons
@subsection Constructors


@cindex List constructors


@menu
* list spec cons pair::         Pair constructors.
* list spec cons list::         List constructors.
@end menu


@c page
@node list spec cons pair
@subsubsection Pair constructors


@defun cons @var{a} @var{d}
The primitive constructor.  Return a newly allocated pair whose car is
@var{a} and whose cdr is @var{d}.  The pair is guaranteed to be
different (in the sense of @func{eqv?}) from every existing object.

@example
(cons 'a '())        => (a)
(cons '(a) '(b c d)) => ((a) b c d)
(cons "a" '(b c))    => ("a" b c)
(cons 'a 3)          => (a . 3)
(cons '(a b) 'c)     => ((a b) . c)
@end example
@end defun


@defun xcons @var{d} @var{a}
Defined as @code{(lambda (d a) (cons a d))}.  Of utility only as a value
to be conveniently passed to higher--order procedures.

@example
(xcons '(b c) 'a) => (a b c)
@end example

The name stands for ``eXchanged CONS''.
@end defun


@defun {cons*} @var{elt1} @var{elt2} ...
Like @func{list}, but the last argument provides the tail of the
constructed list, returning:

@example
(cons elt1 (cons elt2 (cons ... eltn)))
@end example

This function is called @func{list*} in Common Lisp and about half of
the Schemes that provide it, and @func{cons*} in the other half.

@example
(cons* 1 2 3 4)
=> (1 2 3 . 4)

(cons* 1)
=> 1
@end example
@end defun


@c page
@node list spec cons list
@subsubsection List constructors


@defun list @var{object} ...
Return a newly allocated list of its arguments.

@example
(list 'a (+ 3 4) 'c)
=> (a 7 c)

(list)
=> ()
@end example
@end defun


@defun make-list @var{n} [@var{fill}]
Return an @var{n}--element list, whose elements are all the value
@var{fill}.  If the fill argument is not given, the elements of the list
may be arbitrary values.

@example
(make-list 4 'c)
=> (c c c c)

(make-list 0)
=> ()
@end example
@end defun


@defun list-tabulate @var{n} @var{init-proc}
Return an @var{n}--element list.  Element @var{i} of the list, where
@code{0 <= i < n}, is produced by @code{(init-proc i)}.  No guarantee is
made about the dynamic order in which @var{init-proc} is applied to
these indices.

@example
(list-tabulate 4 values)
=> (0 1 2 3)
@end example
@end defun


@defun list-copy @var{flist}
Copy the spine of the argument.
@end defun


@defun circular-list @var{elt1} @var{elt2} ...
Construct a circular list of the elements.

@example
(circular-list 'z 'q) => (z q z q z q ...)
@end example
@end defun


@defun iota @var{count} [@var{start} @var{step}]
Return a list containing the elements:

@example
(start start+step ... start+(count-1)*step)
@end example

The @var{start} and @var{step} parameters default to @code{0} and
@code{1}, respectively.  This procedure takes its name from the
@acronym{APL} primitive.

@example
(iota 5)
=> (0 1 2 3 4)

(iota 5 0 -0.1)
=> (0 -0.1 -0.2 -0.3 -0.4)
@end example

@quotation
@strong{Nausicaa note:} When @var{count} is negative the return value is
the empty list.
@end quotation
@end defun


@c page
@node list spec pred
@subsection Predicates


@cindex List predicates


@menu
* list spec pred kind::         Kinds of list.
* list spec pred null::         Null predicates.
* list spec pred pair::         Pair predicates.
* list spec pred cmp::          Comparison.
@end menu


@c page
@node list spec pred kind
@subsubsection Kind of list


The predicates @func{proper-list?}, @func{circular-list?}, and
@func{dotted-list?} partition the entire universe of Scheme values.


@defun proper-list? @var{x}
Return true if, and only if, @var{x} is a proper list: a finite,
nil--terminated list.  More carefully: The empty list is a proper list.
A pair whose cdr is a proper list is also a proper list:

@example
<proper-list> ::= ()                        (Empty proper list)
              |   (cons <x> <proper-list>)  (Proper-list pair)
@end example

Note that this definition rules out circular lists.  This function is
required to detect this case and return @false{}.  Nil--terminated lists
are called ``proper'' lists by @rnrs{5} and Common Lisp.  The opposite
of proper is improper.

@rnrs{5} binds this function to the variable @func{list?}.

@example
(not (proper-list? x)) = (or (dotted-list? x)
                             (circular-list? x))
@end example
@end defun


@defun circular-list? @var{x}
Return @true{} if @var{x} is a circular list.  A circular list is a
value such that for every @code{n >= 0}, @code{cdrn(x)} is a pair.

Terminology: The opposite of circular is finite.

@example
(not (circular-list? x)) = (or (proper-list? x)
                               (dotted-list? x))
@end example
@end defun


@defun dotted-list? @var{x}
Return @true{} if @var{x} is a finite, non--nil--terminated list.  That
is, there exists an @code{n >= 0} such that @code{cdrn(x)} is neither a
pair nor @code{()}.  This includes non--pair, non--@code{()} values
(e.g. symbols, numbers), which are considered to be dotted lists of
length 0.

@example
(not (dotted-list? x)) = (or (proper-list? x)
                             (circular-list? x))
@end example
@end defun


@c page
@node list spec pred null
@subsubsection Null predicates


@defun null? @var{object}
Return @true{} if object is the empty list; otherwise @false{}.
@end defun


@defun null-list? @var{clist}
@var{clist} is a proper or circular list.  This procedure returns
@true{} if the argument is the empty list, and @false{} otherwise.  It
is an error to pass this procedure a value which is not a proper or
circular list.  This procedure is recommended as the termination
condition for list--processing procedures that are not defined on dotted
lists.
@end defun


@c page
@node list spec pred pair
@subsubsection Pair predicates


@defun pair? @var{object}
Return @true{} if object is a pair; otherwise @false{}.

@example
(pair? '(a . b)) =>  #t
(pair? '(a b c)) =>  #t
(pair? '())      =>  #f
(pair? '#(a b))  =>  #f
(pair? 7)        =>  #f
(pair? 'a)       =>  #f
@end example
@end defun


@defun not-pair? @var{x}
Defined as: @code{(lambda (x) (not (pair? x)))}.  Provided as a
procedure as it can be useful as the termination condition for
list--processing procedures that wish to handle all finite lists, both
proper and dotted.
@end defun


@c page
@node list spec pred cmp
@subsubsection Comparison


@defun list= @var{elm=?} @var{list1} ...
Determines list equality, given an element--equality procedure
@var{elm=?}.  Proper list @var{AL} equals proper list @var{BL} if:

@enumerate
@item
they are of the same length;

@item
their corresponding elements are equal, according to @var{elm=?}.
@end enumerate

If the element--comparison procedure's first argument is from
@var{listi}, then its second argument is from @var{listi+1}, i.e. it is
always called as @code{(elm=? a b)} for @var{a} an element of list
@var{AL}, and @var{b} an element of list @var{BL}.

In the n--ary case, every @var{listi} is compared to @var{listi+1} (as
opposed, for example, to comparing @var{list1} to every @var{listi}, for
@code{i>1}).

If there are no list arguments at all, @func{list=} simply returns
@true{}.

It is an error to apply @func{list=} to anything except proper lists.
While implementations may choose to extend it to circular lists, note
that it cannot reasonably be extended to dotted lists, as it provides no
way to specify an equality procedure for comparing the list terminators.

@quotation
@emph{Nausicaa note:} The @value{PACKAGE} implementation does
@strong{not} support comparison of circular lists.
@end quotation

Note that the dynamic order in which the @var{elm=?} procedure is applied
to pairs of elements is not specified.  For example, if @func{list=} is
applied to three lists, @var{AL}, @var{BL}, and @var{CL}, it may first
completely compare @var{AL} to @var{BL}, then compare @var{BL} to
@var{CL}, or it may compare the first elements of @var{AL} and @var{BL},
then the first elements of @var{BL} and @var{CL}, then the second
elements of @var{AL} and @var{BL}, and so forth.

The equality procedure must be consistent with @func{eq?}.  That is, it
must be the case that:

@example
(eq? x y) => (elm=? x y)
@end example

Note that this implies that two lists which are @func{eq?} are always
@func{list=}, as well; implementations may exploit this fact to
``short--cut'' the element--by--element comparisons.

Examples:

@example
(list= eq?)
=> #t

(list= eq? '(a))
=> #t

(list= = '(1 2 3 4)
         '(1 2 3 4))
=> #t

(list= = '(1 2 3 4)
         '(1 9 3 4))
=> #f

(list= = '(1 2 3 4)
         '(1 2 3 4)
         '(1 2 3 4))
=> #t

(list= = '(1 2 3 4)
         '(1 2 3 4 5)
         '(1 2 3 4))
=> #f

(list= = '())
=> #t

(list= = '() '())
=> #t

(list= = '() '() '())
=> #t
@end example
@end defun


@c page
@node list spec select
@subsection Selectors


@cindex List selectors


@defun car @var{pair}
@defunx cdr @var{pair}
@rnrs{5} These functions return the contents of the car and cdr field of
their argument, respectively.  Note that it is an error to apply them to
the empty list.

@example
(car '(a b c))
=> a
(cdr '(a b c))
=> (b c)

(car '((a) b c d))
=> (a)
(cdr '((a) b c d))
=> (b c d)

(car '(1 . 2))
=> 1
(cdr '(1 . 2))
=> 2

(car '())
=> *error*
(cdr '())
=>  *error*
@end example
@end defun


@defun caar @var{pair}
@defunx cadr @var{pair}
@defunx c...r @var{pair}
@defunx cdddar @var{pair}
@defunx cddddr @var{pair}
@rnrs{5} These procedures are compositions of @func{car} and @func{cdr},
where for example @func{caddr} could be defined by:

@example
(define caddr
  (lambda (x)
    (car (cdr (cdr x)))))
@end example

Arbitrary compositions, up to four deep, are provided. There are
twenty-eight of these procedures in all.
@end defun


@defun list-ref @var{clist} @var{i}
@rnrs{5} Return the @var{i}-th element of clist.  This is the same as
the car of @code{(drop clist i)}.  It is an error if @code{i >= n},
where @var{n} is the length of clist.

@example
(list-ref '(a b c d) 2)
=> c
@end example
@end defun


@defun first @var{pair}
@defunx second  @var{pair}
@defunx third   @var{pair}
@defunx fourth  @var{pair}
@defunx fifth   @var{pair}
@defunx sixth   @var{pair}
@defunx seventh @var{pair}
@defunx eighth  @var{pair}
@defunx ninth   @var{pair}
@defunx tenth   @var{pair}
Synonyms for @func{car}, @func{cadr}, @func{caddr}, ...

@example
(third '(a b c d e))
=> c
@end example
@end defun


@defun {car+cdr} @var{pair}
The fundamental pair deconstructor:

@example
(lambda (p)
  (values (car p) (cdr p)))
@end example

This can, of course, be implemented more efficiently by a compiler.
@end defun


@defun take @var{x} @var{i}
@defunx drop @var{x} @var{i}
@func{take} returns the first @var{i} elements of list @var{x}.
@func{drop} returns all but the first @var{i} elements of list @var{x}.

@example
(take '(a b c d e) 2)
=> (a b)

(drop '(a b c d e) 2)
=> (c d e)
@end example

@var{x} may be any value: a proper, circular, or dotted list:

@example
(take '(1 2 3 . d) 2)
=> (1 2)

(drop '(1 2 3 . d) 2)
=> (3 . d)

(take '(1 2 3 . d) 3)
=> (1 2 3)

(drop '(1 2 3 . d) 3)
=> d
@end example

For a legal @var{i}, @func{take} and @func{drop} partition the list in a
manner which can be inverted with append:

@example
(append (take x i) (drop x i)) = x
@end example

@func{drop} is exactly equivalent to performing @var{i} @func{cdr}
operations on @var{x}; the returned value shares a common tail with
@var{x}.

If the argument is a list of non--zero length, @func{take} is guaranteed
to return a freshly--allocated list, even in the case where the entire
list is taken, e.g. @code{(take lis (length lis))}.

@quotation
@emph{Nausicaa note:} @func{drop} will return a list which is a portion
of the argument, unless the return value is the empty list.
@end quotation
@end defun


@defun take-right @var{flist} @var{i}
@defunx drop-right @var{flist} @var{i}
@func{take-right} returns the last @var{i} elements of @var{flist}.
@func{drop-right} returns all but the last @var{i} elements of
@var{flist}.

@example
(take-right '(a b c d e) 2)
=> (d e)

(drop-right '(a b c d e) 2)
=> (a b c)
@end example

The returned list may share a common tail with the argument list.

@var{flist} may be any finite list, either proper or dotted:

@example
(take-right '(1 2 3 . d) 2)
=> (2 3 . d)

(drop-right '(1 2 3 . d) 2)
=> (1)

(take-right '(1 2 3 . d) 0)
=> d

(drop-right '(1 2 3 . d) 0)
=> (1 2 3)
@end example

For a legal @var{i}, @func{take-right} and @var{drop-right} partition
the list in a manner which can be inverted with append:

@example
(append (take flist i) (drop flist i)) = flist
@end example

The return value of @func{take-right} is guaranteed to share a common
tail with @var{flist}.

If the argument is a list of non--zero length, @func{drop-right} is
guaranteed to return a freshly--allocated list, even in the case where
nothing is dropped, e.g. @code{(drop-right lis 0)}.
@end defun


@defun take! @var{clist} @var{i}
@defunx drop-right! @var{flist} @var{i}
@func{take!} and @func{drop-right!} are linear--update variants of
@func{take} and @func{drop-right}: the procedure is allowed, but not
required, to alter the argument list to produce the result.

If @var{x} is circular, @func{take!} may return a
shorter--than--expected list:

@example
(take! (circular-list 1 3 5) 8)
=> (1 3)

(take! (circular-list 1 3 5) 8)
=> (1 3 5 1 3 5 1 3)
@end example

@quotation
@emph{Nausicaa note:} When applied to a circular list these functions go
in infinite loop.
@end quotation
@end defun


@defun split-at @var{x} @var{i}
@defunx split-at! @var{x} @var{i}
@func{split-at} splits the list @var{x} at index @var{i}, returning a
list of the first @var{i} elements, and the remaining tail.  It is
equivalent to:

@example
(values (take x i) (drop x i))
@end example

@func{split-at!} is the linear--update variant.  It is allowed, but not
required, to alter the argument list to produce the result.

@example
(split-at '(a b c d e f g h) 3)
=> (a b c)
   (d e f g h)
@end example
@end defun


@defun last @var{pair}
@defunx last-pair @var{pair}
@func{last} returns the last element of the non--empty, finite list
@var{pair}.  @func{last-pair} returns the last pair in the non--empty,
finite list @var{pair}.

@example
(last '(a b c)) => c
(last-pair '(a b c)) => (c)
@end example
@end defun


@c page
@node list spec misc
@subsection Length, append, concatenate, reverse, zip and count


@cindex List length
@cindex List appending
@cindex List contatenation
@cindex List reversing
@cindex List zip
@cindex List counting


@defun length @var{list}
@defunx {length+} @var{clist}
Both @func{length} and @func{length+} return the length of the argument.
It is an error to pass a value to @func{length} which is not a proper
list (finite and nil--terminated).  In particular, this means an
implementation may diverge or signal an error when @func{length} is
applied to a circular list.

@func{length+}, on the other hand, returns @false{} when applied to a
circular list.

The length of a proper list is a non--negative integer @var{n} such that
@func{cdr} applied @var{n} times to the list produces the empty list.
@end defun


@defun append @var{list1} ...
@defunx append! @var{list1} ...
@func{append} returns a list consisting of the elements of @var{list1}
followed by the elements of the other list parameters.

@example
(append '(x) '(y))        =>  (x y)
(append '(a) '(b c d))    =>  (a b c d)
(append '(a (b)) '((c)))  =>  (a (b) (c))
@end example

The resulting list is always newly allocated, except that it shares
structure with the final @var{listi} argument.  This last argument may
be any value at all; an improper list results if it is not a proper
list.  All other arguments must be proper lists.

@example
(append '(a b) '(c . d))  =>  (a b c . d)
(append '() 'a)           =>  a
(append '(x y))           =>  (x y)
(append)                  =>  ()
@end example

@func{append!} is the linear--update variant of @func{append}; it is
allowed, but not required, to alter cons cells in the argument lists to
construct the result list.  The last argument is never altered; the
result list shares structure with this parameter.
@end defun


@defun concatenate @var{list-of-lists}
@defunx concatenate! @var{list-of-lists}
These functions append the elements of their argument together.  That
is, @func{concatenate} returns:

@example
(apply append list-of-lists)
@end example

@noindent
or, equivalently:

@example
(reduce-right append '() list-of-lists)
@end example

@func{concatenate!} is the linear--update variant, defined in terms
of @func{append!} instead of @func{append}.

Note that some Scheme implementations do not support passing more than a
certain number (e.g. 64) of arguments to an n--ary procedure.  In these
implementations, the @code{(apply append ...)} idiom would fail when
applied to long lists, but concatenate would continue to function
properly.

As with @func{append} and @func{append!}, the last element of the input
list may be any value at all.
@end defun


@defun reverse @var{list}
@defunx reverse! @var{list}
@func{reverse} returns a newly allocated list consisting of the elements
of @var{list} in reverse order.

@example
(reverse '(a b c))              =>  (c b a)
(reverse '(a (b c) d (e (f))))  =>  ((e (f)) d (b c) a)
@end example

@func{reverse!} is the linear--update variant of @func{reverse}.  It
is permitted, but not required, to alter the argument's cons cells to
produce the reversed list.
@end defun


@defun append-reverse @var{rev-head} @var{tail}
@defunx append-reverse! @var{rev-head} @var{tail}
@func{append-reverse} returns:

@example
(append (reverse rev-head) tail)
@end example

It is provided because it is a common operation, a common
list--processing style calls for this exact operation to transfer values
accumulated in reverse order onto the front of another list, and because
the implementation is significantly more efficient than the simple
composition it replaces.

@quotation
But note that this pattern of iterative computation followed by a
@func{reverse} can frequently be rewritten as a recursion, dispensing
with the @func{reverse} and @func{append-reverse} steps, and shifting
temporary, intermediate storage from the heap to the stack, which is
typically a win for reasons of cache locality and eager storage
reclamation.
@end quotation

@func{append-reverse!} is just the linear--update variant; it is
allowed, but not required, to alter @var{rev-head}'s cons cells to
construct the result.
@end defun


@defun zip @var{clist1} @var{clist2} ...
Defined as:

@example
(lambda lists (apply map list lists))
@end example

If @func{zip} is passed @var{n} lists, it returns a list as long as the
shortest of these lists, each element of which is an @var{n}--element
list comprised of the corresponding elements from the parameter lists.

@example
(zip '(one two three)
     '(1 2 3)
     '(odd even odd even odd even odd even))
  => ((one 1 odd) (two 2 even) (three 3 odd))

(zip '(1 2 3))
  => ((1) (2) (3))
@end example

At least one of the argument lists must be finite:

@example
(zip '(3 1 4 1)
     (circular-list #f #t))
=> ((3 #f)
    (1 #t)
    (4 #f)
    (1 #t))
@end example
@end defun


@defun unzip1 @var{list}
@defunx unzip2 @var{list}
@defunx unzip3 @var{list}
@defunx unzip4 @var{list}
@defunx unzip5 @var{list}
@func{unzip1} takes a list of lists, where every list must contain at
least one element, and returns a list containing the initial element of
each such list.  That is, it returns @code{(map car lists)}.

@func{unzip2} takes a list of lists, where every list must contain at
least two elements, and returns two values: a list of the first
elements, and a list of the second elements.

@func{unzip3} does the same for the first three elements of the lists,
and so forth.

@example
(unzip2 '((1 one) (2 two) (3 three)))
=> (1 2 3)
   (one two three)
@end example
@end defun


@defun count @var{pred} @var{clist1} ...
@var{pred} is a procedure taking as many arguments as there are lists
and returning a single value.  It is applied element--wise to the
elements of the lists, and a count is tallied of the number of elements
that produce a true value.  This count is returned.

@func{count} is ``iterative'' in that it is guaranteed to apply
@var{pred} to the list elements in a left--to--right order.  The
counting stops when the shortest list expires.

@example
(count even? '(3 1 4 1 5 9 2 5 6))                => 3
(count <     '(1 2 4 8) '(2 4 6 8 10 12 14 16))   => 3
@end example

At least one of the argument lists must be finite:

@example
(count < '(3 1 4 1) (circular-list 1 10)) => 2
@end example
@end defun


@c page
@node list spec fold
@subsection Fold, unfold and map


@cindex List fold, unfold and map


@menu
* list spec fold fold::         Folding.
* list spec fold reduce::       Reducing.
* list spec fold unfold::       Unfolding.
* list spec fold map::          Mapping.
@end menu


@c page
@node list spec fold fold
@subsubsection Folding


@defun fold @var{kons} @var{knil} @var{clist1} @var{clist2} ...
The fundamental list iterator.  First, consider the single
list--parameter case: if @code{clist1 = (e1 e2 ... en)}, then this
procedure returns:

@example
(kons en ... (kons e2 (kons e1 knil)) ... )
@end example

@noindent
that is, it obeys the (tail) recursion:

@example
(fold kons knil ell) = (fold kons (kons (car ell) knil)
                             (cdr ell))
(fold kons knil '()) = knil
@end example

Examples:

@example
;; add the elements
(fold + 0 '(1 2 3))
=> 6

;; reverse a list
(fold cons '() '(1 2 3))
=> (3 2 1)

;; append in reverse order
(fold cons '(4 5 6) '(3 2 1))
=> (1 2 3 4 5 6)

;; how many symbols?
(fold (lambda (x count)
        (if (symbol? x)
            (+ count 1)
          count))
      0
      '(a 1 b 2 c 3))
=> 3

;; length of the longest string
(fold (lambda (s len)
        (max len (string-length s)))
      0
      '("ciao" "hello" "salut" "hola"))
=> 5
@end example

If @var{n} list arguments are provided, then the @var{kons} function
must take @var{n+1} parameters: one element from each list, and the
``seed'' or fold state, which is initially @var{knil}.  The fold
operation terminates when the shortest list runs out of values:

@example
(fold cons* '() '(a b c)
                '(1 2 3 4 5))
=> (c 3
    b 2
    a 1)

(fold (lambda (a b c knil)
        (cons (list a b c) knil))
      '()
      '(1 2 3)
      '(10 20 30)
      '(100 200 300))
=> '((3 30 300)
     (2 20 200)
     (1 10 100))
@end example

At least one of the list arguments must be finite.
@end defun

@c ------------------------------------------------------------

@defun fold-right @var{kons} @var{knil} @var{clist1} @var{clist2} ...
The fundamental list recursion operator.  First, consider the single
list--parameter case.  If @code{clist1 = (e1 e2 ... en)}, then this
procedure returns:

@example
(kons e1 (kons e2 ... (kons en knil)))
@end example

@noindent
that is, it obeys the recursion:

@example
(fold-right kons knil ell) = (kons (car ell)
                                   (fold-right kons knil (cdr ell)))
(fold-right kons knil '()) = knil
@end example

Examples:

@example
;; copy the list
(fold-right cons '() '(1 2 3))
=> (1 2 3)

;; add elements
(fold-right + 0 numbers)
=> 45

;; prepend elements
(fold-right cons '(4 5 6) '(1 2 3))
=> (1 2 3 4 5 6)

;; filter the even numbers
(fold-right (lambda (x l)
              (if (even? x)
                  (cons x l)
                l))
            '()
            '(0 1 2 3 4 5 6 7 8 9))
=> (0 2 4 6 8)
@end example

If @var{n} list arguments are provided, then the @var{kons} function
must take @var{n}+1 parameters: one element from each list, and the
``seed'' or fold state, which is initially @var{knil}.  The fold
operation terminates when the shortest list runs out of values:

At least one of the list arguments must be finite.

@example
(fold-right cons*
            '()
            '(a b c)
            '(1 2 3 4 5))
=> (a 1
    b 2
    c 3)

(fold-right (lambda (a b c knil)
              (cons (list a b c)
                    knil))
            '()
            '(1 2 3)
            '(10 20 30)
            '(100 200 300))
=> ((1 10 100)
    (2 20 200)
    (3 30 300))
@end example
@end defun

@c ------------------------------------------------------------

@defun pair-fold @var{kons} @var{knil} @var{clist1} @var{clist2} ...
Analogous to @func{fold}, but @var{kons} is applied to successive
sublists of the lists, rather than successive elements; that is,
@var{kons} is applied to the pairs making up the lists, giving this
(tail) recursion:

@example
(pair-fold kons knil ell) = (let ((tail (cdr ell)))
                              (pair-fold kons
                                         (kons ell knil)
                                         tail))
(pair-fold kons knil '()) = knil
@end example

For finite lists, the @var{kons} function may reliably apply
@func{set-cdr!} to the pairs it is given without altering the sequence
of execution.

Examples:

@example
(pair-fold (lambda (elm knil)
             (cons (car elm) knil))
           '(999)
           '(1 2 3))
=> (3 2 1 999)

;;; destructively reverse a list
(pair-fold (lambda (pair tail)
             (set-cdr! pair tail)
             pair)
           '()
           '(0 1 2 3 4 5))
=> (5 4 3 2 1 0)
@end example

At least one of the list arguments must be finite.
@end defun

@c ------------------------------------------------------------

@defun pair-fold-right @var{kons} @var{knil} @var{clist1} @var{clist2} ...
Holds the same relationship with @func{fold-right} that @func{pair-fold}
holds with fold.  Obeys the recursion:

@example
(pair-fold-right kons knil lis) =
    (kons lis (pair-fold-right kons knil (cdr lis)))
(pair-fold-right kons knil '()) = knil
@end example

Example:

@example
(pair-fold-right cons '() '(a b c)) => ((a b c) (b c) (c))
@end example

At least one of the list arguments must be finite.

Examples:

@example
(pair-fold-right (lambda (elm knil)
                   (cons (car elm) knil))
                 '(999)
                 '(1 2 3))
=> (1 2 3 999)

(pair-fold-right (lambda (pair tail)
                   (set-cdr! pair tail)
                   pair)
                 '()
                 '(0 1 2 3 4 5))
=> (0 1 2 3 4 5)

(pair-fold-right (lambda (a b c knil)
                   (cons (list (car a)
                               (car b)
                               (car c))
                         knil))
                 '(999)
                 '(1 2 3)
                 '(10 20 30)
                 '(100 200 300))
=> '((1 10 100)
     (2 20 200)
     (3 30 300)
     999)
@end example
@end defun


@c page
@node list spec fold reduce
@subsubsection Reducing


@defun reduce @var{f} @var{ridentity} @var{list}
@func{reduce} is a variant of @func{fold}.  @var{ridentity} should be a
``right identity'' of the procedure @var{f}; that is, for any value
@var{x} acceptable to @var{f}:

@example
(f x ridentity) = x
@end example

@func{reduce} has the following definition:

@example
if list = (), return ridentity;
otherwise, return (fold f (car list) (cdr list)).
@end example

@noindent
in other words, we compute @code{(fold f ridentity list)}.

Note that @var{ridentity} is used only in the empty--list case.

You typically use @func{reduce} when applying @var{f} is expensive and
you'd like to avoid the extra application incurred when fold applies
@var{f} to the head of list and the identity value, redundantly
producing the same value passed in to @var{f}.  For example, if @var{f}
involves searching a file directory or performing a database query, this
can be significant.

In general, however, @func{fold} is useful in many contexts where
@func{reduce} is not (consider the examples given in the @func{fold}
definition: only one of the five folds uses a function with a right
identity; the other four may not be performed with @func{reduce}).

@quotation
@emph{Note:} @acronym{MIT} Scheme and Haskell flip @var{f}'s arguments
order for their @func{reduce} and @func{fold} functions.
@end quotation

Examples:

@example
;; take the max of a list of non-negative integers
(reduce max 0 '(1 2 3 4 5 6))
=> 6

(reduce + 0 '(0 1 2 3 4 5 6 7 8 9))
=> 45
@end example
@end defun


@defun reduce-right @var{f} @var{ridentity} @var{list}
@func{reduce-right} is the @func{fold-right} variant of
@func{reduce}.  It obeys the following definition:

@example
(reduce-right f ridentity '()) = ridentity
(reduce-right f ridentity '(e1)) = (f e1 ridentity) = e1
(reduce-right f ridentity '(e1 e2 ...)) =
    (f e1 (reduce f ridentity (e2 ...)))
@end example

@noindent
in other words, we compute @code{(fold-right f ridentity list)}.

@example
;; append a bunch of lists together
(reduce-right append
              '()
              '((1 2 3)
                (4 5)
                (6 7 8 9)
                (0)))
=> (1 2 3 4 5 6 7 8 9 0)
@end example
@end defun


@c page
@node list spec fold unfold
@subsubsection Unfolding


@defun unfold @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed} [@var{tail-gen}]
Generate a list from a starting value; return the result.  It is is the
fundamental recursive list constructor, just as @func{fold-right} is the
fundamental recursive list consumer.  It is best described by its basic
recursion:

@example
(unfold stop? map-to-elm seed-step seed tail-gen) =
    (if (stop? seed)
        (tail-gen seed)
      (cons (map-to-elm seed)
            (unfold stop? map-to-elm
                    seed-step (seed-step seed)
                    tail-gen)))
@end example

The arguments are:

@table @var
@item stop?
Determines when to stop: it is applied to the current seed value, and if
the return value is @true{}: unfolding stops.  If it evaluates to
@true{} at the first invocation: the return value of @func{unfold} is
the return value of @var{tail-gen}.

@item map-to-elm
Maps each seed value to the corresponding list element.  It is applied
to the current seed value and must return the value to append to the
result list.

@item seed-step
Maps each seed value to next seed value.

@item first-seed
The ``state'' value for the unfold.  It is the first seed value.

@item tail-gen
Applied to the seed value that caused @func{stop?} to return @true{},
must return the tail of the result list.  Defaults to @code{(lambda (x)
'())}.
@end table

While @func{unfold} may seem a bit abstract to novice functional
programmers, it can be used in a number of ways:

@example
;; List of squares: 1^2 ... 5^2
(unfold (lambda (x) (> x 5))
        (lambda (x) (* x x))
        (lambda (x) (+ x 1))
        1)
=> (1 4 9 16 25)

;; Copy a proper list.
(unfold null-list? car cdr '(1 2 3 4 5))
=> (1 2 3 4 5)

;; Read current input port into a list of values.
(unfold eof-object? values (lambda (x) (read)) (read))

;; Copy a possibly non-proper list:
(unfold not-pair? car cdr '(1 2 3 4 . 5) values)
=> (1 2 3 4 . 5)

;; Append HEAD onto TAIL:
(unfold null-list? car cdr '(1 2 3) (lambda (x) '(4 5 6)))
=> (1 2 3 4 5 6)
@end example

@quotation
@emph{Note:} Interested functional programmers may enjoy noting that
@func{fold-right} and @func{unfold} are in some sense inverses.  That
is, given operations @var{knull?}, @var{kar}, @var{kdr}, @var{kons}, and
@var{knil} satisfying:

@example
(kons (kar x) (kdr x)) = x and (knull? knil) = #t
@end example

@noindent
then:

@example
(fold-right kons knil (unfold knull? kar kdr x)) = x
@end example

@noindent
and:

@example
(unfold knull? kar kdr (fold-right kons knil x)) = x
@end example

This combinator sometimes is called an ``anamorphism''; when an explicit
@var{tail-gen} procedure is supplied, it is called an ``apomorphism''.
@end quotation
@end defun

@c ------------------------------------------------------------

@defun unfold-right @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed} [@var{tail}]
Generate a list from a starting value; return the result.  It is the
fundamental iterative list constructor, just as @func{fold} is the
fundamental iterative list consumer.  Construct a list with the
following loop:

@example
(let loop ((seed seed)
           (ell  tail))
  (if (stop? seed)
      ell
    (loop (seed-step seed)
          (cons (map-to-elm seed) ell))))
@end example

Arguments are:

@table @var
@item stop?
Determine when to stop unfolding.

@item map-to-elm
Map each seed value to the corresponding list element.

@item seed-step
Map each seed value to next seed value.

@item first-seed
The ``state'' value for the unfold.

@item tail
List terminator; defaults to @code{'()}.
@end table

While @func{unfold-right} may seem a bit abstract to novice functional
programmers, it can be used in a number of ways:

@example
;; List of squares: 1^2 ... 10^2
(unfold-right zero?
              (lambda (x) (* x x))
              (lambda (x) (- x 1))
              5)
=> (1 4 9 16 25)

;; Reverse a proper list.
(unfold-right null-list? car cdr '(1 2 3 4 5))
=> (5 4 3 2 1)

;; Read current input port into a list of values.
(unfold-right eof-object? values (lambda (x) (read)) (read))

;; Equivalent to: (append-reverse rev-head tail)
(unfold-right null-list? car cdr '(3 2 1) '(4 5 6))
=> (1 2 3 4 5 6)
@end example

@quotation
@emph{Note:} Interested functional programmers may enjoy noting that
@func{fold} and @func{unfold-right} are in some sense inverses.  That
is, given operations @var{knull?}, @var{kar}, @var{kdr}, @var{kons}, and
@var{knil} satisfying:

@example
(kons (kar x) (kdr x)) = x and (knull? knil) = #t
@end example

@noindent
then:

@example
(fold kons knil (unfold-right knull? kar kdr x)) = x
@end example

@noindent
and:

@example
(unfold-right knull? kar kdr (fold kons knil x)) = x.
@end example

This combinator presumably has some pretentious mathematical name;
interested readers are invited to communicate it to the author.
@end quotation
@end defun


@c page
@node list spec fold map
@subsubsection Mapping


@defun map @var{proc} @var{clist1} @var{clist2} ...
@var{proc} is a procedure taking as many arguments as there are list
arguments and returning a single value.  @func{map} applies @var{proc}
element--wise to the elements of the lists and returns a list of the
results, in order.  The dynamic order in which @var{proc} is applied to
the elements of the lists is unspecified.

@example
(map cadr '((a b)
            (d e)
            (g h)))
=>  (b e h)

(map
   (lambda (n)
     (expt n n))
  '(1 2 3 4 5))
=> (1 4 27 256 3125)

(map + '(1 2 3)
       '(4 5 6))
=> (5 7 9)

(let ((count 0))
  (map
      (lambda (ignored)
        (set! count (+ count 1))
        count)
    '(a b)))
=> (1 2) or (2 1)
@end example

This procedure is extended from its @rnrs{5} specification to allow the
arguments to be of unequal length; it terminates when the shortest list
runs out of elements.

At least one of the list arguments must be a finite list:

@example
(map +
     '(3 1 4 1)
     (circular-list 1 0))
=> (4 1 5 1)
@end example
@end defun


@defun for-each @var{proc} @var{clist1} @var{clist2} ...
The arguments to @func{for-each} are like the arguments to @func{map},
but @func{for-each} calls @var{proc} for its side effects rather than
for its values.  Unlike @func{map}, @func{for-each} is guaranteed to
call @var{proc} on the elements of the lists in order from the first
element(s) to the last, and the value returned by @func{for-each} is
unspecified.

@example
(let ((v (make-vector 5)))
  (for-each
       (lambda (i)
         (vector-set! v i (* i i)))
    '(0 1 2 3 4))
  v)
=> #(0 1 4 9 16)
@end example

This procedure is extended from its @rnrs{5} specification to allow the
arguments to be of unequal length; it terminates when the shortest list
runs out.

At least one of the list arguments must be a finite list.
@end defun


@defun append-map @var{f} @var{clist1} @var{clist2} ...
@defunx append-map! @var{f} @var{clist1} @var{clist2} ...
Equivalent to:

@example
(apply append (map f clist1 clist2 ...))
@end example

@noindent
and:

@example
(apply append! (map f clist1 clist2 ...))
@end example

@noindent
so it makes sense to use these functions only when the list returned by
the map process is a list of lists.

Map @var{f} over the elements of the lists, just as in the @func{map}
function.  However, the results of the applications are appended
together to make the final result.  @func{append-map} uses @func{append}
to append the results together; @func{append-map!} uses @func{append!}.

The dynamic order in which the various applications of @var{f} are made
is not specified.

Example:

@example
(append-map!
    (lambda (x)
      (list x (- x)))
  '(1 3 8))
=> (1 -1 3 -3 8 -8)

(append-map! list
             '(1 2 3)
             '(10 20 30))
=> (1 10 2 20 3 30)
@end example

At least one of the list arguments must be a finite list.
@end defun


@defun {map!} @var{f} @var{list1} @var{clist2} ...
Linear--update variant of @func{map}, @func{map!} is allowed, but not
required, to alter the cons cells of @var{list1} to construct the result
list.

The dynamic order in which the various applications of @var{f} are made
is not specified.  In the n--ary case, @var{clist2}, @var{clist3},
... must have at least as many elements as @var{list1}.
@end defun


@defun map-in-order @var{f} @var{clist1} @var{clist2} ...
A variant of the @func{map} procedure that guarantees to apply @var{f}
across the elements of the @var{listi} arguments in a left--to--right
order.  This is useful for mapping procedures that both have side
effects and return useful values.

At least one of the list arguments must be finite.
@end defun


@defun pair-for-each @var{f} @var{clist1} @var{clist2} ...
Like @func{for-each}, but @var{f} is applied to successive sublists of
the argument lists.  That is, @var{f} is applied to the cons cells of
the lists, rather than the lists' elements.  These applications occur in
left--to--right order.

The @var{f} procedure may reliably apply @func{set-cdr!} to the pairs it
is given without altering the sequence of execution.

@example
(pair-for-each
    (lambda (pair)
      (display pair)
      (newline))
  '(a b c))
; prints
;    (a b c)
;    (b c)
;    (c)
@end example

At least one of the list arguments must be a finite list.
@end defun


@defun filter-map @var{f} @var{clist1} @var{clist2} ...
Like @func{map}, but only true values are saved.

@example
(filter-map
    (lambda (x)
      (and (number? x)
           (* x x)))
  '(a 1 b 3 c 7))
=> (1 9 49)
@end example

The dynamic order in which the various applications of @var{f} are made
is not specified.

At least one of the list arguments must be finite.
@end defun


@c page
@node list spec filter
@subsection Filtering and partitioning


@cindex List filtering


@defun filter @var{pred} @var{list}
@defunx filter! @var{pred} @var{list}
Return all the elements of @var{list} that satisfy predicate @var{pred}.
The list is not disordered: elements that appear in the result list
occur in the same order as they occur in @var{list}.  The returned list
may share a common tail with @var{list}.  The dynamic order in which the
various applications of @var{pred} are made is not specified.

@example
(filter even? '(0 7 8 8 43 -4)) => (0 8 8 -4)
@end example

@func{filter!} is the linear--update variant of @func{filter}.  It is
allowed, but not required, to alter the cons cells in @var{list} to
construct the result lists.
@end defun


@defun partition @var{pred} @var{list}
@defunx partition! @var{pred} @var{list}
Partition the elements of @var{list} with predicate @var{pred}, and
return two values: the list of in--elements and the list of
out--elements.  The list is not disordered: elements occur in the result
lists in the same order as they occur in @var{list}.  The dynamic order
in which the various applications of @var{pred} are made is not
specified.  One of the returned lists may share a common tail with
@var{list}.

@example
(partition symbol? '(one 2 3 four five 6))
  => (one four five)
     (2 3 6)
@end example

@func{partition!} is the linear--update variant of @func{partition}.
It is allowed, but not required, to alter the cons cells in @var{list}
to construct the result lists.
@end defun


@defun remove @var{pred} @var{list}
@defunx remove! @var{pred} @var{list}
Return @var{list} without the elements that satisfy predicate
@var{pred}:

@example
(lambda (pred list)
  (filter (lambda (x)
            (not (pred x)))
          list))
@end example

The list is not disordered: elements that appear in the result list
occur in the same order as they occur in @var{list}.  The returned list
may share a common tail with @var{list}.  The dynamic order in which the
various applications of pred are made is not specified.

@example
(remove even? '(0 7 8 8 43 -4)) => (7 43)
@end example

@func{remove!} is the linear--update variant of @func{remove}.  It is
allowed, but not required, to alter the cons cells in @var{list} to
construct the result lists.
@end defun


@c page
@node list spec search
@subsection Searching


@cindex List searching
@cindex Searching in lists


The following procedures all search lists for a leftmost element
satisfying some criteria.  This means they do not always examine the
entire list; thus, there is no efficient way for them to reliably detect
and signal an error when passed a dotted or circular list.  Here are the
general rules describing how these procedures work when applied to
different kinds of lists:

@table @emph
@item proper lists
The standard, canonical behavior happens in this case.

@item dotted lists
It is an error to pass these procedures a dotted list that does not
contain an element satisfying the search criteria.  That is, it is an
error if the procedure has to search all the way to the end of the
dotted list.

However, this @srfi{} does not specify anything at all about the
behavior of these procedures when passed a dotted list containing an
element satisfying the search criteria.  It may finish successfully,
signal an error, or perform some third action.

Different implementations may provide different functionality in this
case; code which is compliant with this @srfi{} may not rely on any
particular behavior.  Future @srfi{}'s may refine @ansrfi{1} to define
specific behavior in this case.

In brief, @ansrfi{1} compliant code may not pass a dotted list argument to
these procedures.

@item circular lists
It is an error to pass these procedures a circular list that does not
contain an element satisfying the search criteria.  Note that the
procedure is not required to detect this case; it may simply diverge.
It is, however, acceptable to search a circular list if the search is
successful; that is, if the list contains an element satisfying the
search criteria.
@end table

Here are some examples, using the @func{find} and @func{any} procedures
as canonical representatives:

@example
;; Proper list -- success
(find even? '(1 2 3))	=> 2
(any  even? '(1 2 3))	=> #t

;; proper list -- failure
(find even? '(1 7 3))	=> #f
(any  even? '(1 7 3))	=> #f

;; Failure is error on a dotted list.
(find even? '(1 3 . x))	=> error
(any  even? '(1 3 . x))	=> error

;; The dotted list contains an element satisfying the search.
;; This case is not specified -- it could be success, an error,
;; or some third possibility.
(find even? '(1 2 . x))	=> error/undefined
(any  even? '(1 2 . x))	=> error/undefined ; success, error or other.

;; circular list -- success
(find even? (circular-list 1 6 3)) => 6
(any  even? (circular-list 1 6 3)) => #t

;; circular list -- failure is error. Procedure may diverge.
(find even? (circular-list 1 3)) => error
(any  even? (circular-list 1 3)) => error
@end example


@defun find @var{pred} @var{clist}
Return the first element of @var{clist} that satisfies predicate
@var{pred}; return @false{} if no element does.

@example
(find even? '(3 1 4 1 5 9)) => 4
@end example

Note that @func{find} has an ambiguity in its lookup semantics: if
@func{find} returns @false{}, you cannot tell (in general) if it found a
@false{} element that satisfied @var{pred}, or if it did not find any
element at all.  In many situations, this ambiguity cannot arise: either
the list being searched is known not to contain any @false{} elements,
or the list is guaranteed to have an element satisfying @var{pred}.
However, in cases where this ambiguity can arise, you should use
@func{find-tail} instead of @func{find}, @func{find-tail} has no such
ambiguity:

@example
(cond
 ((find-tail pred lis)
  => (lambda (pair) ...)) ; Handle (CAR PAIR)
 (else ...)) ; Search failed.
@end example
@end defun


@defun find-tail @var{pred} @var{clist}
Return the first pair of @var{clist} whose car satisfies @var{pred}.  If
no pair does, return @false{}.

@func{find-tail} can be viewed as a general--predicate variant of the
@func{member} function.

Examples:

@example
(find-tail even? '(3 1 37 -8 -5 0 0)) => (-8 -5 0 0)
(find-tail even? '(3 1 37 -5)) => #f

;; MEMBER X LIS:
(find-tail (lambda (elt) (equal? x elt)) lis)
@end example

In the circular--list case, this procedure ``rotates'' the list.

@func{find-tail} is essentially @func{drop-while}, where the sense of
the predicate is inverted: @func{find-tail} searches until it finds an
element satisfying the predicate; @func{drop-while} searches until it
finds an element that doesn't satisfy the predicate.
@end defun


@defun take-while @var{pred} @var{clist}
@defunx take-while! @var{pred} @var{clist}
Return the longest initial prefix of @var{clist} whose elements all
satisfy the predicate @var{pred}.

@func{take-while!} is the linear--update variant.  It is allowed, but
not required, to alter the argument list to produce the result.

Example:

@example
(take-while even? '(2 18 3 10 22 9)) => (2 18)
@end example
@end defun


@defun drop-while @var{pred} @var{clist}
Drops the longest initial prefix of @var{clist} whose elements all
satisfy the predicate @var{pred}, and returns the rest of the list.

Example:

@example
(drop-while even? '(2 18 3 10 22 9)) => (3 10 22 9)
@end example

The circular--list case may be viewed as ``rotating'' the list.
@end defun


@defun span @var{pred} @var{clist}
@defunx span! @var{pred} @var{list}
@defunx break @var{pred} @var{clist}
@defunx break! @var{pred} @var{list}
@func{span} splits the list into the longest initial prefix whose
elements all satisfy @var{pred}, and the remaining tail.  @func{break}
inverts the sense of the predicate: the tail commences with the first
element of the input list that satisfies the predicate.

In other words: @func{span} finds the intial span of elements satisfying
@var{pred}, and @func{break} breaks the list at the first element
satisfying @var{pred}.

@func{span} is equivalent to:

@example
(values (take-while pred clist)
        (drop-while pred clist))
@end example

@func{span!} and @func{break!} are the linear--update variants.  They
are allowed, but not required, to alter the argument list to produce the
result.

Examples:

@example
(span even? '(2 18 3 10 22 9))
  => (2 18)
     (3 10 22 9)

(break even? '(3 1 4 1 5 9))
  => (3 1)
     (4 1 5 9)
@end example
@end defun


@defun any @var{pred} @var{clist1} @var{clist2} ...
Apply the predicate across the lists, returning true if the predicate
returns true on any application.

If there are n list arguments @var{clist1} ... @var{clistn}, then
@var{pred} must be a procedure taking n arguments and returning a
boolean result.

@func{any} applies @var{pred} to the first elements of the @var{clisti}
parameters.  If this application returns a true value, @func{any}
immediately returns that value.  Otherwise, it iterates, applying pred
to the second elements of the @var{clisti} parameters, then the third,
and so forth.  The iteration stops when a true value is produced or one
of the lists runs out of values; in the latter case, @func{any} returns
@false{}.  The application of @var{pred} to the last element of the
lists is a tail call.

Note the difference between @func{find} and @func{any}: @func{find}
returns the element that satisfied the predicate; @func{any} returns the
true value that the predicate produced.

Like @func{every}, @func{any}'s name does not end with a question mark:
this is to indicate that it does not return a simple boolean (@true{} or
@false{}), but a general value.

Examples:

@example
(any integer? '(a 3 b 2.7))   => #t
(any integer? '(a 3.1 b 2.7)) => #f
(any < '(3 1 4 1 5)
       '(2 7 1 8 2)) => #t
@end example
@end defun


@defun every @var{pred} @var{clist1} @var{clist2} ...
Apply the predicate across the lists, returning true if the predicate
returns true on every application.

If there are n list arguments @var{clist1} ... @var{clistn}, then
@var{pred} must be a procedure taking n arguments and returning a
boolean result.

@func{every} applies @var{pred} to the first elements of the
@var{clisti} parameters.  If this application returns @false{},
@func{every} immediately returns @false{}.  Otherwise, it iterates,
applying @var{pred} to the second elements of the @var{clisti}
parameters, then the third, and so forth.  The iteration stops when a
@false{} value is produced or one of the lists runs out of values.  In
the latter case, @func{every} returns the true value produced by its
final application of @var{pred}.  The application of @var{pred} to the
last element of the lists is a tail call.

If one of the @var{clisti} has no elements, @func{every} simply returns
@true{}.

Like @func{any}, @func{every}'s name does not end with a question mark:
this is to indicate that it does not return a simple boolean (@true{} or
@false{}), but a general value.
@end defun


@defun list-index @var{pred} @var{clist1} @var{clist2} ...
Return the index of the leftmost element that satisfies @var{pred}.

If there are n list arguments, then @var{pred} must be a function taking
n arguments and returning a boolean result.

@func{list-index} applies @var{pred} to the first elements of the
@var{clisti} parameters.  If this application returns true,
@func{list-index} immediately returns zero.  Otherwise, it iterates,
applying @var{pred} to the second elements of the @var{clisti}
parameters, then the third, and so forth.  When it finds a tuple of list
elements that cause @var{pred} to return true, it stops and returns the
zero--based index of that position in the lists.

The iteration stops when one of the lists runs out of values; in this
case, @func{list-index} returns @false{}.

Examples:

@example
(list-index even? '(3 1 4 1 5 9)) => 2
(list-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => 1
(list-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => #f
@end example
@end defun


@defun member @var{x} @var{list} [@var{=}]
@defunx memq @var{x} @var{list}
@defunx memv @var{x} @var{list}
These procedures return the first sublist of @var{list} whose car is
@var{x}, where the sublists of list are the non--empty lists returned by
@code{(drop list i)} for @var{i} less than the length of @var{list}.  If
@var{x} does not occur in @var{list}, then @false{} is returned.

@func{memq} uses @func{eq?} to compare @var{x} with the elements of
@var{list}, while @var{memv} uses @func{eqv?}, and @func{member} uses
@func{equal?}.

Examples:

@example
(memq 'a '(a b c))          =>  (a b c)
(memq 'b '(a b c))          =>  (b c)
(memq 'a '(b c d))          =>  #f
(memq (list 'a) '(b (a) c)) =>  #f
(member (list 'a)
        '(b (a) c))         =>  ((a) c)
(memq 101 '(100 101 102))   =>  *unspecified*
(memv 101 '(100 101 102))   =>  (101 102)
@end example

@func{member} is extended from its @rnrs{5} definition to allow the
client to pass in an optional equality procedure @var{=} used to compare
keys.

The comparison procedure is used to compare the elements @var{ei} of
list to the key @var{x} in this way:

@example
(= x ei) ; list is (E1 ... En)
@end example

@noindent
that is, the first argument is always @var{x}, and the second argument
is one of the list elements.  Thus one can reliably find the first
element of list that is greater than five with @code{(member 5 list <)}.

Note that fully general list searching may be performed with the
@func{find-tail} and @func{find} procedures:

@example
(find-tail even? list) ; Find the first elt with an even key.
@end example
@end defun


@c page
@node list spec delete
@subsection Deletion


@cindex List deletion


@defun delete @var{x} @var{list} [@var{=}]
@defunx delete! @var{x} @var{list} [@var{=}]
Use the comparison procedure @var{=} (which defaults to @func{equal?})
to find all elements of list that are equal to @var{x}, and delete them
from @var{list}.  The dynamic order in which the various applications of
@var{=} are made is not specified.

The list is not disordered: elements that appear in the result list
occur in the same order as they occur in the argument list.  The result
may share a common tail with the argument list.

Note that fully general element deletion can be performed with the
@func{remove} and @func{remove!} procedures:

@example
;; Delete all the even elements from LIS:
(remove even? lis)
@end example

The comparison procedure is used in this way: @code{(= x ei)}; that is,
@var{x} is always the first argument, and a list element is always the
second argument.  The comparison procedure will be used to compare each
element of list exactly once; the order in which it is applied to the
various @var{ei} is not specified.  Thus, one can reliably remove all
the numbers greater than 5 from a list with @code{(delete 5 list <)}.

@func{delete!} is the linear--update variant of @func{delete}.  It is
allowed, but not required, to alter the cons cells in its argument list
to construct the result.
@end defun


@defun delete-duplicates @var{list} [@var{=}]
@defunx {delete-duplicates!} @var{list} [@var{=}]
Remove duplicate elements from the list argument.  If there are multiple
equal elements in @var{list}, the result list only contains the first or
leftmost of these elements in the result.  The order of these surviving
elements is the same as in the original list: @func{delete-duplicates}
does not disorder the list (hence it is useful for ``cleaning up''
association lists).

The @var{=} parameter is used to compare the elements of the list; it
defaults to @func{equal?}.  If @var{x} comes before @var{y} in
@var{list}, then the comparison is performed @code{(= x y)}.  The
comparison procedure will be used to compare each pair of elements in
list no more than once; the order in which it is applied to the various
pairs is not specified.

Implementations of @func{delete-duplicates} are allowed to share common
tails between argument and result lists; for example, if the list
argument contains only unique elements, it may simply return exactly
this list.

Be aware that, in general, @func{delete-duplicates} runs in time O(n2)
for n--element lists.  Uniquifying long lists can be accomplished in O(n
lg n) time by sorting the list to bring equal elements together, then
using a linear--time algorithm to remove equal elements.  Alternatively,
one can use algorithms based on element--marking, with linear--time
results.

@func{delete-duplicates!} is the linear--update variant of
@func{delete-duplicates}; it is allowed, but not required, to alter the
cons cells in its argument list to construct the result.

@example
(delete-duplicates '(a b a c a b c z)) => (a b c z)

;; Clean up an alist:
(delete-duplicates '((a . 3) (b . 7) (a . 9) (c . 1))
                   (lambda (x y)
                     (eq? (car x) (car y))))
  => ((a . 3) (b . 7) (c . 1))
@end example
@end defun


@c page
@node list spec alist
@subsection Association lists


@cindex List, association lists
@cindex Association lists
@cindex Alists


An ``association list'' (or ``alist'') is a list of pairs.  The car of
each pair contains a key value, and the cdr contains the associated data
value.  They can be used to construct simple look--up tables in Scheme.
Note that association lists are probably inappropriate for
performance--critical use on large data; in these cases, hash tables or
some other alternative should be employed.


@defun assoc @var{key} @var{alist} [@var{=}]
@defunx assq @var{key} @var{alist}
@defunx assv @var{key} @var{alist}
@var{alist} must be an association list: a list of pairs.  These
procedures find the first pair in @var{alist} whose car field is
@var{key}, and returns that pair.  If no pair in @var{alist} has
@var{key} as its car, then @false{} is returned.

@func{assq} uses @func{eq?} to compare @var{key} with the car fields of
the pairs in @var{alist}, while @func{assv} uses @func{eqv?} and
@func{assoc} uses @func{equal?}.

Example:

@example
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)                            =>  (a 1)
(assq 'b e)                            =>  (b 2)
(assq 'd e)                            =>  #f
(assq (list 'a) '(((a)) ((b)) ((c))))  =>  #f
(assoc (list 'a) '(((a)) ((b)) ((c)))) =>  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    =>  *unspecified*
(assv 5 '((2 3) (5 7) (11 13)))    =>  (5 7)
@end example

@func{assoc} is extended from its @rnrs{5} definition to allow the
client to pass in an optional equality procedure @var{=} used to compare
keys.

The comparison procedure is used to compare the elements @var{ei} of
list to the key parameter in this way:

@example
(= key (car ei)) ; list is (E1 ... En)
@end example

@noindent
that is, the first argument is always @var{key}, and the second argument
is one of the list elements.  Thus one can reliably find the first entry
of @var{alist} whose @var{key} is greater than five with @code{(assoc 5
alist <)}.

Note that fully general alist searching may be performed with the
@func{find-tail} and @func{find} procedures:

@example
;; Look up the first association in alist with an even key:
(find (lambda (a)
        (even? (car a)))
      alist)
@end example
@end defun


@defun alist-cons @var{key} @var{datum} @var{alist}
Defined as:

@example
(lambda (key datum alist)
  (cons (cons key datum) alist))
@end example

Cons a new alist entry mapping @var{key} to @var{datum} onto
@var{alist}.
@end defun


@defun alist-copy @var{alist}
Make a fresh copy of @var{alist}.  This means copying each pair that
forms an association as well as the spine of the list:

@example
(lambda (a)
  (map (lambda (elt)
         (cons (car elt) (cdr elt)))
       a))
@end example
@end defun


@defun alist-delete @var{key} @var{alist} [@var{=}]
@defunx alist-delete! @var{key} @var{alist} [@var{=}]
Delete all associations from @var{alist} with the given @var{key}, using
the key-comparison procedure @var{=}, which defaults to @func{equal?}.
The dynamic order in which the various applications of @var{=} are made
is not specified.

Return values may share common tails with the @var{alist} argument.  The
alist is not disordered: elements that appear in the result alist occur
in the same order as they occur in @var{alist}.

The comparison procedure is used to compare the element keys @var{ki} of
@var{alist}'s entries to the key parameter in this way: @code{(= key
ki)}.  Thus, one can reliably remove all entries of @var{alist} whose
key is greater than five with @code{(alist-delete 5 alist <)}.

@func{alist-delete!} is the linear--update variant of
@func{alist-delete}; it is allowed, but not required, to alter cons
cells from the alist parameter to construct the result.
@end defun


@c page
@node list spec set
@subsection Set operations on lists


@cindex List set operations
@cindex Set operations on lists


These procedures implement operations on sets represented as lists of
elements.  They all take an @var{=} argument used to compare elements of
lists.  This equality procedure is required to be consistent with
@func{eq?}.  That is, it must be the case that:

@example
(eq? x y) => (= x y)
@end example

Note that this implies, in turn, that two lists that are @func{eq?} are
also set--equal by any legal comparison procedure.  This allows for
constant--time determination of set operations on @func{eq?} lists.

Be aware that these procedures typically run in time O(n * m) for n--
and m--element list arguments.  Performance--critical applications
operating upon large sets will probably wish to use other data
structures and algorithms.


@defun lset<= @var{=} @var{list1} ...
Return true if, and only if, every @var{listi} is a subset of
@var{listi+1}, using @var{=} for the element--equality procedure.  List
@var{AL} is a subset of list @var{BL} if every element in @var{AL} is
equal to some element of @var{BL}.  When performing an element
comparison, the @var{=} procedure's first argument is an element of
@var{AL}, its second argument an element of @var{BL}.

Examples:

@example
(lset<= eq? '(a) '(a b a) '(a b c c)) => #t

(lset<= eq?) => #t             ; Trivial cases
(lset<= eq? '(a)) => #t
@end example

If invoked with all null lists, the return value is @true{}.
@end defun


@defun lset= @var{=} @var{list1} @var{list2} ...
Return true if, and only if, every @var{listi} is set--equal to
@var{listi+1}, using @var{=} for the element--equality procedure.
``Set--equal'' simply means that @var{listi} is a subset of
@var{listi+1}, and @var{listi+1} is a subset of @var{listi}.  The
@var{=} procedure's first argument is an element of @var{listi}, its
second argument is an element of @var{listi+1}.

Examples:

@example
(lset= eq? '(b e a) '(a e b) '(e e b a)) => #t

(lset= eq?) => #t               ; Trivial cases
(lset= eq? '(a)) => #t
@end example
@end defun


@defun lset-adjoin @var{=} @var{list} @var{elt1} ...
Add the @var{elti} elements not already in the @var{list} parameter to
the result list.  The result shares a common tail with the @var{list}
parameter.  The new elements are added to the front of the list, but no
guarantees are made about their order.  The @var{=} parameter is an
equality procedure used to determine if an elti is already a member of
list.  Its first argument is an element of @var{list}, its second is one
of the @var{elti}.

The @var{list} parameter is always a suffix of the result; even if the
list parameter contains repeated elements, these are not reduced.

Example:

@example
(lset-adjoin eq? '(a b c d c e) 'a 'e 'i 'o 'u)
  => (u o i a b c d c e)
@end example
@end defun


@defun lset-union @var{=} @var{list1} ...
@defunx lset-union! @var{=} @var{list1} ...
Return the union of the lists, using @var{=} for the element--equality
procedure.

The union of lists @var{AL} and @var{BL} is constructed as follows:

@enumerate
@item
If @var{AL} is the empty list, the answer is @var{BL} (or a copy of
@var{BL}).

@item
Otherwise, the result is initialised to be list @var{AL} (or a copy of
@var{AL}).

@item
Proceed through the elements of list @var{BL} in a left--to--right
order.  If @var{b} is such an element of @var{BL}, compare every element
@var{r} of the current result list to @var{b}: @code{(= r b)}.  If all
comparisons fail, @var{b} is consed onto the front of the result.
@end enumerate

However, there is no guarantee that @var{=} will be applied to every
pair of arguments from @var{AL} and @var{BL}.  In particular, if
@var{AL} is @func{eq?} to @var{BL}, the operation may immediately
terminate.

In the n--ary case, the two--argument @func{list-union} operation is
simply folded across the argument lists.

Examples:

@example
(lset-union eq? '(a b c d e) '(a e i o u))
  => (u o i a b c d e)

;; Repeated elements in LIST1 are preserved.
(lset-union eq? '(a a c) '(x a x)) => (x a a c)

;; Trivial cases
(lset-union eq?) => ()
(lset-union eq? '(a b c)) => (a b c)
@end example

@func{lset-union!} is the linear--update variant of @func{lset-union}.
It is allowed, but not required, to use the cons cells in the first list
parameter to construct its answer.  @func{lset-union!} is permitted to
recycle cons cells from any of its list arguments.
@end defun


@defun lset-intersection @var{=} @var{list1} @var{list2} ...
@defunx lset-intersection! @var{=} @var{list1} ...
Return the intersection of the lists, using @var{=} for the
element--equality procedure.

The intersection of lists @var{AL} and @var{BL} is comprised of every
element of @var{AL} that is @var{=} to some element of @var{BL}:
@code{(= a b)}, for @var{a} in @var{AL}, and @var{b} in @var{BL}.  Note
this implies that an element which appears in @var{BL} and multiple
times in list @var{AL} will also appear multiple times in the result.

The order in which elements appear in the result is the same as they
appear in @var{list1}; that is, @func{lset-intersection} essentially
filters @var{list1}, without disarranging element order.  The result may
share a common tail with @var{list1}.

In the n--ary case, the two--argument @func{list-intersection} operation
is simply folded across the argument lists.  However, the dynamic order
in which the applications of @var{=} are made is not specified.  The
procedure may check an element of @var{list1} for membership in every
other list before proceeding to consider the next element of
@var{list1}, or it may completely intersect @var{list1} and @var{list2}
before proceeding to @var{list3}, or it may go about its work in some
third order.

Examples:

@example
(lset-intersection eq? '(a b c d e) '(a e i o u))
  => (a e)

;; Repeated elements in LIST1 are preserved.
(lset-intersection eq? '(a x y a) '(x a x z))
  => '(a x a)

(lset-intersection eq? '(a b c))        ; Trivial case
  => (a b c)
@end example

@func{lset-intersection!} is the linear--update variant of
@func{lset-intersection}.  It is allowed, but not required, to use the
cons cells in the first list parameter to construct its answer.
@end defun


@defun lset-difference @var{=} @var{list1} @var{list2} ...
@defunx lset-difference! @var{=} @var{list1} ...
Return the difference of the lists, using @var{=} for the
element--equality procedure: all the elements of @var{list1} that are
not @var{=} to any element from one of the other @var{listi} parameters.

The @var{=} procedure's first argument is always an element of
@var{list1}; its second is an element of one of the other @var{listi}.
Elements that are repeated multiple times in the @var{list1} parameter
will occur multiple times in the result.

The order in which elements appear in the result is the same as they
appear in @var{list1}; that is, @func{lset-difference} essentially
filters @var{list1}, without disarranging element order.  The result may
share a common tail with @var{list1}.

The dynamic order in which the applications of @var{=} are made is not
specified.  The procedure may check an element of @var{list1} for
membership in every other list before proceeding to consider the next
element of @var{list1}, or it may completely compute the difference of
@var{list1} and @var{list2} before proceeding to @var{list3}, or it may
go about its work in some third order.

@example
(lset-difference eq? '(a b c d e) '(a e i o u))
  => (b c d)

(lset-difference eq? '(a b c))   ; Trivial case
  => (a b c)
@end example

@func{lset-difference!} is the linear--update variant of
@func{lset-difference}.  It is allowed, but not required, to use the
cons cells in the first list parameter to construct its answer.
@end defun


@defun lset-xor @var{=} @var{list1} ...
@defunx lset-xor! @var{=} @var{list1} ...
Return the exclusive--or of the sets, using @var{=} for the
element--equality procedure.  If there are exactly two lists, this is
all the elements that appear in exactly one of the two lists.  The
operation is associative, and thus extends to the n--ary case, in which
the result is a list of the elements that appear in an odd number of the
lists.  The result may share a common tail with any of the @var{listi}
parameters.

More precisely, for two lists @var{AL} and @var{BL}, @var{AL} xor
@var{BL} is a list of:

@itemize
@item
every element @var{a} of @var{AL} such that there is no element @var{b}
of @var{BL} such that @code{(= a b)}, and

@item
every element @var{b} of @var{BL} such that there is no element @var{a}
of @var{AL} such that @code{(= b a)}.
@end itemize

However, an implementation is allowed to assume that @var{=} is
symmetric; that is, that @code{(= a b) => (= b a)}.

This means, for example, that if a comparison @code{(= a b)} produces
true for some @var{a} in @var{AL} and @var{b} in @var{BL}, both @var{a}
and @var{b} may be removed from inclusion in the result.

In the n--ary case, the binary--xor operation is simply folded across
the lists.

Examples:

@example
(lset-xor eq? '(a b c d e) '(a e i o u))
  => (d c b i o u)

;; Trivial cases.
(lset-xor eq?) => ()
(lset-xor eq? '(a b c d e)) => (a b c d e)
@end example

@func{lset-xor!} is the linear--update variant of @func{lset-xor}.  It
is allowed, but not required, to use the cons cells in the first list
parameter to construct its answer.
@end defun


@defun {lset-diff+intersection} @var{=} @var{list1} @var{list2} ...
@defunx {lset-diff+intersection!} @var{=} @var{list1} @var{list2} ...
Return two values: the difference and the intersection of the lists.  It
is equivalent to:

@example
(values (lset-difference = list1 list2 ...)
        (lset-intersection = list1
                             (lset-union = list2 ...)))
@end example

@noindent
but can be implemented more efficiently.

The @var{=} procedure's first argument is an element of @var{list1}; its
second is an element of one of the other @var{listi}.

Either of the answer lists may share a common tail with @var{list1}.
This operation essentially partitions @var{list1}.

@func{lset-diff+intersection!} is the linear--update variant of
@func{lset-diff+intersection}.  It is allowed, but not required, to use
the cons cells in the first list parameter to construct its answer.
@end defun



@c page
@node list spec side
@subsection Primitive side--effects


@cindex List side effects
@cindex Side effects on lists


These two procedures are the primitive, @rnrs{5} side--effect operations
on pairs.

@defun set-car! @var{pair} @var{object}
@defunx set-cdr! pair @var{object}
@rnrs{5} These procedures store object in the car and cdr field of pair,
respectively.  The returned value is unspecified.

@example
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3) =>  *unspecified*
(set-car! (g) 3) =>  *error*
@end example
@end defun


@c page
@node list spec stub
@subsection Stub library bindings


The bindings exported by @library{srfi lists} are re--exported by
@library{list-lib} with the following changes:

@enumerate
@item
The @func{assoc} function from the @srfi{} is renamed to
@func{srfi:assoc}.

@item
The @func{map} function from the @srfi{} is renamed to @func{srfi:map}.

@item
The @func{for-each} function from the @srfi{} is renamed to
@func{srfi:for-each}.

@item
The @func{fold-right} function from the @srfi{} is renamed to
@func{srfi:fold-right}.

@item
The @func{remove} function from the @srfi{} is renamed to
@func{srfi:remove}.

@item
The @func{member} function from the @srfi{} is renamed to
@func{srfi:member}.
@end enumerate


Additionally the following bindings are defined.


@defun tree-copy @var{list}
Copy the whole tree of the list @var{list}, not only the spine (which is
what @func{list-copy} does).
@end defun




@c page
@node list ack
@section Acknowledgements


The design of this library benefited greatly from the feedback provided
during the @srfi{} discussion phase.  Among those contributing
thoughtful commentary and suggestions, both on the mailing list and by
private discussion, were Mike Ashley, Darius Bacon, Alan Bawden, Phil
Bewig, Jim Blandy, Dan Bornstein, Per Bothner, Anthony Carrico, Doug
Currie, Kent Dybvig, Sergei Egorov, Doug Evans, Marc Feeley, Matthias
Felleisen, Will Fitzgerald, Matthew Flatt, Dan Friedman, Lars Thomas
Hansen, Brian Harvey, Erik Hilsdale, Wolfgang Hukriede, Richard Kelsey,
Donovan Kolbly, Shriram Krishnamurthi, Dave Mason, Jussi Piitulainen,
David Pokorny, Duncan Smith, Mike Sperber, Maciej Stachowiak, Harvey
J. Stein, John David Stone, and Joerg F. Wittenberger.  I am grateful to
them for their assistance.

I am also grateful the authors, implementors and documentors of all the
systems mentioned in the rationale.  Aubrey Jaffer and Kent Pitman
should be noted for their work in producing Web--accessible versions of
the @rnrs{5} and Common Lisp spec, which was a tremendous aid.

This is not to imply that these individuals necessarily endorse the
final results, of course.


@c page
@node list references
@section References


This document, in @acronym{HTML}:

@center @url{http://srfi.schemers.org/srfi-1/srfi-1.html}

@noindent
source code for the reference implementation:

@center @url{http://srfi.schemers.org/srfi-1/srfi-1-reference.scm}

@noindent
archive of @ansrfi{1} discussion--list email:

@center @url{http://srfi.schemers.org/srfi-1/mail-archive/maillist.html}

@noindent
@srfi{} web site:

@center @url{http://srfi.schemers.org/}

@noindent
@emph{Common Lisp: the Language}.  Guy L. Steele Jr. (editor).  Digital
Press, Maynard, Mass., second edition 1990.  Available at:

@center @url{http://www.elwood.com/alu/table/references.htm#cltl2}

@noindent
@emph{The Common Lisp "HyperSpec"}, produced by Kent Pitman, is
essentially the @ansi{} spec for Common Lisp:

@center @url{http://www.harlequin.com/education/books/HyperSpec/}

@emph{Revised^5 report on the algorithmic language Scheme}.  R. Kelsey,
W. Clinger, J. Rees (editors).  Higher--Order and Symbolic Computation,
Vol. 11, No. 1, September, 1998, and ACM SIGPLAN Notices, Vol. 33,
No. 9, October, 1998.  Available at

@center @url{http://www.schemers.org/Documents/Standards/}


@c page
@node strings
@chapter String library


@cindex @srfi{} strings


The @library{srfi strings} library has been written by Olin Shivers as
the reference implementation for @ansrfi{13}.

@menu
* strings license::             Original license.
* strings abstract::            Abstract.
* strings rationale::           Rationale.
* strings spec::                Specification.
* strings ack::                 Acknowledgments.
* strings references::          References.
@end menu


@c page
@node strings license
@section Strings document license


Certain portions of this document, the specific, marked segments of text
describing the @rnrs{5} procedures, were adapted with permission from
the @rnrs{5} report.

All other text is copyright @copyright{} 1998, 1999, 2000 Olin Shivers.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node strings abstract
@section Abstract


@rnrs{5} Scheme has an impoverished set of string--processing utilities,
which is a problem for authors of portable code.  This @srfi{} proposes
a coherent and comprehensive set of string--processing procedures; it is
accompanied by a reference implementation of the specification.  The
reference implementation is: portable, efficient, open source .

The routines in this @srfi{} are backwards--compatible with the
string--processing routines of @rnrs{5}.



@c page
@node strings rationale
@section Rationale


This @srfi{} defines two libraries that provide a rich set of
operations for manipulating strings.  These are frequently useful for
scripting and other text--manipulation applications.  The library's
design was influenced by the string libraries found in @acronym{MIT}
Scheme, Gambit, RScheme, MzScheme, slib, Common Lisp, Bigloo, guile,
Chez, @acronym{APL}, Java, and the @acronym{SML} standard basis.

All procedures involving character comparison are available in both
case--sensitive and case--insensitive forms.

All functionality is available in substring and full--string forms.

@menu
* strings ratio code-point::    Strings are code-point sequences.
* strings ratio i18n::          Internationalisation and
                                super-@ascii{} character types.
@end menu


@c page
@node strings ratio code-point
@subsection Strings are code--point sequences


This @srfi{} considers strings simply to be a sequence of ``code
points'' or character encodings.  Operations such as comparison or
reversal are always done code point by code point.  See the comments
below on super--@ascii{} character types for implications that follow.

It's entirely possible that a legal string might not be a sensible
``text'' sequence.  For example, consider a string comprised entirely of
zero--width Unicode accent characters with no preceding base character
to modify; this is a legal string, albeit one that does not make a great
deal of sense when interpreted as a sequence of natural--language text.
The routines in this @srfi{} do not handle these ``text'' concerns;
they restrict themselves to the underlying view of strings as merely a
sequence of ``code points''.

This @srfi{} defines string operations that are locale--independent and
context--independent.  While it is certainly important to have a
locale--sensitive comparison or collation procedure when processing
text, it is also important to have a suite of operations that are
reliably invariant for basic string processing; otherwise, a change of
locale could cause data structures such as hash tables, b--trees, symbol
tables, directories of filenames, etc. to become corrupted.

Locale--sensitive and context--sensitive text operations, such as
collation, are explicitly deferred to a subsequent, companion ``text''
@srfi{}.


@c page
@node strings ratio i18n
@subsection Internationalisation and super-@ascii{} character types


The major issue confronting this @srfi{} is the existence of
super--@ascii{} character encodings, such as eight--bit Latin--1 or
16--bit and 32--bit Unicode.  It is a design goal of this @srfi{} for
the @api{} to be portable across string implementations based on at
least these three standard encodings.  Unfortunately, this places strong
limitations on the @api{} design.  Here are some relevant issues.  Be
warned that life in a super--@ascii{} world is significantly more
complex; there are no easy answers for many of these issues.

@c ------------------------------------------------------------

@subsubheading Case mapping and case--folding


@noindent
Upper--casing and lower--casing characters is complex in super--@ascii{}
encodings.

@itemize
@item
Some characters case--map to more than one character.  For example, the
Latin--1 German @code{eszet} character upper--cases to @code{SS}.

@itemize --
@item
This means that the @rnrs{5} function @func{char-upcase} is not
well--defined, since it is defined to produce a (single) character
result.

@item
It means that an in--place @func{string-upcase!} procedure cannot be
reliably defined, since the original string may not be long enough to
contain the result; an @var{N}--character string might upcase to a
@var{2N}--character result.

@item
It means that case--insensitive string--matching or searching is quite
tricky.  For example, an @var{n}--character string @var{s} might match a
@var{2N}--character string @var{s'}.
@end itemize

@item
Some characters case--map in different ways depending upon their
surrounding context.  For example, the Unicode Greek capital sigma
character downcases differently depending upon whether or not it is the
final character in a word.  Again, this spells trouble for the simple
@rnrs{5} char--downcase function.

@item
Unicode defines three cases: lowercase, uppercase and titlecase.  The
distinction between uppercase and titlecase arises in the presence of
Unicode's compound characters.  For example, Unicode has a single
character representing the compound pair @code{dz}.  Uppercasing the
@code{dz} character produces the compound character @code{DZ}, while
titlecasing (or, as Americans say, capitalizing) it produces compound
character @code{Dz}.

@item
Turkish actually has different case--mappings from other languages.
@end itemize

The Unicode Consortium's web site:

@center @url{http://www.unicode.org/}

@noindent
has detailed discussions of the issues.  See in particular technical
report 21 on case mappings:

@center @url{http://www.unicode.org/unicode/reports/tr21/}

@ansrfi{13} makes no attempt to deal with these issues; it uses a simple
one--to--ont locale--independent and context--independent case--mapping,
specifically Unicode's one--to--one case--mappings given in:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}

The format of this file is explained in:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html}

Note that this means that German @code{eszet} upper--cases to itself,
not @code{SS}.

Case--mapping and case--folding operations in @ansrfi{13} are
locale--independent so that shifting locales won't wreck hash tables,
b--trees, symbol tables, etc.

@c ------------------------------------------------------------

@subsubheading String equality and string normalisation


@noindent
Comparing strings for equality is complicated because in some cases
Unicode actually provides multiple encodings for the ``same'' character,
and because what we usually think of as a ``character'' can be
represented in Unicode as a sequence of several code--points.  For
example, consider the letter @code{e} with an acute accent.  There is a
single Unicode character for this.  However, Unicode also allows one to
represent this with a two--character sequence: the @code{e} character
followed by a zero--width acute--accent character.  As another example,
Unicode provides some Asian characters in ``narrow'' and ``full''
widths.

There are multiple ways we might want to compare strings for equality.
In (roughly) decreasing order of precision:

@itemize
@item
we might want a precise comparison of the actual encoding, so that
@code{<e-acute>} would not compare equal to @code{<e, acute>};

@item
we might want a ``normalised'' comparison, where these two sequences
would compare equal;

@item
we might want an even more--permissive normalisation, where
visually--distinct properties of ``the same'' character would be
ignored; for example, we might want narrow/full--width versions of the
same Asian character to compare equal;a

@item
we might want comparisons that are insensitive to accents and
diacritical marks;

@item
we might want comparisons that are case--insensitive;

@item
we might want comparisons that are insensitive to several of the above
properties;

@item
we might want ways to ``normalise'' strings into various canonical
forms.
@end itemize

This library does not address these complexities.  @ansrfi{13} string
equality is simply based upon comparing the encoding values used for the
characters.  Accent--insensitive and other types of comparison are not
provided; only a simple form of case--insensitive comparison is
provided, which uses the one--to--one case mappings specified by Unicode
in:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}

These are adequate for ``program'' or ``systems'' use of strings (e.g.
to manipulate program identifiers and operating--system filenames).

@c ------------------------------------------------------------

@subsubheading String inequality


@noindent
Above and beyond the issues arising in string--equality, when we attempt
to order strings there are even further considerations.

@itemize
@item
French orders accents with right--to--left significance; the reverse of
the significance of the characters.

@item
Case--insensitive ordering is not well defined by simple code--point
considerations, even for simple @ascii{}: there are punctuation
characters between the @ascii{}'s upper--case range of letters and its
lower--case range (left--bracket, backslash, right--bracket, caret,
underbar and backquote).  Does left--bracket compare less--than or
greater--than @code{a} in a case--insensitive comparison?

@item
The German @code{eszet} character should sort as if it were the pair of
letters @code{ss}.
@end itemize

Unicode defines a complex set of machinery for ordering or ``collating''
strings, which involves mapping each string to a multi--byte sort key,
and then doing simple lexicographic sorting with these keys.  These
rules can be overlaid by additional domain--specific or
language--specific rules.  Again, this @srfi{} does not address these
issues.  @ansrfi{13} string ordering is strictly based upon a
character--by--character comparison of the values used for representing
the string.

@c ------------------------------------------------------------

@subsubheading Naming conventions


@noindent
This library contains a large number of procedures, but they follow a
consistent naming scheme, and are consistent with the conventions
developed in @ansrfi{1}.  The names are composed of smaller lexemes in a
regular way that exposes the structure and relationships between the
procedures.  This should help the programmer to recall or reconstitute
the name of the particular procedure that he needs when writing his own
code.  In particular:

@itemize
@item
Procedures whose names end in @code{-ci} are case--insensitive variants.

@item
Procedures whose names end in @code{!} are side--effecting variants.
What values these procedures return is usually not specified.

@item
The order of common parameters is consistent across the different
procedures.

@item
Left/right/both directionality: Procedures that have left/right
directional variants use the following convention:

@multitable {right--to--left} {Suffix}
@headitem Direction @tab Suffix
@item left-to-right @tab none
@item right-to-left @tab --right
@item both @tab --both
@end multitable

This is a general convention that was established in @ansrfi{1}.  The
value of a convention is proportional to the extent of its use.
@end itemize

@c ------------------------------------------------------------

@subsubheading Shared storage


@noindent
Some Scheme implementations, e.g. Guile and T, provide ways to construct
substrings that share storage with other strings.  This facility is
called ``shared--text substrings''.  Shared--text substrings can be used
to eliminate the allocation and copying time and space required to
produce substrings, which can be a tremendous savings for some
applications, reducing a linear--time operation to constant time.
Additionally, some algorithms rely on the sharing property of these
substrings: the application assumes that if the underlying storage is
mutated, then all strings sharing that storage will show the change.
However, shared--text substrings are not a common feature; most Scheme
implementations do not provide them.

@ansrfi{13} takes a middle ground with respect to shared--text substrings.
In particular, a Scheme implementation does not need to have
shared--text substrings in order to implement this @srfi{}.

There is an additional form of storage sharing enabled by some @ansrfi{13}
procedures, even without the benefit of shared--text substrings.  In
some cases, some @ansrfi{13} routines are allowed to return as a result
one of the strings that was passed in as a parameter.  For example, when
constructing a substring with the @func{substring/shared} procedure, if
the requested substring is the entire string, the procedure is permitted
simply to return the original value.  That is:

@example
(eq? s (substring/shared s 0 (string-length s))) => true or false
@end example

@noindent
whereas the @rnrs{5} @func{substring} function is required to allocate a
fresh copy:

@example
(eq? s (substring s 0 (string-length s))) => false.
@end example

In keeping with @ansrfi{13}'s general approach to sharing, compliant
implementations are allowed, but not required, to provide this kind of
sharing.  Hence, procedures may not rely upon sharing in these cases.

Most procedures that permit results to share storage with inputs have
equivalent procedures that require allocating fresh storage for results.
If an application wishes to be sure a new, fresh string is allocated,
then these ``pure'' procedures should be used.

@multitable {string-concatenate-reverse} {string-concatenate-reverse/shared}
@headitem Fresh copy guaranteed @tab Sharing permitted
@item @func{string-copy} @tab @func{substring/shared}
@item @func{string-copy} @tab @func{string-take} @func{string-take-right}
@item @func{string-copy} @tab @func{string-drop} @func{string-drop-right}
@item @func{string-concatenate} @tab @func{string-concatenate/shared}
@item @func{string-append} @tab @func{string-append/shared}
@item @func{string-concatenate-reverse} @tab @func{string-concatenate-reverse/shared}
@item @tab @func{string-pad string-pad-right}
@item @tab @func{string-trim string-trim-right}
@item @tab @func{string-trim-both}
@item @tab @func{string-filter string-delete}
@end multitable

On the other hand, the functionality is present to allow one to write
efficient code without shared--text substrings.  You can write efficient
code that works by passing around start/end ranges indexing into a
string instead of simply building a shared--text substring.  The @api{}
would be much simpler without this consideration; if we had cheap
shared--text substrings, all the start/end index parameters would
vanish.  However, since @ansrfi{13} does not require implementations to
provide shared--text substrings, the extended @api{} is provided.

@c ------------------------------------------------------------

@subsubheading @rnrs{4}/@rnrs{5} procedures


@noindent
The @rnrs{4} and @rnrs{5} reports define 22 string procedures.  The
@ansrfi{13} package includes 8 of these exactly as defined, 3 in an
extended, backwards--compatible way, and drops the remaining 11 (whose
functionality is available via other bindings).

The 8 procedures provided exactly as documented in the reports are:

@example
string?         make-string     string
string-length   string-ref      string-set!
string-append   list->string
@end example

The 11 functions not included are:

@example
string=?        string-ci=?     string<?
string-ci<?     string>?        string-ci>?
string<=?       string-ci<=?    string>=?
string-ci>=?    substring
@end example

The @ansrfi{13} package provides alternate bindings and extended
functionality.

Additionally, the three extended procedures are:

@example
string-fill! s char [start end] -> unspecified
string->list s [start end] -> char-list
string-copy  s [start end] -> string
@end example

They are uniformly extended to take optional start/end parameters
specifying substring ranges.

@c ------------------------------------------------------------

@subsubheading Extra--@srfi{} recommendations


@noindent
This @srfi{} recommends the following:

@itemize
@item
A @srfi{} be defined for shared--text substrings, allowing programs to
be written that actually rely on the shared--storage properties of these
data structures.

@item
A @srfi{} be defined for manipulating Unicode text: various
normalisation operations, collation, searching, etc.  Collation
operations might be parameterised by a ``collation'' structure
representing collation rules for a particular locale or language.

Alternatively, a data structure specifying collation rules could be
activated with dynamic scope by special procedures, possibly overridden
by allowing collation rules to be optional arguments to procedures that
need to order strings, e.g.

@example
(with-locale* denmark-locale
  (lambda ()
    (f x)
    (g 42)))

(with-locale taiwan-locale
  (f x)
  (h denmark-locale)
  (g 42))

(set-locale! denmark-locale)
@end example

@item
A @srfi{} be defined for manipulating characters that is portable
across at least @ascii{}, Latin--1 and Unicode.

@itemize
@item
For backwards--compatibility, @func{char-upcase} and
@func{char-downcase} should be defined to use the one--to--one
locale--insensitive and context--insensitive case mappings given by
Unicode's @file{UnicodeData.txt} table.

@item
Numeric codes for standard functions that map between characters and
integers should be required to use the Unicode/Latin--1/@ascii{}
mapping.  This allows programmers to write portable code.

@item
@func{char-titlecase} be added to @func{char-upcase} and
@func{char-downcase}.

@item
@func{char-titlecase?} be added to @func{char-upcase?} and
@func{char-downcase?}.

@item
Title/up/down--case functions be added to the character--processing
suite which allow 1->n case maps by returning immutable,
possibly--multi--character strings instead of single characters.  These
case mappings need not be locale--sensitive or context--sensitive.
@end itemize
@end itemize

These recommendations are not a part of the @ansrfi{13} spec.  Note also
that requiring a Unicode/Latin-1/@ascii{} interface to integer/char
mapping functions does not imply anything about the actual underlying
encodings of characters.


@c page
@node strings spec
@section Specification


@menu
High level procedures

* strings spec intro::          Introduction.
* strings spec pred::           Predicates.
* strings spec cons::           Constructors.
* strings spec list::           List and string conversion.
* strings spec select::         Selection.
* strings spec modify::         Modification.
* strings spec compar::         Comparison.
* strings spec prefix::         Prefixes and suffixes.
* strings spec search::         Searching.
* strings spec case-map::       Alphabetic case mapping.
* strings spec append::         Reverse and append.
* strings spec fold::           Fold, unfold and map.
* strings spec replicate::      Replicate and rotate.
* strings spec misc::           Miscellaneous: intertion, parsing.
* strings spec filter::         Filtering and deleting.

Low level procedures

* strings spec parsing::        Start/end optional-argument parsing
                                and checking utilities.
* strings spec knuth::          Knuth-Morris-Pratt searching.
@end menu


@c page
@node strings spec intro
@subsection Introduction


In the following procedure specifications:

@itemize
@item
An @var{s} parameter is a string.

@item
A @var{char} parameter is a character.

@item
@var{start} and @var{end} parameters are half--open string indices
specifying a substring within a string parameter; when optional, they
default to @code{0} and the length of the string, respectively.  When
specified, it must be the case that:

@example
0 <= start <= end <= (string-length s)
@end example

@noindent
for the corresponding parameter @var{s}.  They typically restrict a
procedure's action to the indicated substring.

@item
A @var{pred} parameter is a unary character predicate procedure,
returning a true/false value when applied to a character.

@item
A @var{char}/@var{char-set}/@var{pred} parameter is a value used to
select/search for a character in a string.  If it is a character, it is
used in an equality test; if it is a character set, it is used as a
membership test; if it is a procedure, it is applied to the characters
as a test predicate.

@item
An @var{i} parameter is an exact non--negative integer specifying an
index into a string.

@item
@var{len} and @var{nchars} parameters are exact non--negative integers
specifying a length of a string or some number of characters.

@item
An @var{obj} parameter may be any value at all.
@end itemize

Passing values to procedures with these parameters that do not satisfy
these types is an error.

Parameters given in square brackets are optional.  Unless otherwise
noted in the text describing the procedure, any prefix of these optional
parameters may be supplied, from zero arguments to the full list.  When
a procedure returns multiple values, this is shown by listing the return
values in square brackets, as well.  So, for example, the procedure with
signature:

@example
halts? f [x init-store]
@end example

@noindent
would take one (@var{f}), two (@var{f}, @var{x}) or three (@var{f},
@var{x}, @var{init-store}) input parameters.

A parameter followed by @code{...} means zero--or--more elements.  So
the procedure with the signature:

@example
sum-squares x ...
@end example

@noindent
takes zero or more arguments (@var{x} ...), while the procedure with
signature:

@example
spell-check doc dict1 dict2 ...
@end example

@noindent
takes two required parameters (@var{doc} and @var{dict1}) and zero or
more optional parameters (@var{dict2} ...).

If a procedure is said to return ``unspecified'', this means that
nothing at all is said about what the procedure returns.  Such a
procedure is not even required to be consistent from call to call.  It
is simply required to return a value (or values) that may be passed to a
command continuation, e.g. as the value of an expression appearing as a
non--terminal subform of a begin expression.  Note that in @rnrs{5},
this restricts such a procedure to returning a single value;
non--@rnrs{5} systems may not even provide this restriction.


Unless explicitly stated, for all the functions: Case--insensitive
comparison is done by case--folding characters with the operation

@example
(char-downcase (char-upcase c))
@end example

@noindent
where the two case--mapping operations are assumed to be one--to--one,
locale--insensitive and context--insensitive, and compatible with the
one--to--one case mappings specified by Unicode's @file{UnicodeData.txt}
table:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}

Comparison is simply done on individual code--points of the string.


@c page
@node strings spec pred
@subsection Predicates


@defun string? @var{obj}
@rnrs{5} Return @true{} if @var{obj} is a string, otherwise return
@false{}.
@end defun


@defun string-null? @var{s}
Return @true{} if @var{obj} is the empty string, otherwise return
@false{}.
@end defun


@defun string-every @var{char/char-set/pred} @var{s} [@var{start} @var{end}]
@defunx string-any @var{char/char-set/pred} @var{s} [@var{start} @var{end}]
Check to see if the given criteria is true of every/any character in
@var{s}, proceeding from left (index @var{start}) to right (index
@var{end}).

If @var{char/char-set/pred} is a character, it is tested for equality
with the elements of @var{s}.

If @var{char/char-set/pred} is a character set, the elements of @var{s}
are tested for membership in the set.

If @var{char/char-set/pred} is a predicate procedure, it is applied to
the elements of @var{s}.  The predicate is ``witness--generating'':

@itemize
@item
If @func{string-any} returns true, the returned true value is the one
produced by the application of the predicate.

@item
If @func{string-every} returns true, the returned true value is the one
produced by the final application of the predicate to @code{s[end]}.  If
@func{string-every} is applied to an empty sequence of characters, it
simply returns @true{}.
@end itemize

If @func{string-every} or @func{string-any} apply the predicate to the
final element of the selected sequence (i.e. @code{s[end-1]}), that
final application is a tail call.

The names of these procedures do not end with a question mark; this is
to indicate that, in the predicate case, they do not return a simple
boolean (@true{} or @false{}), but a general value.
@end defun



@c page
@node strings spec cons
@subsection Constructors


@defun make-string @var{len} [@var{char}]
@rnrs{5} Return a newly allocated string of length @var{len}.  If
@var{char} is given, then all elements of the string are initialized to
@var{char}, otherwise the contents of the string are unspecified.
@end defun


@defun string @var{char1} ...
@rnrs{5} Return a newly allocated string composed of the argument
characters.
@end defun


@defun string-tabulate @var{proc} @var{len}
@var{proc} is an @func{integer->char} procedure.  Construct a string of
size @var{len} by applying @var{proc} to each index to produce the
corresponding string element. The order in which @var{proc} is applied
to the indices is not specified.
@end defun



@c page
@node strings spec list
@subsection List and string conversion


@defun string->list @var{s} [@var{start} @var{end}]
@defunx list->string @var{char-list}
@rnrs{5}+ @func{string->list} returns a newly allocated list of the
characters that make up the given string.  @func{list->string} returns a
newly allocated string formed from the characters in the list
@var{char-list}, which must be a list of characters.
@func{string->list} and @func{list->string} are inverses so far as
@func{equal?} is concerned.

@func{string->list} is extended from the @rnrs{5} definition to take
optional @var{start}/@var{end} arguments.
@end defun


@defun reverse-list->string @var{char-list}
An efficient implementation of @code{(compose list->string reverse)}:

@example
(reverse-list->string '(#\a #\B #\c))
=> "cBa"
@end example

This is a common idiom in the epilog of string--processing loops that
accumulate an answer in a reverse--order list.  See also
@func{string-concatenate-reverse} for the ``chunked'' variant.
@end defun


@defun string-join @var{string-list} [@var{delimiter} @var{grammar}]
This procedure is a simple unparser: it pastes strings together using
the @var{delimiter} string.

The @var{grammar} argument is a symbol that determines how the delimiter
is used, and defaults to @code{infix}.  Supported values for
@var{grammar} are:

@table @code
@item infix
Means an infix or separator grammar: insert the delimiter between list
elements.  An empty list will produce an empty string; note, however,
that parsing an empty string with an infix or separator grammar is
ambiguous: Is it an empty list, or a list of one element, the empty
string?

@item strict-infix
Means the same as @code{infix}, but will raise an error if given an
empty list.

@item suffix
Means a suffix or terminator grammar: insert the delimiter after every
list element.  This grammar has no ambiguities.

@item prefix
Means a prefix grammar: insert the delimiter before every list element.
This grammar has no ambiguities.
@end table

The delimiter is the string used to delimit elements; it defaults to a
single space.

Examples:

@example
(string-join '("foo" "bar" "baz") ":")
=> "foo:bar:baz"

(string-join '("foo" "bar" "baz") ":" 'suffix)
=> "foo:bar:baz:"

;; Infix grammar is ambiguous wrt empty list vs. empty string,
(string-join '()   ":") => ""
(string-join '("") ":") => ""

;; but suffix & prefix grammars are not.
(string-join '()   ":" 'suffix) => ""
(string-join '("") ":" 'suffix) => ":"
@end example
@end defun



@c page
@node strings spec select
@subsection Selection


@defun string-length @var{s}
@rnrs{5} Return the number of characters in the string @var{s}.
@end defun


@defun string-ref @var{s} @var{i}
@rnrs{5} Return character @code{s[i]} using zero--origin indexing.
@var{i} must be a valid index of @var{s}.
@end defun


@defun string-copy @var{s} [@var{start} @var{end}]
@defunx substring/shared @var{s} @var{start} [@var{end}]
@rnrs{5}+ @func{substring/shared} returns a string whose contents are
the characters of @var{s} beginning with index @var{start} (inclusive)
and ending with index @var{end} (exclusive).  It differs from the
@rnrs{5} @func{substring} in two ways:

@itemize
@item
The @var{end} parameter is optional, not required.

@item
@func{substring/shared} may return a value that shares memory with
@var{s} or is @func{eq?} to @var{s}.
@end itemize

@func{string-copy} is extended from its @rnrs{5} definition by the
addition of its optional @var{start}/@var{end} parameters.  In contrast
to @func{substring/shared}, it is guaranteed to produce a
freshly--allocated string.

Use @func{string-copy} when you want to indicate explicitly in your code
that you wish to allocate new storage; use @func{substring/shared} when
you don't care if you get a fresh copy or share storage with the
original string.

Examples:

@example
(string-copy "Beta substitution")
=> "Beta substitution"

(string-copy "Beta substitution" 1 10)
=> "eta subst"

(string-copy "Beta substitution" 5)
=> "substitution"
@end example
@end defun


@defun string-copy! @var{target} @var{tstart} @var{s} [@var{start} @var{end}]
Copy the sequence of characters from index range @code{[start,end)} in
the string @var{s} to the string @var{target}, beginning at index
@var{tstart}.  The characters are copied left--to--right or
right--to--left as needed; the copy is guaranteed to work, even if
@var{target} and @var{s} are the same string.

It is an error if the copy operation runs off the end of the target
string, e.g.

@example
(string-copy! (string-copy "Microsoft") 0
              "Regional Microsoft Operating Companies")
=> error
@end example
@end defun


@defun string-take @var{s} @var{nchars}
@defunx string-drop @var{s} @var{nchars}
@defunx string-take-right @var{s} @var{nchars}
@defunx string-drop-right @var{s} @var{nchars}
@func{string-take} returns the first @var{nchars} of @var{s}.

@func{string-drop} returns all but the first @var{nchars} of @var{s}.

@func{string-take-right} returns the last @var{nchars} of @var{s}.

@func{string-drop-right} returns all but the last @var{nchars} of
@var{s}.

If these procedures produce the entire string, they may return either
@var{s} or a copy of @var{s}; in some implementations, proper substrings
may share memory with @var{s}.

Examples:

@example
(string-take "Pete Szilagyi" 6) => "Pete S"
(string-drop "Pete Szilagyi" 6) => "zilagyi"

(string-take-right "Beta rules" 5) => "rules"
(string-drop-right "Beta rules" 5) => "Beta "
@end example

It is an error to take or drop more characters than are in the string:

@example
(string-take "foo" 37) => error
@end example
@end defun


@defun string-pad @var{s} @var{len} [@var{char} @var{start} @var{end}]
@defunx string-pad-right @var{s} @var{len} [@var{char} @var{start} @var{end}]
Build a string of length @var{len} comprised of @var{s} padded on the
left (right) by as many occurrences of the character @var{char} as
needed.  If @var{s} has more than len chars, it is truncated on the left
(right) to length @var{len}.  @var{char} defaults to @code{#\space}.

If @code{len <= (end - start)}, the returned value is allowed to share
storage with @var{s}, or be exactly @var{s} (if @code{len = (end -
start)}).

Examples:

@example
(string-pad     "325" 5) => "  325"
(string-pad   "71325" 5) => "71325"
(string-pad "8871325" 5) => "71325"
@end example
@end defun


@defun string-trim @var{s} [@var{char/char-set/pred} @var{start} @var{end}]
@defunx string-trim-right @var{s} [@var{char/char-set/pred} @var{start} @var{end}]
@defunx string-trim-both @var{s} [@var{char/char-set/pred} @var{start} @var{end}]
Trim @var{s} by skipping over all characters on the left/on the right/on
both sides that satisfy the second parameter @var{char/char-set/pred}:

@itemize
@item
if it is a character @var{char}, characters equal to @var{char} are
trimmed;

@item
if it is a char set @var{char-set}, characters contained in
@var{char-set} are trimmed;

@item
if it is a predicate @var{pred}, it is a test predicate that is applied
to the characters in @var{s}; a character causing it to return true is
skipped.
@end itemize

@var{char/char-set/pred} defaults to the character set
@code{char-set:whitespace} defined in @ansrfi{14}.

If no trimming occurs, these functions may return either @var{s} or a
copy of @var{s}; in some implementations, proper substrings may share
memory with @var{s}.

Example:

@example
(string-trim-both "  The outlook wasn't brilliant,  \n\r")
=> "The outlook wasn't brilliant,"
@end example
@end defun



@c page
@node strings spec modify
@subsection Modification


@defun string-set! @var{s} @var{i} @var{char}
@rnrs{5} @var{i} must be a valid index of @var{s}.  @func{string-set!}
stores @var{char} in element @var{i} of @var{s}.  Constant string
literals appearing in code are immutable; it is an error to use them in
a @func{string-set!}.

Example:

@example
(define (f) (make-string 3 #\*))
(define (g) "***")
(string-set! (f) 0 #\?)                ==>  unspecified
(string-set! (g) 0 #\?)                ==>  error
(string-set! (symbol->string 'immutable)
             3
             #\?)                      ==>  error
@end example
@end defun


@defun string-fill! @var{s} @var{char} [@var{start} @var{end}]
@rnrs{5} Store @var{char} in every element of @var{s}.

@func{string-fill} is extended from the @rnrs{5} definition to take
optional @var{start}/@var{end} arguments.
@end defun



@c page
@node strings spec compar
@subsection Comparison


@defun string-compare @var{s1} @var{s2} @var{proc<} @var{proc=} @var{proc>} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-compare-ci @var{s1} @var{s2} @var{proc<} @var{proc=} @var{proc>} [@var{start1} @var{end1} @var{start2} @var{end2}]
Apply @var{proc<}, @var{proc=}, or @var{proc>} to the mismatch index,
depending upon whether @var{s1} is less than, equal to, or greater than
@var{s2}.  The ``mismatch index'' is the largest index @var{i} such that
for every @code{0 <= j < i}, @code{s1[j] = s2[j]}; that is, @var{i} is
the first position that doesn't match.

@func{string-compare-ci} is the case--insensitive variant.

The optional @var{start}/@var{end} indices restrict the comparison to
the indicated substrings of @var{s1} and @var{s2}.  The mismatch index
is always an index into @var{s1}; in the case of @var{proc=}, it is
always @var{end1}; we observe the protocol in this redundant case for
uniformity.

@example
(string-compare "The cat in the hat" "abcdefgh"
                values values values
                4 6         ; Select "ca"
                2 4)        ; & "cd"
=> 5    ; Index of S1's "a"
@end example

True text collation is not handled by this @srfi{}.
@end defun


@defun string= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string<> @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string< @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string> @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string<= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string>= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, @func{string<} is
the lexicographic ordering on strings induced by the ordering
@func{char<?} on characters.  If two strings differ in length but are
the same up to the length of the shorter string, the shorter string is
considered to be lexicographically less than the longer string.

The optional @var{start}/@var{end} indices restrict the comparison to
the indicated substrings of @var{s1} and @var{s2}.

True text collation is not handled by this @srfi{}.
@end defun


@defun string-ci= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-ci<> @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-ci< @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-ci> @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-ci<= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-ci>= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
Case--insensitive variants.
@end defun


@defun string-hash @var{s} [@var{bound} @var{start} @var{end}]
@defunx string-hash-ci @var{s} [@var{bound} @var{start} @var{end}]
Compute a hash value for the string @var{s}.  @var{bound} is a
non--negative exact integer specifying the range of the hash function.
A positive value restricts the return value to the range @code{[0,
bound)}.

If @var{bound} is either zero or not given, the implementation may use
an implementation--specific default value, chosen to be as large as is
efficiently practical.  For instance, the default range might be chosen
for a given implementation to map all strings into the range of integers
that can be represented with a single machine word.

The optional @var{start}/@var{end} indices restrict the hash operation
to the indicated substring of @var{s}.

@func{string-hash-ci} is the case--insensitive variant.

Invariants:

@example
(<= 0 (string-hash s b) (- b 1)) ; When B > 0.
(string=    s1 s2)  =>  (= (string-hash s1 b)    (string-hash s2 b))
(string-ci= s1 s2)  =>  (= (string-hash-ci s1 b) (string-hash-ci s2 b))
@end example

A legal but nonetheless discouraged implementation:

@example
(define (string-hash    s . other-args) 1)
(define (string-hash-ci s . other-args) 1)
@end example

Rationale: allowing the user to specify an explicit bound simplifies
user code by removing the mod operation that typically accompanies every
hash computation, and also may allow the implementation of the hash
function to exploit a reduced range to efficiently compute the hash
value.  E.g., for small bounds, the hash function may be computed in a
fashion such that intermediate values never overflow into bignum
integers, allowing the implementor to provide a fixnum--specific ``fast
path'' for computing the common cases very rapidly.
@end defun



@c page
@node strings spec prefix
@subsection Prefixes and suffixes


@defun string-prefix-length @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-suffix-length @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-prefix-length-ci @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-suffix-length-ci @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
Return the length of the longest common prefix/suffix of the two
strings.  For prefixes, this is equivalent to the ``mismatch index'' for
the strings (modulo the @var{starti} index offsets).

The optional @var{start}/@var{end} indices restrict the comparison to
the indicated substrings of @var{s1} and @var{s2}.

@func{string-prefix-length-ci} and @func{string-suffix-length-ci} are
the case--insensitive variants.
@end defun


@defun string-prefix? @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-suffix? @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-prefix-ci? @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-suffix-ci? @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
Return @true{} if @var{s1} is a prefix/suffix of @var{s2}; otherwise
return @false{}.  The optional @var{start}/@var{end} indices restrict
the comparison to the indicated substrings of @var{s1} and @var{s2}.

@func{string-prefix-ci?} and @func{string-suffix-ci?} are the
case--insensitive variants.
@end defun



@c page
@node strings spec search
@subsection Searching


@defun string-index @var{s} @var{char/char-set/pred} [@var{start} @var{end}]
@defunx string-index-right @var{s} @var{char/char-set/pred} [@var{start} @var{end}]
@defunx string-skip @var{s} @var{char/char-set/pred} [@var{start} @var{end}]
@defunx string-skip-right @var{s} @var{char/char-set/pred} [@var{start} @var{end}]
@func{string-index} (@func{string-index-right}) searches through the
string from the left (right), returning the index of the first
occurrence of a character which

@itemize
@item
equals @var{char/char-set/pred} if it is a character;

@item
is in @var{char/char-set/pred} if it is a character set;

@item
satisfies the predicate @var{char/char-set/pred} if it is a procedure.
@end itemize

If no match is found, the functions return @false{}.

The @var{start} and @var{end} parameters specify the beginning and end
indices of the search; the search includes the @var{start} index, but
not the @var{end} index.  Be careful of ``fencepost'' considerations:
when searching right--to--left, the first index considered is
@var{end-1}, whereas when searching left--to--right, the first index
considered is @var{start}

That is, the @var{start}/@var{end} indices describe a same half--open
interval @code{[start,end)} in these procedures that they do in all the
other @ansrfi{13} procedures.

The skip functions are similar, but use the complement of the criteria:
they search for the first char that does @strong{nor} satisfy the test.
E.g., to skip over initial whitespace, say:

@example
(cond [(string-skip s char-set:whitespace) =>
       (lambda (i) ...)] ; s[i] is not whitespace.
      ...)
@end example
@end defun


@defun string-count @var{s} @var{char/char-set/pred} [@var{start} @var{end}]
Return a count of the number of characters in @var{s} that satisfy the
@var{char/char-set/pred} argument.  If this argument is a procedure, it
is applied to the character as a predicate; if it is a character set,
the character is tested for membership; if it is a character, it is used
in an equality test.
@end defun


@defun string-contains @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-contains-ci @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
Return true if the string @var{s1} contains string @var{s2}; otherwise
return @false{}.  Return the index in @var{s1} where @var{s2} occurs as
a substring.  The optional @var{start}/@var{end} indices restrict the
operation to the indicated substrings.

The returned index is in the range @code{[start1,end1)}.  A successful
match must lie entirely in the @code{[start1,end1)} range of @var{s1}.

Example:

@example
;; Searches "a geek"
(string-contains "eek -- what a geek." "ee" 12 18)
=> 15
@end example

@func{string-contains-ci} is the case--insensitive variant.
@end defun



@c page
@node strings spec case-map
@subsection Alphabetic case mapping


@defun string-titlecase @var{s} [@var{start} @var{end}]
@defunx string-titlecase! @var{s} [@var{start} @var{end}]
For every character @var{c} in the selected range of @var{s}, if @var{c}
is preceded by a cased character, it is downcased; otherwise it is
titlecased.

@func{string-titlecase} returns the result string and does not alter its
s parameter.  @func{string-titlecase!} is the in--place side--effecting
variant.

Examples:

@example
(string-titlecase "--capitalize tHIS sentence.")
=> "--Capitalize This Sentence."

(string-titlecase "see Spot run. see Nix run.")
=> "See Spot Run. See Nix Run."

(string-titlecase "3com makes routers.")
=> "3Com Makes Routers."
@end example

Note that if a @var{start} index is specified, then the character
preceding @code{s[start]} has no effect on the titlecase decision for
character @code{s[start]}:

@example
(string-titlecase "greasy fried chicken" 2)
=> "Easy Fried Chicken"
@end example

Titlecase and cased information must be compatible with the Unicode
specification.
@end defun


@defun string-upcase @var{s} [@var{start} @var{end}]
@defunx string-upcase! @var{s} [@var{start} @var{end}]
@defunx string-downcase @var{s} [@var{start} @var{end}]
@defunx string-downcase! @var{s} [@var{start} @var{end}]
Raise or lower the case of the alphabetic characters in the string.

@func{string-upcase} and @func{string-downcase} return the result string
and do not alter their s parameter.  @func{string-upcase!} and
@func{string-downcase!} are the in--place side--effecting variants.
@end defun



@c page
@node strings spec append
@subsection Reverse and append


@defun string-reverse @var{s} [@var{start} @var{end}]
@defunx string-reverse! @var{s} [@var{start} @var{end}]
Reverse the string.  @func{string-reverse} returns the result string and
does not alter its s parameter.  @func{string-reverse!} is the in--place
side--effecting variant.

Examples:

@example
(string-reverse "Able was I ere I saw elba.")
=> ".able was I ere I saw elbA"

;;; In-place rotate-left, the Bell Labs way:
(lambda (s i)
  (let ([i (modulo i (string-length s))])
    (string-reverse! s 0 i)
    (string-reverse! s i)
    (string-reverse! s)))
@end example

Unicode note: Reversing a string simply reverses the sequence of
code--points it contains.  So a zero--width accent character a coming
after a base character @var{b} in string @var{s} would come out before
@var{b} in the reversed result.
@end defun


@defun string-append @var{s1} ...
@rnrs{5} Return a newly allocated string whose characters form the
concatenation of the given strings.
@end defun


@defun string-concatenate @var{string-list}
Append the elements of @var{string-list} together into a single string.
Guaranteed to return a freshly allocated string.

Note that the @code{(apply string-append string-list)} idiom is not
robust for long lists of strings, as some Scheme implementations limit
the number of arguments that may be passed to an n--ary procedure.
@end defun


@defun string-concatenate/shared @var{string-list}
@defunx string-append/shared @var{s1} ...
These two procedures are variants of @func{string-concatenate} and
@func{string-append} that are permitted to return results that share
storage with their parameters.  In particular, if
@func{string-append/shared} is applied to just one argument, it may
return exactly that argument, whereas @func{string-append} is required
to allocate a fresh string.
@end defun


@defun string-concatenate-reverse @var{string-list} [@var{final-string} @var{end}]
@defunx string-concatenate-reverse/shared @var{string-list} [@var{final-string} @var{end}]
With no optional arguments, these functions are equivalent to:

@example
(string-concatenate (reverse string-list))
@end example

@noindent
and:

@example
(string-concatenate/shared (reverse string-list))
@end example

@noindent
respectively.

If the optional argument @func{final-string} is specified, it is consed
onto the beginning of @var{string-list} before performing the
@func{list-reverse} and @func{string-concatenate} operations.

If the optional argument @var{end} is given, only the first end
characters of @var{final-string} are added to the string list, thus
producing:

@example
(string-concatenate
  (reverse (cons (substring/shared final-string 0 end)
                 string-list)))
@end example

Example:

@example
(string-concatenate-reverse '(" must be" "Hello, I") " going.XXXX" 7)
=> "Hello, I must be going."
@end example

This procedure is useful in the construction of procedures that
accumulate character data into lists of string buffers, and wish to
convert the accumulated data into a single string when done.

Unicode note: Reversing a string simply reverses the sequence of
code--points it contains.  So a zero--width accent character @var{ac}
coming after a base character @var{bc} in string @var{s} would come out
before @var{bc} in the reversed result.
@end defun



@c page
@node strings spec fold
@subsection Fold, unfold and map


@defun string-map @var{proc} @var{s} [@var{start} @var{end}]
@defunx string-map! @var{proc} @var{s} [@var{start} @var{end}]
@var{proc} is a @code{char->char} procedure; it is mapped over @var{s}.
@func{string-map} returns the result string and does not alter its
@var{s} parameter.  @func{string-map!} is the in--place side--effecting
variant.

Note: The order in which @var{proc} is applied to the elements of
@var{s} is not specified.
@end defun


@defun string-fold @var{kons} @var{knil} @var{s} [@var{start} @var{end}]
@defunx string-fold-right @var{kons} @var{knil} @var{s} [@var{start} @var{end}]
These are the fundamental iterators for strings.

The left--fold operator maps the @var{kons} procedure across the string
from left to right:

@example
(... (kons s[2] (kons s[1] (kons s[0] knil))))
@end example

@noindent
in other words, @func{string-fold} obeys the (tail) recursion:

@example
(string-fold kons knil s start end) =
   (string-fold kons (kons s[start] knil) start+1 end)
@end example

The right--fold operator maps the @var{kons} procedure across the string
from right to left:

@example
(kons s[0] (... (kons s[end-3] (kons s[end-2] (kons s[end-1] knil)))))
@end example

@noindent
obeying the (tail) recursion:

@example
(string-fold-right kons knil s start end) =
   (string-fold-right kons (kons s[end-1] knil) start end-1)
@end example

Examples:

@example
;;; Convert a string to a list of chars.
(string-fold-right cons '() s)

;;; Count the number of lower-case characters in a string.
(string-fold (lambda (c count)
               (if (char-lower-case? c)
                   (+ count 1)
                 count))
              0
              s)

;;; Double every backslash character in S.
(let* ([ans-len (string-fold (lambda (c sum)
                               (+ sum (if (char=? c #\\) 2 1)))
                             0 s)]
       [ans (make-string ans-len)])
  (string-fold (lambda (c i)
                 (let ([i (if (char=? c #\\)
                              (begin (string-set! ans i #\\) (+ i 1))
                            i)])
                    (string-set! ans i c)
                    (+ i 1)))
               0 s)
  ans)
@end example

The right--fold combinator is sometimes called a ``catamorphism''.
@end defun


@defun string-unfold @var{p} @var{f} @var{g} @var{seed} [@var{base} @var{make-final}]
This is a fundamental constructor for strings.

@table @var
@item g
Is used to generate a series of ``seed'' values from the initial seed:

@example
seed, (g seed), (g2 seed), (g3 seed), ...
@end example

@item p
Tells us when to stop; when it returns true when applied to one of the
seed values.

@item f
Maps each seed value to the corresponding character in the result
string.  These chars are assembled into the string in a left--to--right
order.

@item base
Is the optional initial/leftmost portion of the constructed string; it
defaults to the empty string.

@item make-final
Is applied to the terminal seed value (on which @var{p} returns true) to
produce the final/rightmost portion of the constructed string.  It
defaults to @code{(lambda (x) "")}.
@end table

More precisely, the following (simple, inefficient) definitions hold:

@example
;;; Iterative
(define (string-unfold p f g seed base make-final)
  (let lp ([seed seed]
           [ans base])
    (if (p seed)
        (string-append ans (make-final seed))
      (lp (g seed) (string-append ans (string (f seed)))))))

;;; Recursive
(define (string-unfold p f g seed base make-final)
  (string-append base
                 (let recur ([seed seed])
                   (if (p seed)
                       (make-final seed)
                     (string-append (string (f seed))
                                    (recur (g seed)))))))
@end example

@func{string-unfold} is a fairly powerful string constructor; we can use
it to convert a list to a string, read a port into a string, reverse a
string, copy a string, and so forth.  Examples:

@example
(port->string p) = (string-unfold eof-object? values
                                  (lambda (x) (read-char p))
                                    (read-char p))

(list->string lis) = (string-unfold null? car cdr lis)

(string-tabulate f size) = (string-unfold (lambda (i)
                                            (= i size))
                                          f add1 0)
@end example

@noindent
to map @var{f} over a list @var{lis}, producing a string:

@example
(string-unfold null? (compose f car) cdr lis)
@end example

Interested functional programmers may enjoy noting that
@func{string-fold-right} and @func{string-unfold} are in some sense
inverses.  That is, given operations @var{knull?}, @var{kar}, @var{kdr},
@var{kons}, and @var{knil} satisfying:

@example
(kons (kar x) (kdr x)) = x  and (knull? knil) = #t
@end example

@noindent
then:

@example
(string-fold-right kons knil (string-unfold knull? kar kdr x)) = x
@end example

@noindent
and:

@example
(string-unfold knull? kar kdr (string-fold-right kons knil s)) = s.
@end example

The final string constructed does not share storage with either
@var{base} or the value produced by @var{make-final}.

This combinator sometimes is called an ``anamorphism''.

Note: implementations should take care that runtime stack limits do not
cause overflow when constructing large (e.g., megabyte) strings with
@func{string-unfold}.
@end defun


@defun string-unfold-right @var{p} @var{f} @var{g} @var{seed} [@var{base} @var{make-final}]
This is a fundamental constructor for strings.

@table @var
@item g
Is used to generate a series of ``seed'' values from the initial seed:

@example
seed, (g seed), (g2 seed), (g3 seed), ...
@end example

@item p
Tells us when to stop; when it returns true when applied to one of these
seed values.

@item f
Maps each seed value to the corresponding character in the result
string.  These chars are assembled into the string in a right--to--left
order.

@item base
Is the optional initial/rightmost portion of the constructed string; it
defaults to the empty string.

@item make-final
Is applied to the terminal seed value (on which @var{p} returns true) to
produce the final/leftmost portion of the constructed string.  It
defaults to @code{(lambda (x) "")}.
@end table

More precisely, the following (simple, inefficient) definitions hold:

@example
;;; Iterative
(define (string-unfold-right p f g seed base make-final)
  (let lp ([seed seed]
           [ans base])
    (if (p seed)
        (string-append (make-final seed) ans)
      (lp (g seed) (string-append (string (f seed)) ans)))))

;;; Recursive
(define (string-unfold-right p f g seed base make-final)
  (string-append (let recur ([seed seed])
                   (if (p seed)
                       (make-final seed)
                     (string-append (recur (g seed))
                                    (string (f seed)))))
                 base))
@end example

Interested functional programmers may enjoy noting that
@func{string-fold} and @func{string-unfold-right} are in some sense
inverses. That is, given operations @var{knull?}, @var{kar}, @var{kdr},
@var{kons}, and @var{knil} satisfying:

@example
(kons (kar x) (kdr x)) = x and (knull? knil) = #t
@end example

@noindent
then:

@example
(string-fold kons knil (string-unfold-right knull? kar kdr x)) = x
@end example

@noindent
and:

@example
(string-unfold-right knull? kar kdr (string-fold kons knil s)) = s.
@end example

The final string constructed does not share storage with either
@var{base} or the value produced by @func{make-final}.

Note: implementations should take care that runtime stack limits do not
cause overflow when constructing large (e.g., megabyte) strings with
@func{string-unfold-right}.
@end defun


@defun string-for-each @var{proc} @var{s} [@var{start} @var{end}]
Apply @var{proc} to each character in @var{s}.  @func{string-for-each}
is required to iterate from start to end in increasing order.
@end defun


@defun string-for-each-index @var{proc} @var{s} [@var{start} @var{end}]
Apply @var{proc} to each index of @var{s}, in order.  The optional
@var{start}/@var{end} pairs restrict the endpoints of the loop.  This is
simply a method of looping over a string that is guaranteed to be safe
and correct.  Example:

@example
(let* ([len (string-length s)]
       [ans (make-string len)])
  (string-for-each-index
      (lambda (i) (string-set! ans (- len i) (string-ref s i)))
      s)
  ans)
@end example
@end defun



@c page
@node strings spec replicate
@subsection Replicate and rotate


@defun xsubstring @var{s} @var{from} [@var{to} @var{start} @var{end}]
This is the ``extended substring'' procedure that implements replicated
copying of a substring of some string.

@var{s} is a string; @var{start} and @var{end} are optional arguments
that demarcate a substring of @var{s}, defaulting to 0 and the length of
@var{s} (i.e. the whole string).

This function replicates the selected substring ``up and down'' index
space, in both the positive and negative directions.  For example, if
@code{s = "abcdefg"}, @code{start=3}, and @code{end=6}, then we have the
conceptual bidirectionally--infinite string:

@example
...  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d  ...
... -9 -8 -7 -6 -5 -4 -3 -2 -1  0 +1 +2 +3 +4 +5 +6 +7 +8 +9  ...
@end example

@noindent
that is @code{defg} repeated in both directions.

@func{xsubstring} returns the substring of this string beginning at
index @var{from}, and ending at @var{to} which defaults to @code{from +
(end - start)}.

We can use @func{xsubstring} to perform a variety of tasks:

@itemize
@item
To rotate a string left: @code{(xsubstring "abcdef" 2) => "cdefab"}.

@item
To rotate a string right: @code{(xsubstring "abcdef" -2) => "efabcd"}.

@item
To replicate a string: @code{(xsubstring "abc" 0 7) => "abcabca"}.
@end itemize

Note that:

@itemize
@item
The @var{from}/@var{to} indices give a half--open range; the characters
from index @var{from} up to, but not including, index @var{to}.

@item
The @var{from}/@var{to} indices are not in terms of the index space for
string @var{s}.  They are in terms of the replicated index space of the
substring defined by @var{s}, @var{start}, and @var{end}.
@end itemize

It is an error if @code{start = end}; although this is allowed by
special dispensation when @code{from = to}.
@end defun


@defun string-xcopy! @var{target} @var{tstart} @var{s} @var{sfrom} [@var{sto} @var{start} @var{end}]
Exactly the same as @func{xsubstring}, but the extracted text is written
into the string @var{target} starting at index @var{tstart}.  This
operation is not defined if @code{(eq? target s)} or these two arguments
share storage; we cannot copy a string on top of itself.
@end defun



@c page
@node strings spec misc
@subsection Miscellaneous: intertion, parsing


@defun string-replace @var{s1} @var{s2} @var{start1} @var{end1} [@var{start2} @var{end2}]
Return:

@example
(string-append (substring/shared s1 0 start1)
               (substring/shared s2 start2 end2)
               (substring/shared s1 end1 (string-length s1)))
@end example

That is, the segment of characters in @var{s1} from @var{start1} to
@var{end1} is replaced by the segment of characters in @var{s2} from
@var{start2} to @var{end2}.  If @code{start1 = end1}, this simply
splices the @var{s2} characters into @var{s1} at the specified index.

Examples:

@example
(string-replace "The TCL programmer endured daily ridicule."
                "another miserable perl drone" 4 7 8 22 )
=> "The miserable perl programmer endured daily ridicule."

(string-replace "It's easy to code it up in Scheme." "lots of fun" 5 9)
=> "It's lots of fun to code it up in Scheme."

(define (string-insert s i t) (string-replace s t i i))

(string-insert "It's easy to code it up in Scheme." 5 "really ")
=> "It's really easy to code it up in Scheme."
@end example
@end defun


@defun string-tokenize @var{s} [@var{token-set} @var{start} @var{end}]
Split the string @var{s} into a list of substrings, where each substring
is a maximal non--empty contiguous sequence of characters from the
character set @var{token-set}.

@itemize
@item
@var{token-set} defaults to @code{char-set:graphic} (see @ansrfi{14} for
more on character sets and @code{char-set:graphic}).

@item
If @var{start} or @var{end} indices are provided, they restrict
@func{string-tokenize} to operating on the indicated substring of
@var{s}.
@end itemize

This function provides a minimal parsing facility for simple
applications.  More sophisticated parsers that handle quoting and
backslash effects can easily be constructed using regular--expression
systems; be careful not to use @func{string-tokenize} in contexts where
more serious parsing is needed.

@example
(string-tokenize "Help make programs run, run, RUN!")
=> ("Help" "make" "programs" "run," "run," "RUN!")
@end example
@end defun



@c page
@node strings spec filter
@subsection Filtering and deleting


@defun string-filter @var{char/char-set/pred} @var{s} [@var{start} @var{end}]
@defunx string-delete @var{char/char-set/pred} @var{s} [@var{start} @var{end}]
Filter the string @var{s}, retaining only those characters that
satisfy/do not satisfy the @var{char/char-set/pred} argument.  If this
argument is a procedure, it is applied to the character as a predicate;
if it is a char--set, the character is tested for membership; if it is a
character, it is used in an equality test.

If the string is unaltered by the filtering operation, these functions
may return either @var{s} or a copy of @var{s}.
@end defun


@c page
@node strings spec parsing
@subsection Start/end optional--argument parsing and checking utilities


@defun {string-parse-start+end} @var{proc} @var{s} @var{args}
@defunx {string-parse-final-start+end} @var{proc} @var{s} @var{args}
@func{string-parse-start+end} may be used to parse a pair of optional
start/end arguments from an argument list, defaulting them to 0 and the
length of some string @var{s}, respectively.

Let the length of string @var{s} be @var{slen}.

@itemize
@item
If @code{args = ()}, the function returns @code{(values '() 0 slen)}.

@item
If @code{args = (i)}, @var{i} is checked to ensure it is an exact
integer, and that @code{0 <= i <= slen}.  The function returns
@code{(values (cdr args) i slen)}.

@item
If @code{args = (i j ...)}, @var{i} and @var{j} are checked to ensure
they are exact integers, and that @code{0 <= i <= j <= slen}.  The
function returns @code{(values (cddr args) i j)}.
@end itemize

If any of the checks fail, an error condition is raised, and @var{proc}
is used as part of the error condition; it should be the client
procedure whose argument list @func{string-parse-start+end} is parsing.

@func{string-parse-final-start+end} is exactly the same, except that the
@var{args} list passed to it is required to be of length two or less; if
it is longer, an error condition is raised.  It may be used when the
optional start/end parameters are final arguments to the procedure.

Note that in all cases, these functions ensure that @var{s} is a string
(by necessity, since all cases apply @func{string-length} to @var{s}
either to default end or to bounds-check it).
@end defun


@deffn Syntax let-string-start+end (@var{start} @var{end} [@var{rest}]) @var{proc-exp} @var{s-exp} @var{args-exp} @var{body} ...
Syntactic sugar for an application of @func{string-parse-start+end} or
@func{string-parse-final-start+end}.  If a @var{rest} variable is given,
the form is equivalent to:

@example
(call-with-values
    (lambda ()
      (string-parse-start+end proc-exp s-exp args-exp))
  (lambda (rest start end)
    body ...))
@end example

If no @var{rest} variable is given, the form is equivalent to:

@example
(call-with-values
    (lambda ()
      (string-parse-final-start+end proc-exp s-exp args-exp))
  (lambda (start end)
    body ...))
@end example
@end deffn


@defun check-substring-spec @var{proc} @var{s} @var{start} @var{end}
@defunx substring-spec-ok? @var{s} @var{start} @var{end}
Check values @var{s}, @var{start} and @var{end} to ensure they specify a
valid substring.  This means that @var{s} is a string, @var{start} and
@var{end} are exact integers, and:

@example
0 <= start <= end <= (string-length s)
@end example

If the values are not proper:

@itemize
@item
@func{check-substring-spec} raises an error condition.  @var{proc} is
used as part of the error condition, and should be the procedure whose
parameters we are checking.

@item
@func{substring-spec-ok?} returns @false{}.
@end itemize

Otherwise, @func{substring-spec-ok?} returns @true{}, and
@func{check-substring-spec} simply returns (what it returns is not
specified).
@end defun



@c page
@node strings spec knuth
@subsection Knuth-Morris-Pratt searching


The Knuth--Morris--Pratt string--search algorithm is a method of rapidly
scanning a sequence of text for the occurrence of some fixed string.  It
has the advantage of never requiring backtracking; hence, it is useful
for searching not just strings, but also other sequences of text that do
not support backtracking or random--access, such as input ports.

The following routines package up the initialisation and searching
phases of the algorithm for general use.  They also support searching
through sequences of text that arrive in buffered chunks, in that
intermediate search state can be carried across applications of the
search loop from the end of one buffer application to the next.

A second critical property of @acronym{KMP} search is that it requires
the allocation of auxiliary memory proportional to the length of the
pattern, but constant in the size of the character type.  Alternate
searching algorithms frequently require the construction of a table with
an entry for every possible character; which can be prohibitively
expensive in a 16-bit or 32-bit character representation.


@defun make-kmp-restart-vector @var{s} [@var{c=} @var{start} @var{end}]
Build a Knuth--Morris--Pratt ``restart vector'', which is useful for
quickly searching character sequences for the occurrence of string
@var{s} (or the substring of @var{s} demarcated by the optional
@var{start}/@var{end} parameters, if provided).

@var{c=} is a character--equality function used to construct the restart
vector.  It defaults to @func{char=?}; use @func{char-ci=?}  instead for
case--folded string search.

The definition of the restart vector @var{rv} for string @var{s} is: If
we have matched chars @code{0..i-1} of @var{s} against some search
string @var{ss}, and @code{s[i]} doesn't match @code{ss[k]}, then reset
@code{i := rv[i]}, and try again to match @code{ss[k]}.  If @code{rv[i]
= -1}, then punt @code{ss[k]} completely, and move on to @code{ss[k+1]}
and @code{s[0]}.

In other words, if you have matched the first @var{i} chars of @var{s},
but the @var{i+1}'th char doesn't match, @code{rv[i]} tells you what the
next--longest prefix of @var{s} is that you have matched.

The following string--search function shows how a restart vector is used
to search.  Note the attractive feature of the search process: it is
``on line'', that is, it never needs to back up and reconsider
previously seen data.  It simply consumes characters one--at--a--time
until declaring a complete match or reaching the end of the sequence.
Thus, it can be easily adapted to search other character sequences (such
as ports) that do not provide random access to their contents.

@example
(define (find-substring pattern source start end)
  (let ([plen (string-length pattern)]
        [rv (make-kmp-restart-vector pattern)])

    ;; The search loop. SJ & PJ are redundant state.
    (let lp ([si start]
             [pi 0]
             [sj (- end start)]     ; (- end si)  -- how many chars left.
             [pj plen])             ; (- plen pi) -- how many chars left.
       (if (= pi plen)
           (- si plen)                             ; Win.
         (and (<= pj sj)                           ; Lose.
              (if [char=? (string-ref source si)           ; Test.
                          (string-ref pattern pi)]
                  (lp (+ 1 si) (+ 1 pi) (- sj 1) (- pj 1)) ; Advance.
                (let ([pi (vector-ref rv pi)])             ; Retreat.
                  (if (= pi -1)
                      (lp (+ si 1)  0   (- sj 1)  plen)    ; Punt.
                    (lp si          pi  sj        (- plen pi))))))))))
@end example

The optional @var{start}/@var{end} parameters restrict the restart
vector to the indicated substring of @var{pat}; @var{rv} is @code{end -
start} elements long.  If @code{start > 0}, then @var{rv} is offset by
start elements from @var{pat}.  That is, @code{rv[i]} describes pattern
element @code{pat[i + start]}.  Elements of @var{rv} are themselves
indices that range just over @code{[0, end-start)}, not @code{[start,
end)}.

Rationale: the actual value of @var{rv} is ``position independent''; it
does not depend on where in the pat string the pattern occurs, but only
on the actual characters comprising the pattern.
@end defun


@defun kmp-step @var{pat} @var{rv} @var{c} @var{i} @var{c=} @var{p-start}
This function encapsulates the work performed by one step of the
@acronym{KMP} string search; it can be used to scan strings, input
ports, or other on--line character sources for fixed strings.

@var{pat} is the non--empty string specifying the text for which we are
searching.  @var{rv} is the Knuth--Morris--Pratt restart vector for the
pattern, as constructed by @func{make-kmp-restart-vector}.  The pattern
begins at @code{pat[p-start]}, and is @code{(string-length rv)}
characters long.  @var{c=} is the character--equality function used to
construct the restart vector, typically @func{char=?} or
@func{char-ci=?}.

Suppose the pattern is @var{n} characters in length:

@example
pat[p-start, p-start + n)
@end example

We have already matched i characters:

@example
pat[p-start, p-start + i)
@end example

@noindent
@var{p-start} is typically zero.  @var{c} is the next character in the
input stream.  @func{kmp-step} returns the new @var{i} value; that is,
how much of the pattern we have matched, including character @var{c}.
When @var{i} reaches @var{n}, the entire pattern has been matched.

Thus a typical search loop looks like this:

@example
(let loop ([i 0])
  (or (= i n)                           ; Win -- #t
      (and (not (end-of-stream))        ; Lose -- #f
           (loop (kmp-step pat rv (get-next-character)
                           i char=? 0)))))
@end example

Example:

@example
;; Read chars from IPORT until we find string PAT or hit EOF.
(define (port-skip pat iport)
  (let* ([rv     (make-kmp-restart-vector pat)]
         [patlen (string-length pat)])
    (let loop ([i       0]
              [nchars   0])
      (if (= i patlen)
          nchars                        ; Win -- nchars skipped
        (let ([c (read-char iport)])
          (if (eof-object? c)
              c                         ; Fail -- EOF
            (loop (kmp-step pat rv c i char=? 0) ; Continue
                  (+ nchars 1))))))))
@end example

This procedure could be defined as follows:

@example
(define (kmp-step pat rv c i c= p-start)
  (let loop ([i i])
    (if (c= c (string-ref pat (+ i p-start)))   ; Match =>
        (+ i 1)                                 ;   Done.
      (let ([i (vector-ref rv i)])              ; Back up in PAT.
        (if (= i -1)
            0                                   ; Can't back up more.
          (loop i)))))))                        ; Keep going.
@end example

Rationale: this procedure takes no optional arguments because it is
intended as an inner--loop primitive and we do not want any run--time
penalty for optional--argument parsing and defaulting, nor do we wish
barriers to procedure integration/inlining.
@end defun


@defun string-kmp-partial-search @var{pat} @var{rv} @var{s} @var{i} [@var{c=} @var{p-start} @var{s-start} @var{s-end}]
Apply @func{kmp-step} across @var{s}; optional @var{s-start}/@var{s-end}
bounds parameters restrict search to a substring of @var{s}.  The
pattern is @code{(vector-length rv)} characters long; optional
@var{p-start} index indicates non--zero start of pattern in @var{pat}.

Suppose @code{plen = (vector-length rv)} is the length of the pattern.
@var{i} is an integer index into the pattern (that is @code{0 <= i <
plen}) indicating how much of the pattern has already been matched.
This means the pattern must be non-empty: @code{plen > 0}.

@itemize
@item
On success, return @code{-j}, where @var{j} is the index in @var{s}
bounding the end of the pattern; e.g. a value that could be used as the
end parameter in a call to @func{substring/shared}.

@item
On continue, return the current search state @code{i'} (an index into
@var{rv}) when the search reached the end of the string.  This is a
non--negative integer.
@end itemize

Hence:

@itemize
@item
A negative return value indicates success, and says where in the string
the match occured.

@item
A non--negative return value provides the @var{i} to use for continued
search in a following string.
@end itemize

This utility is designed to allow searching for occurrences of a fixed
string that might extend across multiple buffers of text.  This is why,
for example, we do not provide the index of the start of the match on
success; it may have occurred in a previous buffer.

To search a character sequence that arrives in ``chunks'', write a loop
of this form:

@example
(let loop ([i 0])
  (and (not (end-of-data?))             ; Lose -- return #f.
       (let* ([buf (get-next-chunk)]    ; Get or fill up the buffer.
              [i   (string-kmp-partial-search pat rv buf i)])
         (if (< i 0)
             (- i)                      ; Win -- return end index.
           (loop i)))))                 ; Keep looking.
@end example

Modulo @var{start}/@var{end} optional-argument parsing, this procedure
could be defined as follows:

@example
(define (string-kmp-partial-search pat rv s i c= p-start s-start s-end)
  (let ([patlen (vector-length rv)])
    (let loop ([si s-start]       ; An index into S.
               [vi i])            ; An index into RV.
      (cond [(= vi patlen) (- si)]      ; Win.
            [(= si end) vi]             ; Ran off the end.
            [else (loop (+ si 1)        ; Match s[si] & loop.
                      (kmp-step pat rv (string-ref s si)
                                vi c= p-start))]))))
@end example
@end defun



@c page
@node strings ack
@section Acknowledgments


The design of this library benefited greatly from the feedback provided
during the @srfi{} discussion phase.  Among those contributing
thoughtful commentary and suggestions, both on the mailing list and by
private discussion, were Paolo Amoroso, Lars Arvestad, Alan Bawden, Jim
Bender, Dan Bornstein, Per Bothner, Will Clinger, Brian Denheyer, Mikael
Djurfeldt, Kent Dybvig, Sergei Egorov, Marc Feeley, Matthias Felleisen,
Will Fitzgerald, Matthew Flatt, Arthur A. Gleckler, Ben Goetter, Sven
Hartrumpf, Erik Hilsdale, Richard Kelsey, Oleg Kiselyov, Bengt Kleberg,
Donovan Kolbly, Bruce Korb, Shriram Krishnamurthi, Bruce Lewis, Tom
Lord, Brad Lucier, Dave Mason, David Rush, Klaus Schilling, Jonathan
Sobel, Mike Sperber, Mikael Staldal, Vladimir Tsyshevsky, Donald Welsh,
and Mike Wilson.  I am grateful to them for their assistance.

I am also grateful the authors, implementors and documentors of all the
systems mentioned in the introduction.  Aubrey Jaffer and Kent Pitman
should be noted for their work in producing Web--accessible versions of
the @rnrs{5} and Common Lisp spec, which was a tremendous aid.

This is not to imply that these individuals necessarily endorse the
final results, of course.

During this document's long development period, great patience was
exhibited by Mike Sperber, who is the editor for the @srfi{}, and by
Hillary Sullivan, who is not.


@c page
@node strings references
@section References


@emph{Case mappings}.  Unicode Technical Report 21.

@center @url{http://www.unicode.org/unicode/reports/tr21/}

@noindent
@emph{Common Lisp: the Language}.  Guy L. Steele Jr. (editor).  Digital
Press, Maynard, Mass., second edition 1990.  Available at:

@center @url{http://www.elwood.com/alu/table/references.htm#cltl2}

@noindent
@emph{The Common Lisp ``HyperSpec''}, produced by Kent Pitman, is
essentially the @ansi{} spec for Common Lisp:

@center @url{http://www.harlequin.com/education/books/HyperSpec/}

@noindent
The following URLs provide documentation on relevant Java classes.

@example
http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Character.html
http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html
http://java.sun.com/products/jdk/1.2/docs/api/java/lang/StringBuffer.html
http://java.sun.com/products/jdk/1.2/docs/api/java/text/Collator.html
http://java.sun.com/products/jdk/1.2/docs/api/java/text/package-summary.html
@end example

@noindent
MIT-Scheme:

@center @url{http://www.swiss.ai.mit.edu/projects/scheme/}

@noindent
@emph{Revised^5 report on the algorithmic language Scheme}.  R. Kelsey,
W. Clinger, J. Rees (editors).  Higher--Order and Symbolic Computation,
Vol. 11, No. 1, September, 1998; and ACM SIGPLAN Notices, Vol. 33,
No. 9, October, 1998.  Available at:

@center @url{http://www.schemers.org/Documents/Standards/}

@noindent
The SRFI web site.

@center @url{http://srfi.schemers.org/}

@noindent
@ansrfi{14}: Character--set library.  The @ansrfi{14} char--set library
defines a character--set data type, which is used by some procedures in
this library.

@center @url{http://srfi.schemers.org/srfi-14/}

@noindent
The Unicode site:

@center @url{http://www.unicode.org/}

@noindent
The Unicode character database.

@example
ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html
@end example


@c page
@node char-set
@chapter Character set library


@cindex @srfi{} char-set


The @library{srfi char-set} has been written by Olin Shivers as the
reference implementation for @ansrfi{14}.

@menu
* char-set license::            Original license.
* char-set abstract::           Abstract.
* char-set rationale::          Rationale.
* char-set spec::               Specification.
* char-set ack::                Acknowledgements.
@end menu


@c page
@node char-set license
@section Original license


Certain portions of this document---the specific, marked segments of
text describing the @rnrs{5} procedures---were adapted with permission
from the @rnrs{5} report editors.

All other text is Copyright @copyright{} 1998, 1999, 2000 Olin Shivers.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node char-set abstract
@section Abstract


The ability to efficiently represent and manipulate sets of characters
is an unglamorous but very useful capability for text--processing code;
one that tends to pop up in the definitions of other libraries.  Hence
it is useful to specify a general substrate for this functionality
early.

This @srfi{} defines a general library that provides this functionality.
It is accompanied by a reference implementation for the spec.

The reference implementation is fairly efficient, straightforwardly
portable, and has a ``free software'' copyright.  The implementation is
tuned for ``small'' 7 or 8 bit character types, such as @ascii{} or
Latin-1; the data structures and algorithms would have to be altered for
larger 16 or 32 bit character types such as Unicode; however, the specs
have been carefully designed with these larger character types in mind.
Several forthcoming @srfi{}s can be defined in terms of this one:

@itemize
@item
string library;

@item
delimited input procedures (e.g., read-line);

@item
regular expressions.
@end itemize


@c page
@node char-set rationale
@section Rationale


The ability to efficiently manipulate sets of characters is quite useful
for text--processing code.  Encapsulating this functionality in a
general, efficiently implemented library can assist all such code.  This
library defines a new data structure to represent these sets, called a
@code{char-set}.  The @code{char-set} type is distinct from all other
types.

This library is designed to be portable across implementations that use
different character types and representations, especially @ascii{},
Latin-1 and Unicode.  Some effort has been made to preserve
compatibility with Java in the Unicode case (see the definition of
@func{char-set:whitespace} for the single real deviation).


@subsubheading Linear-update operations

The procedures of this @srfi{}, by default, are ``pure functional'';
they do not alter their parameters.  However, this @srfi{} defines a set
of ``linear--update'' procedures which have a hybrid
pure--functional/side--effecting semantics: they are allowed, but not
required, to side--effect one of their parameters in order to construct
their result.  An implementation may legally implement these procedures
as pure, side--effect--free functions, or it may implement them using
side effects, depending upon the details of what is the most efficient
or simple to implement in terms of the underlying representation.

The linear--update routines all have names ending with @code{!}.

Clients of these procedures may not rely upon these procedures working
by side effect.  For example, this is not guaranteed to work:

@example
(let* ((cs1 (char-set #\a #\b #\c))      ; cs1 = @{a,b,c@}.
       (cs2 (char-set-adjoin! cs1 #\d))) ; Add d to @{a,b,c@}.
  cs1) ; Could be either @{a,b,c@} or @{a,b,c,d@}.
@end example

However, this is well--defined:

@example
(let ((cs (char-set #\a #\b #\c)))
  (char-set-adjoin! cs #\d)) ; Add d to @{a,b,c@}.
@end example

So clients of these procedures write in a functional style, but must
additionally be sure that, when the procedure is called, there are no
other live pointers to the potentially--modified character set (hence
the term ``linear update'').

There are two benefits to this convention:

@itemize
@item
Implementations are free to provide the most efficient possible
implementation, either functional or side--effecting.

@item
Programmers may nonetheless continue to assume that character sets are
purely functional data structures: they may be reliably shared without
needing to be copied, uniquified, and so forth.
@end itemize

Note that pure functional representations are the right thing for
@ascii{}--based or Latin-1--based Scheme implementations, since a
@code{char-set} can be represented in an @ascii{} Scheme with 4 32-bit
words.  Pure set--algebra operations on such a representation are very
fast and efficient.  Programmers who code using linear--update
operations are guaranteed the system will provide the best
implementation across multiple platforms.

In practice, these procedures are most useful for efficiently
constructing character sets in a side--effecting manner, in some limited
local context, before passing the character set outside the local
construction scope to be used in a functional manner.

Scheme provides no assistance in checking the linearity of the
potentially side--effected parameters passed to these functions; there's
no linear type checker or run--time mechanism for detecting violations.
(But sophisticated programming environments, such as DrScheme, might
help.)


@subsubheading Extra--@srfi{} recommendations


Users are cautioned that the @rnrs{5} predicates:

@example
char-alphabetic?
char-numeric?
char-whitespace?
char-upper-case?
char-lower-case?
@end example

@noindent
may or may not be in agreement with the @ansrfi{14} base character sets:

@example
char-set:letter
char-set:digit
char-set:whitespace
char-set:upper-case
char-set:lower-case
@end example

Implementors are strongly encouraged to bring these predicates into
agreement with the base character sets of this @srfi{}; not to do so
risks major confusion.


@c page
@node char-set spec
@section Specification


@menu
* char-set spec intro::         Introduction.
* char-set spec general::       General procedures.
* char-set spec iter::          Iterating over char sets.
* char-set spec create::        Creating char sets.
* char-set spec query::         Querying char sets.
* char-set spec algebra::       Char sets algebra.
* char-set spec sets::          Standard char sets.
@end menu


@c page
@node char-set spec intro
@subsection Introduction


In the following procedure specifications:

@itemize
@item
A @var{cs} parameter is a character set.

@item
An @var{s} parameter is a string.

@item
A @var{char} parameter is a character.

@item
A @var{char-list} parameter is a list of characters.

@item
A @var{pred} parameter is a unary character predicate procedure,
returning a @true{}/@false{} value when applied to a character.

@item
An @var{obj} parameter may be any value at all.
@end itemize

Passing values to procedures with these parameters that do not satisfy
these types is an error.

Unless otherwise noted in the specification of a procedure, procedures
always return character sets that are distinct (from the point of view
of the linear--update operations) from the parameter character sets.
For example, @func{char-set-adjoin} is guaranteed to provide a fresh
character set, even if it is not given any character parameters.

Parameters given in square brackets are optional.  Unless otherwise
noted in the text describing the procedure, any prefix of these optional
parameters may be supplied, from zero arguments to the full list.

A parameter followed by @code{...} means zero--or--more elements.


@c page
@node char-set spec general
@subsection General procedures


@defun char-set? @var{obj}
Return @true{} if @var{obj} is a character set, otherwise @false{}.
@end defun


@defun char-set= @var{cs1} ...
Return @true{} if the given character sets are equal.

Boundary cases:

@example
(char-set=)
=> #t

(char-set= cs)
=> #t
@end example

@quotation
@emph{Rationale:} Transitive binary relations are generally extended to
@var{n}--ary relations in Scheme, which enables clearer, more concise
code to be written.  While the zero--argument and one--argument cases
will almost certainly not arise in first--order uses of such relations,
they may well arise in higher--order cases or macro-generated code.
E.g., consider:

@example
(apply char-set= cset-list)
@end example

This is well--defined if the list is empty or a singleton list.  Hence
we extend these relations to any number of arguments.  Implementors have
reported actual uses of @var{n}--ary relations in higher--order cases
allowing for fewer than two arguments.  The way of Scheme is to handle
the general case; we provide the fully general extension.

A counter--argument to this extension is that @rnrs{5}'s transitive
binary arithmetic relations (=, <, etc.) require at least two arguments,
hence this decision is a break with the prior convention; although it is
at least one that is backwards--compatible.
@end quotation
@end defun


@defun char-set<= @var{cs1} ...
Return @true{} if every character set @var{csi} is a subset of character
set @var{csi}+1.

Boundary cases:

@example
(char-set<=)
=> #t

(char-set<= cs)
=> #t
@end example

@quotation
@emph{Rationale:} See @func{char-set=} for discussion of zero--argument
and one--argument applications.  Consider testing a list of char--sets
for monotonicity with:

@example
(apply char-set<= cset-list)
@end example
@end quotation
@end defun


@defun char-set-hash @var{cs}
@defunx char-set-hash @var{cs} @var{bound}
Compute and return a hash value for the character set @var{cs}.  The
hash value is an exact integer.

@var{bound} is a non--negative exact integer specifying the range of the
hash function.  A positive value restricts the return value to the range
@code{[0, @var{bound})}.

If @var{bound} is either zero or not given, the implementation may use
an implementation--specific default value, chosen to be as large as is
efficiently practical.  For instance, the default range might be chosen
for a given implementation to map all strings into the range of integers
that can be represented with a single machine word.

Invariant:

@example
(char-set= cs1 cs2) => (= (char-set-hash cs1 b)
                          (char-set-hash cs2 b))
@end example

A legal but nonetheless discouraged implementation:

@example
(define (char-set-hash cs . maybe-bound) 1)
@end example

@quotation
@emph{Rationale:} allowing the user to specify an explicit bound
simplifies user code by removing the mod operation that typically
accompanies every hash computation, and also may allow the
implementation of the hash function to exploit a reduced range to
efficiently compute the hash value.

E.g., for small bounds, the hash function may be computed in a fashion
such that intermediate values never overflow into bignum integers,
allowing the implementor to provide a fixnum--specific ``fast path'' for
computing the common cases very rapidly.
@end quotation
@end defun


@c page
@node char-set spec iter
@subsection Iterating over char sets


@defun char-set-cursor @var{cset}
@defunx char-set-ref @var{cset} @var{cursor}
@defunx char-set-cursor-next @var{cset} @var{cursor}
@defunx end-of-char-set? @var{cursor}
Cursors are a low--level facility for iterating over the characters in a
set.  A cursor is a value that indexes a character in a char set.

@func{char-set-cursor} produces a new cursor for a given char set.

The set element indexed by the cursor is fetched with
@func{char-set-ref}.

A cursor index is incremented with @func{char-set-cursor-next}; in this
way, code can step through every character in a char set.

Stepping a cursor ``past the end'' of a char set produces a cursor that
answers @true{} to @func{end-of-char-set?}.  It is an error to pass such
a cursor to @func{char-set-ref} or to @func{char-set-cursor-next}.

A cursor value may not be used in conjunction with a different character
set; if it is passed to @func{char-set-ref} or
@func{char-set-cursor-next} with a character set other than the one used
to create it, the results and effects are undefined.

Cursor values are not necessarily distinct from other types.  They may
be integers, linked lists, records, procedures or other values.  This
license is granted to allow cursors to be very ``lightweight'' values
suitable for tight iteration, even in fairly simple implementations.

Note that these primitives are necessary to export an iteration facility
for char sets to loop macros.

Example:

@example
(define cs (char-set #\G #\a #\T #\e #\c #\h))

;; Collect elts of CS into a list.
(let lp ((cur (char-set-cursor cs)) (ans '()))
  (if (end-of-char-set? cur)
      ans
    (lp (char-set-cursor-next cs cur)
        (cons (char-set-ref cs cur) ans))))
=> (#\G #\T #\a #\c #\e #\h)

;; Equivalently, using a list unfold (from SRFI 1):
(unfold-right end-of-char-set?
              (curry char-set-ref cs)
              (curry char-set-cursor-next cs)
              (char-set-cursor cs))
=> (#\G #\T #\a #\c #\e #\h)
@end example

@quotation
@emph{Rationale:} Note that the cursor @api{}'s four functions ``fit''
the functional protocol used by the unfolders provided by the list,
string and char-set @srfi{}s (see the example above).
@end quotation
@end defun


@defun char-set-fold @var{kons} @var{knil} @var{cs}
This is the fundamental iterator for character sets.  Applies the
function @var{kons} across the character set @var{cs} using initial
state value @var{knil}.  That is, if @var{cs} is the empty set, the
procedure returns @var{knil}.  Otherwise, some element @var{c} of
@var{cs} is chosen; let @var{cs'} be the remaining, unchosen
characters.  The procedure returns:

@example
(char-set-fold kons (kons c knil) cs')
@end example

Examples:

@example
;; CHAR-SET-MEMBERS
(lambda (cs)
  (char-set-fold cons '() cs))

;; CHAR-SET-SIZE
(lambda (cs)
  (char-set-fold (lambda (c i)
                   (+ i 1))
                 0
                 cs))

;; How many vowels in the char set?
(lambda (cs)
  (char-set-fold
    (lambda (c i)
      (if (vowel? c)
          (+ i 1)
        i))
    0
    cs))
@end example
@end defun


@defun char-set-unfold @var{f} @var{p} @var{g} @var{seed} [@var{base-cs}]
@defunx char-set-unfold! @var{f} @var{p} @var{g} @var{seed} @var{base-cs}
This is a fundamental constructor for char-sets.

@table @var
@item g
Is used to generate a series of ``seed'' values from the initial
@var{seed}.

@item p
It is applied to the seed values and whenever it returns true the
unfolding stops.

@item f
Map each seed value to a character.  These characters are added to the
base character set @var{base-cs} to form the result; @var{base-cs}
defaults to the empty set.
@end table

@func{char-set-unfold!} adds the characters to @var{base-cs} in a
linear--update; it is allowed, but not required, to side--effect and use
@var{base-cs}'s storage to construct the result.

More precisely, the following definitions hold, ignoring the
optional--argument issues:

@example
(define (char-set-unfold p f g seed base-cs)
  (char-set-unfold! p f g seed (char-set-copy base-cs)))

(define (char-set-unfold! p f g seed base-cs)
  (let lp ((seed seed)
           (cs base-cs))
    (if (p seed)
        cs                                   ; P says we are done.
      (lp (g seed)                           ; Loop on (G SEED).
          (char-set-adjoin! cs (f seed)))))) ; Add (F SEED) to set.
@end example

(Note that the actual implementation may be more efficient.)

Examples:

@example
(port->char-set p) = (char-set-unfold eof-object? values
                                      (lambda (x)
                                        (read-char p))
                                      (read-char p))

(list->char-set lis) = (char-set-unfold null? car cdr lis)
@end example
@end defun


@defun char-set-for-each @var{proc} @var{cs}
Apply procedure @var{proc} to each character in the character set
@var{cs}.  Note that the order in which @var{proc} is applied to the
characters in the set is not specified, and may even change from one
procedure application to another.

Nothing at all is specified about the value returned by this procedure;
it is not even required to be consistent from call to call.  It is
simply required to be a value (or values) that may be passed to a
command continuation, e.g. as the value of an expression appearing as a
non--terminal subform of a begin expression.

Note that in @rnrs{5}, this restricts the procedure to returning a
single value; non--@rnrs{5} systems may not even provide this
restriction.
@end defun


@defun char-set-map @var{proc} @var{cs}
@var{proc} is a char->char procedure.  It is applied to all the
characters in the char-set @var{cs}, and the results are collected into
a new character set.

Essentially, @func{char-set-map} lifts @var{proc} from a char->char
procedure to a char-set -> char-set procedure.

Example:

@example
(char-set-map char-downcase cset)
@end example
@end defun


@c page
@node char-set spec create
@subsection Creating char sets


@defun char-set-copy @var{cs}
Return a copy of the character set @var{cs}.  ``Copy'' means that if
either the input parameter or the result value of this procedure is
passed to one of the linear--update procedures described below, the
other character set is guaranteed not to be altered.

A system that provides pure--functional implementations of the
linear--operator suite could implement this procedure as the identity
function; so copies are not guaranteed to be distinct by @func{eq?}.
@end defun


@defun char-set @var{char1} ...
Return a character set containing the given characters.
@end defun


@defun list->char-set @var{char-list} [@var{base-cs}]
@defunx list->char-set! @var{char-list} @var{base-cs}
Return a character set containing the characters in the list of
characters @var{char-list}.

If character set @var{base-cs} is provided, the characters from
@var{char-list} are added to it.

@func{list->char-set!} is allowed, but not required, to side--effect and
reuse the storage in @var{base-cs}; @func{list->char-set} produces a
fresh character set.
@end defun


@defun string->char-set @var{s} [@var{base-cs}]
@defunx string->char-set! @var{s} @var{base-cs}
Return a character set containing the characters in the string @var{s}.

If character set @var{base-cs} is provided, the characters from @var{s}
are added to it.

@func{string->char-set!} is allowed, but not required, to side--effect
and reuse the storage in @var{base-cs}; @func{string->char-set} produces
a fresh character set.
@end defun


@defun char-set-filter @var{pred} @var{cs} [@var{base-cs}]
@defunx char-set-filter! @var{pred} @var{cs} @var{base-cs}
Return a character set containing every character @var{c} in @var{cs}
such that @code{(pred c)} returns true.

If character set @var{base-cs} is provided, the characters specified by
@var{pred} are added to it.

@func{char-set-filter!} is allowed, but not required, to side--effect
and reuse the storage in @var{base-cs}; @func{char-set-filter} produces
a fresh character set.

An implementation may not save away a reference to @var{pred} and invoke
it after @func{char-set-filter} or @func{char-set-filter!} returns; that
is, ``lazy'', on--demand implementations are not allowed, as @var{pred}
may have external dependencies on mutable data or have other
side--effects.

@quotation
@emph{Rationale:} This procedure provides a means of converting a
character predicate into its equivalent character set; the @var{cs}
parameter allows the programmer to bound the predicate's domain.

Programmers should be aware that filtering a character set such as
@func{char-set:full} could be a very expensive operation in an
implementation that provided an extremely large character type, such as
32-bit Unicode.
@end quotation
@end defun


@defun ucs-range->char-set @var{lower} @var{upper} [@var{error?} @var{base-cs}]
@defunx ucs-range->char-set! @var{lower} @var{upper} @var{error?} @var{base-cs}
@var{lower} and @var{upper} are exact non--negative integers,
@var{lower} <= @var{upper}.

Return a character set containing every character whose ISO/IEC 10646
UCS-4 code lies in the half--open range @code{[@var{lower},
@var{upper})}.

@itemize
@item
If the requested range includes unassigned UCS values, these are
silently ignored (the current UCS specification has ``holes'' in the
space of assigned codes).

@item
If the requested range includes ``private'' or ``user space'' codes,
these are handled in an implementation--specific manner; however, a
UCS--based or Unicode--based Scheme implementation should pass them
through transparently.

@item
If any code from the requested range specifies a valid, assigned UCS
character that has no corresponding representative in the
implementation's character type, then (1) an error is raised if
@var{error?}  is true, and (2) the code is ignored if @var{error?} is
@false{} (the default).  This might happen, for example, if the
implementation uses @ascii{} characters, and the requested range
includes non--@ascii{} characters.
@end itemize

If character set @var{base-cs} is provided, the characters specified by
the range are added to it.

@func{ucs-range->char-set!} is allowed, but not required, to
side--effect and reuse the storage in @var{base-cs};
@func{ucs-range->char-set} produces a fresh character set.

Note that @ascii{} codes are a subset of the Latin-1 codes, which are in
turn a subset of the 16-bit Unicode codes, which are themselves a subset
of the 32-bit UCS-4 codes.  We commit to a specific encoding in this
routine, regardless of the underlying representation of characters, so
that client code using this library will be portable.  I.e., a
conformant Scheme implementation may use EBCDIC or SHIFT-JIS to encode
characters; it must simply map the UCS characters from the given range
into the native representation when possible, and report errors when not
possible.
@end defun


@defun ->char-set @var{x}
Coerces @var{x} into a char-set.  @var{x} may be a string, character or
char-set.  A string is converted to the set of its constituent
characters; a character is converted to a singleton set; a char-set is
returned as--is.

This procedure is intended for use by other procedures that want to
provide ``user--friendly'', wide--spectrum interfaces to their clients.
@end defun


@c page
@node char-set spec query
@subsection Querying char sets


@defun char-set-size @var{cs}
Return the number of elements in character set @var{cs}.
@end defun


@defun char-set-count @var{pred} @var{cs}
Apply @var{pred} to the chars of character set @var{cs}, and return the
number of chars that caused the predicate to return true.
@end defun


@defun char-set->list @var{cs}
This procedure returns a list of the members of character set @var{cs}.
The order in which @var{cs}'s characters appear in the list is not
defined, and may be different from one call to another.
@end defun


@defun char-set->string @var{cs}
This procedure returns a string containing the members of character set
@var{cs}.  The order in which @var{cs}'s characters appear in the string
is not defined, and may be different from one call to another.
@end defun


@defun char-set-contains? @var{cs} @var{char}
This procedure tests char for membership in character set @var{cs}.
@end defun


@defun char-set-every @var{pred} @var{cs}
@defunx char-set-any @var{pred} @var{cs}
@func{char-set-every} returns true if predicate @var{pred} returns true
of every character in the character set @var{cs}.

@func{char-set-any} applies pred to every character in character set
@var{cs}, and returns the first true value it finds.  If no character
produces a true value, it returns @false{}.

The order in which these procedures sequence through the elements of
@var{cs} is not specified.

Note that if you need to determine the actual character on which a
predicate returns true, use @func{char-set-any} and arrange for the
predicate to return the character parameter as its true value, e.g.

@example
(char-set-any
    (lambda (c)
      (and (char-upper-case? c) c))
  cs)
@end example
@end defun


@c page
@node char-set spec algebra
@subsection Char sets algebra


@defun char-set-adjoin @var{cs} @var{char1} ...
@defunx char-set-delete @var{cs} @var{char1} ...
Add/delete the @var{chari} characters to/from character set @var{cs}.
@end defun


@defun char-set-adjoin! @var{cs} @var{char1} ...
@defunx char-set-delete! @var{cs} @var{char1} ...
Linear--update variants.  These procedures are allowed, but not
required, to side--effect their first parameter.
@end defun


@defun char-set-complement @var{cs}
@defunx char-set-union @var{cs1} ...
@defunx char-set-intersection @var{cs1} ...
@defunx char-set-difference @var{cs1} @var{cs2} ...
@defunx char-set-xor @var{cs1} ...
@defunx char-set-diff+intersection @var{cs1} @var{cs2} ...
These procedures implement set complement, union, intersection,
difference, and exclusive--or for character sets.

The union, intersection and xor operations are @var{n}--ary.  The
difference function is also @var{n}--ary, associates to the left (that
is, it computes the difference between its first argument and the union
of all the other arguments), and requires at least one argument.

Boundary cases:

@example
(char-set-union) => char-set:empty
(char-set-intersection) => char-set:full
(char-set-xor) => char-set:empty
(char-set-difference cs) => cs
@end example

@func{char-set-diff+intersection} returns 2 values: the difference and
the intersection of the arguments; it partitions its first parameter.
It is equivalent to:

@example
(values (char-set-difference cs1 cs2 ...)
        (char-set-intersection cs1 (char-set-union cs2 ...)))
@end example

@noindent
but can be implemented more efficiently.

Programmers should be aware that @func{char-set-complement} could
potentially be a very expensive operation in Scheme implementations that
provide a very large character type, such as 32-bit Unicode.  If this is
a possibility, sets can be complemented with respect to a smaller
universe using @func{char-set-difference}.
@end defun


@defun char-set-complement! @var{cs}
@defunx char-set-union! @var{cs1} @var{cs2} ...
@defunx char-set-intersection! @var{cs1} @var{cs2} ...
@defunx char-set-difference! @var{cs1} @var{cs2} ...
@defunx char-set-xor! @var{cs1} @var{cs2} ...
@defunx char-set-diff+intersection! @var{cs1} @var{cs2} @var{cs3} ...
These are linear--update variants of the set--algebra functions.  They
are allowed, but not required, to side--effect their first (required)
parameter.

@func{char-set-diff+intersection!} is allowed to side--effect both of
its two required parameters.
@end defun


@c page
@node char-set spec sets
@subsection Standard char sets


Several character sets are predefined for convenience:

@vtable @code
@item char-set:lower-case
Lower-case letters.

@item char-set:upper-case
Upper-case letters.

@item char-set:title-case
Title-case letters.

@item char-set:letter
Letters.

@item char-set:digit
Digits.

@item char-set:letter+digit
Letters and digits.

@item char-set:graphic
Printing characters except spaces.

@item char-set:printing
Printing characters including spaces.

@item char-set:whitespace
Whitespace characters.

@item char-set:iso-control
The ISO control characters.

@item char-set:punctuation
Punctuation characters.

@item char-set:symbol
Symbol characters.

@item char-set:hex-digit
A hexadecimal digit: 0-9, A-F, a-f.

@item char-set:blank
Blank characters -- horizontal whitespace.

@item char-set:ascii
All characters in the ASCII set..

@item char-set:empty
Empty set.

@item char-set:full
All characters.
@end vtable

Note that there may be characters in @code{char-set:letter} that are
neither upper or lower case; this might occur in implementations that
use a character type richer than @ascii{}, such as Unicode.  A ``graphic
character'' is one that would put ink on your page.  While the exact
composition of these sets may vary depending upon the character type
provided by the underlying Scheme system, here are the definitions for
some of the sets in an @ascii{} implementation:

@example
char-set:lower-case     a-z
char-set:upper-case     A-Z
char-set:letter         A-Z and a-z
char-set:digit          0123456789
char-set:punctuation    !"#%&'()*,-./:;?@@[\]_@{@}
char-set:symbol         $+<=>^`|~
char-set:whitespace     Space, newline, tab, form feed,
                        vertical tab, carriage return
char-set:blank          Space and tab
char-set:graphic        letter + digit + punctuation + symbol
char-set:printing       graphic + whitespace
char-set:iso-control    ASCII 0-31 and 127
@end example

Note that the existence of the @code{char-set:ascii} set implies that
the underlying character set is required to be at least as rich as
@ascii{} (including @ascii{}'s control characters).

@quotation
@emph{Rationale:} The name choices reflect a shift from the older
``alphabetic/numeric'' terms found in @rnrs{5} and @posix{} to newer,
Unicode--influenced ``letter/digit'' lexemes.
@end quotation


@c ------------------------------------------------------------

@subheading Unicode, Latin-1 and @ascii{} definitions of the standard character sets


In Unicode Scheme implementations, the base character sets are
compatible with Java's Unicode specifications.  For @ascii{} or Latin-1,
we simply restrict the Unicode set specifications to their first 128 or
256 codes, respectively.  Scheme implementations that are not based on
@ascii{}, Latin-1 or Unicode should attempt to preserve the sense or
spirit of these definitions.

The following descriptions frequently make reference to the ``Unicode
character database''.  This is a file, available at:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}

Each line contains a description of a Unicode character.  The first
semicolon--delimited field of the line gives the hex value of the
character's code; the second field gives the name of the character, and
the third field gives a two--letter category.  Other fields give simple
1-1 case--mappings for the character and other information; see:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html}

@noindent
for further description of the file's format.  Note in particular the
two--letter category specified in the the third field, which is
referenced frequently in the descriptions below.


@subsubheading char-set:lower-case

For Unicode, we follow Java's specification: a character is lowercase if:

@itemize
@item
it is not in the range [U+2000,U+2FFF];

@item
the Unicode attribute table does not give a lowercase mapping for it;

@item at least one of the following is true:

@itemize
@item
the Unicode attribute table gives a mapping to uppercase for the
character;

@item
the name for the character in the Unicode attribute table contains the
words ``SMALL LETTER'' or ``SMALL LIGATURE''.
@end itemize
@end itemize

The lower--case @ascii{} characters are:

@example
abcdefghijklmnopqrstuvwxyz
@end example

Latin-1 adds another 33 lower--case characters to the @ascii{} set:

@example
00B5    MICRO SIGN
00DF    LATIN SMALL LETTER SHARP S
00E0    LATIN SMALL LETTER A WITH GRAVE
00E1    LATIN SMALL LETTER A WITH ACUTE
00E2    LATIN SMALL LETTER A WITH CIRCUMFLEX
00E3    LATIN SMALL LETTER A WITH TILDE
00E4    LATIN SMALL LETTER A WITH DIAERESIS
00E5    LATIN SMALL LETTER A WITH RING ABOVE
00E6    LATIN SMALL LETTER AE
00E7    LATIN SMALL LETTER C WITH CEDILLA
00E8    LATIN SMALL LETTER E WITH GRAVE
00E9    LATIN SMALL LETTER E WITH ACUTE
00EA    LATIN SMALL LETTER E WITH CIRCUMFLEX
00EB    LATIN SMALL LETTER E WITH DIAERESIS
00EC    LATIN SMALL LETTER I WITH GRAVE
00ED    LATIN SMALL LETTER I WITH ACUTE
00EE    LATIN SMALL LETTER I WITH CIRCUMFLEX
00EF    LATIN SMALL LETTER I WITH DIAERESIS
00F0    LATIN SMALL LETTER ETH
00F1    LATIN SMALL LETTER N WITH TILDE
00F2    LATIN SMALL LETTER O WITH GRAVE
00F3    LATIN SMALL LETTER O WITH ACUTE
00F4    LATIN SMALL LETTER O WITH CIRCUMFLEX
00F5    LATIN SMALL LETTER O WITH TILDE
00F6    LATIN SMALL LETTER O WITH DIAERESIS
00F8    LATIN SMALL LETTER O WITH STROKE
00F9    LATIN SMALL LETTER U WITH GRAVE
00FA    LATIN SMALL LETTER U WITH ACUTE
00FB    LATIN SMALL LETTER U WITH CIRCUMFLEX
00FC    LATIN SMALL LETTER U WITH DIAERESIS
00FD    LATIN SMALL LETTER Y WITH ACUTE
00FE    LATIN SMALL LETTER THORN
00FF    LATIN SMALL LETTER Y WITH DIAERESIS
@end example

Note that three of these have no corresponding Latin-1 upper--case
character:

@example
00B5    MICRO SIGN
00DF    LATIN SMALL LETTER SHARP S
00FF    LATIN SMALL LETTER Y WITH DIAERESIS
@end example

The compatibility micro character uppercases to the non--Latin-1 Greek
capital mu; the German sharp s character uppercases to the pair of
characters ``SS'', and the capital y--with--diaeresis is non--Latin-1.

@c ------------------------------------------------------------

@subsubheading char-set:upper-case

For Unicode, we follow Java's specification: a character is uppercase if

@itemize
@item
it is not in the range @code{[U+2000, U+2FFF]};

@item
the Unicode attribute table does not give an uppercase mapping for it
(this excludes titlecase characters);

@item
at least one of the following is true:

@itemize
@item
the Unicode attribute table gives a mapping to lowercase for the
character;

@item
the name for the character in the Unicode attribute table contains the
words ``CAPITAL LETTER'' or ``CAPITAL LIGATURE''.
@end itemize
@end itemize

The upper--case @ascii{} characters are:

@example
ABCDEFGHIJKLMNOPQRSTUVWXYZ
@end example

Latin-1 adds another 30 upper--case characters to the @ascii{} set:

@example
00C0    LATIN CAPITAL LETTER A WITH GRAVE
00C1    LATIN CAPITAL LETTER A WITH ACUTE
00C2    LATIN CAPITAL LETTER A WITH CIRCUMFLEX
00C3    LATIN CAPITAL LETTER A WITH TILDE
00C4    LATIN CAPITAL LETTER A WITH DIAERESIS
00C5    LATIN CAPITAL LETTER A WITH RING ABOVE
00C6    LATIN CAPITAL LETTER AE
00C7    LATIN CAPITAL LETTER C WITH CEDILLA
00C8    LATIN CAPITAL LETTER E WITH GRAVE
00C9    LATIN CAPITAL LETTER E WITH ACUTE
00CA    LATIN CAPITAL LETTER E WITH CIRCUMFLEX
00CB    LATIN CAPITAL LETTER E WITH DIAERESIS
00CC    LATIN CAPITAL LETTER I WITH GRAVE
00CD    LATIN CAPITAL LETTER I WITH ACUTE
00CE    LATIN CAPITAL LETTER I WITH CIRCUMFLEX
00CF    LATIN CAPITAL LETTER I WITH DIAERESIS
00D0    LATIN CAPITAL LETTER ETH
00D1    LATIN CAPITAL LETTER N WITH TILDE
00D2    LATIN CAPITAL LETTER O WITH GRAVE
00D3    LATIN CAPITAL LETTER O WITH ACUTE
00D4    LATIN CAPITAL LETTER O WITH CIRCUMFLEX
00D5    LATIN CAPITAL LETTER O WITH TILDE
00D6    LATIN CAPITAL LETTER O WITH DIAERESIS
00D8    LATIN CAPITAL LETTER O WITH STROKE
00D9    LATIN CAPITAL LETTER U WITH GRAVE
00DA    LATIN CAPITAL LETTER U WITH ACUTE
00DB    LATIN CAPITAL LETTER U WITH CIRCUMFLEX
00DC    LATIN CAPITAL LETTER U WITH DIAERESIS
00DD    LATIN CAPITAL LETTER Y WITH ACUTE
00DE    LATIN CAPITAL LETTER THORN
@end example

@c ------------------------------------------------------------

@subsubheading char-set:title-case

In Unicode, a character is titlecase if it has the category @code{Lt} in
the character attribute database.  There are very few of these
characters; here is the entire 31-character list as of Unicode 3.0:

@example
01C5    LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON
01C8    LATIN CAPITAL LETTER L WITH SMALL LETTER J
01CB    LATIN CAPITAL LETTER N WITH SMALL LETTER J
01F2    LATIN CAPITAL LETTER D WITH SMALL LETTER Z
1F88    GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI
1F89    GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI
1F8A    GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
1F8B    GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
1F8C    GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
1F8D    GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
1F8E    GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
1F8F    GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
1F98    GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI
1F99    GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI
1F9A    GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
1F9B    GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
1F9C    GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
1F9D    GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
1F9E    GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
1F9F    GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
1FA8    GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI
1FA9    GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI
1FAA    GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
1FAB    GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
1FAC    GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
1FAD    GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
1FAE    GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
1FAF    GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
1FBC    GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI
1FCC    GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI
1FFC    GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI
@end example

There are no @ascii{} or Latin-1 titlecase characters.

@c ------------------------------------------------------------

@subsubheading char-set:letter

In Unicode, a letter is any character with one of the letter categories
(@code{Lu}, @code{Ll}, @code{Lt}, @code{Lm}, @code{Lo}) in the Unicode
character database.

There are 52 @ascii{} letters:

@example
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
@end example

There are 117 Latin-1 letters.  These are the 115 characters that are
members of the Latin-1 @code{char-set:lower-case} and
@code{char-set:upper-case} sets, plus:

@example
00AA    FEMININE ORDINAL INDICATOR
00BA    MASCULINE ORDINAL INDICATOR
@end example

These two letters are considered lower--case by Unicode, but not by Java
or @ansrfi{14}.

@c ------------------------------------------------------------

@subsubheading char-set:digit

In Unicode, a character is a digit if it has the category @code{Nd} in
the character attribute database.  In Latin-1 and @ascii{}, the only
such characters are @code{0123456789}.  In Unicode, there are other
digit characters in other code blocks, such as Gujarati digits and
Tibetan digits.

@c ------------------------------------------------------------

@subsubheading char-set:hex-digit

The only hex digits are @code{0123456789abcdefABCDEF}.

@c ------------------------------------------------------------

@subsubheading char-set:letter+digit

The union of @code{char-set:letter} and @code{char-set:digit}.

@c ------------------------------------------------------------

@subsubheading char-set:graphic

A graphic character is one that would put ink on paper.  The @ascii{}
and Latin-1 graphic characters are the members of:

@example
char-set:letter
char-set:digit
char-set:punctuation
char-set:symbol
char-set:printing
@end example

A printing character is one that would occupy space when printed, i.e.,
a graphic character or a space character.  @code{char-set:printing} is
the union of @code{char-set:whitespace} and @code{char-set:graphic}.

@c ------------------------------------------------------------

@subsubheading char-set:whitespace

In Unicode, a whitespace character is either:

@itemize
@item
a character with one of the space, line, or paragraph separator
categories (Zs, Zl or Zp) of the Unicode character database.

@item
@code{U+0009} Horizontal tabulation (\t control-I).

@item
@code{U+000A} Line feed (\n control-J).

@item
@code{U+000B} Vertical tabulation (\v control-K).

@item
@code{U+000C} Form feed (\f control-L).

@item
@code{U+000D} Carriage return (\r control-M).
@end itemize

There are 24 whitespace characters in Unicode 3.0:

@example
0009    HORIZONTAL TABULATION   \t control-I
000A    LINE FEED               \n control-J
000B    VERTICAL TABULATION     \v control-K
000C    FORM FEED               \f control-L
000D    CARRIAGE RETURN         \r control-M
0020    SPACE                   Zs
00A0    NO-BREAK SPACE          Zs
1680    OGHAM SPACE MARK        Zs
2000    EN QUAD                 Zs
2001    EM QUAD                 Zs
2002    EN SPACE                Zs
2003    EM SPACE                Zs
2004    THREE-PER-EM SPACE      Zs
2005    FOUR-PER-EM SPACE       Zs
2006    SIX-PER-EM SPACE        Zs
2007    FIGURE SPACE            Zs
2008    PUNCTUATION SPACE       Zs
2009    THIN SPACE              Zs
200A    HAIR SPACE              Zs
200B    ZERO WIDTH SPACE        Zs
2028    LINE SEPARATOR          Zl
2029    PARAGRAPH SEPARATOR     Zp
202F    NARROW NO-BREAK SPACE   Zs
3000    IDEOGRAPHIC SPACE       Zs
@end example

The @ascii{} whitespace characters are the first six characters in the
above list; line feed, horizontal tabulation, vertical tabulation, form
feed, carriage return, and space.  These are also exactly the characters
recognised by the @posix{} @cfunc{isspace} procedure.  Latin-1 adds the
no-break space.

@c ------------------------------------------------------------

@subsubheading char-set:iso-control

The @iso{} control characters are the Unicode/Latin-1 characters in the
ranges @code{[U+0000, U+001F]} and @code{[U+007F, U+009F]}.

@ascii{} restricts this set to the characters in the range
@code{[U+0000, U+001F]} plus the character @code{U+007F}.

Note that Unicode defines other control characters which do not belong
to this set (hence the qualifying prefix @code{iso-} in the name).

@c ------------------------------------------------------------

@subsubheading char-set:punctuation

In Unicode, a punctuation character is any character that has one of the
punctuation categories in the Unicode character database (@code{Pc},
@code{Pd}, @code{Ps}, @code{Pe}, @code{Pi}, @code{Pf}, or @code{Po}.)

ASCII has 23 punctuation characters:

@example
!"#%&'()*,-./:;?@@[\]_@{@}
@end example

Latin-1 adds six more:

@example
00A1    INVERTED EXCLAMATION MARK
00AB    LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
00AD    SOFT HYPHEN
00B7    MIDDLE DOT
00BB    RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
00BF    INVERTED QUESTION MARK
@end example

Note that the nine @ascii{} characters @code{$+<=>^`|~} are not
punctuation.  They are ``symbols''.

@c ------------------------------------------------------------

@subsubheading char-set:symbol

In Unicode, a symbol is any character that has one of the symbol
categories in the Unicode character database (@code{Sm}, @code{Sc},
@code{Sk}, or @code{So}).

There are nine @ascii{} symbol characters:

@example
$+<=>^`|~
@end example

Latin-1 adds 18 more:

@example
00A2    CENT SIGN
00A3    POUND SIGN
00A4    CURRENCY SIGN
00A5    YEN SIGN
00A6    BROKEN BAR
00A7    SECTION SIGN
00A8    DIAERESIS
00A9    COPYRIGHT SIGN
00AC    NOT SIGN
00AE    REGISTERED SIGN
00AF    MACRON
00B0    DEGREE SIGN
00B1    PLUS-MINUS SIGN
00B4    ACUTE ACCENT
00B6    PILCROW SIGN
00B8    CEDILLA
00D7    MULTIPLICATION SIGN
00F7    DIVISION SIGN
@end example

@c ------------------------------------------------------------

@subsubheading char-set:blank

Blank chars are horizontal whitespace.  In Unicode, a blank character is
either:

@itemize
@item
a character with the space separator category (@code{Zs}) in the Unicode
character database;

@item
@code{U+0009} Horizontal tabulation (\t control-I).
@end itemize

There are eighteen blank characters in Unicode 3.0:

@example
0009    HORIZONTAL TABULATION   \t control-I
0020    SPACE                   Zs
00A0    NO-BREAK SPACE          Zs
1680    OGHAM SPACE MARK        Zs
2000    EN QUAD                 Zs
2001    EM QUAD                 Zs
2002    EN SPACE                Zs
2003    EM SPACE                Zs
2004    THREE-PER-EM SPACE      Zs
2005    FOUR-PER-EM SPACE       Zs
2006    SIX-PER-EM SPACE        Zs
2007    FIGURE SPACE            Zs
2008    PUNCTUATION SPACE       Zs
2009    THIN SPACE              Zs
200A    HAIR SPACE              Zs
200B    ZERO WIDTH SPACE        Zs
202F    NARROW NO-BREAK SPACE   Zs
3000    IDEOGRAPHIC SPACE       Zs
@end example

The @ascii{} blank characters are the first two characters above;
horizontal tab and space.  Latin-1 adds the no--break space.


@c page
@node char-set ack
@section Acknowledgements


The design of this library benefited greatly from the feedback provided
during the SRFI discussion phase.  Among those contributing thoughtful
commentary and suggestions, both on the mailing list and by private
discussion, were Paolo Amoroso, Lars Arvestad, Alan Bawden, Jim Bender,
Dan Bornstein, Per Bothner, Will Clinger, Brian Denheyer, Kent Dybvig,
Sergei Egorov, Marc Feeley, Matthias Felleisen, Will Fitzgerald, Matthew
Flatt, Arthur A. Gleckler, Ben Goetter, Sven Hartrumpf, Erik Hilsdale,
Shiro Kawai, Richard Kelsey, Oleg Kiselyov, Bengt Kleberg, Donovan
Kolbly, Bruce Korb, Shriram Krishnamurthi, Bruce Lewis, Tom Lord, Brad
Lucier, Dave Mason, David Rush, Klaus Schilling, Jonathan Sobel, Mike
Sperber, Mikael Staldal, Vladimir Tsyshevsky, Donald Welsh, and Mike
Wilson.  I am grateful to them for their assistance.

I am also grateful the authors, implementors and documentors of all the
systems mentioned in the introduction.  Aubrey Jaffer should be noted
for his work in producing Web--accessible versions of the @rnrs{5} spec,
which was a tremendous aid.

This is not to imply that these individuals necessarily endorse the
final results, of course.

During this document's long development period, great patience was
exhibited by Mike Sperber, who is the editor for the @srfi{}, and by
Hillary Sullivan, who is not.


@c page
@node args-fold
@chapter A program argument processor


@cindex @srfi{} args-fold


The @library{srfi args-fold} has been written by Anthony Carrico as the
reference implementation for @ansrfi{37}.

@menu
* args-fold license::           Original license.
* args-fold abstract::          Abstract.
* args-fold rationale::         Rationale.
* args-fold spec::              Specification.
@end menu


@c page
@node args-fold license
@section Original license


Copyright @copyright{} 2002 Anthony Carrico (2002).  All Rights
Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node args-fold abstract
@section Abstract


Many operating systems make the set of argument strings used to invoke a
program available (often following the program name string in an array
called @code{argv}).  Most programs need to parse and process these
argument strings in one way or another.  This @srfi{} describes a set
of procedures that support processing program arguments according to
@posix{} and @gnu{} C Library Reference Manual guidelines.


@c page
@node args-fold rationale
@section Rationale


Program arguments are the primary interface to many programs, so
processing arguments is a common programming task.  There are many common
(often conflicting) ways take care of this task, so a custom processor
is often necessary; however, many programmers (and their users) would
welcome a convenient interface supporting common guidelines.

@posix{} provides several guidelines for the specification of program
options, option--arguments, and operands.  It also notes historical
exceptions to these guidelines.  The @gnu{} C Library Reference Manual
describes long option extensions to the @posix{} guidelines.

This @srfi{} supports creating programs following the guidelines
mentioned above by:

@itemize
@item
parsing short--options and long--options in any order and possibly
repeated;

@item
option-arguments (possibly required or forbidden);

@item
operands (non-option argument strings);

@item
recognizing option processing termination.
@end itemize

It parses argument strings according to the following rules:

@enumerate
@item
each short--option name is a single character;

@item
one or more short--options are accepted in a single argument string when
grouped behind one @code{-} delimiter character; examples: @code{-a},
@code{-bcd};

@item
a short--option--argument is accepted in a separate argument string
immediately following a short--option; examples: @code{-a foo},
@code{-bcd bar};

@item
also (for historical reasons) a short--option--argument is accepted
immediately following the last short--option in a single argument
string; examples: @code{-afoo}, @code{-bcdbar};

@item
each long--option name is one or more characters;

@item
one long--option is accepted in a single argument string when preceded
by two @code{-} delimiter characters; example: @code{--help};

@item
in a single argument string, a long--option followed by one @code{=}
delimiter character followed by a long--option--argument is accepted;
example: @code{--speed=fast};

@item
the first @code{--} argument string is accepted as a delimiter
indicating the end of options; it is not treated as an option or an
operand; any argument strings following this delimiter are treated as
operands, even if they begin with the @code{-} character;

@item
all other argument strings are treated as operands; this includes
argument strings consisting of a single - character;

@item
operands may be intermingled with options in any order.
@end enumerate

Preliminary versions of this interface are already available for some
Scheme implementations: here for Chicken, and here for Scsh.



@c page
@node args-fold spec
@section Specification


@findex args-fold


@func{args-fold} is an iterator similar to @ansrfi{1} fold procedure
(``the fundamental list iterator'').  As it parses options and operands,
it calls their corresponding operand and option processors.  Unlike
mapping, folding passes state, called seeds, from one processor to the
next.

For example, a program may need a list of operands and a table of
options.  To build these, @func{args-fold} could be seeded with an empty
operand list, and an empty option table.  The operand processor could
add the operands to the operand list, and the option processors could
add the options to the option table.  Along the way, some option
processors might even take immediate action for options like
@code{--version} or @code{--help}.  This kind of heterogeneous
processing is appropriate for program arguments, and folding allows a
functional implementation if desired.


@deffn {Procedure Prototype} option-processor @var{option} @var{name} @var{arg} @var{seeds} ...
Prototype for an option--processor.  It should return the next seeds as
values.  @var{option} will be the option.  @var{name} will be one of the
@var{OPTION}'s option--names as encountered by @func{args-fold}.
@var{arg} will be a string, or @false{} if @func{args-fold} didn't
encounter an option--argument.
@end deffn


@deffn {Procedure Prototype} operand-processor @var{operand} @var{seeds}
Prototype for an operand--processor.  It should return the next seeds as
values.  @var{operand} will be a string.
@end deffn


@defun option @var{names} @var{required-arg?} @var{optional-arg?} @var{option-proc}
Return an option.  @var{names} is a list of short (character) and long
(string) option names.  @var{required-arg?} specifies if this options
requires an option--argument (boolean).  @var{optional-arg?} specifies
if this option can accept an option--argument (boolean).
@var{option-proc} is a procedure (following the option--processor
prototype) used to process this option.
@end defun


@defun option-names @var{option}
@defunx option-required-arg? @var{option}
@defunx option-optional-arg? @var{option}
@defunx option-processor @var{option}
Return the contents of corresponding fields of @var{option}.
@end defun


@defun args-fold @var{args} @var{options} @var{unrecognized-option-proc} @var{operand-proc} @var{seeds} ...
Parse argument strings left--to--right, calling the appropriate
processors in--order (for the parsed known options, unknown options, and
operands), passing the seed values from one processor to the next and
returning the final seeds values as results.

@var{args} is a list of strings.  @var{options} is a list of options.
@var{unrecognized-option-proc} is a procedure (following the
@code{option-processor} prototype) for unrecognized options.
@func{operand-proc} is a procedure (following the
@code{operand-processor} prototype) for operands.

@emph{Note:} @func{args-fold} will create temporary options as necessary
for the @func{unrecognized-option-proc}.
@end defun


@c page
@node streams
@chapter Streams


@cindex @srfi{} streams

The following libraries:

@example
(srfi streams)
(srfi streams primitive)
(srfi streams derived)
@end example

@noindent
are written by Philip L. Bewig as the reference implementation for
@ansrfi{41}.


@menu
* streams license::             Streams document license.
* streams abstract::            Abstract.
* streams rationale::           Rationale.
* streams primitive::           The @library{streams primitive} library.
* streams primitive example::   Streams primitive library example.
* streams derived::             The @library{streams derived} library.
* streams utilities::           Utilities.
* streams examples::            Examples.
* streams ack::                 Acknowledgments.
* streams references::          References.
@end menu


@c page
@node streams license
@section Streams document license


Copyright @copyright{} 2007, 2008 by Philip L. Bewig.  All Rights
Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node streams abstract
@section Abstract


@cindex @srfi{} streams abstract


Streams, sometimes called lazy lists, are a sequential data structure
containing elements computed only on demand.  A stream is either null or
is a pair with a stream in its cdr.  Since elements of a stream are
computed only when accessed, streams can be infinite.  Once computed, the
value of a stream element is cached in case it is needed again.

Streams without memoization were first described by Peter Landin in
1965.  Memoization became accepted as an essential feature of streams
about a decade later.  Today, streams are the signature data type of
functional programming languages such as Haskell.

This Scheme Request for Implementation describes two libraries for
operating on streams: a canonical set of stream primitives and a set of
procedures and syntax derived from those primitives that permits
convenient expression of stream operations.  They rely on facilities
provided by @rnrs{6}, including libraries, records, and error reporting.



@c page
@node streams rationale
@section Rationale


@cindex @srfi{} streams rationale


Harold Abelson and Gerald Jay Sussman discuss streams at length, giving
a strong justification for their use.  The streams they provide are
represented as a cons pair with a promise to return a stream in its cdr;
for instance, a stream with elements the first three counting numbers is
represented conceptually as:

@example
(cons 1 (delay (cons 2 (delay (cons 3 (delay '()))))))
@end example

Philip Wadler, Walid Taha and David MacQueen describe such streams as
odd because, regardless of their length, the parity of the number of
constructors (@func{delay}, @func{cons}, @code{(quote ())}) in the
stream is odd.

The streams provided here differ from those of Abelson and Sussman,
being represented as promises that contain a cons pair with a stream in
its cdr; for instance, the stream with elements the first three counting
numbers is represented conceptually as:

@example
(delay (cons 1 (delay (cons 2 (delay (cons 3 (delay '())))))))
@end example

@noindent
this is an even stream because the parity of the number of constructors
in the stream is even.

Even streams are more complex than odd streams in both definition and
usage, but they offer a strong benefit: they fix the off--by--one error
of odd streams.  Wadler, Taha and MacQueen show, for instance, that an
expression like:

@example
(stream->list 4 (stream-map / (stream-from 4 -1)))
@end example

@noindent
evaluates to @code{(1/4 1/3 1/2 1)} using even streams but fails with a
divide--by--zero error using odd streams, because the next element in
the stream, which will be 1/0, is evaluated before it is accessed.  This
extra bit of laziness is not just an interesting oddity; it is vitally
critical in many circumstances, as will become apparent below.

When used effectively, the primary benefit of streams is improved
modularity.  Consider a process that takes a sequence of items,
operating on each in turn.  If the operation is complex, it may be
useful to split it into two or more procedures in which the
partially--processed sequence is an intermediate result.  If that
sequence is stored as a list, the entire intermediate result must reside
in memory all at once; however, if the intermediate result is stored as
a stream, it can be generated piecemeal, using only as much memory as
required by a single item.  This leads to a programming style that uses
many small operators, each operating on the sequence of items as a
whole, similar to a pipeline of unix commands.

In addition to improved modularity, streams permit a clear exposition of
backtracking algorithms using the ``stream of successes'' technique, and
they can be used to model generators and co--routines.  The implicit
memoization of streams makes them useful for building persistent data
structures, and the laziness of streams permits some multi--pass
algorithms to be executed in a single pass.  Savvy programmers use
streams to enhance their programs in countless ways.

There is an obvious space/time trade--off between lists and streams;
lists take more space, but streams take more time (to see why, look at
all the type conversions in the implementation of the stream
primitives).  Streams are appropriate when the sequence is truly
infinite, when the space savings are needed, or when they offer a
clearer exposition of the algorithms that operate on the sequence.



@c page
@node streams primitive
@section The @library{streams primitive} library


@cindex @srfi{} streams primitive library


The @library{streams primitive} library provides two mutually--recursive
abstract data types: An object of the @code{stream} abstract data type
is a promise that, when forced, is either @code{stream-null} or is an
object of type @code{stream-pair}.  An object of the @code{stream-pair}
abstract data type contains a @code{stream-car} and a @code{stream-cdr},
which must be a @code{stream}.  The essential feature of streams is the
systematic suspensions of the recursive promises between the two data
types.

@example
alpha stream
  :: (promise stream-null)
  |  (promise (alpha stream-pair))

alpha stream-pair
  :: (promise alpha) x (promise (alpha stream))
@end example

The object stored in the @code{stream-car} of a @code{stream-pair} is a
promise that is forced the first time the @code{stream-car} is accessed;
its value is cached in case it is needed again.  The object may have any
type, and different stream elements may have different types.  If the
@code{stream-car} is never accessed, the object stored there is never
evaluated.  Likewise, the @code{stream-cdr} is a promise to return a
stream, and is only forced on demand.

This library provides eight operators: constructors for
@code{stream-null} and @code{stream-pairs}, type recognizers for streams
and the two kinds of streams, accessors for both fields of a
@code{stream-pair}, and a lambda that creates procedures that return
streams.


@defun stream-null
Return a promise that, when forced, is a single object, distinguishable
from all other objects, that represents the null stream.
@func{stream-null} is immutable and unique.
@end defun


@deffn Syntax stream-cons @var{object} @var{stream}
A macro that accepts an object and a stream and creates a
newly--allocated stream containing a promise that, when forced, is a
@code{stream-pair} with the object in its @code{stream-car} and the
stream in its @code{stream-cdr}.

@func{stream-cons} must be syntactic, not procedural, because neither
@var{object} nor @var{stream} is evaluated when @func{stream-cons} is
called.  Since @var{stream} is not evaluated, when the
@code{stream-pair} is created, it is not an error to call
@func{stream-cons} with a @var{stream} argument that is not of type
@code{stream}; however, doing so will cause an error later when the
@code{stream-cdr} of the @code{stream-pair} is accessed.

Once created, a @code{stream-pair} is immutable; there is @strong{no}
@func{stream-set-car!} or @func{stream-set-cdr!} that modifies an
existing @code{stream-pair}.  There is no dotted--pair or improper
stream as with lists.
@end deffn


@defun stream? @var{object}
Return @true{} if the @var{object} is a @code{stream} and @false{}
otherwise.  If @var{object} is a @code{stream}, @func{stream?} does not
force its promise.

If @code{(stream? obj)} is @true{}, then one of @code{(stream-null?
obj)} and @code{(stream-pair? obj)} will be @true{} and the other will
be @false{}; if @code{(stream? obj)} is @false{}, both
@code{(stream-null?  obj)} and @code{(stream-pair?  obj)} will be
@false{}.
@end defun


@defun stream-null? @var{object}
Return @true{} if the @var{object} is the distinguished null stream and
@false{} otherwise.  If @var{object} is a @code{stream},
@func{stream-null?} must force its promise in order to distinguish
@code{stream-null} from @code{stream-pair}.
@end defun


@defun stream-pair? @var{object}
Take an @var{object} and return @true{} if it is a @code{stream-pair}
constructed by @func{stream-cons} and @false{} otherwise.  If
@var{object} is a @code{stream}, @func{stream-pair?} must force its
promise in order to distinguish @code{stream-null} from
@code{stream-pair}.
@end defun


@defun stream-car @var{stream}
Return the object stored in the @code{stream-car} of @var{stream}.
@func{stream-car} signals an error if the object passed to it is not a
@code{stream-pair}.  Calling @func{stream-car} causes the object stored
there to be evaluated if it has not yet been; the object's value is
cached in case it is needed again.
@end defun


@defun stream-cdr @var{stream}
Return the stream stored in the @code{stream-cdr} of @var{stream}.
@func{stream-cdr} signals an error if the object passed to it is not a
@code{stream-pair}.  Calling @func{stream-cdr} does not force the
promise containing the stream stored in the @code{stream-cdr} of the
stream.
@end defun


@deffn Syntax stream-lambda @var{args} . @var{body}
Create a procedure that returns a promise to evaluate the body of the
procedure.  The last body expression to be evaluated must yield a
stream.

As with normal lambda, @var{args} may be a single variable name, in
which case all the formal arguments are collected into a single list, or
a list of variable names, which may be null if there are no arguments,
proper if there are an exact number of arguments, or dotted if a fixed
number of arguments is to be followed by zero or more arguments
collected into a list.

@var{body} must contain at least one expression, and may contain
internal definitions preceding any expressions to be evaluated.
@end deffn



@c page
@node streams primitive example
@section Streams primitive library example


@example
(define strm123
  (stream-cons 1
    (stream-cons 2
      (stream-cons 3
        stream-null))))

(stream-car strm123) => 1

(stream-car (stream-cdr strm123) => 2

(stream-pair?
  (stream-cdr
    (stream-cons (/ 1 0) stream-null))) => #f

(stream? (list 1 2 3)) => #f

(define iter
  (stream-lambda (f x)
    (stream-cons x (iter f (f x)))))

(define nats (iter (lambda (x) (+ x 1)) 0))

(stream-car (stream-cdr nats)) => 1

(define stream-add
  (stream-lambda (s1 s2)
    (stream-cons
      (+ (stream-car s1) (stream-car s2))
      (stream-add (stream-cdr s1)
                  (stream-cdr s2)))))

(define evens (stream-add nats nats))

(stream-car evens) => 0

(stream-car (stream-cdr evens)) => 2

(stream-car (stream-cdr (stream-cdr evens))) => 4
@end example



@c page
@node streams derived
@section The @library{streams derived} library


@cindex @srfi{} streams derived library


The @library{streams derived} library provides useful procedures and
syntax that depend on the primitives defined in @ref{streams primitive}.


@deffn Syntax define-stream (@var{name} @var{args}) . @var{body}
Create a procedure that returns a @code{stream}, and may appear anywhere
a normal @func{define} may appear, including as an internal definition,
and may have internal definitions of its own, including other
@func{define-streams}.  The defined procedure takes arguments in the
same way as @func{stream-lambda}.

@func{define-stream} is syntactic sugar on @func{stream-lambda}; see
also @func{stream-let}, which is also a sugaring of
@func{stream-lambda}.

The following example is a simple version of @func{stream-map} that
takes only a single input stream calls itself recursively:

@example
(define-stream (stream-map proc strm)
  (if (stream-null? strm)
      stream-null
      (stream-cons
        (proc (stream-car strm))
        (stream-map proc (stream-cdr strm))))))
@end example
@end deffn


@defun list->stream @var{list-of-objects}
Return a newly--allocated @code{stream} containing in its elements the
objects in the list.  Since the objects are given in a list, they are
evaluated when @func{list->stream} is called, before the @code{stream}
is created.  If the list of objects is null, as in @code{(list->stream
'())}, the null @code{stream} is returned.  See also @func{stream}.

Example:

@example
(define strm123 (list->stream '(1 2 3)))

; fails with divide-by-zero error
(define s (list->stream (list 1 (/ 1 0) -1)))
@end example
@end defun


@defun port->stream [@var{port}]
Return a newly--allocated @code{stream} containing in its elements the
characters on the @var{port}.  If @var{port} is not given it defaults to
the current input port.  The returned @code{stream} has finite length
and is terminated by @code{stream-null}.

It looks like one use of @func{port->stream} would be this:

@example
(define s ;wrong!
  (with-input-from-file filename
    (lambda () (port->stream))))
@end example

@noindent
but that fails, because @func{with-input-from-file} is eager, and closes
the input port prematurely, before the first character is read.  To read
a file into a stream, use:

@example
(define-stream (file->stream filename)
  (let ((p (open-input-file filename)))
    (stream-let loop ((c (read-char p)))
      (if (eof-object? c)
          (begin (close-input-port p)
                 stream-null)
          (stream-cons c
            (loop (read-char p)))))))
@end example
@end defun


@deffn Syntax stream @var{object} ...
Take zero or more objects and create a newly--allocated @code{stream}
containing in its elements the objects, in order.  Since @func{stream}
is syntactic, the objects are evaluated when they are accessed, not when
the @code{stream} is created.  If no objects are given, as in
@code{(stream)}, the null stream is returned.  See also
@func{list->stream}.

Example:

@example
(define strm123 (stream 1 2 3))

; (/ 1 0) not evaluated when stream is created
(define s (stream 1 (/ 1 0) -1))
@end example
@end deffn


@defun stream->list [@var{n}] @var{stream}
Take a natural number @var{n} and a @var{stream} and return a
newly--allocated list containing in its elements the first @var{} items
in the @var{stream}.  If the @var{stream} has less than @var{n} items
all the items in the @var{stream} will be included in the returned list.
If @var{n} is not given it defaults to infinity, which means that unless
@var{stream} is finite @func{stream->list} will never return.

Example:

@example
(stream->list 10
  (stream-map (lambda (x) (* x x))
    (stream-from 0)))
  => (0 1 4 9 16 25 36 49 64 81)
@end example
@end defun


@defun stream-append @var{stream} ...
Return a newly--allocated @code{stream} containing in its elements those
elements contained in its input streams, in order of input.  If any of
the input streams is infinite, no elements of any of the succeeding
input streams will appear in the output stream; thus, if @var{x} is
infinite, @code{(stream-append x y)} is identical to @var{x}.  See also
@func{stream-concat}.

Example: quicksort can be used to sort a @code{stream}, using
@func{stream-append} to build the output; the sort is lazy; so if only
the beginning of the output stream is needed, the end of the stream is
never sorted.

@example
(define-stream (qsort lt? strm)
  (if (stream-null? strm)
      stream-null
      (let ((x (stream-car strm))
            (xs (stream-cdr strm)))
        (stream-append
          (qsort lt?
            (stream-filter
              (lambda (u) (lt? u x))
              xs))
          (stream x)
          (qsort lt?
            (stream-filter
              (lambda (u) (not (lt? u x)))
              xs))))))
@end example

Note also that, when used in tail position as in @func{qsort},
@func{stream-append} does not suffer the poor performance of
@func{append} on lists.  The list version of @func{append} requires
re--traversal of all its list arguments except the last each time it is
called.  But @func{stream-append} is different.  Each recursive call to
@func{stream-append} is suspended; when it is later forced, the
preceding elements of the result have already been traversed, so
tail--recursive loops that produce streams are efficient even when each
element is appended to the end of the result stream.  This also implies
that during traversal of the result only one promise needs to be kept in
memory at a time.
@end defun


@defun stream-concat @var{stream}
Take a @var{stream} consisting of one or more streams and return a
newly--allocated stream containing all the elements of the input
streams.  If any of the streams in the input stream is infinite, any
remaining streams in the input stream will never appear in the output
stream.  See also @func{stream-append}.

Example:

@example
(stream->list
  (stream-concat
    (stream
      (stream 1 2) (stream) (stream 3 2 1))))
  => (1 2 3 2 1)
@end example

Example: the permutations of a finite stream can be determined by
interleaving each element of the stream in all possible positions within
each permutation of the other elements of the stream; @func{interleave}
returns a stream of streams with @var{x} inserted in each possible
position of @var{yy}:

@example
(define-stream (interleave x yy)
  (stream-match yy
    [() (stream (stream x))]
    [(y .  ys)
      (stream-append
        (stream (stream-cons x yy))
        (stream-map
          (lambda (z) (stream-cons y z))
          (interleave x ys)))]))

(define-stream (perms xs)
  (if (stream-null? xs)
      (stream (stream))
      (stream-concat
        (stream-map
          (lambda (ys)
            (interleave (stream-car xs) ys))
          (perms (stream-cdr xs))))))
@end example
@end defun


@defun stream-constant @var{object} ...
Take one or more objects and return a newly--allocated @code{stream}
containing in its elements the objects, repeating the objects in
succession forever.

Example:

@example
(stream-constant 1) => 1 1 1 ...

(stream-constant #t #f) => #t #f #t #f #t #f ...
@end example
@end defun


@defun stream-drop @var{n} @var{stream}
Return the suffix of the input stream that starts at the next element
after the first @var{n} elements.  The output stream shares structure
with the input stream; thus, promises forced in one instance of the
stream are also forced in the other instance of the stream.  If the
input stream has less than @var{n} elements, @func{stream-drop} returns
the null stream.  See also @func{stream-take}.

Example:

@example
(define (stream-split n strm)
  (values (stream-take n strm)
          (stream-drop n strm)))
@end example
@end defun


@defun stream-drop-while @var{pred?} @var{stream}
Return the suffix of the input stream that starts at the first element
@var{x} for which @code{(pred? x)} is @false{}.  The output stream
shares structure with the input stream.  See also
@func{stream-take-while}.

Example: @func{stream-unique} creates a new stream that retains only the
first of any sub--sequences of repeated elements.

@example
(define-stream (stream-unique eql? strm)
  (if (stream-null? strm)
      stream-null
      (stream-cons (stream-car strm)
        (stream-unique eql?
          (stream-drop-while
            (lambda (x)
              (eql? (stream-car strm) x))
            strm)))))
@end example
@end defun


@defun stream-filter @var{pred?} @var{stream}
Return a newly--allocated stream that contains only those elements
@var{x} of the input stream for which @code{(pred? x)} is non--@false{}.

Example:

@example
(stream-filter odd? (stream-from 0))
   => 1 3 5 7 9 ...
@end example
@end defun


@defun stream-fold @var{proc} @var{base} @var{stream}
Apply a binary procedure to @var{base} and the first element of
@var{stream} to compute a new base, then apply the procedure to the new
base and the next element of @var{stream} to compute a succeeding base,
and so on, accumulating a value that is finally returned as the value of
@func{stream-fold} when the end of the @var{stream} is reached.

@var{stream} must be finite, or @func{stream-fold} will enter an
infinite loop.  See also @func{stream-scan}, which is similar to
@func{stream-fold}, but useful for infinite streams.

For readers familiar with other functional languages, this is a
left--fold; there is no corresponding right--fold, since right--fold
relies on finite streams that are fully--evaluated, at which time they
may as well be converted to a list.

Example: @func{stream-fold} is often used to summarize a stream in a
single value, for instance, to compute the maximum element of a stream.

@example
(define (stream-maximum lt? strm)
  (stream-fold
    (lambda (x y) (if (lt? x y) y x))
    (stream-car strm)
    (stream-cdr strm)))
@end example

Example: sometimes, it is useful to have @func{stream-fold} defined only
on non--null streams:

@example
(define (stream-fold-one proc strm)
  (stream-fold proc
    (stream-car strm)
    (stream-cdr strm)))
@end example

@noindent
@func{stream-minimum} can then be defined as:

@example
(define (stream-minimum lt? strm)
  (stream-fold-one
    (lambda (x y) (if (lt? x y) x y))
    strm))
@end example

Example: @func{stream-fold} can also be used to build a stream:

@example
(define-stream (isort lt? strm)
    (define-stream (insert strm x)
      (stream-match strm
        [() (stream x)]
        [(y .  ys)
          (if (lt? y x)
              (stream-cons y (insert ys x))
              (stream-cons x strm))]))
    (stream-fold insert stream-null strm))
@end example
@end defun


@defun stream-for-each @var{proc} @var{stream} ...
Apply a procedure element--wise to corresponding elements of the input
streams for its side--effects; return nothing.  @func{stream-for-each}
stops as soon as any of its input streams is exhausted.

Example: the following procedure displays the contents of a file:

@example
(define (display-file filename)
  (stream-for-each display
    (file->stream filename)))
@end example
@end defun


@defun stream-from @var{first} [@var{step}]
Create a newly--allocated stream that contains @var{first} as its first
element and increments each succeeding element by @var{step}.  If
@var{step} is not given it defaults to @code{1}.  @var{first} and
@var{step} may be of any numeric type.  @func{stream-from} is frequently
useful as a generator in @func{stream-of} expressions.  See also
@func{stream-range} for a similar procedure that creates finite streams.

@func{stream-from} could be implemented as:

@example
(stream-iterate (lambda (x) (+ x step)) first)
@end example

Example:

@example
(define nats (stream-from 0)) => 0 1 2 ...
(define odds (stream-from 1 2)) => 1 3 5 ...
@end example
@end defun


@defun stream-iterate @var{proc} @var{base}
Create a newly--allocated stream containing @var{base} in its first
element and apply @var{proc} to each element in turn to determine the
succeeding element.  See also @func{stream-unfold} and
@func{stream-unfolds}.

Examples:

@example
(stream-iterate (lambda (x) (+ x 1)) 0)
  => 0 1 2 3 4 ...

(stream-iterate (lambda (x) (* x 2)) 1)
  => 1 2 4 8 16 ...
@end example

Given a seed between 0 and 232, exclusive, the following expression
creates a stream of pseudo--random integers between 0 and 232,
exclusive, beginning with seed, using the method described by Stephen
Park and Keith Miller:

@example
(stream-iterate
  (lambda (x) (modulo (* x 16807) 2147483647))
  seed)
@end example

Example: successive of the following stream approach the value of the
``golden ratio'' 1.618...:

@example
(stream-iterate (lambda (x) (+ 1 (/ x))) 1)
@end example
@end defun


@defun stream-length @var{stream}
Take an input stream and return the number of elements in the stream; it
does not evaluate its elements.  @func{stream-length} may only be used
on finite streams; it enters an infinite loop with infinite streams.

Example:

@example
(stream-length strm123) => 3
@end example
@end defun


@deffn Syntax stream-let @var{tag} ((@var{var} @var{expr}) ...) @var{body}
Create a local scope that binds each variable to the value of its
corresponding expression.  Additionally bind @var{tag} to a procedure
which takes the bound variables as arguments and @var{body} as its
defining expressions, binding the tag with @func{stream-lambda}.
@var{tag} is in scope within @var{body}, and may be called recursively.

When the expanded expression defined by @func{stream-let} is evaluated,
@func{stream-let} evaluates the expressions in its body in an
environment containing the newly--bound variables, returning the value
of the last expression evaluated, which must yield a stream.

@func{stream-let} provides syntactic sugar on @func{stream-lambda}, in
the same manner as normal @func{let} provides syntactic sugar on normal
@func{lambda}.  However, unlike normal @func{let}, the @var{tag} is
required, not optional, because unnamed @func{stream-let} is
meaningless.

Example: @func{stream-member} returns the first @code{stream-pair} of
the input @var{strm} with a @code{stream-car} @var{x} that satisfies
@code{(eql? obj x)}, or the null stream if @var{x} is not present in
@var{strm}.

@example
(define-stream (stream-member eql? obj strm)
  (stream-let loop ((strm strm))
    (cond [(stream-null? strm) strm]
          [(eql? obj (stream-car strm)) strm]
          [else (loop (stream-cdr strm))])))
@end example
@end deffn


@defun stream-map @var{proc} @var{stream} ...
Apply a procedure element--wise to corresponding elements of the input
streams, returning a newly--allocated stream containing elements that
are the results of those procedure applications.  The output stream has
as many elements as the minimum--length input stream, and may be
infinite.

Example:

@example
(define (square x) (* x x))

(stream-map square (stream 9 3)) => 81 9

(define (sigma f m n)
  (stream-fold + 0
    (stream-map f (stream-range m (+ n 1)))))

(sigma square 1 100) => 338350
@end example

In some functional languages, @func{stream-map} takes only a single
input stream, and @func{stream-zipwith} provides a companion function
that takes multiple input streams.
@end defun


@deffn Syntax stream-match @var{stream} @var{clause} ...
Provide the syntax of pattern--matching for streams.  The input
@var{stream} is an expression that evaluates to a stream.  @var{clause}
arguments are of the form @code{(pattern [fender] expr)}, consisting of
a pattern that matches a stream of a particular shape, an optional
fender that must succeed if the pattern is to match, and an expression
that is evaluated if the pattern matches.  There are four types of
patterns:

@table @code
@item ()
matches the null stream;

@item (pat0 pat1 ...)
matches a finite stream with length exactly equal to the number of
pattern elements;

@item (pat0 pat1 ...  . patrest)
matches an infinite stream, or a finite stream with length at least as
great as the number of pattern elements before the literal dot;

@item pat
matches an entire stream; should always appear last in the list of
nclauses; it's not an error to appear elsewhere, but subsequent clauses
could never match.
@end table

Each pattern element @var{pati} may be either:

@table @emph
@item an identifier
matches any stream element; additionally, the value of the stream
element is bound to the variable named by the identifier, which is in
scope in the fender and expression of the corresponding clause; each
identifier in a single pattern must be unique;

@item a literal underscore
matches any stream element, but creates no bindings.
@end table

The patterns are tested in order, left--to--right, until a matching
pattern is found; if @var{fender} is present, it must evaluate as
non--@false{} for the match to be successful.  Pattern variables are
bound in the corresponding fender and expression.  Once the matching
pattern is found, the corresponding expression is evaluated and returned
as the result of the match.  An error is signaled if no pattern matches
the input stream.

@func{stream-match} is often used to distinguish null streams from
non--null streams, binding head and tail:

@example
(define (len strm)
  (stream-match strm
    [() 0]
    [(head .  tail) (+ 1 (len tail))]))
@end example

Fenders can test the common case where two stream elements must be
identical; the else pattern is an identifier bound to the entire stream,
not a keyword as in @func{cond}.

@example
(stream-match strm
  [(x y .  _) (equal? x y) 'ok]
  [else 'error])
@end example

A more complex example uses two nested matchers to match two different
stream arguments; @code{(stream-merge lt? .  strms)} stably merges two
or more streams ordered by the @var{lt?} predicate:

@example
(define-stream (stream-merge lt? .  strms)
  (define-stream (merge xx yy)
    (stream-match xx (() yy) ((x .  xs)
      (stream-match yy (() xx) ((y .  ys)
        (if (lt? y x)
            (stream-cons y (merge xx ys))
          (stream-cons x (merge xs yy))))))))
  (stream-let loop ((strms strms))
    (cond [(null? strms) stream-null]
          [(null? (cdr strms)) (car strms)]
          [else (merge (car strms)
                       (apply stream-merge lt?
                         (cdr strms)))])))
@end example
@end deffn


@deffn Syntax stream-of @var{expr} @var{clause} ...
Provide the syntax of stream comprehensions, which generate streams by
means of looping expressions.  The result is a stream of objects of the
type returned by @var{expr}.  There are four types of @var{clause}
arguments:

@table @code
@item (var in stream-expr)
loop over the elements of @var{stream-expr}, in order from the start of
the stream, binding each element of the stream in turn to @var{var}.
@func{stream-from} and @func{stream-range} are frequently useful as
generators for @var{stream-expr};

@item (var is expr)
bind @var{var} to the value obtained by evaluating @var{expr};

@item (pred? expr)
include in the output stream only those elements @var{x} for which
@code{(pred? x)} is non--@false{}.
@end table

The scope of variables bound in the stream comprehension is the clauses
to the right of the binding clause (but not the binding clause itself)
plus the result expression.

When two or more generators are present, the loops are processed as if
they are nested from left to right; that is, the rightmost generator
varies fastest.  A consequence of this is that only the first generator
may be infinite and all subsequent generators must be finite.  If no
generators are present, the result of a stream comprehension is a stream
containing the result expression; thus, @code{(stream-of 1)} produces a
finite stream containing only the element @code{1}.

@example
(stream-of (* x x)
  (x in (stream-range 0 10))
  (even? x))
  => 0 4 16 36 64

(stream-of (list a b)
  (a in (stream-range 1 4))
  (b in (stream-range 1 3)))
  => (1 1) (1 2) (2 1) (2 2) (3 1) (3 2)

(stream-of (list i j)
  (i in (stream-range 1 5))
  (j in (stream-range (+ i 1) 5)))
  => (1 2) (1 3) (1 4) (2 3) (2 4) (3 4)
@end example
@end deffn


@defun stream-range @var{first} @var{past} [@var{step}]
Create a newly--allocated stream that contains @var{first} as its first
element and increments each succeeding element by @var{step}.  The
stream is finite and ends before @var{past}, which is not an element of
the stream.  If @var{step} is not given it defaults to @code{1} if
@var{first} is less than @var{past} and @code{-1} otherwise.

@var{first}, @var{past} and @var{step} may be of any numeric type.

@func{stream-range} is frequently useful as a generator in
@func{stream-of} expressions.  See also @func{stream-from} for a similar
procedure that creates infinite streams.

Examples:

@example
(stream-range 0 10)     => 0 1 2 3 4 5 6 7 8 9
(stream-range 0 10 2)   => 0 2 4 6 8
@end example

Successive elements of the stream are calculated by adding @var{step} to
@var{first}, so if any of @var{first}, @var{past} or @var{step} are
inexact, the length of the output stream may differ from:

@example
(ceiling (- (/ (- past first) step) 1)
@end example
@end defun


@defun stream-ref @var{stream} @var{n}
Return the @var{n}-th element of @var{stream}, counting from zero.  An
error is signaled if @var{n} is greater than or equal to the length of
@var{stream}.

Example:

@example
(define (fact n)
  (stream-ref
    (stream-scan * 1 (stream-from 1))
    n))
@end example
@end defun


@defun stream-reverse @var{stream}
Return a newly--allocated stream containing the elements of the input
@var{stream} but in reverse order.  @func{stream-reverse} may only be
used with finite streams; it enters an infinite loop with infinite
streams.  @func{stream-reverse} does not force evaluation of the
elements of the stream.

@example
(define s (stream 1 (/ 1 0) -1))
(define r (stream-reverse s))
(stream-ref r 0)
(stream-ref r 2)        => 1
(stream-ref r 1)        => error: division by zero
@end example
@end defun


@defun stream-scan @var{proc} @var{base} @var{stream}
Accumulate the partial folds of an input @var{stream} into a
newly--allocated output stream.  The output stream is the @var{base}
followed by:

@example
(stream-fold proc base (stream-take i stream))
@end example

@noindent
for each of the first i elements of @var{stream}.

Examples:

@example
(stream-scan + 0 (stream-from 1))
  => (stream 0 1 3 6 10 15 ...)

(stream-scan * 1 (stream-from 1))
  => (stream 1 1 2 6 24 120 ...)
@end example
@end defun


@defun stream-take @var{n} @var{stream}
Take a non--negative integer @var{n} and a @var{stream} and return a
newly--allocated stream containing the first @var{f}n elements of the
input stream.  If the input stream has less than @var{n} elements, so
does the output stream.  See also @func{stream-drop}.

Example: @func{merge-sort} splits a stream into two equal--length
pieces, sorts them recursively and merges the results:

@example
(define-stream (merge-sort lt? strm)
  (let* ([n     (quotient (stream-length strm) 2)]
         [ts    (stream-take n strm)]
         [ds    (stream-drop n strm)])
    (if (zero? n)
        strm
      (stream-merge lt? (msort < ts) (msort < ds)))))
@end example
@end defun


@defun stream-take-while @var{pred?} @var{stream}
Take a predicate and a stream and return a newly--allocated stream
containing those elements @var{x} that form the maximal prefix of the
input stream for which @code{(pred? x)} is non--@false{}.  See also
@func{stream-drop-while}.

@example
(stream-car
  (stream-reverse
    (stream-take-while
      (lambda (x) (< x 1000))
      primes)))
  => 997
@end example
@end defun


@defun stream-unfold @var{map} @var{pred?} @var{gen} @var{base}
@func{stream-unfold} is the fundamental recursive stream constructor.
It constructs a stream by repeatedly applying @var{gen} to successive
values of @var{base}, in the manner of @func{stream-iterate}, then
applying @var{map} to each of the values so generated, appending each of
the mapped values to the output stream as long as @code{(pred? base)} is
non--@false{}.  See also @func{stream-iterate} and
@func{stream-unfolds}.

Example: the expression below creates the finite stream:

@example
0 1 4 9 16 25 36 49 64 81
@end example

@noindent
initially the base is @code{0}, which is less than @code{10}, so
@var{map} squares the base and the mapped value becomes the first
element of the output stream; then @var{gen} increments the base by
@code{1}, so it becomes @code{1}; this is less than @code{10}, so
@var{map} squares the new base and @code{1} becomes the second element
of the output stream; and so on, until the base becomes @code{10}, when
@var{pred?}  stops the recursion and @code{stream-null} ends the output
stream.

@example
(stream-unfold
  (lambda (x) (expt x 2)) ; map
  (lambda (x) (< x 10))   ; pred?
  (lambda (x) (+ x 1))    ; gen
  0)                      ; base
@end example
@end defun


@defun stream-unfolds @var{proc} @var{seed}
Return @var{n} newly--allocated streams containing those elements
produced by successive calls to the generator @var{proc}, which takes
the current @var{seed} as its argument and returns @code{n+1} values:

@example
(proc seed) -> seed result0 ...  resultn-1
@end example

@noindent
where the returned @var{seed} is the input @var{seed} to the next call
to the generator and @var{resulti} indicates how to produce the next
element of the ith result stream:

@table @code
@item (value)
@var{value} is the next car of the result stream;

@item #f
no value produced by this iteration of the generator @var{proc} for the
result stream;

@item ()
the end of the result stream.
@end table

It may require multiple calls of @var{proc} to produce the next element
of any particular result stream.  See also @func{stream-iterate} and
@func{stream-unfold}.

@func{stream-unfolds} is especially useful when writing expressions that
return multiple streams.  For instance, @code{(stream-partition pred?
strm)} is equivalent to:

@example
(values
  (stream-filter pred? strm)
  (stream-filter
    (lambda (x) (not (pred? x))) strm))
@end example

@noindent
but only tests @func{pred?} once for each element of @var{strm}.

Example:

@example
(define (stream-partition pred? strm)
  (stream-unfolds
    (lambda (s)
      (if (stream-null? s)
          (values s '() '())
        (let ([a (stream-car s)]
              [d (stream-cdr s)])
          (if (pred? a)
              (values d (list a) #f)
            (values d #f (list a))))))
    strm))

(call-with-values
  (lambda ()
    (stream-partition odd?
      (stream-range 1 6)))
  (lambda (odds evens)
    (list (stream->list odds)
          (stream->list evens))))
  => ((1 3 5) (2 4))
@end example
@end defun


@defun stream-zip @var{stream} ...
Take one or more input streams and return a newly--allocated stream in
which each element is a list (not a stream) of the corresponding
elements of the input streams.  The output stream is as long as the
shortest input stream, if any of the input streams is finite, or is
infinite if all the input streams are infinite.

A common use of @func{stream-zip} is to add an index to a stream, as in:

@example
(stream-finds eql? obj strm)
@end example

@noindent
which returns all the zero--based indices in @var{strm} at which
@var{obj} appears; @code{(stream-find eql? obj strm)} returns the first
such index, or @false{} if @var{obj} is not in @var{strm}.

@example
(define-stream (stream-finds eql? obj strm)
  (stream-of (car x)
    (x in (stream-zip (stream-from 0) strm))
    (eql? obj (cadr x))))

(define (stream-find eql? obj strm)
  (stream-car
    (stream-append
      (stream-finds eql? obj strm)
      (stream #f))))

(stream-find char=? #\l
  (list->stream
    (string->list "hello")))
  => 2

(stream-find char=? #\l
  (list->stream
    (string->list "goodbye")))
  => #f
@end example

@func{stream-find} is not as inefficient as it looks; although it calls
@func{stream-finds}, which finds all matching indices, the matches are
computed lazily, and only the first match is needed for
@func{stream-find}.
@end defun



@c page
@node streams utilities
@section Utilities


@cindex @srfi{} streams utilities


Streams, being the signature structured data type of functional
programming languages, find useful expression in conjunction with
higher--order functions.  Some of these higher--order functions, and
their relationship to streams, are described below.

The identity and constant procedures are frequently useful as the
recursive base for maps and folds; @code{(identity obj)} always returns
@var{obj}, and @code{(const obj)} creates a procedure that takes any
number of arguments and always returns the same @var{obj}, no matter its
arguments:

@example
(define (identity obj) obj)

(define (const obj) (lambda x obj))
@end example

Many of the stream procedures take a unary predicate that accepts an
element of a stream and returns a boolean.  Procedure @code{(negate
pred?)}  takes a unary predicate and returns a new unary predicate that,
when called, returns the opposite boolean value as the original
predicate.

@example
(define (negate pred?)
  (lambda (x) (not (pred? x))))
@end example

@func{negate} is useful for procedures like @func{stream-take-while}
that take a predicate, allowing them to be used in the opposite
direction from which they were written; for instance, with the predicate
reversed, @func{stream-take-while} becomes @func{stream-take-until}.
@func{stream-remove} is the opposite of @func{stream-filter}:

@example
(define-stream (stream-remove pred? strm)
  (stream-filter (negate pred?) strm))
@end example

A section is a procedure which has been partially applied to some of its
arguments; for instance, @code{(double x)}, which returns twice its
argument, is a partial application of the multiply operator to the
number 2.  Sections come in two kinds:

@itemize
@item
left sections partially apply arguments starting from the left;
@item
right sections partially apply arguments starting from the right;
@end itemize

@noindent
the procedure @func{lsec} takes a procedure and some prefix of its
arguments and returns a new procedure in which those arguments are
partially applied; the procedure @func{rsec} takes a procedure and some
reversed suffix of its arguments and returns a new procedure in which
those arguments are partially applied:

@example
(define (lsec proc . args)
  (lambda x (apply proc (append args x))))

(define (rsec proc . args)
  (lambda x
    (apply proc (reverse (append (reverse args) (reverse x))))))
@end example

Since most of the stream procedures take a stream as their last
(rightmost) argument, left sections are particularly useful in
conjunction with streams.

@example
(define stream-sum (lsec stream-fold + 0))
@end example

Function composition creates a new function by partially applying
multiple functions, one after the other.  In the simplest case there are
only two functions, @var{f} and @var{g}, composed as @code{(compose f
g)}; the composition can be bound to create a new function, as in:

@example
(define fg (compose f g))
@end example

@noindent
The procedure @func{compose} takes one or more procedures and returns a
new procedure that performs the same action as the individual procedures
would if called in succession:

@example
(define (compose . fns)
  (let comp ((fns fns))
    (cond
      [(null? fns) 'error]
      [(null? (cdr fns)) (car fns)]
      [else
        (lambda args
          (call-with-values
            (lambda ()
              (apply
                (comp (cdr fns))
                args))
            (car fns)))])))
@end example

@func{compose} works with sections to create succinct but highly
expressive procedure definitions.  The expression to compute the squares
of the integers from 1 to 10 given above at @func{stream-unfold} could
be written by composing @func{stream-map}, @func{stream-take-while}, and
@func{stream-iterate}:

@example
([compose
  (lsec stream-map (rsec expt 2))
  (lsec stream-take-while (negate (rsec > 10)))
  (lsec stream-iterate (rsec + 1))]
 1)
@end example



@c page
@node streams examples
@section Examples


@cindex @srfi{} streams examples


The examples below show a few of the myriad ways streams can be
exploited, as well as a few ways they can trip the unwary user.  All the
examples are drawn from published sources; it is instructive to compare
the Scheme versions to the originals in other languages.

@menu
* streams examples infinite::   Infinite streams.
* streams examples generators:: Generators and co--routines.
* streams examples pipeline::   A pipeline of procedures.
* streams examples persistent:: Persistent data.
* streams examples passes::     Reducing two passes to one.
* streams examples pitfalls::   Pitfalls.
@end menu


@c page
@node streams examples infinite
@subsection Infinite streams


As a simple illustration of infinite streams, consider this definition
of the natural numbers:

@example
(define nats
  (stream-cons 0
    (stream-map add1 nats)))
@end example

@noindent
the recursion works because it is offset by one from the initial
@func{stream-cons}.  Another sequence that uses the offset trick is this
definition of the Fibonacci numbers:

@example
(define fibs
  (stream-cons 1
    (stream-cons 1
      (stream-map +
        fibs
        (stream-cdr fibs)))))
@end example

Yet another sequence that uses the same offset trick is the Hamming
numbers, named for the mathematician and computer scientist Richard
Hamming, defined as all numbers that have no prime factors greater than
5; in other words, Hamming numbers are all numbers expressible as

@example
2i x 3j x 5k
@end example

@noindent
where @var{i}, @var{j} and @var{k} are non--negative integers.  The
Hamming sequence starts with 1 2 3 4 5 6 8 9 10 12 and is computed
starting with 1, taking 2, 3 and 5 times all the previous elements with
@func{stream-map}, then merging @func{sub-streams} and eliminating
duplicates:

@example
(define hamming
  (stream-cons 1
    (stream-unique =
      (stream-merge <
        (stream-map (lsec * 2) hamming)
        (stream-map (lsec * 3) hamming)
        (stream-map (lsec * 5) hamming)))))
@end example

It is possible to have an infinite stream of infinite streams. Consider
the definition of @func{power-table}:

@example
(define power-table
  (stream-of
    (stream-of (expt m n)
      (m in (stream-from 1)))
      (n in (stream-from 2))))
@end example

@noindent
which evaluates to an infinite stream of infinite streams:

@example
(stream
  (stream 1 4 9 16 25 ...)
  (stream 1 8 27 64 125 ...)
  (stream 1 16 81 256 625 ...)
  ...)
@end example

But even though it is impossible to display @func{power-table} in its
entirety, it is possible to select just part of it:

@example
(stream->list 10 (stream-ref power-table 1))
  => (1 8 27 64 125 216 343 512 729 1000)
@end example

This example clearly shows that the elements of a stream are computed
lazily, as they are needed; @code{(stream-ref power-table 0)} is not
computed, even when its successor is displayed, since computing it would
enter an infinite loop.

Chris Reade shows how to calculate the stream of prime numbers according
to the sieve of Eratosthenes, using a method that eliminates multiples
of the sifting base with addition rather than division:

@example
(define primes (let ()
  (define-stream (next base mult strm)
    (let ((first (stream-car strm))
          (rest (stream-cdr strm)))
      (cond ((< first mult)
              (stream-cons first
                (next base mult rest)))
            ((< mult first)
              (next base (+ base mult) strm))
            (else (next base
                    (+ base mult) rest)))))
  (define-stream (sift base strm)
    (next base (+ base base) strm))
  (define-stream (sieve strm)
    (let ((first (stream-car strm))>
          (rest (stream-cdr strm)))
      (stream-cons first
        (sieve (sift first rest)))))
  (sieve (stream-from 2))))
@end example

A final example of infinite streams is a functional pearl from Jeremy
Gibbons, David Lester and Richard Bird that enumerates the positive
rational numbers without duplicates:

@example
(define rats
  (stream-iterate
    (lambda (x)
      (let* ((n (floor x)) (y (- x n)))
        (/ (- n -1 y))))
    1))
@end example


@c page
@node streams examples generators
@subsection Generators and co--routines


It is possible to model generators and co--routines using streams.
Consider the task, due to Carl Hewitt, of determining if two trees have
the same sequence of leaves:

@example
(same-fringe? = '(1 (2 3)) '((1 2) 3))  => #t

(same-fringe? = '(1 2 3) '(1 (3 2)))    => #f
@end example

The simplest solution is to flatten both trees into lists and compare
them element--by--element:

@example
(define (flatten tree)
  (cond [(null? tree) '()]
        [(pair? (car tree))
         (append (flatten (car tree))
                 (flatten (cdr tree)))]
        [else (cons (car tree)
                    (flatten (cdr tree)))]))

(define (same-fringe? eql? tree1 tree2)
  (let loop ([t1 (flatten tree1)]
             [t2 (flatten tree2)])
    (cond [(and (null? t1) (null? t2)) #t]
          [(or (null? t1) (null? t2)) #f]
          [(not (eql? (car t1) (car t2))) #f]
          [else (loop (cdr t1) (cdr t2))])))
@end example

That works, but requires time to flatten both trees and space to store
the flattened versions; if the trees are large, that can be a lot of
time and space, and if the fringes differ, much of that time and space
is wasted.

Hewitt used a generator to flatten the trees one element at a time,
storing only the current elements of the trees and the machines needed
to continue flattening them, so @func{same-fringe?} could stop early if
the trees differ.  Dorai Sitaram presents both the generator solution
and a co--routine solution, which both involve tricky calls to
@func{call-with-current-continuation} and careful coding to keep them
synchronized.

An alternate solution flattens the two trees to streams instead of
lists, which accomplishes the same savings of time and space, and
involves code that looks little different than the list solution
presented above:

@example
(define-stream (flatten tree)
  (cond [(null? tree) stream-null]
        [(pair? (car tree))
         (stream-append
           (flatten (car tree))
           (flatten (cdr tree)))]
        [else (stream-cons
                (car tree)
                (flatten (cdr tree)))]))

(define (same-fringe? eql? tree1 tree2)
  (let loop ([t1 (flatten tree1)]
             [t2 (flatten tree2)])
    (cond [(and (stream-null? t1)
                (stream-null? t2)) #t]
          [(or  (stream-null? t1)
                (stream-null? t2)) #f]
          [(not (eql? (stream-car t1)
                      (stream-car t2))) #f]
          [else (loop (stream-cdr t1)
                      (stream-cdr t2))])))
@end example

Note that streams, a data structure, replace generators or co--routines,
which are control structures, providing a fine example of how lazy
streams enhance modularity.


@c page
@node streams examples pipeline
@subsection A pipeline of procedures


Another way in which streams promote modularity is enabling the use of
many small procedures that are easily composed into larger programs, in
the style of Unix pipelines, where streams are important because they
allow a large dataset to be processed one item at a time.  Bird and
Wadler provide the example of a text formatter.  Their example uses
right--folds:

@example
(define (stream-fold-right f base strm)
  (if (stream-null? strm)
      base
    (f (stream-car strm)
       (stream-fold-right f base
         (stream-cdr strm)))))

(define (stream-fold-right-one f strm)
  (stream-match strm
    [(x) x]
    [(x . xs)
     (f x (stream-fold-right-one f xs))]))
@end example

Bird and Wadler define text as a stream of characters, and develop a
standard package for operating on text, which they derive mathematically
(this assumes the line--separator character is a single
@code{#\newline}):

@example
(define (breakon a)
  (stream-lambda (x xss)
    (if (equal? a x)
        (stream-append (stream (stream)) xss)
      (stream-append
        (stream (stream-append
            (stream x) (stream-car xss)))
        (stream-cdr xss)))))

(define-stream (lines strm)
  (stream-fold-right
    (breakon #\newline)
    (stream (stream))
    strm))

(define-stream (words strm)
  (stream-filter stream-pair?
    (stream-fold-right
      (breakon #\space)
      (stream (stream))
      strm)))

(define-stream (paras strm)
  (stream-filter stream-pair?
    (stream-fold-right
      (breakon stream-null)
      (stream (stream))
      strm)))

(define (insert a)
  (stream-lambda (xs ys)
    (stream-append xs (stream a) ys)))

(define unlines
  (lsec stream-fold-right-one
    (insert #\newline)))

(define unwords
  (lsec stream-fold-right-one
    (insert #\space)))

(define unparas
  (lsec stream-fold-right-one
    (insert stream-null)))
@end example

These versatile procedures can be composed to count words, lines and
paragraphs; the @func{normalize} procedure squeezes out multiple spaces
and blank lines:

@example
(define countlines
  (compose stream-length lines))

(define countwords
  (compose stream-length
           stream-concat
           (lsec stream-map words)
           lines))

(define countparas
  (compose stream-length paras lines))

(define parse
  (compose (lsec stream-map
             (lsec stream-map words))
           paras
           lines))

(define unparse
  (compose unlines
           unparas
           (lsec stream-map
             (lsec stream-map unwords))))

(define normalize (compose unparse parse))
@end example

More useful than normalization is text--filling, which packs as many
words onto each line as will fit.

@example
(define (greedy m ws)
  (- (stream-length
       (stream-take-while (rsec <= m)
         (stream-scan
           (lambda (n word)
             (+ n (stream-length word) 1))
           -1
           ws))) 1))

(define-stream (fill m ws)
  (if (stream-null? ws)
      stream-null
    (let* ([n (greedy m ws)]
           [fstline (stream-take n ws)]
           [rstwrds (stream-drop n ws)])
      (stream-append
        (stream fstline)
        (fill m rstwrds)))))

(define linewords
  (compose stream-concat
           (lsec stream-map words)))

(define textparas
  (compose (lsec stream-map linewords)
           paras
           lines))

(define (filltext m strm)
  (unparse (stream-map (lsec fill m) (textparas strm))))
@end example

To display filename in lines of @var{n} characters, say:

@example
(stream-for-each display
  (filltext n (file->stream filename)))
@end example

Though each operator performs only a single task, they can be composed
powerfully and expressively.  The alternative is to build a single
monolithic procedure for each task, which would be harder and involve
repetitive code.  Streams ensure procedures are called as needed.


@c page
@node streams examples persistent
@subsection Persistent data


Queues are one of the fundamental data structures of computer science.
In functional languages, queues are commonly implemented using two
lists, with the front half of the queue in one list, where the head of
the queue can be accessed easily, and the rear half of the queue in
reverse order in another list, where new items can easily be added to
the end of a queue.  The standard form of such a queue holds that the
front list can only be null if the rear list is also null:

@example
(define queue-null (cons '() '())

(define (queue-null? obj)
  (and (pair? obj) (null? (car obj))))

(define (queue-check f r)
  (if (null? f)
      (cons (reverse r) '())
    (cons f r)))

(define (queue-snoc q x)
  (queue-check (car q) (cons x (cdr q))))

(define (queue-head q)
  (if (null? (car q))
      (error "empty queue: head")
    (car (car q))))

(define (queue-tail q)
  (if (null? (car q))
      (error "empty-head: tail")
    (queue-check (cdr (car q)) (cdr q))))
@end example

This queue operates in amortized constant time per operation, with two
conses per element, one when it is added to the rear list, and another
when the rear list is reversed to become the front list.
@func{queue-snoc} and @func{queue-head} operate in constant time;
@func{queue-tail} operates in worst--case linear time when the front
list is empty.

Chris Okasaki points out that, if the queue is used persistently, its
time--complexity rises from linear to quadratic since each persistent
copy of the queue requires its own linear--time access.  The problem can
be fixed by implementing the front and rear parts of the queue as
streams, rather than lists, and rotating one element from rear to front
whenever the rear list is larger than the front list:

@example
(define queue-null
  (cons stream-null stream-null))

(define (queue-null? x)
  (and (pair? x) (stream-null (car x))))

(define (queue-check f r)
  (if (< (stream-length r) (stream-length f))
      (cons f r)
    (cons (stream-append f (stream-reverse r))
          stream-null)))

(define (queue-snoc q x)
  (queue-check (car q) (stream-cons x (cdr q))))

(define (queue-head q)
  (if (stream-null? (car q))
      (error "empty queue: head")
    (stream-car (car q))))

(define (queue-tail q)
  (if (stream-null? (car q))
      (error "empty queue: tail")
    (queue-check (stream-cdr (car q)) (cdr q))))
@end example

Memoization solves the persistence problem; once a queue element has
moved from rear to front, it needs never be moved again in subsequent
traversals of the queue.  Thus, the linear time--complexity to access
all elements in the queue, persistently, is restored.


@c page
@node streams examples passes
@subsection Reducing two passes to one


The final example is a lazy dictionary, where definitions and uses may
occur in any order; in particular, uses may precede their corresponding
definitions.  This is a common problem.

Many programming languages allow procedures to be used before they are
defined.  Macro processors must collect definitions and emit uses of
text in order.  An assembler needs to know the address that a linker
will subsequently give to variables.  The usual method is to make two
passes over the data, collecting the definitions on the first pass and
emitting the uses on the second pass.  But Chris Reade shows how streams
allow the dictionary to be built lazily, so that only a single pass is
needed.  Consider a stream of requests:

@example
(define requests
  (stream
    '(get 3)
    '(put 1 "a")    ; use follows definition
    '(put 3 "c")    ; use precedes definition
    '(get 1)
    '(get 2)
    '(put 2 "b")    ; use precedes definition
    '(put 4 "d")))  ; unused definition
@end example

We want a procedure that will display cab, which is the result of
@code{(get 3)}, @code{(get 1)}, and @code{(get 2)}, in order.  We first
separate the request stream into gets and puts:

@example
(define (get? obj) (eq? (car obj) 'get))

(define-stream (gets strm)
  (stream-map cadr (stream-filter get? strm)))

(define-stream (puts strm)
  (stream-map cdr  (stream-remove get? strm)))
@end example

Now, @func{run-dict} inserts each element of the puts stream into a lazy
dictionary, represented as a stream of key/value pairs (an association
stream), then looks up each element of the gets stream with
@func{stream-assoc}:

@example
(define-stream (run-dict requests)
  (let ([dict (build-dict (puts requests))])
    (stream-map (rsec stream-assoc dict)
      (gets requests))))

(define (stream-assoc key dict)
    (cond [(stream-null? dict) #f]
          [(equal? key (car (stream-car dict)))
           (stream-car dict)]
          [else (stream-assoc key
                  (stream-cdr dict))]))
@end example

@var{dict} is created in the @func{let}, but nothing is initially added
to it.  Each time @func{stream-assoc} performs a lookup, enough of
@var{dict} is built to satisfy the lookup, but no more.  We are assuming
that each item is defined once and only once.  All that is left is to
define the procedure that inserts new items into the dictionary, lazily:

@example
(define-stream (build-dict puts)
  (if (stream-null? puts)
      stream-null
    (stream-cons
      (stream-car puts)
      (build-dict (stream-cdr puts)))))

@end example

Now we can run the requests and print the result:

@example
(stream-for-each display
  (stream-map cadr (run-dict requests)))
@end example

The @code{(put 4 "d")} definition is never added to the dictionary
because it is never needed.


@c page
@node streams examples pitfalls
@subsection Pitfalls


Programming with streams, or any lazy evaluator, can be tricky, even for
programmers experienced in the genre.  Programming with streams is even
worse in Scheme than in a purely functional language, because, though
the streams are lazy, the surrounding Scheme expressions in which they
are embedded are eager.  The impedance between lazy and eager can
occasionally lead to astonishing results.  Thirty--two years ago,
William Burge warned:

@quotation
Some care must be taken when a stream is produced to make sure that its
elements are not really a list in disguise, in other words, to make sure
that the stream elements are not materialized too soon.
@end quotation

For example, a simple version of @func{stream-map} that returns a stream
built by applying a unary procedure to the elements of an input stream
could be defined like this:

@example
(define-stream (stream-map proc strm) ;wrong!
  (let loop ([strm strm])
    (if (stream-null? strm)
        stream-null
      (stream-cons
        (proc (stream-car strm))
        (loop (stream-cdr strm))))))
@end example

That looks right.  It properly wraps the procedure in
@func{stream-lambda}, and the two legs of the @func{if} both return
streams, so it type--checks.  But it fails because the named @func{let}
binds @var{loop} to a procedure using normal @func{lambda} rather than
@func{stream-lambda}, so even though the first element of the result
stream is lazy, subsequent elements are eager.  @func{stream-map} can be
written using @func{stream-let}:

@example
(define-stream (stream-map proc strm)
  (stream-let loop ([strm strm])
    (if (stream-null? strm)
        stream-null
      (stream-cons
        (proc (stream-car strm))
        (loop (stream-cdr strm))))))
@end example

Here, @func{stream-let} assures that each element of the result stream
is properly delayed, because each is subject to the @func{stream-lambda}
that is implicit in @func{stream-let}, so the result is truly a stream,
not a ``list in disguise''.  Another version of this procedure was given
previously at the description of @func{define-stream}.

Another common problem occurs when a stream--valued procedure requires
the next stream element in its definition.  Consider this definition of
@func{stream-unique}:

@example
(define-stream (stream-unique eql? strm) ;wrong!
  (stream-match strm
    [() strm]
    [(_) strm]
    [(a b . _)
     (if (eql? a b)
         (stream-unique eql?
           (stream-cdr strm))
       (stream-cons a
         (stream-unique eql?
           (stream-cdr strm))))]))
@end example

@noindent
the @code{(a b . _)} pattern requires the value of the next stream
element after the one being considered.  Thus, to compute the nth
element of the stream, one must know the n+1st element, and to compute
the n+1st element, one must know the n+2nd element, and to compute...
The correct version, given above in the description of
@func{stream-drop-while}, only needs the current stream element.

A similar problem occurs when the stream expression uses the previous
element to compute the current element:

@example
(define (nat n)
  (stream-ref
    (stream-let loop ([s (stream 0)])
      (stream-cons (stream-car s)
        (loop (stream (add1 (stream-car s))))))
    n))
@end example

@noindent
this program traverses the stream of natural numbers, building the
stream as it goes.  The definition is correct: @code{(nat 15)} evaluates
to 15; but it needlessly uses unbounded space because each stream
element holds the value of the prior stream element in the binding to
@var{s}.

When traversing a stream, it is easy to write the expression in such a
way that evaluation requires unbounded space, even when that is not
strictly necessary.  During the discussion of @ansrfi{40}, Joe Marshall
created this infamous procedure:

@example
(define (times3 n)
  (stream-ref
    (stream-filter
      (lambda (x)
        (zero? (modulo x n)))
      (stream-from 0))
    3))
@end example

@noindent
@code{(times3 5)} evaluates to 15 and @code{(times3 #e1e9)} evaluates to
three billion, though it takes a while.  In either case, @func{times3}
should operate in bounded space, since each iteration mutates the
promise that holds the next value.  But it is easy to write
@func{times3} so that it does not operate in bounded space, as the
follies of @ansrfi{40} showed.

The common problem is that some element of the stream (often the first
element) is bound outside the expression that is computing the stream,
so it holds the head of the stream, which holds the second element, and
so on.  In addition to testing the programmer, this procedure tests the
stream primitives (it caught several errors during development) and also
tests the underlying Scheme system (it found a bug in one
implementation).

Laziness is no defense against an infinite loop; for instance, the
expression below never returns, because the @func{odd?} predicate never
finds an odd stream element.

@example
(stream-null?
  (stream-filter odd?
    (stream-from 0 2)))
@end example

Ultimately, streams are defined as promises, which are implemented as
thunks (lambda with no arguments).  Since a stream is a procedure,
comparisons such as @func{eq?}, @func{eqv?} and @func{equal?} are not
meaningful when applied to streams.  For instance, the expression

@example
(define s ((stream-lambda () stream-null)))
@end example

@noindent
defines @var{s} as the null stream, and @code{(stream-null? s)} is
@true{}, but @code{(eq?  s stream-null)} is @false{}.

To determine if two streams are equal, it is necessary to evaluate the
elements in their common prefixes, reporting @false{} if two elements
ever differ and @true{} if both streams are exhausted at the same time.

@example
(define (stream-equal? eql? xs ys)
  (cond [(and (stream-null? xs)
              (stream-null? ys)) #t]
        [(or (stream-null? xs)
             (stream-null? ys)) #f]
        [(not (eql? (stream-car xs)
                    (stream-car ys))) #f]
        [else (stream-equal? eql?
                (stream-cdr xs)
                (stream-cdr ys))]))
@end example

It is generally not a good idea to mix lazy streams with eager
side--effects, because the order in which stream elements are evaluated
determines the order in which the side--effects occur.  For a simple
example, consider this side--effecting version of @func{strm123}:

@example
(define strm123-with-side-effects
  (stream-cons (begin (display "one") 1)
    (stream-cons (begin (display "two") 2)
      (stream-cons (begin (display "three") 3)
        stream-null))))
@end example

The stream has elements @code{1 2 3}.  But depending on the order in
which stream elements are accessed, @code{"one"}, @code{"two"} and
@code{"three"} could be printed in any order.

Since the performance of streams can be very poor, normal (eager) lists
should be preferred to streams unless there is some compelling reason to
the contrary.  For instance, computing pythagorean triples with streams:

@example
(stream-ref
  (stream-of (list a b c)
    (n in (stream-from 1))
    (a in (stream-range 1 n))
    (b in (stream-range a n))
    (c is (- n a b))
    (= (+ (* a a) (* b b)) (* c c)))
  50)
@end example

@noindent
is about two orders of magnitude slower than the equivalent expression
using loops:

@example
(do ([n 1 (+ n 1)]) ([> n 228])
  (do ([a 1 (+ a 1)]) ([> a n])
    (do ([b a (+ b 1)]) ([> b n])
      (let ([c (- n a b)])
        (if (= (+ (* a a) (* b b)) (* c c))
            (display (list a b c)))))))
@end example


@c page
@node streams ack
@section Acknowledgments


Jos Koot sharpened my thinking during many email discussions, suggested
several discussion points in the text, and contributed the final version
of @func{stream-match}. Michael Sperber and Abdulaziz Ghuloum gave
advice on @rnrs{6}.


@c page
@node streams references
@section References


All cited web pages visited during September 2007.


@noindent
Harold Abelson and Gerald Jay Sussman with Julie Sussman.
@emph{Structure and Interpretation of Computer Programs}.  @acronym{MIT}
Press, Cambridge, Massachusetts.  Second edition, 1996.  The classic
text on computer science.  Section 3.5 includes extensive discussion of
odd streams.

@center @url{mitpress.mit.edu/sicp}

@noindent
Anne L. Bewig.  @emph{Golden Ratio} (personal communication).  Homework
for the high school course Calculus.  Teaching my daughter how to
calculate the 200th element of a continued fraction was a moment of
sheer joy in the development of the stream libraries.

@noindent
Philip L. Bewig.  @emph{Scheme Request for Implementation 40: A Library
of Streams}.  August, 2004.  Describes an implementation of the stream
data type.

@center @url{srfi.schemers.org/srfi-40}

@noindent
Richard Bird and Philip Wadler.  @emph{Introduction to Functional
Programming}.  Prentice Hall, 1988.  The classic text on functional
programming.  Even streams are discussed in the context of purely
functional programming.

@noindent
William H. Burge.  @emph{Recursive Programming Techniques}.
Addison--Wesley, 1975.  An early text on functional programming, and
still one of the best, though the terminology is dated.  Discusses even
streams in Section 3.10.

@noindent
Jeremy Gibbons, David Lester and Richard Bird, @emph{Functional Pearl:
Enumerating the Rationals,} under consideration for publication in
Journal of Functional Programming.  Discusses a series of expressions
that enumerate the rational numbers without duplicates.

@center @url{http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/rationals.pdf}

@noindent
Carl Hewitt.  @emph{Viewing control structures as patterns of passing
messages,} in Journal of Artificial Intelligence, Volume 8, Number 3
(June, 1977), pp 323-364.  Also published as Artificial Intelligence
Memo 410 by the Massachusetts Institute of Technology.  Describes the
Actor message-passing system; one of the examples used is the
@func{same-fringe?} problem.

@center @url{ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-410.pdf}

@noindent
Peter J. Landin.  @emph{A correspondence between ALGOL 60 and Church's
lambda-notation: Part I,} Communications of the ACM, Volume 8, Number 2,
February 1965, pages 89-101.  The seminal description of streams.

@noindent
Joe Marshall.  "Stream problem redux", from Usenet comp.lang.scheme,
June 28, 2002.  The original post on comp.lang.scheme that describes the
times3 problem.

@center @url{groups.google.com/group/comp.lang.scheme/msg/db4b4a1f33e3eea8}

@noindent
Chris Okasaki.  @emph{Purely Functional Data Structures}.  Cambridge
University Press, 2003.  Revised version of Okasaki's thesis Purely
Functional Data Structures, Carnegie--Mellon University, 1996.  Provides
a strong defense of laziness, and describes several data structures that
exploit laziness, including streams and queues.

@center @url{www.cs.cmu.edu/~rwh/theses/okasaki.pdf}

@noindent
Stephen K. Park and Keith W. Miller.  @emph{Random number generators:
good ones are hard to find}, Communications of the ACM, Volume 31, Issue
10 (October 1988), pages 1192--1201.  Describes a minimal standard
random number generator.

@noindent
Simon Peyton--Jones, et al, editors.  @emph{Haskell 98: Haskell 98
Language and Libraries: The Revised Report}.  December 2002.  Haskell is
the prototypical purely functional language, and includes even streams,
which it calls lists, as its fundamental structured data type.

@center @url{www.haskell.org/onlinereport}

@noindent
Chris Reade.  @emph{Elements of Functional Programming}.
Addison--Wesley, April 1989.  A textbook on functional programming.

@noindent
Antoine de Saint--Exupery.  Chapter III @emph{"L'Avion" of Terre des
Hommes}.  1939.  ``Perfection is achieved, not when there is nothing
more to add, but when there is nothing left to take away.''

@noindent
Dorai Sitaram.  @emph{Teach Yourself Scheme in Fixnum Days}.  A useful
introduction to Scheme; includes generator and co--routine solutions to
the @func{same-fringe?} problem.

@center @url{www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html}

@noindent
Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton von Straaten,
editors.  @emph{Revised6 Report on the Algorithmic Language Scheme}.
September 26, 2007.  @url{www.r6rs.org}.  The standard definition of the
Scheme programming language.

@noindent
Andre van Tonder.  @emph{Scheme Request for Implementation 45:
Primitives for Expressing Iterative Lazy Algorithms}.  April, 2004.
Describes the problems inherent in the promise data type of @rnrs{5}
(also present in @rnrs{6}), and provides the alternate promise data type
used in the stream primitives.

@center @url{srfi.schemers.org/srfi-45}

@noindent
Philip Wadler.  @emph{How to replace failure by a list of successes}, in
Proceedings of the conference on functional programming languages and
computer architecture, Nancy, France, 1985, pages 113--128.  Describes
the ``list of successes'' technique for implementing backtracking
algorithms using streams.

@noindent
Philip Wadler, Walid Taha, and David MacQueen.  @emph{How to add
laziness to a strict language without even being odd.} 1998 ACM SIGPLAN
Workshop on @acronym{ML}, pp. 24ff.  Describes odd and even styles of
lazy evaluation, and shows how to add lazy evaluation to the strict
functional language @acronym{SML}.

@center @url{homepages.inf.ed.ac.uk/wadler/papers/lazyinstrict/lazyinstrict.ps}



@c page
@node lightweight-testing
@chapter Lightweight testing


@cindex @srfi{} lightweight-testing

The @library{srfi lightweight-testing} has been written by Sebastian
Egner as the reference implementation for @ansrfi{78}.


@menu
* lightweight-testing license::         Original license.
* lightweight-testing abstract::        Abstract.
* lightweight-testing rationale::       Rationale.
* lightweight-testing spec::            Specification.
* lightweight-testing references::      References.
@end menu


@c page
@node lightweight-testing license
@section Original license


Copyright @copyright{} 2005--2006 Sebastian Egner.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node lightweight-testing abstract
@section Abstract


A simple mechanism is defined for testing Scheme programs.  As a most
primitive example, the expression:

@example
(check (+ 1 1) => 3)
@end example

@noindent
evaluates the expression @code{(+ 1 1)} and compares the result with the
expected result @code{3} provided after the syntactic keyword @code{=>}.
Then the outcome of this comparison is reported in human--readable form
by printing a message of the form:

@example
(+ 1 1) => 2 ; *** failed ***
; expected result: 3
@end example

Moreover, the outcome of any executed check is recorded in a global
state counting the number of correct and failed checks and storing the
first failed check.  At the end of a file, or at any other point, the
user can print a summary using @func{check-report}.

In addition to the simple test above, it is also possible to execute a
parametric sequence of checks.  Syntactically, this takes the form of an
eager comprehension in the sense of @ansrfi{42}.  For example:

@example
(check-ec (:range e 100)
          (:let x (expt 2.0 e))
  (= (+ x 1) x) => #f (e x))
@end example

This statement runs the variable e through @code{@{0..99@}} and for each
binding defines @var{x} as @code{(expt 2.0 e)}.  Then it is checked if
@code{(+ x 1)} is equal to @var{x}, and it is expected that this is not
the case (i.e. expected value is @false{}).  The trailing @code{(e x)}
tells the reporting mechanism to print the values of both @var{e} and
@var{x} in case of a failed check.  The output could look like this:

@example
(let ((e 53) (x 9007199254740992.0)) (= (+ x 1) x)) => #t ; *** failed ***
; expected result: #f
@end example

The specification of bindings to report, @code{(e x)} in the example, is
optional but very informative.  Other features of this @srfi{} are:

@itemize
@item
a way to specify a different equality predicate (default is
@func{equal?});

@item
controlling the amount of reporting being printed;

@item
switching off the execution and reporting of checks entriely;

@item
retrieving a boolean if all checks have been executed and passed.
@end itemize



@c page
@node lightweight-testing rationale
@section Rationale


The mechanism defined in this @srfi{} should be available in every
Scheme system because it has already proven useful for interactive
development----of @srfi{}s.

Although it is extremely straightforward, the origin of the particular
mechanism described here is the @file{examples.scm} file accompanying
the reference implementation of @ansrfi{42}.  The same mechanism has been
reimplemented for the reference implementation of @srfi{67}, and a
simplified version is yet again found in the reference implementation of
@ansrfi{77}.

The mechanism in this @srfi{} does not replace more sophisticated
approaches to unit testing, like @srfi{64} or SchemeUnit.  These
systems provide more control of the testing, separate the definition of
a test, its execution, and its reports, and provide several other
features.

Neil Van Dyke's Testeez library is very close in spirit to this
@srfi{}.  In Testeez, tests are disabled by (re--)defining a macro.
The advantage of this method is that the code for the test cases can be
removed entirely, and hence even the dependency on the Testeez library.
This @srfi{} on the other hand, uses a Scheme conditional @code{(cond,
if)} to prevent execution of the testing code.  This method is more
dynamic but retains dead testing code, unless a compiler and a module
system are used to apply constant folding and dead code elimination.
The only major addition in @srfi{} over Testeez is the comprehension
for formulating parametric tests.

Design considerations for this @srfi{} include the following:

@itemize
@item
Reporting is human--readable and as specific as possible, i.e. not just
``assertion failed'' but the expression with actual and expected value,
and if possibly the relevant part of the bindings environment.

@item
An effort is made to print closed Scheme expressions, i.e. expressions
that can directly be copy/pasted into a @repl{} for further analysis
(e.g. the let expression in the abstract).

@item
By default the checks report both correct and failed checks.  However,
it is possible to reduce the output, or even to switch off the execution
of checks.  It has turned out useful to be able to run only some subset
checks for the features currently under development.  This can be done
by changing the reporting mode between differnt sections.

@item
The global state (correct/failed count) is not made available to the
user program.  This reduces the dependencies between different checks
because it is not possible to use the state.

@item
Ocassionally, it is useful to check that a certain expression does not
yield an ordinary result but raises an error.  However, @rnrs{5} does
not specify the mechanism by which this occurs (e.g. raising exception,
breaking into a @repl{}, aborting the program, etc.).  For this reason,
this @srfi{} is restricted to the case that the checked expressions
evaluate normally.

@item
Though usually I am very much in favor of strictly prefix syntax, for
this @srfi{} I make an exception because the infix @code{=>} syntax is
widely used and intuitive.
@end itemize



@c page
@node lightweight-testing spec
@section Specification


@deffn Syntax check @var{expr} (=> @var{equal}) @var{expected}
@deffnx Syntax check @var{expr} => @var{expected}
Evaluate @var{expr} and compare the value to the value of @var{expected}
using the predicate @var{equal}, which is @func{equal?} when omitted.
Then a report is printed according to the current mode setting (see
below) and the outcome is recorded in a global state to be used in
@func{check-report}.

The precise order of evaluation is that first @var{equal} and
@var{expected} are evaluated (in unspecified order) and then @var{expr}
is evaluated.  Example: @code{(check (+ 1 1) => 2)}.
@end deffn


@deffn Syntax check-ec @var{qualifier*} @var{expr} (=> @var{equal}) @var{expected} (@var{argument*}))
@deffnx Syntax check-ec @var{qualifier*} @var{expr} => @var{expected} (@var{argument*})
@deffnx Syntax check-ec @var{qualifier*} @var{expr} (=> @var{equal}) @var{expected}
@deffnx Syntax check-ec @var{qualifier*} @var{expr} => @var{expected}
An eager comprehension for executing a parametric sequence of checks.

Enumerate the sequence of bindings specified by @var{qualifier*}.  For
each binding evaluate @var{equal} and @var{expected} in unspecified
order. Then evaluate @var{expr} and compare the value obtained to the
value of @var{expected} using the value of @var{equal} as predicate,
which is @func{equal?} when omitted.

The comprehension stops after the first failed check, if there is any.
Then a report is printed according to the current mode setting (see
below) and the outcome is recorded in a global state to be used in
@func{check-report}.  The entire @func{check-ec} counts as a single
check.

In case the check fails @var{argument*} is used for constructing an
informative message with the argument values.  Use @var{argument*} to
list the relevant free variables of @var{expr} (see examples) that you
want to have printed.

A @var{qualifier} is any qualifier of an eager comprehension as
specified in @srfi{42}.

Examples:

@example
(check-ec (: e 100)
          (positive? (expt 2 e))
          => #t (e)) ; fails on fixnums

(check-ec (: e 100)
          (:let x (expt 2.0 e))
          (= (+ x 1) x)
          => #f (x)) ; fails

(check-ec (: x 10)
          (: y 10)
          (: z 10)
          (* x (+ y z))
          => (+ (* x y) (* x z))
             (x y z)) ; passes with 10^3 cases checked
@end example
@end deffn


@defun check-report
Print a summary and the first failed check, if there is any, depending
on the current mode settings.
@end defun


@defun check-set-mode! @var{mode}
Set the current mode to @var{mode}, which must be a symbol among:
@code{off}, @code{summary}, @code{report-failed}, @code{report}; the
default is @code{report}.  Note that you can change the mode at any
time, and that @func{check}, @func{check-ec} and @func{check-report} use
the current value.

The mode symbols have the following meaning:

@table @code
@item off
do not execute any of the checks;

@item summary
print only summary in @func{check-report} and nothing else;

@item report-failed
report failed checks when they happen, and in summary;

@item report
report every example executed.
@end table
@end defun


@defun check-reset!
Reset the global state (counters of correct/failed examples) to the
state immediately after loading the module for the first time, i.e. no
checks have been executed.
@end defun


@defun check-passed? @var{expected-total-count}
Return @true{} if there were no failed checks and
@var{expected-total-count} correct checks, @false{} otherwise.

Rationale: This procedure can be used in automatized tests by
terminating a test program with the statement:

@example
(exit (if (check-passed? n) 0 1))
@end example
@end defun



@c page
@node lightweight-testing references
@section References


@emph{@ansrfi{64}: a Scheme @api{} for test suites}. Per Bothner. January,
2005.

@center @url{http://srfi.schemers.org/srfi-64}

@noindent
@emph{SchemeUnit}.  Noel Welsh.  February, 2003.

@center @url{http://schematics.sourceforge.net/schemeunit.html}

@noindent
@emph{Testeez, Lightweight Unit Test Mechanism for Scheme}.  Neil Van
Dyke.  May, 2005.

@center @url{http://www.neilvandyke.org/testeez}

@noindent
@emph{Revised^5 Report on the Algorithmic Language Scheme}.

@center @url{http://www.schemers.org/Documents/Standards/R5RS/}

@noindent
@emph{@ansrfi{42}: eager comprehensions}.  Sebastian Egner.

@center @url{http://srfi.schemers.org/srfi-42}


@c page
@node environment-variables
@chapter Environment variables


@cindex @srfi{} environment-variables

The @library{srfi environment-variables} library has been written by
Taro Minowa (Higepon) as the reference implementation for @ansrfi{98}.


@menu
* environment-variables license::       Original license.
* environment-variables abstract::      Abstract.
* environment-variables rationale::     Rationale.
* environment-variables spec::          Specification.
* environment-variables issues::        Issues.
* environment-variables ack::           Acknowledgements.
@end menu


@c page
@node environment-variables license
@section Original license


Copyright @copyright{} 2008 Taro Minowa (Higepon).  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

@c page
@node environment-variables abstract
@section Abstract


This @srfi{} specifies the procedure @func{get-environment-variable},
which gets the value of the specified environment variable, and the
procedure @func{get-environment-variables}, which gets an association
list of all environment-variables.


@c page
@node environment-variables rationale
@section Rationale


Most operating systems provide a mechanism for passing auxiliary
parameters implicitly to child processes.  Usually, this mechanism is
called ``the environment'', and is conceptually a map from string names
to string values.  The string names are called environment variables.

Some applications rely on environment variables to modify their behavior
according to local settings.  Also, various established protocols rely
on environment variables as a form of interprocess communication.  For
example, most implementations of the common gateway interface
(@acronym{CGI}) use environment variables to pass Meta--Variables from
the server to the script.  Environment variables are also required by
@ansrfi{96} @acronym{SLIB} Prerequisites.  Providing a means to access
environment variables is therefore indispensable for writing practical
programs in Scheme.

Most widely--used Scheme implementations provide a function for getting
the value of a specified environment variable.  The name for this
function is usually getenv, but varies (see below).  Some
implementations also provide a way to get all the environment variables,
but others do not.

This @srfi{} specifies a uniform interface for accessing environment
variables.  That should make it easier to write portable programs that
need access to their environment.  For example, a @acronym{CGI} program
may portably obtain the values of the Meta--Variables
@env{QUERY_STRING}, @env{CONTENT_LENGTH} and @env{REQUEST_METHOD} as in
the following examples:

@example
(get-environment-variable "QUERY_STRING") => "foo=bar&huga=hige"
(get-environment-variable "CONTENT_LENGTH") => "512"
(get-environment-variable "REQUEST_METHOD") => "post"
@end example


@c page
@node environment-variables spec
@section Specification


The following two procedures belong to the @rnrs{6} library named
@library{system}.  This is a provisional library name until the naming
rules for @rnrs{6} @srfi{} libraries are specified.

@deffn Procedure get-environment-variable @var{name}
Return the value of the named environment variable as a string, or
@false{} if the named environment variable is not found.  The name
argument is expected to be a string.  @func{get-environment-variable}
may use locale--setting information to encode the name and decode the
value of the environment variable.  If @func{get-environment-variable}
can't decode the value, @func{get-environment-variable} may raise an
exception.

@example
(get-environment-variable "PATH")
=> "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin"
@end example
@end deffn


@deffn Procedure get-environment-variables
Return names and values of all the environment variables as an alist.
The same decoding considerations as for @func{get-environment-variable}
apply.

@example
(get-environment-variables)
=> (("PATH" . "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin")
    ("USERNAME" . "taro"))
@end example
@end deffn


@c page
@node environment-variables issues
@section Issues


@func{get-environment-variable} is expected to return a ``Scheme
string''.

Unfortunately, many current platforms, including @posix{}--like ones, do
not require environment variables to be interpretable as sequences of
characters.  In particular, environment variables can be used to name
files, and filenames on the system can amount to @code{NULL}--terminated
byte vectors, which, if the Scheme program were to collect uninterpreted
and pass to, say, the open call, would work just fine, but which might
not represent a string in the particular encoding the program expects.

While in principle it may be desirable to provide a mechanism for
accessing environment variables raw, this @srfi{} specifies a ``string''
return type because that best represents the consensus of existing
implementations, and captures the semantically desirable behavior in the
common case that the byte sequence is interpretable as a string.


@c page
@node environment-variables ack
@section Acknowledgements


Thanks to Shiro Kawai, Alexey Radul, jmuk, Kokosabu, leque and all the
members of the @code{#Lisp_Scheme} @acronym{IRC} channel on Freenode.


@c page
@node Documentation License
@appendix GNU Free Documentation License

@include fdl.texiinc


@c page
@node references
@appendix Bibliography and references


See the @srfi{} official site:

@center @url{http://srfi.schemers.org/}


@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
