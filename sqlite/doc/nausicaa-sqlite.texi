\input texinfo.tex
@c %**start of header
@setfilename nausicaa-sqlite.info
@settitle SQLite3 for Nausicaa
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@macro record{NAME}
@code{<\NAME\>}
@end macro

@macro condition{NAME}
@code{&\NAME\}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro sql{}
@acronym{SQL}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      SQLite3 for Nausicaa

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/SQLite

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-sqlite

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2009

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a
distribution of librarires for @rnrs{6} Scheme implementations; it
provides a binding to the SQLite3 @sql{} database engine.  It is built
upon Nausicaa/Scheme, making use of its foreign--functions interface; so
it currently supports only @gnu{}+Linux systems.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/nausicaa/downloads}

The project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/tree/master}

SQLite home page is at:

@center @url{http://www.sqlite.org/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-sqlite: (nausicaa-sqlite). Sqlite3 binding for Nausicaa Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* conditions::                  Condition objects.
* enumerations::                Enumeration definitions.
* marshaling::                  Functions marshaling arguments.
* compensated::                 Compensated constructors.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Condition objects

* conditions data::             Condition objects holding values.
* conditions error::            Condition objects signaling errors.

Condition objects holding values

* conditions data database::    Database specification objects.
* conditions data session::     Database session objects.
* conditions data query::       Database query objects.
* conditions data statement::   Database statement objects.

Condition objects signaling errors

* conditions error base::       Base condition type for errors.
* conditions error opening::    Database opening errors.
* conditions error querying::   Database querying errors.
* conditions error preparing::  Errors preparing @sql{} statements.
* conditions error stepping::   Errors executing @sql{} statements.
* conditions error finalising:: Errors finalising @sql{} statements.

Enumeration definitions

* enumerations open::           Database creation and opening flags.

Functions marshaling arguments

* marshaling open::             Creating and opening a database.
* marshaling exec::             Executing @sql{} statements with
                                a Scheme callback.
* marshaling table::            Retrieving a table.
* marshaling step::             Preparing and executing @sql{}
                                statements.
* marshaling column::           Statement column accessors.
* marshaling mutex::            Locking access to a database.

Compensated constructors

* compensated open::            Creating and/or opening databases.

@end detailmenu
@end menu

@end ifnottex

@c page
@node overview
@chapter Overview of the package


@value{PACKAGE} is a distribution of librarires for @rnrs{6} Scheme
implementations; it provides a binding to the SQLite @sql{} database
engine.  It is built upon Nausicaa/Scheme, making use of its
foreign--functions interface; so it currently supports only @gnu{}+Linux
systems.  It suports Ikarus, Mosh and Ypsilon Scheme.

The installed libraries are:

@table @library
@item foreign databases sqlite shared-object
Exports the single binding @code{sqlite-shared-object}, referencing the
SQLite shared library.

@item foreign databases sqlite sizeof
Exports bindings for constant values and data types inspection.

@item foreign databases sqlite platform
Exports a binding for each function in SQLite.  It implements a
one--to--one map between foreign functions and Scheme functions; the
Scheme functions have the same name of the foreign ones, so
@cfunc{sqlite3_close} is available as @func{sqlite3_close}.  This
library makes the original SQLite documentation relevant for this Scheme
package.

@item foreign databases sqlite conditions
Defines condition types used to signal @value{PACKAGE} errors.

@item foreign databases sqlite enumerations
Defines enumeration sets of symbols.

@item foreign databases sqlite primitives
Exports a binding for each foreign function, implementing, for some of
them, marshaling of arguments and return values; the Scheme functions
have the same name of the foreign ones, but with underscores turned into
dashes and the @code{3} stripped; so @cfunc{sqlite3_close} is available
as @func{sqlite-close}.

@item foreign databases sqlite
Compound library; reexports bindings from the following libraries:

@example
(foreign databases sqlite sizeof)
(foreign databases sqlite conditions)
(foreign databases sqlite enumerations)
(foreign databases sqlite primitives)
@end example

@item foreign databases sqlite compensated
Additional wrappers for constructors and destructors making use of the
@library{compensations} library; this library is built on top of
@library{foreign databases sqlite}.  @nauref{compensations, Compensation
stacks}
@end table

@c page
@node conditions
@chapter Condition objects


@menu
* conditions data::             Condition objects holding values.
* conditions error::            Condition objects signaling errors.
@end menu

@c page
@node conditions data
@section Condition objects holding values


@menu
* conditions data database::    Database specification objects.
* conditions data session::     Database session objects.
* conditions data query::       Database query objects.
* conditions data statement::   Database statement objects.
@end menu

@c page
@node conditions data database
@subsection Database specification objects


@deftp {Condition Type} &sqlite-database
Condition type used to hold the database connection object involved in
an error; it is derived from @condition{condition}.  It has the
following fields:

@table @code
@item database
Contains a Scheme string representing a database selector for the SQLite
open functions; it must valid as first argument to @func{sqlite-open}
and @func{sqlite-open-v2}.
@end table
@end deftp


@defun make-sqlite-database-condition @var{database}
@defunx sqlite-database-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-database}.
@end defun


@defun sqlite-database-condition @var{condition}
Accessor for the @code{database} field of @condition{sqlite-database}
condition objects.
@end defun

@c page
@node conditions data session
@subsection Database session objects


@deftp {Condition Type} &sqlite-session
Condition type used to hold the database specification involved in an
error; it is derived from @condition{condition}.  It has the following
fields:

@table @code
@item session
Contains a pointer to a database connection object.
@end table
@end deftp


@defun make-sqlite-session-condition @var{session}
@defunx sqlite-session-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-session}.
@end defun


@defun sqlite-session-condition @var{condition}
Accessor for the @code{session} field of @condition{sqlite-session}
condition objects.
@end defun

@c page
@node conditions data query
@subsection Database query objects


@deftp {Condition Type} &sqlite-query
Condition type used to hold the @sql{} query involved in an error; it is
derived from @condition{condition}.  It has the following fields:

@table @code
@item query
Contains a Scheme string representing a @sql{} query for SQLite
databases.
@end table
@end deftp


@defun make-sqlite-query-condition @var{query}
@defunx sqlite-query-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-query}.
@end defun


@defun sqlite-query-condition @var{condition}
Accessor for the @code{query} field of @condition{sqlite-query}
condition objects.
@end defun

@c page
@node conditions data statement
@subsection Database statement objects


@deftp {Condition Type} &sqlite-statement
Condition type used to hold the @sql{} statement involved in an error;
it is derived from @condition{condition}.  It has the following fields:

@table @code
@item statement
Contains a pointer value referencing an SQLite statement data structure.
@end table
@end deftp


@defun make-sqlite-statement-condition @var{statement}
@defunx sqlite-statement-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-statement}.
@end defun


@defun sqlite-statement-condition @var{condition}
Accessor for the @code{statement} field of @condition{sqlite-statement}
condition objects.
@end defun

@c page
@node conditions error
@section Condition objects signaling errors


@menu
* conditions error base::       Base condition type for errors.
* conditions error opening::    Database opening errors.
* conditions error querying::   Database querying errors.
* conditions error preparing::  Errors preparing @sql{} statements.
* conditions error stepping::   Errors executing @sql{} statements.
* conditions error finalising:: Errors finalising @sql{} statements.
* conditions error resetting::  Errors resetting @sql{} statements.
@end menu

@c page
@node conditions error base
@subsection Base condition type for errors


@deftp {Condition Type} &sqlite-error
Base type for condition objects representing errors in @value{PACKAGE}
exceptions; it is derived from @condition{error}.  Objects of this type
are not meant to be used directly.  It has no fields:

@table @code
@item code
The error code returned by the SQLite foreign function.
@end table
@end deftp


@defun make-sqlite-error-condition @var{code}
@defunx sqlite-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-error}.
@end defun

@c page
@node conditions error opening
@subsection Database opening errors


@deftp {Condition Type} &sqlite-opening-error
Condition type used to tag compound condition objects as representing
SQLite database opening errors; it is derived from
@condition{sqlite-error}.  It has no fields.
@end deftp


@defun make-sqlite-opening-error-condition @var{code}
@defunx sqlite-opening-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-opening-error}.
@end defun


@deffn Syntax raise-sqlite-opening-error @ameta{who} @ameta{message} @ameta{code} @ameta{database}
Raise a continuable exception signaling an SQLite database opening
error.  If the continuation is exercised, it must return a valid pointer
to a SQLite database connection object.

It is defined as:

@example
(define-syntax raise-sqlite-opening-error
  (syntax-rules ()
    ((_ ?who ?message ?code ?database)
     (raise-continuable
      (condition (make-sqlite-opening-error-condition ?code)
                 (make-sqlite-database-condition ?database)
                 (make-who-condition ?who)
                 (make-message-condition ?message))))))
@end example
@end deffn

@c page
@node conditions error querying
@subsection Database querying errors


@deftp {Condition Type} &sqlite-querying-error
Condition type used to tag compound condition objects representing
SQLite database querying errors; it is derived from
@condition{sqlite-error}.  It has no fields.
@end deftp


@defun make-sqlite-querying-error-condition @var{code}
@defunx sqlite-querying-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-querying-error}.
@end defun


@deffn Syntax raise-sqlite-querying-error @ameta{who} @ameta{message} @ameta{code} @ameta{session} @ameta{query}
Raise a continuable exception signaling an SQLite database querying
error.  If the continuation is exercised, it must return an integer
compatible with the return values of @func{sqlite-exec}.

It is defined as:

@example
(define-syntax raise-sqlite-querying-error
  (syntax-rules ()
    ((_ ?who ?message ?code ?session ?query)
     (raise-continuable
      (condition (make-sqlite-querying-error-condition ?code)
                 (make-sqlite-session-condition ?session)
                 (make-sqlite-query-condition ?query)
                 (make-who-condition ?who)
                 (make-message-condition ?message))))))
@end example
@end deffn

@c page
@node conditions error preparing
@subsection Errors preparing @sql{} statements


@deftp {Condition Type} &sqlite-preparing-error
Condition type used to tag compound condition objects representing
errors preparing @sql{} statements; it is derived from
@condition{sqlite-error}.  It has no fields.
@end deftp


@defun make-sqlite-preparing-error-condition @var{code}
@defunx sqlite-preparing-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-preparing-error}.
@end defun


@deffn Syntax raise-sqlite-preparing-error @ameta{who} @ameta{message} @ameta{code} @ameta{session} @ameta{query}
Raise a non--continuable exception signaling an error preparing an
@sql{} statement for SQLite.

It is defined as:

@example
(define-syntax raise-sqlite-preparing-error
  (syntax-rules ()
    ((_ ?who ?message ?code ?session ?query)
     (raise
      (condition (make-sqlite-preparing-error-condition ?code)
                 (make-sqlite-session-condition ?session)
                 (make-sqlite-query-condition ?query)
                 (make-who-condition ?who)
                 (make-message-condition ?message))))))
@end example
@end deffn

@c page
@node conditions error stepping
@subsection Errors executing @sql{} statements


@deftp {Condition Type} &sqlite-stepping-error
Condition type used to tag compound condition objects representing
errors stepping through the execution of @sql{} statements; it is
derived from @condition{sqlite-error}.  It has no fields.
@end deftp


@defun make-sqlite-stepping-error-condition @var{code}
@defunx sqlite-stepping-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-stepping-error}.
@end defun


@deffn Syntax raise-sqlite-stepping-error @ameta{who} @ameta{message} @ameta{code} @ameta{session} @ameta{statement}
Raise a non--continuable exception signaling an error stepping through
the execution of an @sql{} statement for SQLite.

It is defined as:

@example
(define-syntax raise-sqlite-stepping-error
  (syntax-rules ()
    ((_ ?who ?message ?code ?session ?statement)
     (raise
      (condition (make-sqlite-stepping-error-condition ?code)
                 (make-sqlite-session-condition ?session)
                 (make-sqlite-statement-condition ?statement)
                 (make-who-condition ?who)
                 (make-message-condition ?message))))))
@end example
@end deffn

@c page
@node conditions error finalising
@subsection Errors finalising @sql{} statements


@deftp {Condition Type} &sqlite-finalising-error
@deftpx {Condition Type} &sqlite-finalizing-error
Condition type used to tag compound condition objects representing
errors finalising @sql{} statements; it is derived from
@condition{sqlite-error}.  It has no fields.
@end deftp


@defun make-sqlite-finalising-error-condition @var{code}
@defunx make-sqlite-finalizing-error-condition @var{code}
@defunx sqlite-finalising-error-condition? @var{obj}
@defunx sqlite-finalizing-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-finalising-error}.
@end defun


@deffn Syntax raise-sqlite-finalising-error @ameta{who} @ameta{message} @ameta{code} @ameta{session} @ameta{statement}
@deffnx Syntax raise-sqlite-finalizing-error @ameta{who} @ameta{message} @ameta{code} @ameta{session} @ameta{statement}
Raise a non--continuable exception signaling an error finalising an
@sql{} statement for SQLite.

It is defined as:

@example
(define-syntax raise-sqlite-finalising-error
  (syntax-rules ()
    ((_ ?who ?message ?code ?session ?statement)
     (raise
      (condition (make-sqlite-finalising-error-condition ?code)
                 (make-sqlite-session-condition ?session)
                 (make-sqlite-statement-condition ?statement)
                 (make-who-condition ?who)
                 (make-message-condition ?message))))))
@end example
@end deffn

@c page
@node conditions error resetting
@subsection Errors resetting @sql{} statements


@deftp {Condition Type} &sqlite-resetting-error
Condition type used to tag compound condition objects representing
errors resetting @sql{} statements; it is derived from
@condition{sqlite-error}.  It has no fields.
@end deftp


@defun make-sqlite-resetting-error-condition @var{code}
@defunx sqlite-resetting-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{sqlite-resetting-error}.
@end defun


@deffn Syntax raise-sqlite-resetting-error @ameta{who} @ameta{message} @ameta{code} @ameta{session} @ameta{statement}
Raise a non--continuable exception signaling an error resetting an
@sql{} statement for SQLite.

It is defined as:

@example
(define-syntax raise-sqlite-resetting-error
  (syntax-rules ()
    ((_ ?who ?message ?code ?session ?statement)
     (raise
      (condition (make-sqlite-resetting-error-condition ?code)
                 (make-sqlite-session-condition ?session)
                 (make-sqlite-statement-condition ?statement)
                 (make-who-condition ?who)
                 (make-message-condition ?message))))))
@end example
@end deffn

@c page
@node enumerations
@chapter Enumeration definitions


This chapter defines the enumerations used to map at the Scheme level
the constants exported by SQLite.  Unless otherwise specified, all the
bindings are exported by the library @library{foreign databases sqlite
enumerations} and reexported by the compound library @library{foreign
databases sqlite}.

@menu
* enumerations open::           Database creation and opening flags.
@end menu

@c page
@node enumerations open
@section Database creation and opening flags


@deftp {Enumeration Type} sqlite-open-flag-symbol
Enumeration type for flags used by @func{sqlite-open-v2} to create
and/or open a database.  The following symbols are supported, one for
each @samp{SQLITE_OPEN_*} constant defined by SQLite:

@example
CREATE                  DELETEONCLOSE
EXCLUSIVE               FULLMUTEX
MAIN_DB                 MAIN_JOURNAL
MASTER_JOURNAL          NOMUTEX
PRIVATECACHE            READONLY
READWRITE               SHAREDCACHE
SUBJOURNAL              TEMP_DB
TEMP_JOURNAL            TRANSIENT_DB
@end example
@end deftp


@deffn Syntax sqlite-open-flags @ameta{symbol} ...
Evaluates into an enumeration set of type @func{sqlite-open-flag-symbol}
holding the argument symbols.
@end deffn


@defun %sqlite-open-enum->flags @var{enum-set}
Convert an enumeration set of type @func{sqlite-open-flag-symbol} into
the corresponding Inclusive OR combination of @samp{SQLITE_OPEN_*}
values.

This binding is exported by @library{foreign databases sqlite
enumerations}, but @strong{not} by the compound library @library{foreign
databases sqlite}.
@end defun

@c page
@node marshaling
@chapter Functions marshaling arguments


This chapter documents functions from the @library{foreign databases
sqlite primitives} library implementing: marshaling of arguments and
return values; conversion of SQLite errors into exceptions with
condition objects.

@menu
* marshaling open::             Creating and opening a database.
* marshaling exec::             Executing @sql{} statements with
                                a Scheme callback.
* marshaling table::            Retrieving a table.
* marshaling step::             Preparing and executing @sql{}
                                statements.
* marshaling column::           Statement column accessors.
* marshaling mutex::            Locking access to a database.
@end menu

@c page
@node marshaling open
@section Creating and opening a database


@defun sqlite-open @var{database}
Create and/or open a database using @cfunc{sqlite3_open}.  If successful
return a pointer value referencing a database connection object; else
raise a continuable exception with condition object of type
@condition{sqlite-opening-error}.

If opening fails because not enough memory is available, the condition
object also has a component of type @condition{out-of-memory}.
@nauref{memory conditions, Out of memory errors}.

@var{database} must be a Scheme string or symbol representing a database
specification; it can be the pathname of a file or @samp{:memory:} or
any other valid specification.

@example
(let ((session (sqlite-open ':memory:)))
  ---
  (sqlite-close session))
@end example
@end defun


@defun sqlite-open-v2 @var{database} @var{flags-set}
@defunx sqlite-open-v2 @var{database} @var{flags-set} @var{vfs-module}
Create and/or open a database using @cfunc{sqlite3_open_v2}.  If
successful return a pointer value referencing a database connection
object; else raise a continuable exception with condition object of type
@condition{sqlite-opening-error}.

If opening fails because not enough memory is available, the condition
object also has a component of type @condition{out-of-memory}.
@nauref{memory conditions, Out of memory errors}.

@var{database} must be a Scheme string or symbol representing a database
specification; it can be the pathname of a file or @samp{:memory:} or
any other valid specification.

@var{flags-set} must be an enumeration set of composed
@func{sqlite-open-flags}; notice that the @samp{CREATE} symbol is
required to create a new database file.

@var{vfs-module} must be a Scheme string or symbol representing the name
of a SQLite @acronym{VFS} module; if it is not given or it is @false{},
it selects the default SQLite @acronym{VFS} module.

@example
(let ((session (sqlite-open-v2 "/var/sqlite/accounts"
                 (sqlite-open-flags CREATE READWRITE
                                    NOMUTEX))))
  ---
  (sqlite-close db))
@end example
@end defun

@c page
@node marshaling exec
@section Executing @sql{} statements with a Scheme callback


@defun sqlite-exec @var{session} @var{query}
@defunx sqlite-exec @var{session} @var{query} @var{scheme-callback}
Execute the @sql{} statement @var{query}, which must be a Scheme string,
for the database referenced by the pointer @var{session}.

If @var{scheme-callback} is given and it is not @false{}, it must be a
Scheme function which is invoked for every row in the result; the
function must accept two arguments: a list of Scheme strings
representing the names of the columns, a list of Scheme strings
representing the values of the columns.  Null values are represented by
@false{}.

The callback must return @samp{SQLITE_OK} to proceed with the iteration
or @samp{SQLITE_ABORT} to interrupt it.  If the callback raises an
exception, the raised object is catched and correctly rethrown by
@func{sqlite-exec}; such exception must be non--continuable.

@example
(sqlite-exec session "create table accounts
   (id       INTEGER PRIMARY KEY,
    nickname TEXT,
    password TEXT);")

(sqlite-exec session
  "insert into accounts (nickname, password)
     values ('ichigo', 'abcde');
   insert into accounts (nickname, password)
     values ('rukia', '12345');
   insert into accounts (nickname, password)
     values ('chad', 'fist');")

(sqlite-exec session "select * from accounts;"
   (lambda (column-names column-values)
     (write column-names)(newline)
     (write column-values)(newline)
     (newline)
     SQLITE_OK))
@print{} ("id" "nickname" "password")
@print{} ("1" "ichigo" "abcde")
@print{}
@print{} ("id" "nickname" "password")
@print{} ("2" "rukia" "12345")
@print{}
@print{} ("id" "nickname" "password")
@print{} ("3" "chad" "fist")
@end example
@end defun

@c page
@node marshaling table
@section Retrieving a table


@defun sqlite-get-table @var{session} @var{query}
Execute the @sql{} statement @var{query}, which must be a Scheme string,
for the database referenced by the pointer @var{session}; the query
should have a table as result (else it is better to use
@func{sqlite-exec} without callback argument).

Return a list of lists: the first sublist holding a Scheme string for
each column name, the subsequent lists holding the row values.

@example
(sqlite-exec session "create table accounts
   (id INTEGER PRIMARY KEY,
    nickname TEXT,
    password TEXT);")

(sqlite-exec session
  "insert into accounts (nickname, password)
     values ('ichigo', 'abcde');
   insert into accounts (nickname, password)
     values ('rukia', '12345');
   insert into accounts (nickname, password)
     values ('chad', 'fist');")

(sqlite-get-table session
   "select * from accounts;")
@result{} (("id" "nickname" "password")
    ("1" "ichigo" "abcde")
    ("2" "rukia" "12345")
    ("3" "chad" "fist"))
@end example
@end defun

@c page
@node marshaling step
@section Preparing and executing @sql{} statements


The function @func{sqlite2_prepare} is not wrapped by a marshaling
function because, according to the documentation of SQLite version
3.6.19, its usage is deprecated.


@defun sqlite-prepare-v2 @var{session} @var{query}
Prepare all the @sql{} statements in @var{query} for execution in the
database referenced by the pointer @var{session}; return a list of
pointers to SQLite statement structures.  If @var{query} is empty or
contains only comments, the returned list is empty.

@var{query} can contain multiple @sql{} statements and each of them is
prepared separately; if an error occurs preparing a statement, an
exception is raised with condition type
@condition{sqlite-preparing-error}.  All the statements from @var{query}
previously prepared are silently finalised.

Notice that preparing a statement may fail if a prerequisite statement
has not been executed yet; for example, an @samp{insert} statement will
fail if it is prepared before the involved table has been created.
@end defun


@defun sqlite-step @var{session} @var{statement}
Execute a step of the SQLite statement whose structure is referenced by
the pointer @var{statement}; @var{session} must be a pointer to the
database and it is used to retrieve error messages.

The return value is the return value of the foreign function; the codes
representing successful evaluation are:

@table @samp
@item SQLITE_ROW
Means that the a step of execution was correctly performed, but more
steps are needed; data is available to be extracted with the column
accessors.

@item SQLITE_DONE
Means that the last step of execution was correctly performed and the
statement execution is completed.
@end table

If an error occurs, an exception is raised with condition type
@condition{sqlite-stepping-error}.
@end defun


@defun sqlite-finalise @var{session} @var{statement}
@defunx sqlite-finalize @var{session} @var{statement}
Finalise the SQLite statement structure referenced by the pointer
@var{statement}; @var{session} must be a pointer to the database and it
is used to retrieve error messages.  If an error occurs, an exception is
raised with condition type @condition{sqlite-finalising-error}.
@end defun


@defun sqlite-reset @var{session} @var{statement}
Reset the SQLite statement structure referenced by the pointer
@var{statement} to its initial state @strong{after} preparation, so that
the statement is ready to be reexecuted; @var{session} must be a pointer
to the database and it is used to retrieve error messages.  If an error
occurs, an exception is raised with condition type
@condition{sqlite-resetting-error}.
@end defun


Usage example:

@smallexample
(let* ((sql  "create table accounts
                (id       INTEGER PRIMARY KEY,
                 nickname TEXT,
                 password TEXT);")
       (stmt (car (sqlite-prepare-v2 session sql))))
  (let loop ()
    (let ((code (sqlite-step session statement)))
      (if (= code SQLITE_DONE)
          (loop)
        (sqlite-finalise session statement)))))

(let ((sql   "insert into accounts (nickname, password)
                values ('ichigo', 'abcde');
              insert into accounts (nickname, password)
                values ('rukia',  '12345');
              insert into accounts (nickname, password)
                values ('chad',   'fist');")
      (stmts (sqlite-prepare-v2 session sql)))
  (for-each
      (lambda (statement)
        (let loop ()
          (let ((code (sqlite-step session statement)))
            (if (= code SQLITE_DONE)
                (loop)
              (sqlite-finalise session statement)))))
    stmts))

(let ((sql   "select * from accounts;")
      (stmts (sqlite-prepare-v2 session sql))
      (first #t))
  (for-each
      (lambda (statement)
        (let loop ()
          (let ((code (sqlite-step session statement)))
            (cond ((= code SQLITE_ROW)
                   (when first
                     (set first #t)
                     (write (list (sqlite-column-count statement)
                                  (sqlite-column-name  statement 0)
                                  (sqlite-column-name  statement 1)
                                  (sqlite-column-name  statement 2)))
                     (newline))
                   (write (list (sqlite-column-int  statement 0)
                                (sqlite-column-text statement 1)
                                (sqlite-column-text statement 2)))
                   (newline)
                   (loop))
                  ((= code SQLITE_DONE)
                   (sqlite-finalise session statement))
                  (else
                   (loop))))))
    stmts))
@print{} (3 "id" "nickname" "password")
@print{} (1 "ichigo" "abcde")
@print{} (2 "rukia" "12345")
@print{} (3 "chad" "fist")
@end smallexample

@c page
@node marshaling column
@section Statement column accessors


The following functions can be applied to a statement pointer to
retrieve the execution result of an @sql{} statement; the number of
columns in the result is returned by @func{sqlite-column-count}.


@defun sqlite-column-name @var{statement} @var{column-index}
Wrapper for @cfunc{sqlite3_column_name} which extracts the string
representing the column name, from the column at @var{column-index} in
the statement structure referenced by the pointer @var{statement}.
Return a Scheme string.
@end defun


@defun sqlite-column-text @var{statement} @var{column-index}
Wrapper for @cfunc{sqlite3_column_text} which extracts the string from
the column at @var{column-index} in the statement structure referenced
by the pointer @var{statement}.  Return a Scheme string.
@end defun

@c page
@node marshaling mutex
@section Locking access to a database


@deffn Syntax with-sqlite-locking @ameta{session} @ameta{form0} @ameta{form} ...
Acquire the mutex for the database referenced by the pointer
@ameta{session}, evaluate the forms, then release the mutex.

It is implemented as follows:

@example
(define-syntax with-sqlite-locking
  (syntax-rules ()
    ((_ ?session ?form0 ?form ...)
     (let ((mux (sqlite3_db_mutex ?session)))
       (dynamic-wind
           (lambda ()
             (sqlite3_mutex_enter mux))
           (lambda ()
             ?form0 ?form ...)
           (lambda ()
             (sqlite3_mutex_leave mux)))))))
@end example
@end deffn

@c page
@node compensated
@chapter Compensated constructors


This chapter documents compensated constructor, which make use of the
@library{compensations} library to automatically invoke the appropriate
destructor for synchronous resources.  @nauref{compensations,
Compensation stacks}.

Unless otherwise specified, all the bindings are exported by the library
@library{foreign databases sqlite compensated}.

@menu
* compensated open::            Creating and/or opening databases.
@end menu

@c page
@node compensated open
@section Creating and/or opening databases


@defun sqlite-open/c @var{arg} ...
Wrapper for @func{sqlite-open} which pushes the appropriate call to
@func{sqlite-close} on the current compensations stack.  Take the same
arguments of @func{sqlite-open}.
@end defun


@defun sqlite-open-v2/c @var{arg} ...
Wrapper for @func{sqlite-open-ve} which pushes the appropriate call to
@func{sqlite-close} on the current compensations stack.  Take the same
arguments of @func{sqlite-open}.
@end defun

@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
