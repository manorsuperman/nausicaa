@c nettle.texiinc --

@ignore

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro api{}
@acronym{API}
@end macro

@macro gnu{}
@acronym{GNU}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@end ignore

@c page
@node nettle
@appendix Nettle original documentation


@quotation
This appendix is a revision of the original documentation for Nettle
version 2.0.  The author of the original document is Niels Möller, which
placed it in the public domain; the author of this revision is Marco
Maggi @email{mrc.mgg@@gmail.com}.  This appendix is released in the
public domain; you may freely copy it, in whole or in part, with or
without modification.  Attribution is appreciated, but not required.
@end quotation

@menu
* nettle types::                Type definitions.
* nettle armor::                @ascii{} armor algorithms.
* nettle md::                   Computing message digests.
* nettle cipher::               Symmetric key cryptography.
* nettle pubkey::               Public--key algorithms.
* nettle random::               Randomness.
* nettle buffer::               Memory buffers.
* nettle sexp::                 S--expressions.
* nettle asn1::                 Limited support for @acronym{ASN.1}.
* nettle misc::                 Miscellaneous functions.
@end menu

@c page
@node nettle types
@appendixsec Type definitions


@menu
* nettle types armor::          @ascii{} armor algorithms.
* nettle types md::             Message digest computation.
* nettle types cipher::         Symmetric key cryptography.
* nettle types random::         Randomness generation.
* nettle types misc::           Miscellaneous types.
@end menu

@c page
@node nettle types armor
@appendixsubsec @ascii{} armor algorithms


@deftp {Function Prototype} nettle_armor_length_func
Compute the output length for an @ascii{} armor encoding when the input
is of @var{length} bytes.  It is defined as:

@example
typedef unsigned
nettle_armor_length_func (unsigned length);
@end example
@end deftp


@deftp {Function Prototype} nettle_armor_init_func
Initialise the context for an @ascii{} armor algorithm.  It is defined
as:

@example
typedef void
nettle_armor_init_func (void *ctx);
@end example
@end deftp


@deftp {Function Prototype} nettle_armor_encode_update_func
Process input data with an encoding @ascii{} armor algorithm; produce
output, update context.  It is defined as:

@example
typedef unsigned
nettle_armor_encode_update_func (void *ctx,
                                 uint8_t *dst,
                                 unsigned src_length,
                                 const uint8_t *src);
@end example
@end deftp


@deftp {Function Prototype} nettle_armor_encode_final_func
Finalise the context of an encoding @ascii{} armor algorithm.  It is
defined as:

@example
typedef unsigned
nettle_armor_encode_final_func (void *ctx, uint8_t *dst);
@end example
@end deftp


@deftp {Function Prototype} nettle_armor_decode_update_func
Process input data with a decoding @ascii{} armor algorithm; produce
output, update context.  It is defined as:

@example
typedef int
nettle_armor_decode_update_func (void *ctx,
   unsigned *dst_length, uint8_t *dst,
   unsigned src_length,  const uint8_t *src);
@end example
@end deftp


@deftp {Function Prototype} nettle_armor_decode_final_func
Finalise the context of an encoding @ascii{} armor algorithm.  It is
defined as:

@example
typedef int
nettle_armor_decode_final_func (void *ctx);
@end example
@end deftp

@c page
@node nettle types md
@appendixsubsec Message digest computation


@deftp {Function Prototype} nettle_hash_init_func
Initialise the context for message digest computation.  It is defined
as:

@example
typedef void
nettle_hash_init_func (void *ctx);
@end example
@end deftp


@deftp {Function Prototype} nettle_hash_update_func
Update a message digest context with new data.  It is defined as:

@example
typedef void
nettle_hash_update_func (void *ctx,
                         unsigned length, const uint8_t *src);
@end example
@end deftp


@deftp {Function Prototype} nettle_hash_digest_func
Compute the message digest itself and store it in the supplied memory
block.  It is defined as:

@example
typedef void
nettle_hash_digest_func (void *ctx,
                         unsigned length, uint8_t *dst);
@end example
@end deftp

@c page
@node nettle types cipher
@appendixsubsec Symmetric key cryptography


@deftp {Function Prototype} nettle_set_key_func
Set key for cipher algorithms.  It is defined as:
@example
typedef void
nettle_set_key_func (void *ctx, unsigned length, const uint8_t *key);
@end example
@end deftp


@deftp {Function Prototype} nettle_crypt_func
Encryption or decryption function for symmetric key cryptography.  It is
defined as:

@example
typedef void
nettle_crypt_func (void *ctx, unsigned length,
                   uint8_t *dst, const uint8_t *src);
@end example
@end deftp

@c page
@node nettle types random
@appendixsubsec Randomness generation


@deftp {Function Prototype} nettle_random_func
Used by key generation and @acronym{DSA} signature creation.  It is
defined as:

@example
typedef void
nettle_random_func (void *ctx, unsigned length, uint8_t *dst);
@end example
@end deftp

@c page
@node nettle types misc
@appendixsubsec Miscellaneous types


@deftp {Function Prototype} nettle_progress_func
Progress report function, mainly for key generation.  It is defined as:

@example
typedef void
nettle_progress_func (void *ctx, int c);
@end example
@end deftp

@c page
@node nettle armor
@appendixsec @ascii{} encodings


@menu
* nettle armor base16::         Base16 encoding.
* nettle armor base64::         Base64 encoding.
@end menu

@c page
@node nettle armor base16
@appendixsubsec Base16 encoding


@subsubheading Encoding


@defmac BASE16_ENCODE_LENGTH (@var{length})
Evaluate to the maximum length of output for
@cfunc{base16_encode_update} when the input has @var{length} bytes.
@end defmac


@deftypefun void base16_encode_single (uint8_t * @var{dst}, uint8_t @var{src})
Encodes a single byte; always stores two digits in @code{dst[0]} and
@code{dst[1]}.
@end deftypefun


@deftypefun void base16_encode_update (uint8_t * @var{dst}, unsigned @var{length}, const uint8_t * @var{src})
Encode a buffer.  Always store @code{BASE16_ENCODE_LENGTH(length)}
digits in @var{dst}.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Decoding


@deftp {Structure} {struct base16_decode_ctx}
Context structure for decoding operations.
@end deftp


@defmac BASE16_DECODE_LENGTH (@var{length})
Evaluate to the maximum output length for @cfunc{base16_decode_update}.
We have at most @math{4} buffered bits in the context, and a total of
@code{(length + 1) * 4} bits.
@end defmac


@deftypefun void base16_decode_init (struct base16_decode_ctx * @var{ctx})
Initialise an already allocated context structure.
@end deftypefun


@deftypefun int base16_decode_single (struct base16_decode_ctx * @var{ctx}, uint8_t * @var{dst}, uint8_t @var{src})
Decode a single byte.  Return amount of output (@math{0} or @math{1}),
or @math{-1} on errors.
@end deftypefun


@deftypefun int base16_decode_update (struct base16_decode_ctx * @var{ctx}, unsigned * @var{dst_length}, uint8_t * @var{dst}, unsigned @var{src_length}, const uint8_t * @var{src})
Decode a buffer in base16 format; return @math{1} on success, @math{0}
on error.

@var{dst} should point to an area of size at least
@code{BASE16_DECODE_LENGTH(length)} bytes, and for sanity checking,
@code{*dst_length} should be initialized to the size of that area before
the call.  @code{*dst_length} is updated to the amount of decoded
output.  Currently results in an assertion failure if *DST_LENGTH is too
small.
@end deftypefun


@deftypefun int base16_decode_final (struct base16_decode_ctx * @var{ctx})
Verify that the context holds no bits, returns @math{1} on success.
@end deftypefun

@c page
@node nettle armor base64
@appendixsubsec Base64 encoding


@subsubheading High--level encoding


@deftp Structure {struct base64_encode_ctx}
Context structure for encoding operations.
@end deftp


@defmac BASE64_ENCODE_LENGTH (@var{length})
Maximum length of the output for @cfunc{base64_encode_update} when the
input has @var{length} bytes; does not include any padding that
@cfunc{base64_encode_final} may add.

We have at most @math{4} buffered bits in the encoding context
structure and a total of @code{4 + length * 8} bits.
@end defmac


@defmac BASE64_ENCODE_FINAL_LENGTH
Maximum length of output generated by @cfunc{base64_encode_final}.
@end defmac


@defmac BASE64_ENCODE_RAW_LENGTH (@var{length})
Evaluate to the exact length of output generated by
@cfunc{base64_encode_raw}, including padding, when the input has
@var{length} bytes.
@end defmac


@deftypefun void base64_encode_init (struct base64_encode_ctx * @var{ctx})
Initialise an already allocated encoding context structure.
@end deftypefun


@deftypefun unsigned base64_encode_single (struct base64_encode_ctx * @var{ctx}, uint8_t * @var{dst}, uint8_t @var{src})
Encode a single byte; return the amount of output (always @math{1} or
@math{2}).
@end deftypefun


@deftypefun unsigned base64_encode_update (struct base64_encode_ctx * @var{ctx}, uint8_t * @var{dst}, unsigned @var{length}, const uint8_t * @var{src})
Encode a buffer; return the number of output characters.  @var{dst}
should point to an area of size at least
@code{BASE64_ENCODE_LENGTH(length)}.
@end deftypefun


@deftypefun unsigned base64_encode_final (struct base64_encode_ctx * @var{ctx}, uint8_t * @var{dst})
DST should point to an area of size at least
@code{BASE64_ENCODE_FINAL_LENGTH}.
@end deftypefun


@c ------------------------------------------------------------

@subsubheading Low--level encoding


@deftypefun void base64_encode_raw (uint8_t * @var{dst}, unsigned @var{length}, const uint8_t * @var{src})
Encode a string in one go, including any padding at the end; generate
exactly @code{BASE64_ENCODE_RAW_LENGTH(length)} bytes of output.
Support overlapped operation, if @code{src <= dst}.
@end deftypefun


@deftypefun void base64_encode_group (uint8_t * @var{dst}, uint32_t @var{group})
Encode the bytes in @var{group}.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading High--level decoding


@deftp Structure {struct base64_decode_ctx}
Context data structure for decoding operations.
@end deftp


@defmac BASE64_DECODE_LENGTH (@var{length})
Maximum length of output for @cfunc{base64_decode_update} when the input
has @var{length} bytes.  We have at most @math{6} buffered bits and a
total of @code{(length + 1) * 6} bits.
@end defmac


@deftypefun void base64_decode_init (struct base64_decode_ctx * @var{ctx})
Initialise an already allocated context structure.
@end deftypefun


@deftypefun int base64_decode_single (struct base64_decode_ctx * @var{ctx}, uint8_t * @var{dst}, uint8_t @var{src})
Decode a single byte, return the amount of output (@math{0} or
@math{1}), or @math{-1} on errors.
@end deftypefun


@deftypefun int base64_decode_update (struct base64_decode_ctx * @var{ctx}, unsigned * @var{dst_length}, uint8_t * @var{dst}, unsigned @var{src_length}, const uint8_t * @var{src})
Decode a buffer; return @math{1} on success, @math{0} on error.

@var{dst} should point to an area of size at least
@code{BASE64_DECODE_LENGTH(length)} bytes, and for sanity checking,
@code{*dst_length} should be initialized to the size of that area before
the call.  @code{*dst_length} is updated to the amount of decoded
output.

Currently results in an assertion failure if @code{*dst_length} is too
small.
@end deftypefun


@deftypefun int base64_decode_final (struct base64_decode_ctx * @var{ctx})
Verify that the context holds no bits, returns @math{1} on success.
@end deftypefun


@c page
@node nettle md
@appendixsec Computing message digests


@cindex Hash function


A cryptographic @dfn{hash function} is a function that takes
variable--length strings, and maps them to strings of fixed, short,
length.  There are naturally lots of collisions, as there are more
possible @math{1} MB files than @math{20} byte strings, but the function
is constructed such that is hard to find the collisions.

@menu
* nettle md intro::             Introduction.
* nettle md md2::               @acronym{MD2} algorithm.
* nettle md md4::               @acronym{MD4} algorithm.
* nettle md md5::               @acronym{MD5} algorithm.
* nettle md sha1::              @acronym{SHA1} algorithm.
* nettle md sha256::            @acronym{SHA256} algorithm.
* nettle md meta::              The meta interface.
* nettle md hmac::              Keyed hash functions.
@end menu

@c page
@node nettle md intro
@appendixsubsec Introduction


A cryptographic hash function @math{H} should have the following
properties:

@table @emph
@item One--way
Given a hash value @math{H(x)} it is hard to find a string @math{x} that
hashes to that value.

@item Collision--resistant
It is hard to find two different strings, @math{x} and @math{y}, such
that @math{H(x) = H(y)}.
@end table

Hash functions are useful as building blocks for digital signatures,
message authentication codes, pseudo random generators, association of
unique identifiers to documents, and many other things.

The most commonly used hash functions are @acronym{MD5} and
@acronym{SHA1}.  Unfortunately, both these fail the
collision--resistance requirement; cryptologists have found ways to
construct colliding inputs.  The recommended hash function for new
applications is @acronym{SHA256}, even though it uses a structure
similar to @acronym{MD5} and @acronym{SHA1}.  Constructing better hash
functions is an urgent research problem.

@c page
@node nettle md md2
@appendixsubsec @acronym{MD2} algorithm


@acronym{MD2} is a Ronald Rivest's hash function described in @rfc{}
1319.  It outputs message digests of @math{128} bits, or @math{16}
octets.  Nettle defines @acronym{MD2} in @file{<nettle/md2.h>}.


@deftp {Data Structure} {struct md2_ctx}
Context data structure for message digest computation using
@acronym{MD2}.
@end deftp


@defvr Constant MD2_DIGEST_SIZE
The size of an @acronym{MD2} digest, i.e. @math{16}.
@end defvr


@defvr Constant MD2_DATA_SIZE
The internal block size of @acronym{MD2}.
@end defvr


@deftypefun void md2_init (struct md2_ctx * @var{ctx})
Initialize the @acronym{MD2} state.
@end deftypefun


@deftypefun void md2_update (struct md2_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{data})
Hash some more data.
@end deftypefun


@deftypefun void md2_digest (struct md2_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{digest})
Perform final processing and extracts the message digest, writing it to
@var{digest}.  @var{length} may be smaller than @code{MD2_DIGEST_SIZE},
in which case only the first @var{length} octets of the digest are
written.

This function also resets the context in the same way as
@cfunc{md2_init}.
@end deftypefun

@c page
@node nettle md md4
@appendixsubsec @acronym{MD4} algorithm


@acronym{MD4} is a predecessor of @acronym{MD5}, described in @rfc{}
1320; it is constructed by Ronald Rivest.  It outputs message digests of
@math{128} bits, or @math{16} octets.  Nettle defines @acronym{MD4} in
@file{<nettle/md4.h>}.  Use of @acronym{MD4} is not recommended, but it
is sometimes needed for compatibility with existing applications and
protocols.


@deftp {Data Structure} {struct md4_ctx}
Context data structure for message digest computation using
@acronym{MD2}.
@end deftp


@defvr Constant MD4_DIGEST_SIZE
The size of an @acronym{MD4} digest, i.e. @math{16}.
@end defvr


@defvr Constant MD4_DATA_SIZE
The internal block size of @acronym{MD4}.
@end defvr


@deftypefun void md4_init (struct md4_ctx * @var{ctx})
Initialise the @acronym{MD4} state.
@end deftypefun


@deftypefun void md4_update (struct md4_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{data})
Hash some more data.
@end deftypefun


@deftypefun void md4_digest (struct md4_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{digest})
Perform final processing and extracts the message digest, writing it to
@var{digest}.  @var{length} may be smaller than @code{MD4_DIGEST_SIZE},
in which case only the first @var{length} octets of the digest are
written.

This function also resets the context in the same way as
@cfunc{md4_init}.
@end deftypefun

@c page
@node nettle md md5
@appendixsubsec @acronym{MD5} algorithm


@acronym{MD5} is a message digest function constructed by Ronald Rivest,
and described in @rfc{} 1321.  It outputs message digests of @math{128}
bits, or @math{16} octets.  Nettle defines @acronym{MD5} in
@file{<nettle/md5.h>}.


@deftp {Data Structure} {struct md5_ctx}
Context data structure for message digest computation using
@acronym{MD5}.
@end deftp


@defvr Constant MD5_DIGEST_SIZE
The size of an @acronym{MD5} digest, i.e. @math{16}.
@end defvr


@defvr Constant MD5_DATA_SIZE
The internal block size of @acronym{MD5}.  Useful for some special
constructions, in particular @acronym{HMAC-MD5}.
@end defvr


@deftypefun void md5_init (struct md5_ctx * @var{ctx})
Initialise the @acronym{MD5} state.
@end deftypefun


@deftypefun void md5_update (struct md5_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{data})
Hash some more data.
@end deftypefun


@deftypefun void md5_digest (struct md5_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{digest})
Perform final processing and extracts the message digest, writing it to
@var{digest}.  @var{length} may be smaller than @code{MD5_DIGEST_SIZE},
in which case only the first @var{length} octets of the digest are
written.

This function also resets the context in the same way as
@cfunc{md5_init}.
@end deftypefun


The normal way to use @acronym{MD5} is to call the functions in order:
first @cfunc{md5_init}, then @cfunc{md5_update} zero or more times, and
finally @cfunc{md5_digest}.  After @cfunc{md5_digest}, the context is
reset to its initial state, so we can start over calling
@cfunc{md5_update} to hash new data.

To start over, we can call @cfunc{md5_init} at any time.

@c page
@node nettle md sha1
@appendixsubsec @acronym{SHA1} algorithm


@acronym{SHA1} is a hash function specified by @acronym{NIST} (the
U.S. National Institute for Standards and Technology).  It outputs hash
values of @math{160} bits, or @math{20} octets.  Nettle defines
@acronym{SHA1} in @file{<nettle/sha.h>}.


@deftp {Data Structure} {struct sha1_ctx}
Context data structure for message digest computation using
@acronym{SHA1}.
@end deftp


@defvr Constant SHA1_DIGEST_SIZE
The size of an @acronym{SHA1} digest, i.e. @math{20}.
@end defvr


@defvr Constant SHA1_DATA_SIZE
The internal block size of @acronym{SHA1}.  Useful for some special
constructions, in particular @acronym{HMAC-SHA1}.
@end defvr


@deftypefun void sha1_init (struct sha1_ctx * @var{ctx})
Initialise the @acronym{SHA1} state.
@end deftypefun


@deftypefun void sha1_update (struct sha1_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{data})
Hash some more data.
@end deftypefun


@deftypefun void sha1_digest (struct sha1_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{digest})
Perform final processing and extracts the message digest, writing it to
@var{digest}.  @var{length} may be smaller than @code{SHA1_DIGEST_SIZE},
in which case only the first @var{length} octets of the digest are
written.

This function also resets the context in the same way as
@cfunc{sha1_init}.
@end deftypefun

@c page
@node nettle md sha256
@appendixsubsec @acronym{SHA256} algorithm


@acronym{SHA256} is another hash function specified by @acronym{NIST},
intended as a replacement for @acronym{SHA1}, generating larger digests.
It outputs hash values of @math{256} bits, or @math{32} octets.  Nettle
defines @acronym{SHA256} in @file{<nettle/sha.h>}.


@deftp {Data Structure} {struct sha256_ctx}
Context data structure for message digest computation using
@acronym{SHA256}.
@end deftp


@defvr Constant SHA256_DIGEST_SIZE
The size of an @acronym{SHA256} digest, i.e. @math{32}.
@end defvr

@defvr Constant SHA256_DATA_SIZE
The internal block size of @acronym{SHA256}.  Useful for some special
constructions, in particular @acronym{HMAC-SHA256}.
@end defvr


@deftypefun void sha256_init (struct sha256_ctx * @var{ctx})
Initialise the @acronym{SHA256} state.
@end deftypefun


@deftypefun void sha256_update (struct sha256_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{data})
Hash some more data.
@end deftypefun


@deftypefun void sha256_digest (struct sha256_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{digest})
Perform final processing and extracts the message digest, writing it to
@var{digest}.  @var{length} may be smaller than
@code{SHA256_DIGEST_SIZE}, in which case only the first @var{length}
octets of the digest are written.

This function also resets the context in the same way as
@cfunc{sha256_init}.
@end deftypefun

@c page
@node nettle md meta
@appendixsubsec The meta interface


Nettle includes a struct including information about the supported hash
functions. It is defined in @file{<nettle/nettle-meta.h>}, and is used
by Nettle's implementation of @acronym{HMAC}.


@deftp {Data Structure} @code{struct nettle_hash}
It has the following fields:

@example
name            context_size
digest_size     block_size
init            update
digest
@end example

@noindent
the last three attributes are function pointers, of types
@code{nettle_hash_init_func}, @code{nettle_hash_update_func}, and
@code{nettle_hash_digest_func}.

The first argument to these functions is @code{void *} pointer so a
context struct, which is of size @code{context_size}.
@end deftp


@deftypevr {Constant Struct} {struct nettle_cipher} nettle_md2
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_md4
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_md5
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_sha1
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_sha256
These are all the hash functions that Nettle implements.
@end deftypevr

@c page
@node nettle md hmac
@appendixsubsec Keyed hash functions

@cindex Keyed Hash Function
@cindex Message Authentication Code
@cindex MAC


A @dfn{keyed hash function}, or @dfn{Message Authentication Code}
(@acronym{MAC}) is a function that takes a key and a message, and
produces fixed size @acronym{MAC}.  It should be hard to compute a
message and a matching @acronym{MAC} without knowledge of the key.  It
should also be hard to compute the key given only messages and
corresponding @acronym{MAC}s.

@menu
* nettle md hmac intro::        Introduction to keyed hash functions.
* nettle md hmac meta::         Unified interface.
* nettle md hmac md5::          @acronym{HMAC-MD5} algorithm.
* nettle md hmac sha1::         @acronym{HMAC-SHA1} algorithm.
* nettle md hmac sha256::       @acronym{HMAC-SHA256} algorithm.
@end menu

@c page
@node nettle md hmac intro
@appendixsubsubsec Introduction to keyed hash functions


Keyed hash functions are useful primarily for message authentication;
when Alice and Bob shares a secret: the sender, Alice, computes the
@acronym{MAC} and attaches it to the message.  The receiver, Bob, also
computes the @acronym{MAC} of the message, using the same key, and
compares that to Alice's value: if they match, Bob can be assured that
the message has not been modified on its way from Alice.

However, unlike digital signatures, this assurance is not transferable.
Bob can't show the message and the @acronym{MAC} to a third party and
prove that Alice sent that message. Not even if he gives away the key to
the third party. The reason is that the @emph{same} key is used on both
sides, and anyone knowing the key can create a correct @acronym{MAC} for
any message.  If Bob believes that only he and Alice know the key, and
he knows that he didn't attach a @acronym{MAC} to a particular message,
he knows it must be Alice who did it.  However, the third party can't
distinguish between a @acronym{MAC} created by Alice and one created by
Bob.

Keyed hash functions are typically a lot faster than digital signatures
as well.

One can build keyed hash functions from ordinary hash functions.  Older
constructions simply concatenate secret key and message and hashes that,
but such constructions have weaknesses.  A better construction is
@acronym{HMAC}, described in @rfc{} 2104.

For an underlying hash function @math{H}, with digest size @math{l} and
internal block size @math{b}, @acronym{HMAC-H} is constructed as
follows: from a given key @math{k}, two distinct subkeys @math{k_i} and
@math{k_o} are constructed, both of length @math{b}; the
@acronym{HMAC-H} of a message @math{m} is then computed as @math{H(k_o |
H(k_i | m))}, where @math{|} denotes string concatenation.

@acronym{HMAC} keys can be of any length, but it is recommended to use
keys of length @math{l}, the digest size of the underlying hash function
@math{H}.  Keys that are longer than @math{b} are shortened to length
@math{l} by hashing with @math{H}, so arbitrarily long keys aren't very
useful.

@c page
@node nettle md hmac meta
@appendixsubsubsec Unified interface


Nettle's @acronym{HMAC} functions are defined in @file{<nettle/hmac.h>}.
There are abstract functions that use a pointer to a @code{struct
nettle_hash} to represent the underlying hash function and @code{void *}
pointers that point to three different context structs for that hash
function.  There are also concrete functions for @acronym{HMAC-MD5},
@acronym{HMAC-SHA1}, and @acronym{HMAC-SHA256}.


@deftypefun void hmac_set_key (void * @var{outer}, void * @var{inner}, void * @var{state}, const struct nettle_hash * @var{H}, unsigned @var{length}, const uint8_t * @var{key})
Initialise the three context structs from the key.  The @var{outer} and
@var{inner} contexts corresponds to the subkeys @math{k_o} and
@math{k_i}.  @var{state} is used for hashing the message, and is
initialized as a copy of the @var{inner} context.
@end deftypefun


@deftypefun void hmac_update (void * @var{state}, const struct nettle_hash * @var{H}, unsigned @var{length}, const uint8_t * @var{data})
This function is called zero or more times to process the message.
Actually, @code{hmac_update(state, H, length, data)} is equivalent to
@code{H->update(state, length, data)}, so if we wish we can use the
ordinary update function of the underlying hash function instead.
@end deftypefun


@deftypefun void hmac_digest (const void * @var{outer}, const void * @var{inner}, void * @var{state}, const struct nettle_hash * @var{H}, unsigned @var{length}, uint8_t * @var{digest})
Extract the @acronym{MAC} of the message, writing it to @var{digest}.
@var{outer} and @var{inner} are not modified.  @var{length} is usually
equal to @code{H->digest_size}, but if we provide a smaller value, only
the first @var{length} octets of the @acronym{MAC} are written.

This function also resets the @var{state} context so that we can start
over processing a new message (with the same key).
@end deftypefun


There are some macros to help use these functions correctly.


@defmac HMAC_CTX (@var{type})
Expand into:

@example
@{
   type outer;
   type inner;
   type state;
@}
@end example
@end defmac


It can be used to define a @acronym{HMAC} context struct, either
directly:

@example
struct HMAC_CTX(struct md5_ctx) ctx;
@end example

@noindent
or to give it a struct tag:

@example
struct hmac_md5_ctx HMAC_CTX (struct md5_ctx);
@end example


@defmac HMAC_SET_KEY (@var{ctx}, @var{H}, @var{length}, @var{key})
@var{ctx} is a pointer to a context struct as defined by
@cfunc{HMAC_CTX}, @var{H} is a pointer to a @code{const struct
nettle_hash} describing the underlying hash function (so it must match
the type of the components of @var{ctx}).  The last two arguments
specify the secret key.
@end defmac


@defmac HMAC_DIGEST (@var{ctx}, @var{H}, @var{length}, @var{digest})
@var{ctx} is a pointer to a context struct as defined by
@code{HMAC_CTX}, @var{H} is a pointer to a @code{const struct
nettle_hash} describing the underlying hash function.  The last two
arguments specify where the digest is written.
@end defmac


Note that there is no @cfunc{HMAC_UPDATE} macro; simply call
@cfunc{hmac_update} function directly, or the update function of the
underlying hash function.

@c page
@node nettle md hmac md5
@appendixsubsubsec @acronym{HMAC-MD5} algorithm


@deftp {Data Structure} {struct hmac_md5_ctx}
Context data structure to compute @acronym{MAC} values with the
@acronym{MD5} algorithm.
@end deftp


@deftypefun void hmac_md5_set_key (struct hmac_md5_ctx * @var{ctx}, unsigned @var{key_length}, const uint8_t * @var{key})
Initialise the context with the key.
@end deftypefun


@deftypefun void hmac_md5_update (struct hmac_md5_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{data})
Process some more data.
@end deftypefun


@deftypefun void hmac_md5_digest (struct hmac_md5_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{digest})
Extract the @acronym{MAC}, writing it to @var{digest}.  @var{length} may
be smaller than @code{MD5_DIGEST_SIZE}, in which case only the first
@var{length} octets of the @acronym{MAC} are written.

This function also resets the context for processing new messages, with
the same key.
@end deftypefun

@c page
@node nettle md hmac sha1
@appendixsubsubsec @acronym{HMAC-SHA1} algorithm


@deftp {Data Structure} {struct hmac_sha1_ctx}
Context data structure to compute @acronym{MAC} values with the
@acronym{SHA1} algorithm.
@end deftp


@deftypefun void hmac_sha1_set_key (struct hmac_sha1_ctx * @var{ctx}, unsigned @var{key_length}, const uint8_t * @var{key})
Initialise the context with the key.
@end deftypefun


@deftypefun void hmac_sha1_update (struct hmac_sha1_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{data})
Process some more data.
@end deftypefun


@deftypefun void hmac_sha1_digest (struct hmac_sha1_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{digest})
Extract the @acronym{MAC}, writing it to @var{digest}.  @var{length} may
be smaller than @code{SHA1_DIGEST_SIZE}, in which case only the first
@var{length} octets of the @acronym{MAC} are written.

This function also resets the context for processing new messages, with
the same key.
@end deftypefun

@c page
@node nettle md hmac sha256
@appendixsubsubsec @acronym{HMAC-SHA256} algorithm


@deftp {Data Structure} {struct hmac_sha256_ctx}
Context data structure to compute @acronym{MAC} values with the
@acronym{SHA256} algorithm.
@end deftp


@deftypefun void hmac_sha256_set_key (struct hmac_sha256_ctx * @var{ctx}, unsigned @var{key_length}, const uint8_t * @var{key})
Initialise the context with the key.
@end deftypefun


@deftypefun void hmac_sha256_update (struct hmac_sha256_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{data})
Process some more data.
@end deftypefun


@deftypefun void hmac_sha256_digest (struct hmac_sha256_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{digest})
Extracts the @acronym{MAC}, writing it to @var{digest}.  @var{length}
may be smaller than @code{SHA256_DIGEST_SIZE}, in which case only the
first @var{length} octets of the @acronym{MAC} are written.

This function also resets the context for processing new messages, with
the same key.
@end deftypefun

@c page
@node nettle cipher
@appendixsec Symmetric key cryptography


A @dfn{cipher} is a function that takes a message or @dfn{plaintext} and
a secret @dfn{key} and transforms it to a @dfn{ciphertext}.  Given only
the ciphertext, but not the key, it should be hard to find the
plaintext.  Given matching pairs of plaintext and ciphertext, it should
be hard to find the key.

@menu
* nettle cipher intro::         Introduction to symmetric cryptography.
* nettle cipher aes::           The @acronym{AES} algorithm.
* nettle cipher arcfour::       The @acronym{ARCFOUR} algorithm.
* nettle cipher arctwo::        The @acronym{ARCTWO} algorithm.
* nettle cipher cast128::       The @acronym{CAST}-128 algorithm.
* nettle cipher blowfish::      The @acronym{BLOWFISH} algorithm.
* nettle cipher des::           The @acronym{DES} algorithm.
* nettle cipher des3::          The @acronym{DES3} algorithm.
* nettle cipher serpent::       The @acronym{SERPENT} algorithm.
* nettle cipher twofish::       The @acronym{TWOFISH} algorithm.
* nettle cipher meta::          Unified cipher interface.
* nettle cipher modes::         Cipher modes.
@end menu

@c page
@node nettle cipher intro
@appendixsubsec Introduction to symmetric cryptography


@cindex Block Cipher
@cindex Stream Cipher


There are two main classes of ciphers: block ciphers and stream ciphers.

@itemize
@item
A block cipher can process data only in fixed size chunks, called
@dfn{blocks}; typical block sizes are @math{8} or @math{16} octets.  To
encrypt arbitrary messages, we usually have to pad it to an integral
number of blocks, split it into blocks, and then process each block.

The simplest way is to process one block at a time, independent of each
other; that mode of operation is called @dfn{ECB} (Electronic Code
Book).  However, using @acronym{ECB} is usually a bad idea.  For a
start, plaintext blocks that are equal are transformed to ciphertext
blocks that are equal; that leaks information about the plaintext.

Usually we should apply the cipher in some ``feedback mode'', @dfn{CBC}
(Cipher Block Chaining) and @dfn{CTR} (Counter) being two of of the most
popular.

@item
A stream cipher can be used for messages of arbitrary length; a typical
stream cipher is a keyed pseudo--random generator.  To encrypt a
plaintext message of @math{n} octets: we key the generator, generate
@math{n} octets of pseudo--random data, and XOR it with the plaintext.
To decrypt: we regenerate the same stream using the key, XOR it to the
ciphertext, and the plaintext is recovered.

@strong{Caution}: The first rule for this kind of cipher is the
same as for a One Time Pad: @emph{never} ever use the same key twice.
@end itemize

A common misconception is that encryption, by itself, implies
authentication.  Say that we and a friend share a secret key, and we
receive an encrypted message; we apply the key, and get a plaintext
message that makes sense to us.  Can we then be sure that it really was
our friend that wrote the message we are reading?

The answer is no; for example, if we were using a block cipher in
@acronym{ECB} mode, an attacker may pick up the message on its way, and
reorder, delete or repeat some of the blocks.  Even if the attacker
can't decrypt the message, he can change it so that we are not reading
the same message as our friend wrote.  If we are using a block cipher in
@acronym{CBC} mode rather than @acronym{ECB}, or are using a stream
cipher, the possibilities for this sort of attack are different, but the
attacker can still make predictable changes to the message.

It is recommended to @emph{always} use an authentication mechanism in
addition to encrypting the messages.  Popular choices are Message
Authentication Codes like @acronym{HMAC-SHA1} or digital signatures like
@acronym{RSA}.

Some ciphers have so called ``weak keys'', keys that result in
undesirable structure after the key setup processing, and should be
avoided.  In Nettle, the presence of weak keys for a cipher mean that
the key setup function can fail, so we have to check its return value.
In addition, the context structure has a field @code{status}, that is
set to a non--zero value if key setup fails.  When possible, we should
avoid algorithms that have weak keys.  There are several good ciphers
that don't have any weak keys.

To encrypt a message, we first initialize a cipher context for
encryption or decryption with a particular key; we then use the context
to process plaintext or ciphertext messages.  The initialization is
known as @dfn{key setup}; with Nettle, it is recommended to use each
context struct for only one direction, even if some of the ciphers use a
single key setup function that can be used for both encryption and
decryption.

@c page
@node nettle cipher aes
@appendixsubsec The @acronym{AES} algorithm


@acronym{AES} is a block cipher, specified by @acronym{NIST} as a
replacement for the older @acronym{DES} standard.  The standard is the
result of a competition between cipher designers.  The winning design,
also known as @acronym{RIJNDAEL}, was constructed by Joan Daemen and
Vincent Rijnmen.

Like all the @acronym{AES} candidates, the winning design uses a block
size of @math{128} bits, or @math{16} octets, and variable key--size,
@math{128}, @math{192} and @math{256} bits (@math{16}, @math{24} and
@math{32} octets) being the allowed key sizes.  It does not have any
weak keys.  Nettle defines @acronym{AES} in @file{<nettle/aes.h>}.


@deftp {Data Structure} {struct aes_ctx}
Context structure for encryption and decryption with the @acronym{AES}
algorithm.
@end deftp


@defvr Constant AES_BLOCK_SIZE
The @acronym{AES} block size, @math{16}.
@end defvr


@defvr Constant AES_MIN_KEY_SIZE
@defvrx Constant AES_MAX_KEY_SIZE
The minimum and maximum key sizes.
@end defvr


@defvr Constant AES_KEY_SIZE
Default @acronym{AES} key size, @math{32}.
@end defvr


@deftypefun void aes_set_encrypt_key (struct aes_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{key})
@deftypefunx void aes_set_decrypt_key (struct aes_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{key})
Initialize the cipher, for encryption or decryption, respectively.
@end deftypefun


@deftypefun void aes_encrypt (struct aes_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Encryption function.  @var{length} must be an integral multiple of the
block size.  If it is more than one block, the data is processed in
@acronym{ECB} mode.  @var{src} and @var{dst} may be equal, but they must
not overlap in any other way.
@end deftypefun


@deftypefun void aes_decrypt (struct aes_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{dst}, uint8_t * @var{src})
Analogous to @cfunc{aes_encrypt}.
@end deftypefun

@c page
@node nettle cipher arcfour
@appendixsubsec The @acronym{ARCFOUR} algorithm


@acronym{ARCFOUR} is a stream cipher, also known under the trade marked
name @acronym{RC4}, and it is one of the fastest ciphers around.  A
problem is that the key setup of @acronym{ARCFOUR} is quite weak, we
should never use keys with structure, keys that are ordinary passwords,
or sequences of keys like @samp{secret:1}, @samp{secret:2}, @enddots{}
If we have keys that don't look like random bit strings, and we want to
use @acronym{ARCFOUR}, we should always hash the key before feeding it
to @acronym{ARCFOUR}.  Furthermore, the initial bytes of the generated
key stream leak information about the key; for this reason, it is
recommended to discard the first @acronym{512} bytes of the key stream.

@example
/* A more robust key setup function for ARCFOUR */
void
arcfour_set_key_hashed(struct arcfour_ctx *ctx,
                       unsigned length, const uint8_t *key)
@{
  struct sha256_ctx hash;
  uint8_t digest[SHA256_DIGEST_SIZE];
  uint8_t buffer[0x200];

  sha256_init(&hash);
  sha256_update(&hash, length, key);
  sha256_digest(&hash, SHA256_DIGEST_SIZE, digest);

  arcfour_set_key(ctx, SHA256_DIGEST_SIZE, digest);
  arcfour_crypt(ctx, sizeof(buffer), buffer, buffer);
@}
@end example

Nettle defines @acronym{ARCFOUR} in @file{<nettle/arcfour.h>}.

@deftp {Data Structure} {struct arcfour_ctx}
Context structure for encryption and decryption with the
@acronym{ARCFOUR} algorithm.
@end deftp


@defvr Constant ARCFOUR_MIN_KEY_SIZE
@defvrx Constant ARCFOUR_MAX_KEY_SIZE
Minimum and maximum key sizes.
@end defvr


@defvr Constant ARCFOUR_KEY_SIZE
Default @acronym{ARCFOUR} key size, @math{16}.
@end defvr


@deftypefun void arcfour_set_key (struct arcfour_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{key})
Initialise the cipher; the same function is used for both encryption and
decryption.
@end deftypefun


@deftypefun void arcfour_crypt (struct arcfour_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t *@var{src})
Encrypt or decrypt some data; the same function is used for both
encryption and decryption.  Unlike the block ciphers, this function
modifies the context, so we can split the data into arbitrary chunks and
encrypt them one after another; the result is the same as if we had
called @cfunc{arcfour_crypt} only once with all the data.
@end deftypefun

@c page
@node nettle cipher arctwo
@appendixsubsec The @acronym{ARCTWO} algorithm


@acronym{ARCTWO}, also known as the trade marked name @acronym{RC2}, is
a block cipher specified in @rfc{} 2268.  Nettle also include a
variation of the @acronym{ARCTWO} set key operation that lacks one step,
to be compatible with the reverse engineered @acronym{RC2} cipher
description, as described in a Usenet post to @code{sci.crypt} by Peter
Gutmann.

@acronym{ARCTWO} uses a block size of @math{64} bits, and variable
key--size ranging from @math{1} to @math{128} octets.  Besides the key,
@acronym{ARCTWO} also has a second parameter to key setup, the number of
effective key bits, @var{ekb}; this parameter can be used to
artificially reduce the key size.  In practice, @var{ekb} is usually set
equal to the input key size.

We do not recommend the use of @acronym{ARCTWO}; the Nettle
implementation is provided primarily for interoperability with existing
applications and standards.

Nettle defines @acronym{ARCTWO} in @file{<nettle/arctwo.h>}.


@deftp {Context struct} {struct arctwo_ctx}
Context structure for encryption and decryption with the @acronym{ARCTW}
algorithm.
@end deftp


@defvr Constant ARCTWO_BLOCK_SIZE
The @acronym{ARCTWO} block--size, @math{8}.
@end defvr


@defvr Constant ARCTWO_MIN_KEY_SIZE
@defvrx Constant ARCTWO_MAX_KEY_SIZE
Minimum and maximum key sizes.
@end defvr


@defvr Constant ARCTWO_KEY_SIZE
Default @acronym{ARCTWO} key size, @math{8}.
@end defvr


@deftypefun void arctwo_set_key_ekb (struct arctwo_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{key}, unsigned @var{ekb})
@deftypefunx void arctwo_set_key (struct arctwo_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{key})
@deftypefunx void arctwo_set_key_gutmann (struct arctwo_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{key})
Initialise the cipher; the same function is used for both encryption and
decryption.  The first function is the most general one, which lets us
provide both the variable size key, and the desired effective key size
(in bits).  The maximum value for @var{ekb} is @math{1024}, and for
convenience, @math{ekb = 0} has the same effect as @math{ekb = 1024}.

@code{arctwo_set_key(ctx, length, key)} is equivalent to
@code{arctwo_set_key_ekb(ctx, length, key, 8*length)}, and
@code{arctwo_set_key_gutmann(ctx, length, key)} is equivalent to
@code{arctwo_set_key_ekb(ctx, length, key, 1024)}.
@end deftypefun


@deftypefun void arctwo_encrypt (struct arctwo_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Encryption function.  @var{length} must be an integral multiple of the
block size.  If it is more than one block, the data is processed in
@acronym{ECB} mode.  @var{src} and @var{dst} may be equal, but they
must not overlap in any other way.
@end deftypefun


@deftypefun void arctwo_decrypt (struct arctwo_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Analogous to @cfunc{arctwo_encrypt}.
@end deftypefun

@c page
@node nettle cipher cast128
@appendixsubsec The @acronym{CAST}-128 algorithm


@acronym{CAST}-128 is a block cipher, specified in @rfc{} 2144.  It uses
a @math{64} bit (@math{8} octets) block size, and a variable key size of
up to @math{128} bits.  Nettle defines cast128 in
@file{<nettle/cast128.h>}.


@deftp {Context struct} {struct cast128_ctx}
Context structure for encryption and decryption with the
@acronym{CAST}-128 algorithm.
@end deftp


@defvr Constant CAST128_BLOCK_SIZE
The @acronym{CAST}-128 block--size, @math{8}.
@end defvr


@defvr Constant CAST128_MIN_KEY_SIZE
@defvrx Constant CAST128_MAX_KEY_SIZE
Minimum and maximum @acronym{CAST}-128 key size.
@end defvr


@defvr Constant CAST128_KEY_SIZE
Default @acronym{CAST}-128 key size, @math{16}.
@end defvr


@deftypefun void cast128_set_key (struct cast128_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{key})
Initialise the cipher; the same function is used for both encryption and
decryption.
@end deftypefun


@deftypefun void cast128_encrypt (struct cast128_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Encryption function.  @var{length} must be an integral multiple of the
block size.  If it is more than one block, the data is processed in
@acronym{ECB} mode.  @var{src} and @var{dst} may be equal, but they must
not overlap in any other way.
@end deftypefun


@deftypefun void cast128_decrypt (struct cast128_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Analogous to @cfunc{cast128_encrypt}.
@end deftypefun

@c page
@node nettle cipher blowfish
@appendixsubsec The @acronym{BLOWFISH} algorithm


@acronym{BLOWFISH} is a block cipher designed by Bruce Schneier.  It
uses a block size of @acronym{64} bits (@math{8} octets), and a variable
key size, up to @math{448} bits.  It has some weak keys.

Nettle defines BLOWFISH in @file{<nettle/blowfish.h>}.


@deftp {Context struct} {struct blowfish_ctx}
Context structure for encryption and decryption with the
@acronym{BLOWFISH} algorithm.
@end deftp


@defvr Constant BLOWFISH_BLOCK_SIZE
The @acronym{BLOWFISH} block--size, @math{8}.
@end defvr


@defvr Constant BLOWFISH_MIN_KEY_SIZE
@defvrx Constant BLOWFISH_MAX_KEY_SIZE
Minimum and maximum @acronym{BLOWFISH} key sizes.
@end defvr


@defvr Constant BLOWFISH_KEY_SIZE
Default @acronym{BLOWFISH} key size, @math{16}.
@end defvr


@deftypefun int blowfish_set_key (struct blowfish_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{key})
Initialise the cipher; the same function is used for both encryption and
decryption.  Return @math{1} on success, and @math{0} if the key was
weak.  Calling @cfunc{blowfish_encrypt} or @cfunc{blowfish_decrypt} with
a weak key will crash with an assert violation.
@end deftypefun


@deftypefun void blowfish_encrypt (struct blowfish_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Encryption function.  @var{length} must be an integral multiple of the
block size.  If it is more than one block, the data is processed in
@acronym{ECB} mode.  @var{src} and @var{dst} may be equal, but they
must not overlap in any other way.
@end deftypefun


@deftypefun void blowfish_decrypt (struct blowfish_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Analogous to @cfunc{blowfish_encrypt}.
@end deftypefun

@c page
@node nettle cipher des
@appendixsubsec The @acronym{DES} algorithm


@acronym{DES} is the old Data Encryption Standard, specified by
@acronym{NIST}.  It uses a block size of @math{64} bits (@math{8}
octets), and a key size of @math{56} bits.  However, the key bits are
distributed over @math{8} octets, where the least significant bit of
each octet is used for parity.  A common way to use @acronym{DES} is to
generate @math{8} random octets in some way, then set the least
significant bit of each octet to get odd parity, and initialize
@acronym{DES} with the resulting key.

The key size of @acronym{DES} is so small that keys can be found by
brute force, using specialized hardware or lots of ordinary work
stations in parallel.  One shouldn't be using plain @acronym{DES} at all
today, if one uses @acronym{DES} at all one should be using ``triple
@acronym{DES}''.  @acronym{DES} also has some weak keys.

Nettle defines @acronym{DES} in @file{<nettle/des.h>}.


@deftp {Context struct} {struct des_ctx}
Context structure for encryption and decryption with the
@acronym{DES} algorithm.
@end deftp


@defvr Constant DES_BLOCK_SIZE
The @acronym{DES} block--size, @math{8}.
@end defvr


@defvr Constant DES_KEY_SIZE
@acronym{DES} key size, @math{8}.
@end defvr


@deftypefun int des_set_key (struct des_ctx * @var{ctx}, const uint8_t * @var{key})
Initialise the cipher; the same function is used for both encryption and
decryption.  Return @math{1} on success, and @math{0} if the key was
weak or had bad parity.  Calling @cfunc{des_encrypt} or
@cfunc{des_decrypt} with a bad key will crash with an assert violation.
@end deftypefun


@deftypefun void des_encrypt (struct des_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{dst}, uint8_t * @var{src})
Encryption function.  @var{length} must be an integral multiple of the
block size.  If it is more than one block, the data is processed in
@acronym{ECB} mode.  @var{src} and @var{dst} may be equal, but they must
not overlap in any other way.
@end deftypefun


@deftypefun void des_decrypt (struct des_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Analogous to @cfunc{des_encrypt}.
@end deftypefun


@deftypefun void des_fix_parity (unsigned @var{length}, uint8_t *@var{dst}, const uint8_t *@var{src})
Adjust the parity bits to match @acronym{DES}'s requirements.  We need
this function if we have created a random--looking string by a key
agreement protocol, and want to use it as a @acronym{DES} key.
@var{dst} and @var{src} may be equal.
@end deftypefun

@c page
@node nettle cipher des3
@appendixsubsec The @acronym{DES3} algorithm


The inadequate key size of @acronym{DES} has already been mentioned; one
way to increase the key size is to pipe together several @acronym{DES}
boxes with independent keys.  It turns out that using two @acronym{DES}
ciphers is not as secure as one might think, even if the key size of the
combination is a respectable @math{112} bits.

The standard way to increase @acronym{DES}'s key size is to use three
@acronym{DES} boxes.  The mode of operation is a little peculiar: the
middle @acronym{DES} box is wired in the reverse direction.  To encrypt
a block with @acronym{DES3}, you encrypt it using the first @math{56}
bits of the key, then @emph{decrypt} it using the middle @math{56} bits
of the key, and finally encrypt it again using the last @math{56} bits
of the key.  This is known as @acronym{EDE} triple--@acronym{DES}, for
encrypt--decrypt--encrypt.

The @acronym{EDE} construction provides some backward compatibility, as
you get plain single @acronym{DES} simply by feeding the same key to all
three boxes.  That should help keeping down the gate count, and the
price, of hardware circuits implementing both plain @acronym{DES} and
@acronym{DES3}.

@acronym{DES3} has a key size of @math{168} bits, but just like plain
@acronym{DES}, useless parity bits are inserted, so that keys are
represented as @math{24} octets (@math{192} bits).  As a @math{112} bit
key is large enough to make brute force attacks impractical, some
applications uses a ``two--key'' variant of triple--@acronym{DES}.  In
this mode, the same key bits are used for the first and the last
@acronym{DES} box in the pipe, while the middle box is keyed
independently.  The two--key variant is believed to be secure,
i.e. there are no known attacks significantly better than brute force.

Naturally, it's simple to implement triple--@acronym{DES} on top of
Nettle's @acronym{DES} functions.  Nettle includes an implementation of
three--key @acronym{EDE} triple--@acronym{DES}, it is defined in the
same place as plain @acronym{DES}, @file{<nettle/des.h>}.


@deftp {Context struct} {struct des3_ctx}
Context structure for encryption and decryption with the
@acronym{DES3} algorithm.
@end deftp


@defvr Constant DES3_BLOCK_SIZE
The @acronym{DES3} block--size is the same as @code{DES_BLOCK_SIZE},
@math{8}.
@end defvr


@defvr Constant DES3_KEY_SIZE
@acronym{DES3} key size, @math{24}.
@end defvr


@deftypefun int des3_set_key (struct des3_ctx * @var{ctx}, const uint8_t * @var{key})
Initialise the cipher; the same function is used for both encryption and
decryption.  Return @math{1} on success, and @math{0} if the key was
weak or had bad parity.  Calling @cfunc{des_encrypt} or
@cfunc{des_decrypt} with a bad key will crash with an assert violation.
@end deftypefun


For random--looking strings, we can use @cfunc{des_fix_parity} to adjust
the parity bits before calling @cfunc{des3_set_key}.


@deftypefun void des3_encrypt (struct des3_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Encryption function.  @var{length} must be an integral multiple of the
block size.  If it is more than one block, the data is processed in
@acronym{ECB} mode.  @var{src} and @var{dst} may be equal, but they must
not overlap in any other way.
@end deftypefun


@deftypefun void des3_decrypt (struct des3_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Analogous to @cfunc{des_encrypt}.
@end deftypefun

@c page
@node nettle cipher serpent
@appendixsubsec The @acronym{SERPENT} algorithm


@acronym{SERPENT} is one of the @acronym{AES} finalists, designed by
Ross Anderson, Eli Biham and Lars Knudsen; thus, the interface and
properties are similar to @acronym{AES}'.  One peculiarity is that it is
quite pointless to use it with anything but the maximum key size,
smaller keys are just padded to larger ones.

Nettle defines @acronym{SERPENT} in @file{<nettle/serpent.h>}.


@deftp {Context struct} {struct serpent_ctx}
Context structure for encryption and decryption with the
@acronym{SERPENT} algorithm.
@end deftp


@defvr Constant SERPENT_BLOCK_SIZE
The @acronym{SERPENT} block--size, @math{16}
@end defvr


@defvr Constant SERPENT_MIN_KEY_SIZE
@defvrx Constant SERPENT_MAX_KEY_SIZE
Minimum and maximum @acronym{SERPENT} key sizes.
@end defvr


@defvr Constant SERPENT_KEY_SIZE
Default @acronym{SERPENT} key size, @math{32}.
@end defvr


@deftypefun void serpent_set_key (struct serpent_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{key})
Initialise the cipher; the same function is used for both encryption and
decryption.
@end deftypefun


@deftypefun void serpent_encrypt (struct serpent_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Encryption function.  @var{length} must be an integral multiple of the
block size.  If it is more than one block, the data is processed in
@acronym{ECB} mode.  @var{src} and @var{dst} may be equal, but they must
not overlap in any other way.
@end deftypefun


@deftypefun void serpent_decrypt (struct serpent_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Analogous to @cfunc{serpent_encrypt}.
@end deftypefun

@c page
@node nettle cipher twofish
@appendixsubsec The @acronym{TWOFISH} algorithm


Another @acronym{AES} finalist, this one designed by Bruce Schneier and
others.  Nettle defines it in @file{<nettle/twofish.h>}.


@deftp {Context struct} {struct twofish_ctx}
Context structure for encryption and decryption with the
@acronym{TWOFISH} algorithm.
@end deftp


@defvr Constant TWOFISH_BLOCK_SIZE
The @acronym{TWOFISH} block--size, @math{16}.
@end defvr


@defvr Constant TWOFISH_MIN_KEY_SIZE
@defvrx Constant TWOFISH_MAX_KEY_SIZE
Minimum and maximum @acronym{TWOFISH} key sizes.
@end defvr


@defvr Constant TWOFISH_KEY_SIZE
Default @acronym{TWOFISH} key size, @math{32}.
@end defvr


@deftypefun void twofish_set_key (struct twofish_ctx * @var{ctx}, unsigned @var{length}, const uint8_t * @var{key})
Initialise the cipher; the same function is used for both encryption and
decryption.
@end deftypefun


@deftypefun void twofish_encrypt (struct twofish_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Encryption function.  @var{length} must be an integral multiple of the
block size.  If it is more than one block, the data is processed in
@acronym{ECB} mode.  @var{src} and @var{dst} may be equal, but they must
not overlap in any other way.
@end deftypefun


@deftypefun void twofish_decrypt (struct twofish_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Analogous to @cfunc{twofish_encrypt}.
@end deftypefun

@c page
@node nettle cipher meta
@appendixsubsec Unified cipher interface


Nettle includes data structures including information about some of the
more regular cipher functions.  It should be considered a little
experimental, but can be useful for applications that need a simple way
to handle various algorithms.  Nettle defines these structures in
@file{<nettle/nettle-meta.h>}.


@deftp {Data Structure} struct nettle_cipher
It has the following fields:

@example
name            context_size
block_size      key_size
set_encrypt_key set_decrypt_key
encrypt         decrypt
@end example

@noindent
the last four attributes are function pointers, of types
@code{nettle_set_key_func} and @code{nettle_crypt_func}.

The first argument to these functions is a @code{void *} pointer to a
context struct, which is of size @code{context_size}.
@end deftp


@deftypevr {Constant Struct} {struct nettle_cipher} nettle_aes128
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_aes192
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_aes256
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arcfour128
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_cast128
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_serpent128
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_serpent192
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_serpent256
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_twofish128
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_twofish192
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_twofish256
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo40;
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo64;
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo128;
@deftypevrx {Constant Struct} {struct nettle_cipher} nettle_arctwo_gutmann128;
Nettle includes such structs for all the @emph{regular} ciphers, i.e.
ones without weak keys or other oddities.
@end deftypevr

@c page
@node nettle cipher modes
@appendixsubsec Cipher modes


Cipher modes of operation specifies the procedure to use when encrypting
a message that is larger than the cipher's block size.  Splitting the
message into blocks and processing them independently with the block
cipher (Electronic Code Book mode, @acronym{ECB}) leaks information.
Besides @acronym{ECB}, Nettle provides two other modes of operation:
Cipher Block Chaining (@acronym{CBC}) and Counter mode (@acronym{CTR}).
@acronym{CBC} is widely used, but there are a few subtle issues of
information leakage.  @acronym{CTR} was standardized more recently, and
is believed to be more secure.

@menu
* nettle cipher modes cbc::  Cipher block chaining mode.
* nettle cipher modes ctr::  Counter mode.
@end menu

@c page
@node nettle cipher modes cbc
@appendixsubsubsec Cipher block chaining mode


@cindex Cipher Block Chaining
@cindex CBC Mode


When using @acronym{CBC} mode, plaintext blocks are not encrypted
independently of each other, like in Electronic Cook Book mode.
Instead, when encrypting a block in @acronym{CBC} mode, the previous
ciphertext block is XORed with the plaintext before it is fed to the
block cipher.  When encrypting the first block, a random block called
@dfn{Initialization Vector} (@acronym{IV}) is used as the ``previous
ciphertext block''.  The @acronym{IV} should be chosen randomly, but it
need not be kept secret, and can even be transmitted in the clear
together with the encrypted data.

In symbols, if @math{E_k} is the encryption function of a block cipher,
and @math{IV} is the initialization vector, then @math{n} plaintext
blocks @math{M_1, @dots{}, M_n} are transformed into @math{n} ciphertext
blocks @math{C_1 @dots{} C_n} as follows:

@example
C_1 = E_k(IV  XOR M_1)
C_2 = E_k(C_1 XOR M_2)

@dots{}

C_n = E_k(C_(n-1) XOR M_n)
@end example

Nettle's includes two functions for applying a block cipher in Cipher
Block Chaining mode, one for encryption and one for decryption.  These
functions use @code{void *} to pass cipher contexts around.


@deftypefun {void} cbc_encrypt (void * @var{ctx}, nettle_crypt_func @var{f}, unsigned @var{block_size}, uint8_t * @var{iv}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
@deftypefunx {void} cbc_decrypt (void * @var{ctx}, void (*@var{f})(), unsigned @var{block_size}, uint8_t * @var{iv}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Apply the encryption or decryption function @var{f} in @acronym{CBC}
mode.  The final ciphertext block processed is copied into @var{iv}
before returning, so that large messages can be processed with a
sequence of calls to @cfunc{cbc_encrypt}.  The function @var{f} is of
type:

@example
void f (void * @var{ctx}, unsigned @var{length},
        uint8_t @var{dst}, const uint8_t *@var{src})
@end example

@noindent
and the @cfunc{cbc_encrypt} and @cfunc{cbc_decrypt} functions pass their
argument @var{ctx} on to @var{f}.
@end deftypefun


There are also some macros to help use these functions correctly.

@defmac CBC_CTX (@var{context_type}, @var{block_size})
Expands into:

@example
@{
   context_type ctx;
   uint8_t iv[block_size];
@}
@end example
@end defmac


It can be used to define a @acronym{CBC} context struct, either directly:

@example
struct CBC_CTX(struct aes_ctx, AES_BLOCK_SIZE) ctx;
@end example

@noindent
or to give it a struct tag:

@example
struct aes_cbc_ctx CBC_CTX (struct aes_ctx, AES_BLOCK_SIZE);
@end example


@defmac CBC_SET_IV (@var{ctx}, @var{iv})
The first argument is a pointer to a context struct as defined by
@code{CBC_CTX}, and the second is a pointer to an initialization vector
that is copied into that context.
@end defmac


@defmac CBC_ENCRYPT (@var{ctx}, @var{f}, @var{length}, @var{dst}, @var{src})
@defmacx CBC_DECRYPT (@var{ctx}, @var{f}, @var{length}, @var{dst}, @var{src})
A simpler way to invoke @cfunc{cbc_encrypt} and @cfunc{cbc_decrypt}.
The first argument is a pointer to a context struct as defined by
@cfunc{CBC_CTX}, and the second argument is an encryption or decryption
function following Nettle's conventions.  The last three arguments
define the source and destination area for the operation.
@end defmac


These macros use some tricks to make the compiler display a warning if
the types of @var{f} and @var{ctx} don't match, e.g. if we try to use an
@code{struct aes_ctx} context with the @cfunc{des_encrypt} function.

@c page
@node nettle cipher modes ctr
@appendixsubsubsec Counter mode


@cindex Counter Mode
@cindex CTR Mode


Counter mode (@acronym{CTR}) uses the block cipher as a keyed
pseudo--random generator.  The output of the generator is XORed with the
data to be encrypted.  It can be understood as a way to transform a
block cipher to a stream cipher.

The message is divided into @math{n} blocks @math{M_1 @dots{} M_n} where
@math{M_n} is of size @math{m}, which may be smaller than the block
size.  Except for the last block, all the message blocks must be of size
equal to the cipher's block size.

If @math{E_k} is the encryption function of a block cipher, @math{IC} is
the @dfn{initial counter}, then the @math{n} plaintext blocks are
transformed into @math{n} ciphertext blocks @math{C_1 @dots{} C_n} as
follows:

@example
C_1 = E_k(IC) XOR M_1
C_2 = E_k(IC + 1) XOR M_2

@dots{}

C_(n-1) = E_k(IC + n - 2) XOR M_(n-1)
C_n = E_k(IC + n - 1) [1..m] XOR M_n
@end example

The @acronym{IC} is the initial value for the counter, it plays a
similar role as the @acronym{IV} for @acronym{CBC}.  When adding,
@math{IC + x}, @math{IC} is interpreted as an integer, in network byte
order.  For the last block, @math{E_k(IC + n - 1) [1..m]} means that the
cipher output is truncated to @math{m} bytes.


@deftypefun void ctr_crypt (void * @var{ctx}, nettle_crypt_func @var{f}, unsigned @var{block_size}, uint8_t * @var{ctr}, unsigned @var{length}, uint8_t * @var{dst}, const uint8_t * @var{src})
Apply the encryption function @var{f} in @acronym{CTR} mode.  Note that
for @acronym{CTR} mode, encryption and decryption is the same operation,
and hence @var{f} should always be the encryption function for the
underlying block cipher.

When a message is encrypted using a sequence of calls to
@cfunc{ctr_crypt}, all but the last call @strong{must} use a length that
is a multiple of the block size.
@end deftypefun


Like for @acronym{CBC}, there are also a couple of helper macros.


@defmac CTR_CTX (@var{context_type}, @var{block_size})
Expand into:

@example
@{
   context_type ctx;
   uint8_t ctr[block_size];
@}
@end example
@end defmac


@defmac CTR_SET_COUNTER (@var{ctx}, @var{iv})
The first argument is a pointer to a context struct as defined by
@cfunc{CTR_CTX}, and the second is a pointer to an initial counter that
is copied into that context.
@end defmac


@defmac CTR_CRYPT (@var{ctx}, @var{f}, @var{length}, @var{dst}, @var{src})
A simpler way to invoke @cfunc{ctr_crypt}.  The first argument is a
pointer to a context struct as defined by @cfunc{CTR_CTX}, and the
second argument is an encryption function following Nettle's
conventions.  The last three arguments define the source and destination
area for the operation.
@end defmac

@c page
@node nettle pubkey
@appendixsec Public--key algorithms


Nettle uses @acronym{GMP}, the @gnu{} bignum library, for all
calculations with large numbers.  In order to use the public--key
features of Nettle, we must install @acronym{GMP}, at least version 3.0,
before compiling Nettle, and we need to link the programs with
@code{-lhogweed -lnettle -lgmp}.

@menu
* nettle pubkey intro::         Introduction to public--key algorithms.
* nettle pubkey rsa::           The @acronym{RSA} public key algorithm.
* nettle pubkey dsa::           The @acronym{DSA} digital signature algorithm.
@end menu

@c page
@node nettle pubkey intro
@appendixsubsec Introduction to public--key algorithms


The concept of @dfn{Public--Key} encryption and digital signatures was
discovered by Whitfield Diffie and Martin E. Hellman and described in a
paper in 1976.  In traditional, ``symmetric'', cryptography, sender and
receiver share the same keys, and these keys must be distributed in a
secure way.  And if there are many users or entities that need to
communicate, each @emph{pair} needs a shared secret key known by nobody
else.

@cindex Public Key Cryptography
@cindex One-way function

Public--key cryptography uses trapdoor one--way functions.  A
@dfn{one--way function} is a function @math{F} such that it is easy to
compute the value @math{F(x)} for any @math{x}, but given a value
@math{y}, it is hard to compute a corresponding @math{x} such that
@math{y = F(x)}.  Two examples are cryptographic hash functions, and
exponentiation in certain groups.

A @dfn{trapdoor one--way function} is a function @math{F} that is
one--way, unless one knows some secret information about @math{F}.  If
one knows the secret, it is easy to compute both @math{F} and it's
inverse.  If this sounds strange, look at the @acronym{RSA} example
below.

Two important uses for one--way functions with trapdoors are public--key
encryption, and digital signatures.  The public--key encryption
functions in Nettle are not yet documented; the rest of this chapter is
about digital signatures.

To use a digital signature algorithm, one must first create a
@dfn{key--pair}: A public key and a corresponding private key.  The
private key is used to sign messages, while the public key is used for
verifying that that signatures and messages match.  Some care must be
taken when distributing the public key; it need not be kept secret, but
if a bad guy is able to replace it (in transit, or in some user's list
of known public keys), bad things may happen.

There are two operations one can do with the keys.  The signature
operation takes a message and a private key, and creates a signature for
the message.  A signature is some string of bits, usually at most a few
thousand bits or a few hundred octets.  Unlike paper--and--ink
signatures, the digital signature depends on the message, so one can't
cut it out of context and glue it to a different message.

The verification operation takes a public key, a message, and a string
that is claimed to be a signature on the message, and returns true or
false.  If it returns true, that means that the three input values
matched, and the verifier can be sure that someone went through with the
signature operation on that very message, and that the ``someone'' also
knows the private key corresponding to the public key.

The desired properties of a digital signature algorithm are as follows:
given the public key and pairs of messages and valid signatures on them,
it should be hard to compute the private key, and it should also be hard
to create a new message and signature that is accepted by the
verification operation.

Besides signing meaningful messages, digital signatures can be used for
authorization.  A server can be configured with a public key, such that
any client that connects to the service is given a random nonce message.
If the server gets a reply with a correct signature matching the nonce
message and the configured public key, the client is granted access.  So
the configuration of the server can be understood as ``grant access to
whoever knows the private key corresponding to this particular public
key, and to no others''.

@c page
@node nettle pubkey rsa
@appendixsubsec The @acronym{RSA} public key algorithm


The @acronym{RSA} algorithm was the first practical digital signature
algorithm that was constructed.  It was described 1978 in a paper by
Ronald Rivest, Adi Shamir and L.M. Adleman, and the technique was also
patented in the @acronym{USA} in 1983.  The patent expired on September
20, 2000, and since that day, @acronym{RSA} can be used freely, even in
the @acronym{USA}.

@menu
* nettle pubkey rsa intro::     Introduction to @acronym{RSA}.
* nettle pubkey rsa keys::      Handling @acronym{RSA} keys.
* nettle pubkey rsa sign::      Signing with @acronym{RSA}.
* nettle pubkey rsa crypt::     Encrypting with @acronym{RSA}.
* nettle pubkey rsa sexp::      Converting @acronym{RSA} keys to
                                S--expressions.
* nettle pubkey rsa der::       Converting @acronym{RSA} to @acronym{DER}
                                representation.
@end menu

@c page
@node nettle pubkey rsa intro
@appendixsubsubsec Introduction to @acronym{RSA}


It's remarkably simple to describe the trapdoor function behind
@acronym{RSA}; the ``one-way'' function is:

@example
F(x) = x^e mod n
@end example

@noindent
i.e. raise @math{x} to the @math{e}--th power, while discarding all
multiples of @math{n}; the pair of numbers @math{n} and @math{e} is the
public key.  @math{e} can be quite small, even @math{e = 3} has been
used, although slightly larger numbers are recommended.  @math{n} should
be about @math{1000} bits or larger.

If @math{n} is large enough, and properly chosen, the inverse of
@math{F}, the computation of @math{e}--th roots modulo @math{n}, is very
difficult.  But, where's the trapdoor?

Let's first look at how @acronym{RSA} key--pairs are generated; first
@math{n} is chosen as the product of two large prime numbers @math{p}
and @math{q} of roughly the same size (so if @math{n} is @math{1000}
bits, @math{p} and @math{q} are about @math{500} bits each).  One also
computes the number @math{phi = (p-1)(q-1)}, in mathematical speak,
@math{phi} is the order of the multiplicative group of integers modulo
@math{n}.

Next, @math{e} is chosen; it must have no factors in common with
@math{phi} (in particular, it must be odd), but can otherwise be chosen
more or less randomly.  @math{e = 65537} is a popular choice, because it
makes raising to the @math{e}--th power particularly efficient, and
being prime, it usually has no factors common with @math{phi}.

Finally, a number @math{d}, @math{d < n} is computed such that @math{e d
mod phi = 1}.  It can be shown that such a number exists (this is why
@math{e} and @math{phi} must have no common factors), and that for all
@math{x}:

@example
(x^e)^d mod n = x^(ed) mod n = (x^d)^e mod n = x
@end example

Using Euclid's algorithm, @math{d} can be computed quite easily from
@math{phi} and @math{e}.  But it is still hard to get @math{d} without
knowing @math{phi}, which depends on the factorization of @math{n}.

So @math{d} is the trapdoor, if we know @math{d} and @math{y = F(x)}, we
can recover @math{x} as @math{y^d mod n}.  @math{d} is also the private
half of the @acronym{RSA} key--pair.

The most common signature operation for @acronym{RSA} is defined in
@acronym{PKCS#1}, a specification by RSA Laboratories.  The message to
be signed is first hashed using a cryptographic hash function, e.g.
@acronym{MD5} or @acronym{SHA1}.  Next, some padding, the
@acronym{ASN.1} ``Algorithm Identifier'' for the hash function, and the
message digest itself, are concatenated and converted to a number
@math{x}.  The signature is computed from @math{x} and the private key
as @math{s = x^d mod n}.@footnote{Actually, the computation is not done
like this, it is done more efficiently using @math{p}, @math{q} and the
Chinese remainder theorem (@acronym{CRT}).  But the result is the same.}
The signature, @math{s} is a number of about the same size of @math{n},
and it usually encoded as a sequence of octets, most significant octet
first.

The verification operation is straight--forward, @math{x} is computed
from the message in the same way as above.  Then @math{s^e mod n} is
computed, the operation returns true if and only if the result equals
@math{x}.

@c page
@node nettle pubkey rsa keys
@appendixsubsubsec Handling @acronym{RSA} keys


Nettle represents @acronym{RSA} keys using two structures that contain
large numbers (of type @code{mpz_t}).


@deftp {Data Structure} {struct rsa_public_key}
It has the following fields:

@table @code
@item size
It is the size, in octets, of the modulo, and is used internally.

@item n
@itemx e
They are the public key.
@end table
@end deftp


@deftp {Data Structure} {struct rsa_private_key}
It has the following fields:

@table @code
@item size
It is the size, in octets, of the modulo, and is used internally.

@item d
It is the secret exponent, but it is not actually used when
signing.

@item p
@itemx q
@itemx a
@itemx b
@itemx c
Factors and parameters used when signing; they are computed from
@code{p}, @code{q} and @code{e} such that:

@example
a e mod (p - 1) = 1, b e mod (q - 1) = 1, c q mod p = 1
@end example
@end table
@end deftp


@deftypefun void rsa_public_key_init (struct rsa_public_key * @var{pub})
@deftypefunx void rsa_private_key_init (struct rsa_private_key * @var{key})
Call @code{mpz_init} on all numbers in the key struct.
@end deftypefun


@deftypefun void rsa_public_key_clear (struct rsa_public_key * @var{pub})
@deftypefunx void rsa_private_key_clear (struct rsa_private_key * @var{key})
Call @code{mpz_clear} on all numbers in the key struct.
@end deftypefun


In general, Nettle's @acronym{RSA} functions deviates from Nettle's ``no
memory allocation'' policy.  Space for all the numbers, both in the key
structs above, and temporaries, are allocated dynamically.  For
information on how to customize allocation, see @xref{Custom
Allocation,,GMP Allocation,gmp, GMP Manual}.


@deftypefun int rsa_generate_keypair (struct rsa_public_key * @var{pub}, struct rsa_private_key * @var{key}, void * @var{random_ctx}, nettle_random_func @var{random}, void * @var{progress_ctx}, nettle_progress_func @var{progress}, unsigned @var{n_size}, unsigned @var{e_size});
Generate a key pair; return @code{1} on success, and @code{0} on
failure.  The function can fail for example if if @var{n_size} is too
small, or if @var{e_size} is zero and @code{pub->e} is an even number.

@var{pub} and @var{key} is where the resulting key pair is stored.  The
structs should be initialised, but we don't need to call
@cfunc{rsa_public_key_prepare} or @cfunc{rsa_private_key_prepare} after
key generation.

@var{random_ctx} and @var{random} is a randomness generator.
@code{random(random_ctx, length, dst)} should generate @code{length}
random octets and store them at @var{dst}.  For advice, see
@ref{nettle random}.

@var{progress} and @var{progress_ctx} can be used to get callbacks
during the key generation process, in order to uphold an illusion of
progress.  @var{progress} can be @code{NULL}, in that case there are no
callbacks.

@var{size_n} is the desired size of the modulo, in bits.  If
@var{size_e} is non--zero, it is the desired size of the public exponent
and a random exponent of that size is selected; but if @var{e_size} is
zero, it is assumed that the caller has already chosen a value for
@code{e}, and stored it in @var{pub}.
@end deftypefun


When we have assigned values to the attributes of a key, we must call:


@deftypefun int rsa_public_key_prepare (struct rsa_public_key * @var{pub})
@deftypefunx int rsa_private_key_prepare (struct rsa_private_key * @var{key})
Compute the octet size of the key (stored in the @code{size} attribute,
and may also do other basic sanity checks.  Return one if successful, or
zero if the key can't be used, for instance if the modulo is smaller
than the minimum size specified by @acronym{PKCS#1}.
@end deftypefun

If we need to use the @acronym{RSA} trapdoor, the private key, in a way
that isn't supported by the above functions Nettle also includes a
function that computes @math{x^d mod n} and nothing more, using the
@acronym{CRT} optimization.


@deftypefun void rsa_compute_root (struct rsa_private_key * @var{key}, mpz_t @var{x}, const mpz_t @var{m})
Computes @code{x = m^d}, efficiently.
@end deftypefun

@c page
@node nettle pubkey rsa sign
@appendixsubsubsec Signing with @acronym{RSA}


Before signing or verifying a message, we first hash it with the
appropriate hash function.  We pass the hash function's context struct
to the @acronym{RSA} signature function, and it will extract the message
digest and do the rest of the work.  There are also alternative
functions that take the @acronym{MD5} or @acronym{SHA1} hash digest as
argument.

Creation and verification of signatures is done with the following
functions:


@deftypefun void rsa_md5_sign (const struct rsa_private_key * @var{key}, struct md5_ctx * @var{hash}, mpz_t @var{signature})
@deftypefunx void rsa_sha1_sign (const struct rsa_private_key * @var{key}, struct sha1_ctx * @var{hash}, mpz_t @var{signature})
@deftypefunx void rsa_sha256_sign (const struct rsa_private_key * @var{key}, struct sha256_ctx * @var{hash}, mpz_t @var{signature})
The signature is stored in @var{signature}, which must have been already
initialised.  The hash context is reset so that it can be used for new
messages.
@end deftypefun


@deftypefun void rsa_md5_sign_digest (const struct rsa_private_key * @var{key}, const uint8_t * @var{digest}, mpz_t @var{signature})
@deftypefunx void rsa_sha1_sign_digest (const struct rsa_private_key * @var{key}, const uint8_t * @var{digest}, mpz_t @var{signature});
@deftypefunx void rsa_sha256_sign_digest (const struct rsa_private_key * @var{key}, const uint8_t * @var{digest}, mpz_t @var{signature});
Create a signature from the given hash digest.  @var{digest} should
point to a digest of size @code{MD5_DIGEST_SIZE},
@code{SHA1_DIGEST_SIZE}, or @code{SHA256_DIGEST_SIZE}, respectively.
The signature is stored in @var{signature}, which must have been already
initialised.
@end deftypefun


@deftypefun int rsa_md5_verify (const struct rsa_public_key * @var{key}, struct md5_ctx * @var{hash}, const mpz_t @var{signature})
@deftypefunx int rsa_sha1_verify (const struct rsa_public_key * @var{key}, struct sha1_ctx * @var{hash}, const mpz_t @var{signature})
@deftypefunx int rsa_sha256_verify (const struct rsa_public_key * @var{key}, struct sha256_ctx * @var{hash}, const mpz_t @var{signature})
Return @code{1} if the signature is valid, or @code{0} if it is not; in
either case, the hash context is reset so that it can be used for new
messages.
@end deftypefun


@deftypefun int rsa_md5_verify_digest (const struct rsa_public_key * @var{key}, const uint8_t * @var{digest}, const mpz_t @var{signature})
@deftypefunx int rsa_sha1_verify_digest (const struct rsa_public_key * @var{key}, const uint8_t * @var{digest}, const mpz_t @var{signature})
@deftypefunx int rsa_sha256_verify_digest (const struct rsa_public_key * @var{key}, const uint8_t * @var{digest}, const mpz_t @var{signature})
Return @code{1} if the signature is valid, or @code{0} if it is not.
@var{digest} should point to a digest of size @code{MD5_DIGEST_SIZE},
@code{SHA1_DIGEST_SIZE}, or @code{SHA256_DIGEST_SIZE}, respectively.
@end deftypefun

@c page
@node nettle pubkey rsa crypt
@appendixsubsubsec Encrypting with @acronym{RSA}


@deftypefun int rsa_encrypt (const struct rsa_public_key * @var{key}, void * @var{random_ctx}, nettle_random_func @var{random}, unsigned @var{length}, const uint8_t * @var{cleartext}, mpz_t @var{cipher})
Encrypt @var{length} bytes of @var{cleartext} using the uspplied
@var{key} and store the result in @var{cipher}.  Return true if
successful, false otherwise (for example if the input is too long).

The @var{random} function and its custom context @var{random_ctx} are
used for padding the input data.
@end deftypefun


@deftypefun int rsa_decrypt (const struct rsa_private_key * @var{key}, unsigned * @var{length}, uint8_t * @var{cleartext}, const mpz_t @var{ciphertext})
Decrypt @var{ciphertext} using @var{key} and store the result in the
memory referenced by @var{cleartext}.

@var{cleartext} must point to a buffer of size @code{*@var{length}}; the
value stored in @code{@var{key}->size} is enough for all valid messages.
On success, @code{*@var{length}} is updated to reflect the actual length
of the message.

Return true if successful, false otherwise which happens if decryption
failed or if the message did not fit.
@end deftypefun

@c page
@node nettle pubkey rsa sexp
@appendixsubsubsec Converting @acronym{RSA} keys to S--expressions


@deftypefun int rsa_keypair_to_sexp (struct nettle_buffer * @var{buffer}, const char * @var{algorithm_name}, const struct rsa_public_key * @var{pub}, const struct rsa_private_key * @var{priv})
Generates a public key S--expression describing the public and private
keys; return true if successful, false otherwise.

If @var{priv} is @code{NULL}, generate an S--expression for the public
key only.  If @var{algorithm_name} is @code{NULL}, it implicitly means
@code{rsa}.
@end deftypefun


@deftypefun int rsa_keypair_from_sexp_alist (struct rsa_public_key * @var{pub}, struct rsa_private_key * @var{priv}, unsigned @var{limit}, struct sexp_iterator * @var{I})
Fill the already allocated key structures with values from the
S--expression iterator; return true if successful, false otherwise.

@var{limit} is the maximum number of bytes to read from an
S--expression's atom to compose a bignum; zero means no limit.
@end deftypefun


@deftypefun int rsa_keypair_from_sexp (struct rsa_public_key * @var{pub}, struct rsa_private_key * @var{priv}, unsigned @var{limit}, unsigned @var{length}, const uint8_t * @var{expr})
Fill the already allocated and initialised key structures with values
from the S--expression memory block; return true if successful, false
otherwise.

@var{limit} is the maximum number of bytes to read from an
S--expression's atom to compose a bignum; zero means no limit.

If @var{priv} is @code{NULL}, expect a public key only S--expression; if
@var{pub} is @code{NULL}, expect a private key only S--expression and
ignore the parts not needed for the public key.
@end deftypefun

@c page
@node nettle pubkey rsa der
@appendixsubsubsec Converting @acronym{RSA} to @acronym{DER} representation


@deftypefun int rsa_public_key_from_der_iterator (struct rsa_public_key * @var{pub}, unsigned @var{limit}, struct asn1_der_iterator * @var{I})
Fill the already allocated and initialised public key structure with
values from the iterator; return true if successful, false otherwise.

@var{limit} is the maximum number of bytes to read from an
S--expression's atom to compose a bignum; zero means no limit.
@end deftypefun


@deftypefun int rsa_private_key_from_der_iterator (struct rsa_public_key * @var{pub}, struct rsa_private_key * @var{priv}, unsigned @var{limit}, struct asn1_der_iterator * @var{I})
Fill the already allocated and initialised key structures with values
from the iterator; return true if successful, false otherwise.

@var{limit} is the maximum number of bytes to read from an
S--expression's atom to compose a bignum; zero means no limit.
@end deftypefun


@deftypefun int rsa_keypair_from_der (struct rsa_public_key * @var{pub}, struct rsa_private_key * @var{priv}, unsigned @var{limit}, unsigned @var{length}, const uint8_t * @var{data})
Fill the already allocated and initialised keys structures with values
from the memory block; return true if successful, false otherwise.

@var{limit} is the maximum number of bytes to read from an
S--expression's atom to compose a bignum; zero means no limit.

If @var{priv} is @code{NULL} read only the public key.
@end deftypefun

@c page
@node nettle pubkey dsa
@appendixsubsec The @acronym{DSA} digital signature algorithm


The @acronym{DSA} digital signature algorithm is more complex than
@acronym{RSA}.  It was specified during the early 1990s, and in 1994
NIST published @acronym{FIPS} 186 which is the authoritative
specification.  Sometimes @acronym{DSA} is referred to using the acronym
@acronym{DSS}, for Digital Signature Standard.

@menu
* nettle pubkey dsa intro::     Introduction to @acronym{DSA}.
* nettle pubkey dsa keys::      Handling @acronym{DSA} keys.
* nettle pubkey dsa sign::      Signing with @acronym{DSA}.
* nettle pubkey dsa sexp::      Converting @acronym{RSA} keys to
                                S--expressions.
@end menu

@c page
@node nettle pubkey dsa intro
@appendixsubsubsec Introduction to @acronym{DSA}


For @acronym{DSA}, the underlying mathematical problem is the
computation of discreet logarithms.  The public key consists of a large
prime @math{p}, a small prime @math{q} which is a factor of @math{p-1},
a number @math{g} which generates a subgroup of order @math{q} modulo
@math{p}, and an element @math{y} in that subgroup.

The size of @math{q} is fixed to @math{160} bits, to match with the
@acronym{SHA1} hash algorithm which is used in @acronym{DSA}.  The size
of @math{q} is in principle unlimited, but the standard specifies only
nine specific sizes: @math{512 + l * 64}, where @math{l} is between
@math{0} and @math{8}.  Thus, the maximum size of @math{p} is
@math{1024} bits, at that is also the recommended size.

The subgroup requirement means that if you compute:

@example
g^t mod p
@end example

@noindent
for all possible integers @math{t}, you will get precisely @math{q}
distinct values.

The private key is a secret exponent @math{x}, such that:

@example
g^x = y mod p
@end example

In mathematical speak, @math{x} is the @dfn{discrete logarithm} of
@math{y mod p}, with respect to the generator @math{d}.  The size of
@math{x} will also be about @math{160} bits.

The signature generation algorithm is randomized; in order to create a
@acronym{DSA} signature, we need a good source for random numbers
(@pxref{nettle random}).

To create a signature, one starts with the hash digest of the message,
@math{h}, which is a @math{160} bit number, and a random number
@math{k}, @math{0 < k < q}, also @math{160} bits.  Next, one computes:

@example
r = (g^k mod p) mod q
s = k^-1 (h + x r) mod q
@end example

The signature is the pair @math{(r, s)}, two @math{160} bit numbers.
Note the two different mod operations when computing @math{r}, and the
use of the secret exponent @math{x}.

To verify a signature, one first checks that @code{0 < r} and @math{s <
q}, and then one computes backwards:

@example
w = s^-1 mod q
v = (g^(w h) y^(w r) mod p) mod q
@end example

The signature is valid if @math{v = r}.  This works out because:

@example
w = s^-1 mod q = k (h + x r)^-1 mod q
@end example

@noindent
so that:

@example
g^(w h) y^(w r) = g^(w h) (g^x)^(w r) = g^(w (h + x r)) = g^k
@end example

When reducing @math{mod q} this yields @math{r}.  Note that when
verifying a signature, we don't know either @math{k} or @math{x}: those
numbers are secret.

If we can choose between @acronym{RSA} and @acronym{DSA}, which one is
best?  Both are believed to be secure.  @acronym{DSA} gained popularity
in the late 1990s, as a patent free alternative to @acronym{RSA}.  Now
that the @acronym{RSA} patents have expired, there's no compelling
reason to want to use @acronym{DSA}.

@acronym{DSA} signatures are smaller than @acronym{RSA} signatures,
which is important for some specialized applications.

From a practical point of view, @acronym{DSA}'s need for a good
randomness source is a serious disadvantage.  If we ever use the same
@math{k} (and @math{r}) for two different message, we leak our private
key.

@c page
@node nettle pubkey dsa keys
@appendixsubsubsec Handling @acronym{DSA} keys


Nettle represents @acronym{DSA} keys using two structures, containing
values of type @code{mpz_t}.  For information on how to customize
allocation, see @xref{Custom Allocation,,GMP Allocation,gmp, GMP
Manual}.


@deftp {Data Structure} {struct dsa_public_key}
It has the following fields:

@example
p q g y
@end example
@end deftp


@deftp {Data Structure} {struct dsa_private_key}
It has a single field @code{x}.
@end deftp


@deftypefun void dsa_public_key_init (struct dsa_public_key * @var{pub})
@deftypefunx void dsa_private_key_init (struct dsa_private_key * @var{key})
Call @code{mpz_init} on all numbers in the key structure.
@end deftypefun


@deftypefun void dsa_public_key_clear (struct dsa_public_key * @var{pub})
@deftypefunx void dsa_private_key_clear (struct dsa_private_key * @var{key})
Call @code{mpz_clear} on all numbers in the key structure.
@end deftypefun


@deftypefun int dsa_generate_keypair (struct dsa_public_key * @var{pub}, struct dsa_private_key * @var{key}, void * @var{random_ctx}, nettle_random_func @var{random}, void * @var{progress_ctx}, nettle_progress_func @var{progress}, unsigned @var{bits})
Generate a key pair; return @code{1} on success, and @code{0} on
failure.

@var{pub} and @var{key} is where the resulting key pair is stored.  The
structs should be initialized before you call this function.

@var{random_ctx} and @var{random} is a randomness generator.
@code{random(random_ctx, length, dst)} should generate @code{length}
random octets and store them at @code{dst}.  For advice, see
@ref{nettle random}.

@var{progress} and @var{progress_ctx} can be used to get callbacks
during the key generation process, in order to uphold an illusion of
progress.  @var{progress} can be @code{NULL}, in that case there are no
callbacks.

@var{bits} is the desired size of @math{p}, in bits.  To generate keys
that conform to the standard, you must use a value of the form @math{512
+ l * 64}, for @math{0 <= l <= 8}.  Keys smaller than @math{768} bits
are not considered secure, so we should probably stick to @math{1024}.
Nonstandard sizes are possible, in particular sizes larger than
@math{1024} bits, although @acronym{DSA} implementations can not in
general be expected to support such keys.  Also note that using very
large keys doesn't make much sense, because the security is also limited
by the size of the smaller prime @math{q}, which is always @math{160}
bits.  The function will fail if @var{bits} is too small.
@end deftypefun

@c page
@node nettle pubkey dsa sign
@appendixsubsubsec Signing with @acronym{DSA}


Signatures are represented using the structure below, and need to be
initialized and cleared in the same way as the key structures.


@deftp {Data Structure} {struct dsa_signature}
It has the fields @code{r} and @code{s}.
@end deftp


@deftypefun void dsa_signature_init (struct dsa_signature * @var{signature})
@deftypefunx void dsa_signature_clear (struct dsa_signature * @var{signature})
We must call @cfunc{dsa_signature_init} before creating or using a
signature, and call @cfunc{dsa_signature_clear} when we are finished
with it.
@end deftypefun


For signing, we need to provide both the public and the private key and
a source for random numbers.  Signatures always use the @acronym{SHA1}
hash function.


@deftypefun void dsa_sign (const struct dsa_public_key * @var{pub}, const struct dsa_private_key * @var{key}, void * @var{random_ctx}, nettle_random_func @var{random}, struct sha1_ctx * @var{hash}, struct dsa_signature * @var{signature})
@deftypefunx void dsa_sign_digest (const struct dsa_public_key * @var{pub}, const struct dsa_private_key * @var{key}, void * @var{random_ctx}, nettle_random_func @var{random}, const uint8_t * @var{digest}, struct dsa_signature * @var{signature})
Create a signature from the given hash context or digest.

@var{random_ctx} and @var{random} is a randomness generator.
@code{random(random_ctx, length, dst)} should generate @code{length}
random octets and store them at @code{dst}.  For advice, see @ref{nettle
random}.
@end deftypefun


@deftypefun int dsa_verify (const struct dsa_public_key * @var{key}, struct sha1_ctx * @var{hash}, const struct dsa_signature * @var{signature})
@deftypefunx int dsa_verify_digest (const struct dsa_public_key * @var{key}, const uint8_t * @var{digest}, const struct dsa_signature * @var{signature})
Verify a signature; return @code{1} if the signature is valid, otherwise
@code{0}.
@end deftypefun

@c page
@node nettle pubkey dsa sexp
@appendixsubsubsec Converting @acronym{RSA} keys to S--expressions


@deftypefun int dsa_signature_from_sexp (struct dsa_signature * @var{sig}, struct sexp_iterator * @var{I})
Fill the already allocated and initialised signature structure with
values from the S--expression iterator; return true if successful, false
otherwise.
@end deftypefun


@deftypefun int dsa_keypair_from_sexp_alist (struct dsa_public_key * @var{pub}, struct dsa_private_key * @var{priv}, unsigned @var{limit}, struct sexp_iterator * @var{I})
Fill the already allocated and initialised key structures with values
from the S--expression iterator; return true if successful, false
otherwise.

@var{limit} is the maximum number of bytes to read from an
S--expression's atom to compose a bignum; zero means no limit.
@end deftypefun


@deftypefun int dsa_keypair_from_sexp (struct dsa_public_key * @var{pub}, struct dsa_private_key * @var{priv}, unsigned @var{limit}, unsigned @var{length}, const uint8_t * @var{expr})
Fill the already allocated and initialised key structures with values
from the S--expression's memory block; return true if successful, false
otherwise.

@var{limit} is the maximum number of bytes to read from an
S--expression's atom to compose a bignum; zero means no limit.

If @var{priv} is @code{null}, expect a public key only expression; if
@var{pub} is @code{NULL}, expect a private key only expression and
ignore the parts not needed for the public key.
@end deftypefun

@c page
@node nettle random
@appendixsec Randomness


@cindex Randomness


A crucial ingredient in many cryptographic contexts is randomness: let
@math{p} be a random prime, choose a random initialization vector
@math{iv}, a random key @math{k} and a random exponent @math{e}, etc.
In the theories, it is assumed that we have plenty of randomness around;
if this assumption is not true in practice, systems that are otherwise
perfectly secure, can be broken.  Randomness has often turned out to be
the weakest link in the chain.

@menu
* nettle random intro::         Introduction to pseudo--randomness
                                generation.
* nettle random yarrow::        Yarrow generator.
* nettle random knuth::         Knuth's lagged Fibonacci generator.
@end menu

@c page
@node nettle random intro
@appendixsubsec Introduction to pseudo--randomness generation


In non--cryptographic applications, such as games as well as scientific
simulation, a good randomness generator usually means a generator that
has good statistical properties, and is seeded by some simple function
of things like the current time, process id, and host name.

However, such a generator is inadequate for cryptography, for at least
two reasons:

@itemize
@item
It's too easy for an attacker to guess the initial seed.  Even if it
will take some @math{2^32} tries before he guesses right, that's far too
easy.  For example, if the process id is @math{16} bits, the resolution
of ``current time'' is one second, and the attacker knows what day the
generator was seeded, there are only about @math{2^32} possibilities to
try if all possible values for the process id and time--of--day are
tried.

@item
The generator output reveals too much.  By observing only a small
segment of the generator's output, its internal state can be recovered,
and from there, all previous output and all future output can be
computed by the attacker.
@end itemize

A randomness generator that is used for cryptographic purposes must have
better properties.  Let's first look at the seeding, as the issues here
are mostly independent of the rest of the generator.  The initial state
of the generator (its seed) must be unguessable by the attacker.  So
what's unguessable?  It depends on what the attacker already knows.

The concept used in information theory to reason about such things is
called ``entropy'', or ``conditional entropy'' (not to be confused with
the thermodynamic concept with the same name).  A reasonable requirement
is that the seed contains a conditional entropy of at least some
@math{80-100} bits.

This property can be explained as follows: allow the attacker to ask
@math{n} yes--no--questions, of his own choice, about the seed.  If the
attacker, using this question--and--answer session, as well as any other
information he knows about the seeding process, still can't guess the
seed correctly, then the conditional entropy is more than @math{n} bits.

@cindex Entropy
@cindex Conditional entropy

Let's look at an example.  Let's say information about timing of
received network packets is used in the seeding process.  If there is
some random network traffic going on, this will contribute some bits of
entropy or ``unguessability'' to the seed.  However, if the attacker can
listen in to the local network, or if all but a small number of the
packets were transmitted by machines that the attacker can monitor, this
additional information makes the seed easier for the attacker to figure
out.  Even if the information is exactly the same, the conditional
entropy, or unguessability, is smaller for an attacker that knows some
of it already before the hypothetical question--and--answer session.

Seeding of good generators is usually based on several sources.  The key
point here is that the amount of unguessability that each source
contributes, depends on who the attacker is.  Some sources that have
been used are:

@table @asis
@item High resolution timing of I/O activities
Such as completed blocks from spinning hard disks, network packets, etc.
Getting access to such information is quite system dependent, and not
all systems include suitable hardware.  If available, it's one of the
better randomness source one can find in a digital, mostly predictable,
computer.

@item User activity
Timing and contents of user interaction events is another popular source
that is available for interactive programs.  Obviously, not available
when a machine is unattended.  Also beware of networks: user interaction
that happens across a long serial cable, @acronym{TELNET} session, or
even @acronym{SSH} session may be visible to an attacker, in full or
partially.

@item Audio input
Any room, or even a microphone input that's left unconnected, is a
source of some random background noise, which can be fed into the
seeding process.

@item Specialized hardware
Hardware devices with the sole purpose of generating random data have
been designed.  They range from radioactive samples with an attached
Geiger counter, to amplification of the inherent noise in electronic
components such as diodes and resistors, to low--frequency sampling of
chaotic systems.  Hashing successive images of a Lava lamp is a
spectacular example of the latter type.

@item Secret information
Secret information, such as user passwords or keys, or private files
stored on disk, can provide some unguessability.  A problem is that if
the information is revealed at a later time, the unguessability
vanishes.  Another problem is that this kind of information tends to be
fairly constant, so if we rely on it and seed our generator regularly,
we risk constructing almost similar seeds or even constructing the same
seed more than once.
@end table

For all practical sources, it's difficult but important to provide a
reliable lower bound on the amount of unguessability that it provides.
Two important points are to make sure that the attacker can't observe
our sources (so if you like the Lava lamp idea, remember that we have to
get our own lamp, and not put it by a window or anywhere else where
strangers can see it), and that hardware failures are detected.  What if
the bulb in the Lava lamp, which we keep locked into a cupboard
following the above advice, breaks after a few months?

So let's assume that we have been able to find an unguessable seed,
which contains at least @math{80} bits of conditional entropy, relative
to all attackers that we care about (typically, we must at the very
least assume that no attacker has root privileges on our machine).

How do we generate output from this seed, and how much can we get?  Some
generators (notably the Linux @file{/dev/random} generator) try to
estimate available entropy and restrict the amount of output.  The goal
is that if we read @math{128} bits from @file{/dev/random}, we should
get @math{128} ``truly random'' bits.  This is a property that is useful
in some specialized circumstances, for instance when generating key
material for a one time pad, or when working with unconditional
blinding, but in most cases, it doesn't matter much.  For most
applications, there's no limit on the amount of useful ``random'' data
that we can generate from a small seed; what matters is that the seed is
unguessable and that the generator has good cryptographic properties.

At the heart of all generators lies its internal state.  Future output
is determined by the internal state alone.  Let's call it the
generator's key.  The key is initialized from the unguessable seed.
Important properties of a generator are:

@table @dfn
@item Key--hiding
An attacker observing the output should not be able to recover the
generator's key.

@item Independence of outputs
Observing some of the output should not help the attacker to guess
previous or future output.

@item Forward secrecy
Even if an attacker compromises the generator's key, he should not be
able to guess the generator output @emph{before} the key compromise.

@item Recovery from key compromise
If an attacker compromises the generator's key, he can compute
@emph{all} future output.  This is inevitable if the generator is seeded
only once, at startup.  However, the generator can provide a reseeding
mechanism, to achieve recovery from key compromise.  More precisely: if
the attacker compromises the key at a particular time @math{t_1}, there
is another later time @math{t_2}, such that if the attacker observes all
output generated between @math{t_1} and @math{t_2}, he still can't guess
what output is generated after @math{t_2}.
@end table

Nettle includes one randomness generator that is believed to have all
the above properties, and two simpler ones.

@acronym{ARCFOUR}, like any stream cipher, can be used as a randomness
generator.  Its output should be of reasonable quality, if the seed is
hashed properly before it is used with @cfunc{arcfour_set_key}.  There's
no single natural way to reseed it, but if we need reseeding, we should
be using Yarrow instead.

The ``lagged Fibonacci'' generator in @file{<nettle/knuth-lfib.h>} is a
fast generator with good statistical properties, but is @strong{not} for
cryptographic use.  It is included mostly because the Nettle test suite
needs to generate some test data from a small seed.

The recommended generator to use is Yarrow.

@c page
@node nettle random yarrow
@appendixsubsec Yarrow generator


Yarrow is a family of pseudo--randomness generators, designed for
cryptographic use, by John Kelsey, Bruce Schneier and Niels Ferguson.
Yarrow-160 is described in a paper at:

@center @url{http://www.counterpane.com/yarrow.html}

@noindent
and it uses @acronym{SHA1} and @acronym{DES3}, and has a @math{160} bits
internal state.  Nettle implements Yarrow-256, which is similar, but
uses @acronym{SHA256} and @acronym{AES} to get an internal state of
@math{256} bits.

@menu
* nettle random yarrow intro::          Introduction to Yarrow.
* nettle random yarrow api::            Yarrow programming interface.
* nettle random yarrow entropy::        Entropy estimator.
@end menu

@c page
@node nettle random yarrow intro
@appendixsubsubsec Introduction to Yarrow


Yarrow was an almost finished project, the paper mentioned above is the
closest thing to a specification for it, but some smaller details are
left out.  There is no official reference implementation or test cases.
This section includes an overview of Yarrow, but for the details of
Yarrow-256, as implemented by Nettle, you have to consult the source
code.

Yarrow can use many sources (at least two are needed for proper
reseeding), and two randomness ``pools'', referred to as the ``slow
pool'' and the ``fast pool''.  Input from the sources is fed
alternatingly into the two pools.  When one of the sources has
contributed @math{100} bits of entropy to the fast pool, a ``fast
reseed'' happens and the fast pool is mixed into the internal state.
When at least two of the sources have contributed at least @math{160}
bits each to the slow pool, a ``slow reseed'' takes place.  The contents
of both pools are mixed into the internal state.  These procedures
should ensure that the generator will eventually recover after a key
compromise.

The output is generated by using @acronym{AES} to encrypt a counter,
using the generator's current key.  After each request for output,
another @math{256} bits are generated which replace the key.  This
ensures forward secrecy.

Yarrow can also use a @dfn{seed file} to save state across restarts.
Yarrow is seeded by either feeding it the contents of the previous seed
file, or feeding it input from its sources until a slow reseed happens.

@c page
@node nettle random yarrow api
@appendixsubsubsec Yarrow programming interface


Nettle defines Yarrow-256 in @file{<nettle/yarrow.h>}.


@deftp {Data Structure} {struct yarrow256_ctx}
Context structure for the generator.
@end deftp


@deftp {Data Structure} {struct yarrow_source}
Information about a single source.
@end deftp


@defvr Constant YARROW256_SEED_FILE_SIZE
Recommanded size of the Yarrow-256 seed file.
@end defvr


@deftypefun void yarrow256_init (struct yarrow256_ctx * @var{ctx}, unsigned @var{nsources}, struct yarrow_source * @var{sources})
Initialise the yarrow context and its @var{nsources} sources.  It's
possible to call it with @var{nsources} set to zero and @var{sources}
set to @code{NULL}, if we don't need the update features.
@end deftypefun


@deftypefun void yarrow256_seed (struct yarrow256_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{seed_file})
Seed Yarrow-256 from a previous seed file.  @var{length} should be at
least @code{YARROW256_SEED_FILE_SIZE}, but it can be larger.

The generator will trust us that the @var{seed_file} data really is
unguessable.  After calling this function, we @strong{must} overwrite
the old seed file with newly generated data from
@cfunc{yarrow256_random}.

If it's possible for several processes to read the seed file at about
the same time, access must be coordinated using some locking mechanism.
@end deftypefun


@deftypefun int yarrow256_update (struct yarrow256_ctx * @var{ctx}, unsigned @var{source}, unsigned @var{entropy}, unsigned @var{length}, const uint8_t * @var{data})
Update the generator with data from source @var{source} (an index that
must be smaller than the number of sources).  @var{entropy} is our
estimated lower bound for the entropy in the data, measured in bits.
Calling update with zero @var{entropy} is always safe, no matter if the
data is random or not.

Return @code{1} if a reseed happened, in which case an application using
a seed file may want to generate new seed data with
@cfunc{yarrow256_random} and overwrite the seed file.  Otherwise, the
function returns @code{0}.
@end deftypefun


@deftypefun void yarrow256_random (struct yarrow256_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst})
Generate @var{length} octets of output.  The generator must be seeded
before we call this function.

If we don't need forward secrecy, e.g. if we need non--secret randomness
for initialization vectors or padding, we can gain some efficiency by
buffering, calling this function for reasonably large blocks of data,
say @math{100-1000} octets at a time.
@end deftypefun


@deftypefun int yarrow256_is_seeded (struct yarrow256_ctx * @var{ctx})
Return @code{1} if the generator is seeded and ready to generate output,
otherwise @code{0}.
@end deftypefun


@deftypefun unsigned yarrow256_needed_sources (struct yarrow256_ctx * @var{ctx})
Return the number of sources that must reach the threshold before a slow
reseed will happen.  Useful primarily when the generator is unseeded.
@end deftypefun


@deftypefun void yarrow256_fast_reseed (struct yarrow256_ctx * @var{ctx})
@deftypefunx void yarrow256_slow_reseed (struct yarrow256_ctx * @var{ctx})
Cause a fast or slow reseed to take place immediately, regardless of the
current entropy estimates of the two pools.  Use with care.
@end deftypefun

@c page
@node nettle random yarrow entropy
@appendixsubsubsec Entropy estimator


Nettle includes an entropy estimator for one kind of input source: user
keyboard input.


@deftp {Context struct} {struct yarrow_key_event_ctx}
Information about recent key events.
@end deftp


@deftypefun void yarrow_key_event_init (struct yarrow_key_event_ctx * @var{ctx})
Initialise the context.
@end deftypefun


@deftypefun unsigned yarrow_key_event_estimate (struct yarrow_key_event_ctx * @var{ctx}, unsigned @var{key}, unsigned @var{time})
@var{key} is the id of the key (@ascii{} value, hardware key code, X
keysym, @dots{}, it doesn't matter) and @var{time} is the timestamp of
the event.  The time must be given in units matching the resolution by
which we read the clock.  If we read the clock with microsecond
precision, @var{time} should be provided in units of microseconds.  But
if we use @cfunc{gettimeofday} on a typical Unix system where the clock
ticks @math{10} or so microseconds at a time, @var{time} should be given
in units of @math{10} microseconds.

Return an entropy estimate, in bits, suitable for calling
@cfunc{yarrow256_update}; usually @math{0}, @math{1} or @math{2} bits.
@end deftypefun

@c page
@node nettle random knuth
@appendixsubsec Knuth's lagged Fibonacci generator


@deftp {Data Structure} {struct knuth_lfib_ctx}
Context structure for the generator.
@end deftp


@deftypefun void knuth_lfib_init (struct knuth_lfib_ctx * @var{ctx}, uint32_t @var{seed})
Initialise the context.
@end deftypefun


@deftypefun uint32_t knuth_lfib_get (struct knuth_lfib_ctx * @var{ctx})
Return a single number in the range @math{0 @dots{} 2^30-1}.
@end deftypefun


@deftypefun void knuth_lfib_get_array (struct knuth_lfib_ctx * @var{ctx}, unsigned @var{length}, uint32_t * @var{buffer})
Get an array of numbers.
@end deftypefun


@deftypefun void knuth_lfib_random (struct knuth_lfib_ctx * @var{ctx}, unsigned @var{length}, uint8_t * @var{dst})
Get an array of octets.
@end deftypefun

@c page
@node nettle buffer
@appendixsec Memory buffers


Nettle implements a basic string stream data structure.  The @api{} is
defined in @file{nettle/sexp.h}.

@menu
* nettle buffer types::         Memory buffer data type.
* nettle buffer init::          Initialisation and finalisation
                                of memory buffers.
* nettle buffer write::         Writing data to memory buffers.
@end menu

@c page
@node nettle buffer types
@appendixsubsec Memory buffer data type


@deftp {Data Structure} {struct nettle_buffer}
It has the following fields:

@table @code
@item uint8_t * contents
Pointer to the memory block.

@item unsigned alloc
Number of allocated bytes in the block referenced by @code{contents}.

@item void * realloc_ctx
@itemx nettle_realloc_func * realloc
Function to be used to allocate memory and pointer to its custom context
data.

@item unsigned size
Current data size in the block referenced by @code{contents}.  Used
bytes start from the beginning of the block.
@end table
@end deftp

@c page
@node nettle buffer init
@appendixsubsec Initialisation and finalisation of memory buffers


@deftypefun void nettle_buffer_init (struct nettle_buffer * @var{B})
Initialise an already allocated buffer structure, registering the
standard @cfunc{realloc} function as memory allocator.
@end deftypefun


@deftypefun void nettle_buffer_init_realloc (struct nettle_buffer * @var{B}, void * @var{ctx}, nettle_realloc_func @var{realloc})
Initialise an already allocated buffer structure, registering the
@var{realloc} function as memory allocator with @var{ctx} as its custom
context.
@end deftypefun


@deftypefun void nettle_buffer_init_size (struct nettle_buffer * @var{B}, unsigned @var{len}, uint8_t * @var{block})
Initialise an already allocated buffer structure using the referenced
memory block as internal buffer; this makes the buffer a ``view'' over
the referenced block.

The maximum size of the buffer will be @var{len} and the buffer cannot
be reallocated; attempting to store more than @var{len} bytes in this
buffer will cause an error code to be returned.

The @code{size} field of @var{B} is set to zero, so, initially, the
buffer is considered empty; we can override this by setting explicitly a
value for @code{size}.
@end deftypefun


@deftypefun void nettle_buffer_clear (struct nettle_buffer * @var{B})
Release the allocated memory (if any) and reset all the structure fields
to zero.
@end deftypefun


@deftypefun void nettle_buffer_reset (struct nettle_buffer * @var{B})
Reset the buffer to zero length (empty), without releasing the allocated
memory.
@end deftypefun


@deftypefun int nettle_buffer_grow (struct nettle_buffer * @var{B}, unsigned @var{len})
Make sure the buffer has room for @var{len} bytes, reallocating if
needed.  Return true if successful, false otherwise.
@end deftypefun

@c page
@node nettle buffer write
@appendixsubsec Writing data to memory buffers


@defmac NETTLE_BUFFER_PUTC (@var{buffer}, @var{ch})
Append a single character to @var{buffer}, reallocating it if needed.
Evaluate to true if successful, to false otherwise.
@end defmac


@deftypefun int nettle_buffer_write (struct nettle_buffer * @var{B}, unsigned @var{len}, const uint8_t * @var{ptr})
Append the referenced block of memory to the buffer, copying data;
return true if successful, false otherwise (for example, out of memory
error).
@end deftypefun


@deftypefun {uint8_t *} nettle_buffer_space (struct nettle_buffer * @var{B}, unsigned @var{len})
Make room for new data at the end.  Make sure that the buffer has room
for @var{len} bytes more and mark those bytes as used (setting the
@code{size} field of @var{B}); return a pointer to the first byte in the
buffer in which we can copy the actual @var{len} new bytes of data.  The
pointer is valid only until the next call that can reallocate the
buffer.

Return @code{NULL} if an error occurs (for example, out of memory
error).
@end deftypefun


@deftypefun int nettle_buffer_copy (struct nettle_buffer * @var{dst}, const struct nettle_buffer * @var{src})
Append the contents of @var{src} to the end of @var{dst}; return true if
successful, false otherwise.
@end deftypefun

@c page
@node nettle sexp
@appendixsec S--expressions


The functions documented in this section manage construction and parsing
of S--expressions; the format of S--expressions is decribed by Ron
Rivest in the following document:

@center @url{http://theory.lcs.mit.edu/~rivest/sexp.html}

@noindent
Nettle defines the S--expressions @api{} in @file{nettle/sexp.h}.

@menu
* nettle sexp intro::           Introduction to S--expressions.
* nettle sexp types::           Type definitions.
* nettle sexp iter::            Parsing an S--expression with
                                an iterator.
* nettle sexp output::          Serialising an S--expression.
* nettle sexp examples::        Examples of S--expressions parsing
                                and serialisation.
@end menu

@c page
@node nettle sexp intro
@appendixsubsec Introduction to S--expressions


Nettle sexps format is based on Ron Rivest's work; basically, we can
think of a sexp as a string of characters with nested, matched,
parentheses and strings prefixed with their own length:

@example
(4:ciao)
@end example

@noindent
@code{4} is the number of characters in @code{ciao} and the @code{:}
character acts as separator.  In the canonical format white spaces are
@strong{not} used as separator; the following example is a sexp holding
two elements, the strings @code{ciao} and @code{hello}:

@example
(4:ciao5:hello)
@end example

Numbers are embedded in sexps as atoms, sequences of bytes in network,
big--endian, byte order.

@c page
@node nettle sexp types
@appendixsubsec Type definitions


@deftp {Enumeration} sexp_type
Tag values for sexp component types.
@end deftp


@defvr Constant SEXP_ATOM
@defvrx Constant SEXP_LIST
@defvrx Constant SEXP_END
Values in the @code{enum sexp_type} enumeration.
@end defvr


@deftp {Data Structure} {struct sexp_iterator}
Data type for the S--expression iterator.  It has the following public
fields:

@table @code
@item const uint8_t * buffer
Pointer to a block of memory holding the S--expression.

@item unsigned length
Number of bytes in the block of memory referenced by @code{buffer}.

@item enum sexp_type type
The type of the current element.

@item const uint8_t * atom
If the current element is an atom (@code{SEXP_ATOM} == type), this field
points to the first byte of the atom's string.

@item unsigned atom_length
If the current element is an atom (@code{SEXP_ATOM} == type), this field
holds the number of bytes in the atom's string.
@end table
@end deftp

@c page
@node nettle sexp iter
@appendixsubsec Parsing an S--expression with an iterator


For a full understanding of the following functions we have to read the
examples sections @ref{nettle sexp examples}.  The purpose of this
@api{} is to extract informations from S--expression of known structure;
it is not a tool to parse arbitrary S--expressions.


@deftypefun int sexp_iterator_first (struct sexp_iterator * @var{I}, unsigned @var{len}, const uint8_t * @var{ptr})
Initialise an already allocated iterator structure; return true if
successful, false otherwise.  @var{len} and @var{ptr} must reference a
memory block holding the S--expression to be parsed in canonical format.

This function does @strong{not} mutate the input buffer.
@end deftypefun


@deftypefun int sexp_transport_iterator_first (struct sexp_iterator * @var{I}, unsigned @var{len}, uint8_t * @var{ptr})
Initialise an already allocated iterator structure; return true if
successful, false otherwise.  @var{len} and @var{ptr} must reference a
memory block holding the S--expression to be parsed in transport format.

This function mutates the input buffer, decoding in--place base64 strings.
@end deftypefun


@deftypefun int sexp_iterator_next (struct sexp_iterator * @var{I})
Advance the iterator to the next expression; return true if successful,
false otherwise.  If the iterators advances past the last expression,
the @code{type} field of @var{I} is set to @code{SEXP_END}; if the
iterator is already at the end of the S--expression, nothing happens and
the return value is true.
@end deftypefun


@deftypefun int sexp_iterator_enter_list (struct sexp_iterator * @var{I})
If the current expression is a list, make the iterator enter it and be
ready to parse its subexpressions; return true if successful, false
otherwise.
@end deftypefun


@deftypefun int sexp_iterator_exit_list (struct sexp_iterator * @var{I})
If the iterator is parsing a list, exit it and be ready to parse the
expression after it; return true if successful, false otherwise.  If
there is no other subexpression after the list, the @code{type} field of
the iterator is set to @code{SEXP_END}.
@end deftypefun


@deftypefun {const uint8_t *} sexp_iterator_subexpr (struct sexp_iterator * @var{I}, unsigned * @var{lenp})
Return a pointer to the first byte of the current subexpression and
store its length in bytes in the variable referenced by @var{lenp}; then
get ready to parse the next subexpression with a call to
@cfunc{sexp_iterator_next}.
@end deftypefun


@deftypefun int sexp_iterator_get_uint32 (struct sexp_iterator * @var{I}, uint32_t * @var{nump})
If the current subexpression is a number, store it in the variable
referenced by @var{nump}; then get ready to parse the next subexpression
with a call to @cfunc{sexp_iterator_next}.  Return true if successful,
false otherwise.
@end deftypefun


@deftypefun int nettle_mpz_set_sexp (mpz_t @var{x}, unsigned @var{limit}, struct sexp_iterator * @var{I})
If the current expression is a bignum, store it in the already
initialised @var{x} number; return true if successful, false otherwise.

@var{limit} is the maximum number of bytes to read from an
S--expression's atom to compose a bignum; zero means no limit.
@end deftypefun


@deftypefun int sexp_iterator_check_type (struct sexp_iterator * @var{I}, const uint8_t * @var{key})
Verify if the current expression is a list, whose first subexpression is
an atom, matching the one referenced by @var{key}; finally get ready to
parse the next subexpression with a call to @cfunc{sexp_iterator_next}.
If all of this is successful return true, otherwise return false.

The block of memory referenced by @var{key} must be zero--terminated.
@end deftypefun


@deftypefun {const uint8_t *} sexp_iterator_check_types (struct sexp_iterator * @var{I}, unsigned @var{nkeys}, const uint8_t * const * @var{keys})
Verify if the current expression is a list, whose first subexpression is
an atom, matching one of the @var{nkeys} elements of the array
referenced by @var{keys}; finally get ready to parse the next
subexpression with a call to @cfunc{sexp_iterator_next}.

If all of this is successful return a pointer to the element of
@var{keys} which matched, otherwise return @code{NULL}.

All the elements in the array @var{keys} must be pointers to
zero--terminated memory blocks.
@end deftypefun


@deftypefun int sexp_iterator_assoc (struct sexp_iterator * @var{I}, unsigned @var{nkeys}, const uint8_t * const * @var{keys}, struct sexp_iterator * @var{values})
Query the current expression as an association list; return true if
successful, false otherwise.

@var{keys} must reference an array of @var{nkeys} strings representing
the association list keys.  @var{values} must reference an array of at
least @var{nkeys} iterator structures which are initialised to reference
the first value expression for each found key; prior to this call, the
iterators must be put into a recognisable ``uninitialised'' state, such
as setting the @code{type} field to @code{SEXP_END}.

For example, let's take the following S--expression:

@example
((alpha 1)
 (beta  4 5)
 (delta 6))
@end example

@noindent
it is a list of three sublists, each starting with an atom and each
having more than one subexpression.  To parse it as an association list,
we have to:

@enumerate
@item
Enter the outer list with @cfunc{sexp_iterator_enter_list}, so that the
iterator points to the first sublist @code{(alpha 1)}.

@item
Call @cfunc{sexp_iterator_assoc} looking for one or more of the keys
@code{alpha}, @code{beta} and @code{delta}.

@item
Examine the iterators in @var{values}: the ones that have been mutated,
with respect to their original state, reference the first expression in
the value.

If we search for the keys @code{alpha}, @code{beta} and @code{delta} in
this order:

@itemize -
@item
When the @code{alpha} key is found the first element in @var{keys} is
set to reference the atom @code{1}.

@item
When the @code{beta} key is found the second element in @var{keys} is
set to reference the atom @code{4}.

@item
When the @code{delta} key is found the third element in @var{keys} is
set to reference the atom @code{6}.
@end itemize
@end enumerate
@end deftypefun

@c page
@node nettle sexp output
@appendixsubsec Serialising an S--expression


The following functions accept a @var{fmt} argument similar to the
template string argument to the @cfunc{printf} function.  Format strings
can contain matched parentheses, tokens (@code{foo} in the format string
is formatted as @code{3:foo}), whitespaces (which separate tokens but
are otherwise ignored) and the following formatting specifiers:

@table @code
@item %s
String.  Consumes two arguments: the number of bytes as @code{unsigned}
integer, the pointer to the data as @code{const uint8_t *}.

@item %t
Optional display hint (see the documentation by Ron Rivest for details).
Consumes two arguments: the number of bytes as @code{unsigned} integer,
the pointer to the data as @code{const uint8_t *}.  If the pointer is
@code{NULL}, it means no display type.

@item %i
Non--negative small integer.  Consumes a single argument as
@code{uint32_t} integer.

@item %b
Non--negative bignum.  Consumes a single argument as pointer of type
@code{mpz_src}.

@item %l
Literal string (no length added), typically a balanced subexpression.
Consumes two arguments: the number of bytes as @code{unsigned} integer,
the pointer to the data as @code{const uint8_t *}.

@item %(
@itemx %)
Allow insertion of unbalanced parenthesis.
@end table

@noindent
with the following modifiers:

@table @code
@item 0
For @code{%s}, @code{%t} and @code{%l} it is used as @code{%0s},
@code{%0t} and @code{%0l}; it says that there's no length argument,
instead the string is zero--terminated, and there's only one @code{const
uint8_t *} argument.
@end table


@deftypefun unsigned sexp_format (struct nettle_buffer * @var{B}, const char * @var{fmt}, ...)
Serialise an S--expression somewhat like @cfunc{fprintf} does, but store
the expression in the supplied buffer; return the number of output
characters, or zero if out of memory occurs.

If @var{B} is @code{NULL}, return the number of bytes required to hold
the seriealised S--expression.
@end deftypefun


@deftypefun unsigned sexp_vformat (struct nettle_buffer * @var{B}, const char * @var{fmt}, va_list @var{args})
Like @cfunc{sexp_format}, but accept arguments in a @code{va_list}
container.
@end deftypefun


@deftypefun unsigned sexp_transport_format (struct nettle_buffer * @var{B}, const char * @var{fmt}, ...)
Serialise an S--expression somewhat like @cfunc{fprintf} does, but store
the expression in the supplied buffer; return the number of output
characters, or zero if out of memory occurs.

If @var{B} is @code{NULL}, return the number of bytes required to hold
the seriealised S--expression.
@end deftypefun


@deftypefun unsigned sexp_transport_vformat (struct nettle_buffer * @var{B}, const char * @var{fmt}, va_list @var{args})
Like @cfunc{sexp_transport_format}, but accept arguments in a
@code{va_list} container.
@end deftypefun

@c page
@node nettle sexp examples
@appendixsubsec Examples of S--expressions parsing and serialisation


In this section we see some usage example of the sexp module; some of
the examples are raw programs that parse specific S--expressions: they
are meant only to show the mechanics of parsing.

@menu
* nettle sexp examples header:: Common header file.
* nettle sexp examples atoms::  Parsing atoms.
* nettle sexp examples lists::  Parsing multiple lists.
* nettle sexp examples nested:: Parsing nested list.
* nettle sexp examples assoc::  Parsing key/value S--expressions.
* nettle sexp examples number:: Parsing S--expressions with numbers.
@end menu

@c page
@node nettle sexp examples header
@appendixsubsubsec Common header file


All the examples make use of the following header file:

@example
/* sexp-tokens.h */

#ifndef __SEXP_TOKENS_H
#  define __SEXP_TOKENS_H 1

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <nettle/sexp.h>

#define E(RESULT, MESSAGE)              \
                                        \
  do @{                                  \
    if (! (RESULT)) @{                   \
      error_message = (MESSAGE);        \
      goto error;                       \
    @}                                   \
  @} while (0);

#define newline()                       \
                                        \
  printf("\n")

static void
print_atom (struct sexp_iterator * I)
@{
  assert(SEXP_ATOM == I->type);
  printf("atom: ");
  fwrite(I->atom, I->atom_length,
         sizeof(char), stdout);
  newline();
@}

#endif

/* end of file */
@end example

@c page
@node nettle sexp examples atoms
@appendixsubsubsec Parsing atoms


The following example parses a sexp with three atoms as subsexps:

@example
(alpha beta gamma)
@end example

@noindent
which in canonical format is:

@example
(5:alpha4:beta5:gamma)
@end example

@noindent
the program prints:

@example
atom: alpha
atom: beta
atom: gamma
@end example

@noindent
which are the token strings.

@example
#include "sexp-tokens.h"

int
main (void)
@{
  const char *          error_message;
  struct sexp_iterator  I[1];
  static const char *   sex = "(5:alpha4:beta5:gamma)";
  E(sexp_iterator_first(I, strlen(sex),
                        (const uint8_t *)sex),
    "initialising the iterator");
  E(sexp_iterator_enter_list(I), "entering list");
  @{
    print_atom(I);
    E(sexp_iterator_next(I), "advance to 2nd atom");
    print_atom(I);
    E(sexp_iterator_next(I), "advance to 3rd atom");
    print_atom(I);
  @}
  E(sexp_iterator_exit_list(I), "exiting list");
  E(sexp_iterator_next(I), "advance to end");
  assert(SEXP_END == I->type);
  exit(EXIT_SUCCESS);
 error:
  fprintf(stderr, "parse error: %s\n", error_message);
  exit(EXIT_FAILURE);
@}
@end example

@c page
@node nettle sexp examples lists
@appendixsubsubsec Parsing multiple lists


The following example parses a sexp with two lists as subsexps:

@example
(alpha beta gamma)
(delta theta)
@end example

@noindent
which in canonical format is:

@example
(5:alpha4:beta5:gamma)(5:delta5:theta)
@end example

@noindent
the program prints:

@example
atom: alpha
atom: beta
atom: gamma
atom: delta
atom: theta
@end example

@noindent
which are the token strings.

@example
#include "sexp-tokens.h"

int
main (void)
@{
  const char *          error_message;
  struct sexp_iterator  I[1];
  static const char *   sex =
     "(5:alpha4:beta5:gamma)(5:delta5:theta)";

  E(sexp_iterator_first(I, strlen(sex),
                        (const uint8_t *)sex),
    "initialising the iterator");
  E(sexp_iterator_enter_list(I), "entering list");
  @{
    print_atom(I);
    E(sexp_iterator_next(I), "advance to 2nd atom");
    print_atom(I);
    E(sexp_iterator_next(I), "advance to 3rd atom");
    print_atom(I);
  @}
  E(sexp_iterator_exit_list(I), "exiting list");
  E(sexp_iterator_enter_list(I), "entering list");
  @{
    print_atom(I);
    E(sexp_iterator_next(I), "advance to 2nd atom");
    print_atom(I);
  @}
  E(sexp_iterator_exit_list(I), "exiting list");
  E(sexp_iterator_next(I), "advance to end");
  assert(SEXP_END == I->type);

  exit(EXIT_SUCCESS);
 error:
  fprintf(stderr, "parse error: %s\n", error_message);
  exit(EXIT_FAILURE);
@}
@end example

@c page
@node nettle sexp examples nested
@appendixsubsubsec Parsing nested list


The following example parses a sexp with a nested list as subsexp:

@example
(alpha beta (delta theta) gamma)
@end example

@noindent
which in canonical format is:

@example
(5:alpha4:beta(5:delta5:theta)5:gamma)
@end example

@noindent
the program prints:

@example
atom: alpha
atom: beta
atom: delta
atom: theta
atom: gamma
@end example

@noindent
which are the token strings.

@example
#include "sexp-tokens.h"

int
main (void)
@{
  const char *          error_message;
  struct sexp_iterator  I[1];
  static const char *   sex =
    "(5:alpha4:beta(5:delta5:theta)5:gamma)";

  E(sexp_iterator_first(I, strlen(sex),
                        (const uint8_t *)sex),
    "initialising the iterator");
  E(sexp_iterator_enter_list(I), "entering list");
  @{
    print_atom(I);
    E(sexp_iterator_next(I), "advance to 2nd atom");
    print_atom(I);
    E(sexp_iterator_next(I), "advance to 3rd atom");
    E(sexp_iterator_enter_list(I), "entering list");
    @{
      print_atom(I);
      E(sexp_iterator_next(I), "advance to 2nd atom");
      print_atom(I);
    @}
    E(sexp_iterator_exit_list(I), "exiting list");
    print_atom(I);
  @}
  E(sexp_iterator_exit_list(I), "exiting list");
  E(sexp_iterator_next(I), "advance to end");
  assert(SEXP_END == I->type);

  exit(EXIT_SUCCESS);
 error:
  fprintf(stderr, "parse error: %s\n", error_message);
  exit(EXIT_FAILURE);
@}
@end example

@c page
@node nettle sexp examples assoc
@appendixsubsubsec Parsing key/value S--expressions


The following example parses a sexp as a key/value association list:

@example
((alpha beta gamma))
@end example

@noindent
in which @code{alpha} is interpreted as the ``key'', while @code{beta}
and @code{gamma} are interpreted as the ``values''; in canonical format
it is:

@example
((5:alpha4:beta5:gamma))
@end example

@noindent
notice that we can interpret a sexp as an association list only if: it
is a list of lists; each sublist starts with an atom; each sublist has
more than one element.  The program prints:

@example
atom: beta
atom: gamma
@end example

@noindent
which are the values.

@example
#include "sexp-tokens.h"

int
main (void)
@{
  const char *                  error_message;
  struct sexp_iterator          I[1], S[1];
  static const char *           sex =
     "((5:alpha4:beta5:gamma))";
#define KEYNUM          1
  static const char *const      keys[KEYNUM]
     = @{ "alpha" @};

  E(sexp_iterator_first(I, strlen(sex),
                        (const uint8_t *)sex),
    "initialising the iterator");

  E(sexp_iterator_enter_list(I), "entering list");
  for (int i=0; i<KEYNUM; ++i)
    S[i].type = SEXP_END;
  E(sexp_iterator_assoc(I, KEYNUM,
                        (const uint8_t *const *)keys,
                        S), "parsing keys/values");
  if (SEXP_END != S[0].type) @{
    print_atom(S);
    E(sexp_iterator_next(S), "advance to 2rd atom");
    print_atom(S);
    E(sexp_iterator_next(S), "advance to subsexp end");
    assert(SEXP_END == S->type);
  @}
  assert(SEXP_END == I->type);

  exit(EXIT_SUCCESS);
 error:
  fprintf(stderr, "error: %s\n", error_message);
  exit(EXIT_FAILURE);
@}
@end example

The following example parses another sexp as a key/value association
list:

@example
((alpha  beta gamma)
 (delta  theta))
@end example

@noindent
in which @code{alpha} and @code{delta} are interpreted as the ``keys'',
while @code{beta}, @code{gamma} and @code{theta} are interpreted as the
``values''; in canonical format it is:

@example
((5:alpha4:beta5:gamma)(5:delta5:theta))
@end example

@noindent
the program prints:

@example
atom: beta
atom: gamma
atom: theta
@end example

@noindent
which are the values.

@example
#include "sexp-tokens.h"

int
main (void)
@{
  const char *                  error_message;
  struct sexp_iterator          I[1], S[2];
  static const char *           sex = "((5:alpha4:beta5:gamma)(5:delta5:theta))";
#define KEYNUM          2
  static const char *const      keys[KEYNUM] = @{ "alpha", "delta" @};

  E(sexp_iterator_first(I, strlen(sex), (const uint8_t *)sex),
    "initialising the iterator");
  E(sexp_iterator_enter_list(I), "entering list");

  for (int i=0; i<KEYNUM; ++i)
    S[i].type = SEXP_END;
  E(sexp_iterator_assoc(I, KEYNUM, (const uint8_t *const *)keys,
                        S), "parsing keys/values");
  if (SEXP_END != S[0].type) @{
    print_atom(&S[0]);
    E(sexp_iterator_next(&S[0]), "advance to 2rd atom");
    print_atom(&S[0]);
    E(sexp_iterator_next(&S[0]), "advance to subsexp end");
    assert(SEXP_END == S[0].type);
  @}
  if (SEXP_END != S[1].type) @{
    print_atom(&S[1]);
    E(sexp_iterator_next(&S[1]), "advance to subsexp end");
    assert(SEXP_END == S[1].type);
  @}
  assert(SEXP_END == I->type);

  exit(EXIT_SUCCESS);
 error:
  fprintf(stderr, "error: %s\n", error_message);
  exit(EXIT_FAILURE);
@}
@end example

@c page
@node nettle sexp examples number
@appendixsubsubsec Parsing S--expressions with numbers


The following example parses a sexp with two numbers as subexpressions:

@example
(0 258)
@end example

@noindent
the numbers are serialised in binary, network (big endian) byte order;
in canonical format expressed as C language string it is:

@example
"(1:\x002:\x01\x02)"
@end example

@noindent
notice that when the S--expression has numbers in it, there may be null
bytes, so we cannot use @cfunc{strlen} to determine the length of the
input data.  The program prints:

@example
number atom: 0
number atom: 258
@end example

@noindent
which are the values.

@example
#include "sexp-tokens.h"

static void
print_number (struct sexp_iterator * I)
@{
  const char *  error_message;
  uint32_t      n;
  assert(SEXP_ATOM == I->type);
  E(sexp_iterator_get_uint32(I, &n), "parsing number");
  printf("number atom: %d\n", n);fflush(stdout);
  return;
 error:
  fprintf(stderr, "parse error: %s\n", error_message);
  exit(EXIT_FAILURE);
@}

int
main (void)
@{
  const char *          error_message;
  struct sexp_iterator  I[1];
#define SEXLEN          9
  static const char     sex[1+SEXLEN] =
     "(" "1:\x00" "2:\x01\x02" ")";

  E(sexp_iterator_first(I, SEXLEN, (const uint8_t *)sex),
    "initialising the iterator");
  E(sexp_iterator_enter_list(I), "entering list");
  @{
    print_number(I);
    print_number(I);
    assert(SEXP_END == I->type);
  @}
  E(sexp_iterator_exit_list(I), "exiting list");
  E(sexp_iterator_next(I), "advance to end");
  assert(SEXP_END == I->type);

  exit(EXIT_SUCCESS);
 error:
  fprintf(stderr, "parse error: %s\n", error_message);
  exit(EXIT_FAILURE);
@}

/* end of file */
@end example

@c page
@node nettle asn1
@appendixsec Limited support for @acronym{ASN.1}


@defvr Constant ASN1_TYPE_CONSTRUCTED
@defvrx Constant ASN1_CLASS_UNIVERSAL
@defvrx Constant ASN1_CLASS_APPLICATION
@defvrx Constant ASN1_CLASS_CONTEXT_SPECIFIC
@defvrx Constant ASN1_CLASS_PRIVATE
@defvrx Constant ASN1_CLASS_MASK
@defvrx Constant ASN1_CLASS_SHIFT
Currently undocumented.
@end defvr


@deftp {Enumeration} {enum asn1_type}
Keeps the class number and the constructive in bits 13-14, and the
constructive flag in bit 12.  The remaining 14 bits are the tag
(although currently, only tags in the range 0-30 are supported).
@end deftp


@defvr Constant ASN1_BOOLEAN
@defvrx Constant ASN1_INTEGER
@defvrx Constant ASN1_BITSTRING
@defvrx Constant ASN1_OCTETSTRING
@defvrx Constant ASN1_NULL
@defvrx Constant ASN1_IDENTIFIER
@defvrx Constant ASN1_REAL
@defvrx Constant ASN1_ENUMERATED
@defvrx Constant ASN1_UTF8STRING
@defvrx Constant ASN1_SEQUENCE
@defvrx Constant ASN1_SET
@defvrx Constant ASN1_PRINTABLESTRING
@defvrx Constant ASN1_TELETEXSTRING
@defvrx Constant ASN1_IA5STRING
@defvrx Constant ASN1_UTC
@defvrx Constant ASN1_UNIVERSALSTRING
@defvrx Constant ASN1_BMPSTRING
Currently undocumented.
@end defvr


@deftp {Enumeration} {enum asn1_iterator_result}
Currently undocumented.
@end deftp


@defvr Constant ASN1_ITERATOR_ERROR
@defvrx Constant ASN1_ITERATOR_PRIMITIVE
@defvrx Constant ASN1_ITERATOR_CONSTRUCTED
@defvrx Constant ASN1_ITERATOR_END
Currently undocumented.
@end defvr


@deftp {Data Structure} asn1_der_iterator
Context structure to parse @acronym{DER} objects.
@end deftp


@deftypefun {enum asn1_iterator_result} asn1_der_iterator_first (struct asn1_der_iterator * @var{I}, unsigned @var{len}, const uint8_t * @var{input})
Initialise the iterator.
@end deftypefun


@deftypefun {enum asn1_iterator_result} asn1_der_iterator_next (struct asn1_der_iterator * @var{I})
Advance to the next element.
@end deftypefun


@deftypefun {enum asn1_iterator_result} asn1_der_decode_constructed (struct asn1_der_iterator * @var{I}, struct asn1_der_iterator * @var{contents})
Starts parsing of a constructed object.
@end deftypefun


@deftypefun {enum asn1_iterator_result} asn1_der_decode_constructed_last (struct asn1_der_iterator * @var{I})
Checks that the current object is the final one, and then reinitialise
the iterator to parse its ontents.  For the common case in which we have
a sequence at the end of the object.
@end deftypefun


@deftypefun {enum asn1_iterator_result} asn1_der_decode_bitstring (struct asn1_der_iterator * @var{I}, struct asn1_der_iterator * @var{contents})
Currently undocumented.
@end deftypefun


@deftypefun {enum asn1_iterator_result} asn1_der_decode_bitstring_last (struct asn1_der_iterator * @var{I})
Currently undocumented.
@end deftypefun


@deftypefun int asn1_der_get_uint32 (struct asn1_der_iterator * @var{I}, uint32_t * @var{x})
Currently undocumented.
@end deftypefun

@c page
@node nettle misc
@appendixsec Miscellaneous functions


@deftypefun {uint8_t *} memxor (uint8_t *@var{dst}, const uint8_t *@var{src}, size_t @var{n})
XOR the source area on top of the destination area.  The interface does
not follow the Nettle conventions, because it is intended to be similar
to the @ansi{} C @cfunc{memcpy} function.
@end deftypefun

@cfunc{memxor} is declared in @file{<nettle/memxor.h>}.

@c end of file
