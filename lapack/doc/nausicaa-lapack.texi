\input texinfo.tex
@c %**start of header
@setfilename nausicaa-lapack.info
@settitle LAPACK for Nausicaa
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@macro condition{NAME}
@code{&\NAME\}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro sql{}
@acronym{SQL}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@macro axml{}
@acronym{XML}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@macro lapack{}
@acronym{LAPACK}
@end macro

@macro clapack{}
@acronym{CLAPACK}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro ssh{}
@acronym{SSH}
@end macro

@macro ssl{}
@acronym{SSL}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro tls{}
@acronym{TLS}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      LAPACK for Nausicaa

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@lapack{}

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-lapack

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2010

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a
distribution of libraries for @rnrs{6} Scheme implementations; it
provides a binding to the @clapack{} C language library.  It is built
upon Nausicaa/Scheme, making use of its foreign--functions interface.

The libraries support Ikarus, Mosh and Ypsilon Scheme; the package
supports @gnu{}+Linux systems.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/nausicaa/downloads}

@noindent
the project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/tree/master}

@noindent
@clapack{} is available at:

@center @url{http://www.netlib.org/clapack/}

@noindent
original documentation for @lapack{} and @clapack{} can be found at:

@center @url{http://www.netlib.org/lapack/lug/lapack_lug.html}

@noindent
and in printed form:

@quotation
``LAPACK Users' Guide''.  E. Anderson, Z. Bai, C. Bischof, S. Blackford,
J. Demmel, J. Dongarra, J. Du Croz, A. Greenbaum, S. Hammarling,
A. McKenney, D. and Sorensen.  Third Edition.  Society for Industrial
and Applied Mathematics, 1999.  Philadelphia, PA.  @acronym{ISBN}
0-89871-447-8 (paperback).
@end quotation

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-lapack: (nausicaa-lapack).   @clapack{} for Nausicaa.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* typedefs::                    Type accessors and mutators.
* arguments::                   Special arguments.
* conditions::                  Condition objects.
* vm::                          Basic vector and matrix library.
* lineq::                       Linear equations.
* perms::                       Permutations.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Overview of the package

* overview intro::              Introduction to @lapack{}
                                for end users.
* overview libraries::          Installed libraries.
* overview names::              Function naming conventions.

Type accessors and mutators

* typedefs common::             Common C language types.
* typedefs callbacks::          Callback types.
* typedefs structs::            Data structures.

Condition objects

* conditions error::            Basic error condition.
* conditions argument::         Invalid argument error condition.
* conditions step::             Failed computation step error
                                condition.

Basic vector and matrix library.

* vm real vectors::             Real vectors.
* vm complex vectors::          Complex vectors.
* vm real matrices::            Real matrices.
* vm complex matrices::         Complex matrices.
* vm pivots::                   Vectors of integers as permutation
                                indices.

Linear equations

* lineq general::               General problem.

@end detailmenu
@end menu

@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @version{} of @value{PACKAGE}, a
distribution of libraries for @rnrs{6} Scheme implementations; it
provides a binding to the @clapack{} C language library.  It is built
upon Nausicaa/Scheme, making use of its foreign--functions interface.

The libraries support Ikarus, Mosh and Ypsilon Scheme; the package
supports @gnu{}+Linux systems.

@menu
* overview intro::              Introduction to @lapack{}
                                for end users.
* overview libraries::          Installed libraries.
* overview names::              Function naming conventions.
@end menu

@c page
@node overview intro
@section Introduction to @lapack{} for end users


For end users only interested in solving math equations, @clapack{} can
be intimidating with its 1200+ exported functions; but we do not really
need to read the documentation of all of them.  Rather let's start by
acknowledging that almost each algorithm comes in a version for
@code{float} numbers and a version for @code{double} numbers; so the
count of ``distinct'' algorithms is ~600+.  Then let's acknowledge that
almost each algorithm comes in a version for real numbers and a version
for complex numbers; so the count of ``distinct'' algorithms is down to
~300+.

Finally let's acknowledge @clapack{}'s architecture:

@example
 -----------------------------------------------
|               driver functions                |
|-----------------------------------------------|
| computational functions | auxiliary functions |
 -----------------------------------------------
@end example

@noindent
as end users we are concerned only with the high--level ``driver''
functions, which address the following basic math problems:

@enumerate
@item
Solve a system of linear equations.

@item
Compute eigenvalues and eigenvectors.

@item
Compute the singular value decomposition.
@end enumerate

The original @lapack{} user's guide:

@center @url{http://www.netlib.org/lapack/lug/lapack_lug.html}

@noindent
is a good introductory read, but unfortunately the documentation of the
functions is in the source code itself; for example, the documentation
of @cfunc{dgesvd_} is in the file @file{CLAPACK/SRC/dgesvd.c}.

@c page
@node overview libraries
@section Installed libraries


The installed libraries are:

@table @library
@item foreign math lapack shared-object
Exports the single binding @code{clapack-shared-object} which references
the foreign shared library.

@item foreign math lapack sizeof
Exports bindings to constant values and data structures accessors.

@item foreign math lapack conditions
Exports definitions for condition objects used by this package.

@item foreign math lapack platform
Exports one binding for each foreign function; the bindings to the
Scheme function callouts have the same name of the C functions, so
@cfunc{dgesv_} is available as @func{dgesv_}.  This library makes the
original @lapack{} documentation relevant for this package.

@item foreign math lapack primitives
Exports one binding for each foreign function, implementing, for some
functions, marshaling of arguments and return values.  The bindings to
the Scheme functions have the same name of the C functions, but with the
trailing underscore removed; so @cfunc{dgesv_} is available as
@func{dgesv}.

For all the functions, the @var{info} argument@footnote{See
@url{http://www.netlib.org/lapack/lug/node119.html}.} is handled
internally by the library and must not be given in function calls; in
case of error, detected inspecting the @var{info} value after a function
call, an exception is raised.

This document describes the @code{primitives} @api{}; only the functions
implementing marshaling of values are documented: if a function is not
documented, it means that it is reexported ``as is'' from the
@code{platform} library (with the exception of the @var{info} argument).

This library is @strong{not} thread--safe.

@item foreign math lapack
Compound library exporting the high--level @api{}; it reexports bindings
from the @samp{primitives} library and some bindings from the
@samp{sizeof} library.

@item foreign math lapack vm
Exports a very basic vector and matrix @api{}, mostly intended for
testing.

@c @item foreign math lapack compensated
@c Exports bindings to constructor functions making use of the
@c @library{compensations} library from Nausicaa/Scheme.
@c @nauref{compensations, Compensation stacks}.
@end table

@c page
@node overview names
@section Function naming conventions


The following description comes from the @lapack{} user's guide and the
@acronym{FAQ} web page
(@url{http://@/www.netlib.org/@/lapack/@/faq.html}).

The name of each @lapack{} routine is a coded specification of its
function (within the very tight limits of standard Fortran 77
6-character names).  All driver and computational routines have names of
the form @samp{XYYZZZ}, where for some driver routines the 6th character
is blank.

@itemize
@item
The first letter, @samp{X}, indicates the data type as follows:

@table @code
@item S
Real.

@item D
Double precision.

@item C
Complex.

@item Z
@code{COMPLEX*16} or double complex.
@end table

@item
The next two letters, @samp{YY}, indicate the type of matrix (or of the
most significant matrix).  Most of these two--letter codes apply to both
real and complex matrices; a few apply specifically to one or the other.

@table @code
@item BD
Bidiagonal.

@item DI
Diagonal.

@item GB
General band.

@item GE
General (i.e., unsymmetric, in some cases rectangular).

@item GG
General matrices, generalized problem (i.e., a pair of general
matrices).

@item GT
General tridiagonal.

@item HB
(Complex) Hermitian band.

@item HE
(Complex) Hermitian.

@item HG
Upper Hessenberg matrix, generalized problem (i.e a Hessenberg and a
triangular matrix).

@item HP
(Complex) Hermitian, packed storage.

@item HS
Upper Hessenberg.

@item OP
(Real) orthogonal, packed storage.

@item OR
(Real) orthogonal.

@item PB
Symmetric or Hermitian positive definite band.

@item PO
Symmetric or Hermitian positive definite.

@item PP
Symmetric or Hermitian positive definite, packed storage.

@item PT
Symmetric or Hermitian positive definite tridiagonal.

@item SB
(Real) symmetric band.

@item SP
Symmetric, packed storage.

@item ST
(Real) symmetric tridiagonal.

@item SY
Symmetric.

@item TB
Triangular band.

@item TG
Triangular matrices, generalized problem (i.e., a pair of triangular
matrices).

@item TP
Triangular, packed storage.

@item TR
Triangular (or in some cases quasi--triangular).

@item TZ
Trapezoidal.

@item UN
Complex unitary.

@item UP
Complex unitary, packed storage.
@end table

@item
The last three letters @samp{ZZZ} indicate the computation performed;
for example, @samp{SGEBRD} is a single precision routine that performs a
bidiagonal reduction (@acronym{BRD}) of a real general matrix.
@end itemize

@c page
@node typedefs
@chapter Type accessors and mutators


The bindings described in this chapter are exported by the
@library{foreign math lapack sizeof} library and reexported by the
@library{foreign math lapack} library.

@menu
* typedefs common::             Common C language types.
* typedefs callbacks::          Callback types.
* typedefs structs::            Data structures.
@end menu

@c page
@node typedefs common
@section Common C language types


@deftp {Type Alias} integer
Usually bound to the Scheme symbol @code{signed-int}, it is used to
specify the signed integer arguments to functions.
@end deftp


@defvr Constant sizeof-integer
@defvrx Constant alignof-integer
@defvrx Constant strideof-integer
Size, structure alignment and array stride of @code{integer}.
@end defvr


@defun pointer-ref-c-integer @var{pointer} @var{offset}
@defunx pointer-set-c-integer! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{integer}
value.
@end defun


@defun array-ref-c-integer @var{pointer} @var{index}
Accessor for the elements of an array of @code{integer} values; return
the value at index @var{index}.
@end defun


@deftp {Type Alias} uinteger
Usually bound to the Scheme symbol @code{unsigned-int}, it is used to
specify the unsigned integer arguments to functions.
@end deftp


@defvr Constant sizeof-uinteger
@defvrx Constant alignof-uinteger
@defvrx Constant strideof-uinteger
Size, structure alignment and array stride of @code{uinteger}.
@end defvr


@defun pointer-ref-c-uinteger @var{pointer} @var{offset}
@defunx pointer-set-c-uinteger! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{uinteger}
value.
@end defun


@deftp {Type Alias} shortint
Usually bound to the Scheme symbol @code{signed-short}, it is used to
specify the small signed integer arguments to functions.
@end deftp


@defvr Constant sizeof-shortint
@defvrx Constant alignof-shortint
@defvrx Constant strideof-shortint
Size, structure alignment and array stride of @code{shortint}.
@end defvr


@defun pointer-ref-c-shortint @var{pointer} @var{offset}
@defunx pointer-set-c-shortint! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{shortint}
value.
@end defun


@deftp {Type Alias} real
Usually bound to the Scheme symbol @code{float}, it is used to specify
the single--precision floating point arguments to functions.
@end deftp


@defvr Constant sizeof-real
@defvrx Constant alignof-real
@defvrx Constant strideof-real
Size, structure alignment and array stride of @code{real}.
@end defvr


@defun pointer-ref-c-real @var{pointer} @var{offset}
@defunx pointer-set-c-real! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{real} value.
@end defun


@deftp {Type Alias} doublereal
Usually bound to the Scheme symbol @code{double}, it is used to specify
the double--precision floating point arguments to functions.
@end deftp


@defvr Constant sizeof-doublereal
@defvrx Constant alignof-doublereal
@defvrx Constant strideof-doublereal
Size, structure alignment and array stride of @code{doublereal}.
@end defvr


@defun pointer-ref-c-doublereal @var{pointer} @var{offset}
@defunx pointer-set-c-doublereal! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{doublereal}
value.
@end defun


@deftp {Type Alias} logical
Usually bound to the Scheme symbol @code{signed-int}, it is used to
specify some integer arguments to functions.
@end deftp


@defvr Constant sizeof-logical
@defvrx Constant alignof-logical
@defvrx Constant strideof-logical
Size, structure alignment and array stride of @code{logical}.
@end defvr


@defun pointer-ref-c-logical @var{pointer} @var{offset}
@defunx pointer-set-c-logical! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{logical}
value.
@end defun


@deftp {Type Alias} shortlogical
Usually bound to the Scheme symbol @code{signed-short}, it is used to
specify some nteger arguments to functions.
@end deftp


@defvr Constant sizeof-shortlogical
@defvrx Constant alignof-shortlogical
@defvrx Constant strideof-shortlogical
Size, structure alignment and array stride of @code{shortlogical}.
@end defvr


@defun pointer-ref-c-shortlogical @var{pointer} @var{offset}
@defunx pointer-set-c-shortlogical! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{shortlogical}
value.
@end defun


@deftp {Type Alias} logical1
Usually bound to the Scheme symbol @code{signed-char}, it is used to
specify some signed integer arguments to functions.
@end deftp


@defvr Constant sizeof-logical1
@defvrx Constant alignof-logical1
@defvrx Constant strideof-logical1
Size, structure alignment and array stride of @code{logical1}.
@end defvr


@defun pointer-ref-c-logical1 @var{pointer} @var{offset}
@defunx pointer-set-c-logical1! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{logical1}
value.
@end defun


@deftp {Type Alias} integer1
Usually bound to the Scheme symbol @code{signed-char}, it is used to
specify some integer arguments to functions.
@end deftp


@defvr Constant sizeof-integer1
@defvrx Constant alignof-integer1
@defvrx Constant strideof-integer1
Size, structure alignment and array stride of @code{integer1}.
@end defvr


@defun pointer-ref-c-integer1 @var{pointer} @var{offset}
@defunx pointer-set-c-integer1! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{integer1}
value.
@end defun


@deftp {Type Alias} ftnlen
Usually bound to the Scheme symbol @code{signed-int}, it is used to
specify some integer arguments to functions.
@end deftp


@defvr Constant sizeof-ftnlen
@defvrx Constant alignof-ftnlen
@defvrx Constant strideof-ftnlen
Size, structure alignment and array stride of @code{ftnlen}.
@end defvr


@defun pointer-ref-c-ftnlen @var{pointer} @var{offset}
@defunx pointer-set-c-ftnlen! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{ftnlen}
value.
@end defun


@deftp {Type Alias} flag
Usually bound to the Scheme symbol @code{signed-int}, it is used to
specify some integer arguments to functions.
@end deftp


@defvr Constant sizeof-flag
@defvrx Constant alignof-flag
@defvrx Constant strideof-flag
Size, structure alignment and array stride of @code{flag}.
@end defvr


@defun pointer-ref-c-flag @var{pointer} @var{offset}
@defunx pointer-set-c-flag! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{flag} value.
@end defun


@deftp {Type Alias} ftnint
Usually bound to the Scheme symbol @code{signed-int}, it is used to
specify some integer arguments to functions.
@end deftp


@defvr Constant sizeof-ftnint
@defvrx Constant alignof-ftnint
@defvrx Constant strideof-ftnint
Size, structure alignment and array stride of @code{ftnint}.
@end defvr


@defun pointer-ref-c-ftnint @var{pointer} @var{offset}
@defunx pointer-set-c-ftnint! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{ftnint}
value.
@end defun


@deftp {Type Alias} address
Bound to the Scheme symbol @code{void*}.
@end deftp

@c page
@node typedefs callbacks
@section Callback types


@defvr Constant C_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
void C_fp ()
@end example
@end defvr


@defvr Constant D_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
doublereal D_fp ()
@end example
@end defvr


@defvr Constant E_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
doublereal E_fp ()
@end example
@end defvr


@defvr Constant H_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
functionwith prototype:

@example
void H_fp ()
@end example
@end defvr


@defvr Constant I_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
integer I_fp ()
@end example
@end defvr


@defvr Constant J_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
shortint J_fp ()
@end example
@end defvr


@defvr Constant K_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
shortlogical K_fp ()
@end example
@end defvr


@defvr Constant L_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
logical L_fp ()
@end example
@end defvr


@defvr Constant R_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example

@end example
@end defvr


@defvr Constant S_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
int S_fp ()
@end example
@end defvr

@defvr Constant U_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
int U_fp ()
@end example
@end defvr

@defvr Constant Z_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
void Z_fp ()
@end example
@end defvr

@c page
@node typedefs structs
@section Data structures


The C language data structure @code{complex} has the following
definition:

@example
typedef struct @{
  real r, i;
@} complex;
@end example


@defvr Constant sizeof-complex
@defvrx Constant alignof-complex
@defvrx Constant strideof-complex
Size, structure alignment and array stride of the @code{complex} C
language data structure.
@end defvr


@deffn Syntax struct-complex-r-ref @var{pointer}
@deffnx Syntax struct-complex-r-set! @var{pointer} @var{value}
@deffnx Syntax struct-complex-i-ref @var{pointer}
@deffnx Syntax struct-complex-i-set! @var{pointer} @var{value}
Accessor and mutator for the fields of the @code{complex} C language
data structure.
@end deffn


The C language data structure @code{doublecomplex} has the following
definition:

@example
typedef struct @{
   doublereal r, i;
@} doublecomplex;
@end example


@defvr Constant sizeof-doublecomplex
@defvrx Constant alignof-doublecomplex
@defvrx Constant strideof-doublecomplex
Size, structure alignment and array stride of the @code{doublecomplex} C
language data structure.
@end defvr


@deffn Syntax struct-doublecomplex-r-ref @var{pointer}
@deffnx Syntax struct-doublecomplex-r-set! @var{pointer} @var{value}
@deffnx Syntax struct-doublecomplex-i-ref @var{pointer}
@deffnx Syntax struct-doublecomplex-i-set! @var{pointer} @var{value}
Accessor and mutator for the fields of the @code{doublecomplex} C
language data structure.
@end deffn

@c page
@node arguments
@chapter Special arguments


The following bindings are exported by the @library{foreign math lapack
primitives} library and reexported by the @library{foreign math lapack}
library.


@defvr Constant lower*
Pointer to a memory location holding the integer representation of the
character @samp{L}; it is meant to be used as function argument to
indicate a lower triangular matrix operand.
@end defvr


@defvr Constant upper*
Pointer to a memory location holding the integer representation of the
character @samp{U}; it is meant to be used as function argument to
indicate a upper triangular matrix operand.
@end defvr


@defvr Constant all*
Pointer to a memory location holding the integer representation of the
character @samp{A}; it is meant to be used as function argument.
@end defvr


@defvr Constant none*
Pointer to a memory location holding the integer representation of the
character @samp{N}; it is meant to be used as function argument.
@end defvr

@defvr Constant oscar*
Pointer to a memory location holding the integer representation of the
character @samp{O}; it is meant to be used as function argument.
@end defvr


@defvr Constant sierra*
Pointer to a memory location holding the integer representation of the
character @samp{S}; it is meant to be used as function argument.
@end defvr

@c page
@node conditions
@chapter Condition objects


The bindings documented here are exported by the @library{foreign math
lapack conditions} library and reexported by the @library{foreign math
lapack} library.

@menu
* conditions error::            Basic error condition.
* conditions argument::         Invalid argument error condition.
* conditions step::             Failed computation step error
                                condition.
@end menu

@c page
@node conditions error
@section Basic error condition


@deftp {Condition Type} &lapack-error
Base condition type for all the conditions used by @value{PACKAGE}.  It
is derived from @condition{error}.  It has no fields.
@end deftp


@defun make-lapack-error-condition
@defunx lapack-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{lapack-error}.
@end defun

@c page
@node conditions argument
@section Invalid argument error condition


@deftp {Condition Type} &lapack-invalid-argument
Condition type used to represent ``invalid argument'' errors; it is
derived from @condition{lapack-error}.  It has the following fields:

@table @code
@item argument-position
The position of the invalid argument, starting from @math{1}.  This is
the value of the @var{info} argument to @clapack{} callouts.

@item argument-name
A Scheme symbol representing the invalid argument name.

@item argument-value
The invalid argument value.
@end table
@end deftp


@defun make-lapack-invalid-argument-condition @var{position} @var{name} @var{value}
@defunx lapack-invalid-argument-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{lapack-invalid-argument}.
@end defun


@defun condition-lapack-argument-position @var{condition}
@defunx condition-lapack-argument-name @var{condition}
@defunx condition-lapack-argument-value @var{condition}
Field accessors for the condition objects of type
@condition{lapack-invalid-argument}.
@end defun

@c page
@node conditions step
@section Failed computation step error condition


@deftp {Condition Type} &lapack-failed-step
Condition type used to represent ``invalid argument'' errors; it is
derived from @condition{lapack-error}.  It has the following fields:

@table @code
@item failed-step
The failed step number.  This is the value of the @var{info} argument to
@clapack{} callouts.
@end table
@end deftp


@defun make-lapack-failed-step-condition @var{step}
@defunx lapack-failed-step-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{lapack-failed-step}.
@end defun


@defun condition-lapack-failed-step @var{condition}
Field accessor for condition objects of type
@condition{lapack-failed-step}.
@end defun

@c page
@node vm
@chapter Basic vector and matrix library.


The bindings documented here are exported by the @library{foreign math
lapack vm} library.  Vectors and matrices supported by this library are
composed of real and complex numbers under @code{double} representation.

@menu
* vm real vectors::             Real vectors.
* vm complex vectors::          Complex vectors.
* vm real matrices::            Real matrices.
* vm complex matrices::         Complex matrices.
* vm pivots::                   Vectors of integers as permutation
                                indices.
@end menu

@c page
@node vm real vectors
@section Real vectors


@defun rvc/c @var{len}
Allocate an array capable of holding a real vector of @var{len}
elements; return a pointer to it.  The appropriate free function is
pushed to the current compensations stack.  @nauref{compensations,
Compensation stacks}.
@end defun


@defun rvc-set! @var{rvc} @var{idx} @var{val}
Store the real number @var{val} at location @var{IDX} in the real vector
referenced by the pointer object @var{rvc}.
@end defun


@defun rvc-ref @var{rvc} @var{idx}
Return the real number at location @var{idx} in the real vector
referenced by the pointer object @var{rvc}.
@end defun


@defun rvc-fill! @var{rvc} @var{m}
Fill the real vector referenced by the pointer object @var{rvc} with
values from the list @var{m}.
@end defun


@defun rvc->list @var{rvc} @var{len}
Build and return a list holding the values from the real vector
referenced by the pointer @var{rvc} and length @var{len}.
@end defun

@c page
@node vm complex vectors
@section Complex vectors


@defun rvc/c @var{len}
Allocate an array capable of holding a complex vector of @var{len}
elements; return a pointer to it.  The appropriate free function is
pushed to the current compensations stack.  @nauref{compensations,
Compensation stacks}.
@end defun


@defun rvc-set! @var{rvc} @var{idx} @var{val}
Store the complex number @var{val} at location @var{IDX} in the complex
vector referenced by the pointer object @var{rvc}.
@end defun


@defun rvc-ref @var{rvc} @var{idx}
Return the complex number at location @var{idx} in the complex vector
referenced by the pointer object @var{rvc}.
@end defun


@defun rvc-fill! @var{rvc} @var{m}
Fill the complex vector referenced by the pointer object @var{rvc} with
values from the list @var{m}.
@end defun


@defun rvc->list @var{rvc} @var{len}
Build and return a list holding the values from the complex vector
referenced by the pointer @var{rvc} and length @var{len}.
@end defun

@c page
@node vm real matrices
@section Real matrices


For all the following descriptions: the @var{ld} argument is the
``leading dimension'' of the matrix, in @lapack{} jargon, and the matrix
is accessed in column--major order.


@defun rmx/c @var{rows-num} @var{cols-num}
Allocate an array capable of holding a real matrix of @var{rows-num}
rows and @var{cols-num} columns; return a pointer to it.  The
appropriate free function is pushed to the current compensations stack.
@nauref{compensations, Compensation stacks}.
@end defun


@defun rmx-set! @var{rmx} @var{ldm} @var{row} @var{col} @var{val}
Store the real value @var{val} at location @var{row}, @var{col} in the
real matrix referenced by the pointer object @var{rmx} and column length
@var{ldm}.
@end defun


@defun rmx-ref @var{rmx} @var{ldm} @var{row} @var{col}
Return the real value at location @var{row}, @var{col} in the real
matrix referenced by the pointer object @var{rmx} and column length
@var{ldm}.
@end defun


@defun rmx-fill! @var{rmx} @var{ldm} @var{m}
Fill the real matrix referenced by the pointer object @var{rmx} and
column length @var{ldm}, with values from the list @var{m}.  @var{m} is
a list of lists in row--major order:

@example
((a_11 a_12 a_13)
 (a_21 a_22 a_23)
 (a_31 a_32 a_33))
@end example
@end defun


@defun rmx->list @var{rmx} @var{ldm} @var{rows-num} @var{cols-num}
Build and return a list of lists holding the values, in row--major
order, from the matrix referenced by the pointer @var{rmx}.  @var{ldm}
is the length of a column.  @var{rows-num} and @var{cols-num} are the
numbers of rows and columns.
@end defun

@c page
@node vm complex matrices
@section Complex matrices


For all the following descriptions: the @var{ld} argument is the
``leading dimension'' of the matrix, in @lapack{} jargon, and the matrix
is accessed in column--major order.


@defun cmx/c @var{rows-num} @var{cols-num}
Allocate an array capable of holding a complex matrix of @var{rows-num}
rows and @var{cols-num} columns; return a pointer to it.  The
appropriate free function is pushed to the current compensations stack.
@nauref{compensations, Compensation stacks}.
@end defun


@defun cmx-set! @var{cmx} @var{ldm} @var{row} @var{col} @var{val}
Store the complex value @var{val} at location @var{row}, @var{col} in
the complex matrix referenced by the pointer object @var{cmx} and column
length @var{ldm}.
@end defun


@defun cmx-ref @var{cmx} @var{ldm} @var{row} @var{col}
Return the complex value at location @var{row}, @var{col} in the complex
matrix referenced by the pointer object @var{cmx} and column length
@var{ldm}.
@end defun


@defun cmx-fill! @var{cmx} @var{ldm} @var{m}
Fill the complex matrix referenced by the pointer object @var{cmx} and
column length @var{ldm}, with values from the list @var{m}.  @var{m} is
a list of lists in row--major order:

@example
((a_11 a_12 a_13)
 (a_21 a_22 a_23)
 (a_31 a_32 a_33))
@end example
@end defun


@defun cmx->list @var{cmx} @var{ldm} @var{rows-num} @var{cols-num}
Build and return a list of lists holding the values, in row--major
order, from the matrix referenced by the pointer @var{cmx}.  @var{ldm}
is the length of a column.  @var{rows-num} and @var{cols-num} are the
numbers of rows and columns.
@end defun

@c page
@node vm pivots
@section Vectors of integers as permutation indices


Vectors of @code{integer} numbers are used to store the pivot indices
defining permutation matrices: when using vector @var{piv}, row @math{i}
of the matrix is interchanged with row @math{@var{piv}(i)}.


@defun piv/c @var{len}
Allocate an array capable of holding a vector of @code{integer} values
of @var{len} elements; return a pointer to it.  The appropriate free
function is pushed to the current compensations stack.
@nauref{compensations, Compensation stacks}.
@end defun


@defun piv-set! @var{piv} @var{idx} @var{val}
Store the exact integer number @var{val} at location @var{IDX} in the
integer vector referenced by the pointer object @var{piv}.
@end defun


@defun piv-ref @var{piv} @var{idx}
Return the exact integer number at location @var{idx} in the integer
vector referenced by the pointer object @var{piv}.
@end defun


@defun piv-fill! @var{piv} @var{m}
Fill the integer vector referenced by the pointer object @var{piv} with
values from the list @var{m}.
@end defun


@defun piv->list @var{piv} @var{len}
Build and return a list holding the values from the integer vector
referenced by the pointer @var{piv} and length @var{len}.
@end defun

@c page
@node lineq
@chapter Linear equations


The functions documented in this chapter solve systems of linear
equations.  The bindings are exported by the @library{foreign math
lapack primitives} library and reexported by the @library{foreign math
lapack} library.

@menu
* lineq general::               General problem.
@end menu

@c page
@node lineq general
@section General problem


@defun dgesv @var{n} @var{nrhs} @var{a-mat} @var{lda} @var{ipiv} @var{b-mat} @var{ldb}
Compute the solution to a real system of linear equations:

@example
A * X = B
@end example

@noindent
where @math{A} is an @var{n}-by-@var{n} matrix and @math{X} and @math{B}
are @var{n}-by-@var{nrhs} matrices; @math{A} is a generic matrix.

The LU decomposition with partial pivoting and row interchanges is used
to factor @math{A} as:

@example
A = P * L * U
@end example

@noindent
where @math{P} is a permutation matrix, @math{L} is unit lower
triangular, and @math{U} is upper triangular.  The factored form of
@math{A} is then used to solve the system of equations @math{A * X = B}.

@var{n} must be a non--negative exact integer representing is the number
of linear equations: the order of the matrix @var{a-mat}.  @var{nrhs}
(number of right--hand sides) must be a non--negative exact integer
representing the number of right hand sides: the number of columns of
the matrix @var{b-mat}.

@var{a-mat} must be a pointer object referencing an array of
@code{double} real numbers with dimension @var{lda}:@var{n}; on entry,
the array must hold the coefficient matrix; on exit, the array holds the
factors @math{L} and @math{U} from the factorization @math{A = P*L*U};
the unit diagonal elements of @math{L} are not stored.

@var{lda} must be a positive integer: the leading dimension of the array
@var{a-mat}.  @math{@var{lda} >= max(1, @var{n})}.

@var{ipiv} must be a pointer object referencing an array of
@code{integer} values with dimension @var{n}; on exit, the array holds
the pivot indices that define the permutation matrix @math{P}; row
@math{i} of the matrix was interchanged with row @math{@var{ipiv}(i)}.
To apply the permutation see the function @func{dlaswp}, @ref{perms,
Permutations}.


@var{b-mat} must be a pointer object referencing an array of
@code{double} real numbers with dimension @var{ldb}:@var{nrhs}; on
entry, the array must hold the right hand side matrix @math{B}; on exit,
it holds the solution matrix @math{X}.

@var{ldb} must be a positive exact integer representing the the leading
dimension of the array @math{B}.  @math{@var{ldb} >= max(1, @var{n})}.

@example
(import (rnrs)
  (compensations)
  (foreign math lapack)
  (foreign math lapack vm))

(with-compensations
  (let* ((n   4)
         (A   (rmx/c n n))
         (B   (rvc/c n))
         (piv (piv/c n)))

    (rmx-fill! A n '(( 1.80   2.88   2.05  -0.89)
                     ( 5.25  -2.95  -0.95  -3.80)
                     ( 1.58  -2.69  -2.90  -1.04)
                     (-1.11  -0.66  -0.59   0.80)))

    (rvc-fill! B '(9.52  24.35  0.77  -6.22))

    (dgesv n 1 A n piv B n)

    (rvc->list B n) @result{} (1. -1. 3. -5.)

    (piv->list piv n))) @result{} (2 2 3 4)
@end example
@end defun


@defun zgesv @var{n} @var{nrhs} @var{a-mat} @var{lda} @var{ipiv} @var{b-mat} @var{ldb}
Compute the solution to a complex system of linear equations:

@example
A * X = B
@end example

@noindent
where @math{A} is an @var{n}-by-@var{n} matrix and @math{X} and @math{B}
are @var{n}-by-@var{nrhs} matrices; @math{A} is a generic matrix.

The LU decomposition with partial pivoting and row interchanges is used
to factor @math{A} as:

@example
A = P * L * U
@end example

@noindent
where @math{P} is a permutation matrix, @math{L} is unit lower
triangular, and @math{U} is upper triangular.  The factored form of
@math{A} is then used to solve the system of equations @math{A * X = B}.

@var{n} must be a non--negative exact integer representing is the number
of linear equations: the order of the matrix @var{a-mat}.  @var{nrhs}
(number of right--hand sides) must be a non--negative exact integer
representing the number of right hand sides: the number of columns of
the matrix @var{b-mat}.

@var{a-mat} must be a pointer object referencing an array of
@code{double} complex numbers with dimension @var{lda}:@var{n}; on
entry, the array must hold the coefficient matrix; on exit, the array
holds the factors @math{L} and @math{U} from the factorization @math{A =
P*L*U}; the unit diagonal elements of @math{L} are not stored.

@var{lda} must be a positive integer: the leading dimension of the array
@var{a-mat}.  @math{@var{lda} >= max(1, @var{n})}.

@var{ipiv} must be a pointer object referencing an array of
@code{integer} values with dimension @var{n}; on exit, the array holds
the pivot indices that define the permutation matrix @math{P}; row
@math{i} of the matrix was interchanged with row @math{@var{ipiv}(i)}.
To apply the permutation see the function @func{zlaswp}, @ref{perms,
Permutations}.


@var{b-mat} must be a pointer object referencing an array of
@code{double} complex numbers with dimension @var{ldb}:@var{nrhs}; on
entry, the array must hold the right hand side matrix @math{B}; on exit,
it holds the solution matrix @math{X}.

@var{ldb} must be a positive exact integer representing the the leading
dimension of the array @math{B}.  @math{@var{ldb} >= max(1, @var{n})}.

@example
(import (rnrs)
  (compensations)
  (foreign math lapack)
  (foreign math lapack vm))

(with-compensations
  (let* ((n   4)
         (A   (cmx/c n n))
         (B   (cvc/c n))
         (piv (piv/c n)))

    (cmx-fill! A n
       '((-1.34+2.55i  0.28+3.17i -6.39-2.20i  0.72-0.92i)
         (-0.17-1.41i  3.31-0.15i -0.15+1.34i  1.29+1.38i)
         (-3.29-2.39i -1.91+4.42i -0.14-1.35i  1.72+1.35i)
         ( 2.41+0.39i -0.56+1.47i -0.83-0.69i -1.96+0.67i)))

    (cvc-fill! B
        '(26.26+51.78i 6.43-8.68i -5.75+25.31i 1.16+2.57i))

    (zgesv n 1 A n piv B n)

    (cvc->list B n) @result{} (1.+1.i 2.-3.i -4.-5.i -0.+6.i)

    (piv->list piv n))) @result{} (3 2 3 4)
@end example
@end defun

@c page
@node perms
@chapter Permutations


The functions documented in this chapter apply permutations to matrices.
The bindings are exported by the @library{foreign math lapack
primitives} library and reexported by the @library{foreign math lapack}
library.


@defun dlaswp @var{n} @var{a-mat} @var{lda} @vari{k} @varii{k} @var{ipiv} @var{incx}
Perform a series of row interchanges on the matrix referenced by the
pointer @var{a-mat}.  One row interchange is initiated for each of rows
@vari{k} through @varii{K} of @var{a-mat}.

@var{n} must be an exact integer representing the number of columns of
the matrix @var{a-mat}.

@var{a-mat} must be a pointer to an array of @code{double} real numbers
with dimension @var{lda}:@var{n}.  On entry, the array must hold the
matrix of column dimension @var{n} to which the row interchanges will be
applied.  On exit, the array holds the permuted matrix.

@var{lda} must be an exact integer representing the leading dimension of
the array @var{a-mat}.

@vari{k} and @varii{k} must be exact integers representing the first and
last elements (inclusive) of @var{ipiv} for which a row interchange will
be done.

@var{ipiv} must be a pointer to an array of @code{integer} numbers, with
dimension @math{@var{n} * abs(@var{incx})}; it must hold the vector of
pivot indices.  Only the elements in positions @vari{k} through
@varii{K} of @var{ipiv} are accessed.  @math{@var{ipiv}(K) = L} implies
rows @math{K} and @math{L} are to be interchanged.

@var{incx} must be an exact integer representing the stride between
successive values of @var{ipiv}.  If @var{ipiv} is negative, the pivots
are applied in reverse order.
@end defun


@defun zlaswp @var{n} @var{a-mat} @var{lda} @vari{k} @varii{k} @var{ipiv} @var{incx}
Perform a series of row interchanges on the matrix referenced by the
pointer @var{a-mat}.  One row interchange is initiated for each of rows
@vari{k} through @varii{K} of @var{a-mat}.

@var{n} must be an exact integer representing the number of columns of
the matrix @var{a-mat}.

@var{a-mat} must be a pointer to an array of @code{double} complex
numbers with dimension @var{lda}:@var{n}.  On entry, the array must hold
the matrix of column dimension @var{n} to which the row interchanges
will be applied.  On exit, the array holds the permuted matrix.

@var{lda} must be an exact integer representing the leading dimension of
the array @var{a-mat}.

@vari{k} and @varii{k} must be exact integers representing the first and
last elements (inclusive) of @var{ipiv} for which a row interchange will
be done.

@var{ipiv} must be a pointer to an array of @code{integer} numbers, with
dimension @math{@var{n} * abs(@var{incx})}; it must hold the vector of
pivot indices.  Only the elements in positions @vari{k} through
@varii{K} of @var{ipiv} are accessed.  @math{@var{ipiv}(K) = L} implies
rows @math{K} and @math{L} are to be interchanged.

@var{incx} must be an exact integer representing the stride between
successive values of @var{ipiv}.  If @var{ipiv} is negative, the pivots
are applied in reverse order.
@end defun

@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
