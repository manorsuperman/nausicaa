\input texinfo.tex
@c %**start of header
@setfilename nausicaa-lapack.info
@settitle LAPACK for Nausicaa
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@macro condition{NAME}
@code{&\NAME\}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro sql{}
@acronym{SQL}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@macro axml{}
@acronym{XML}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@macro lapack{}
@acronym{LAPACK}
@end macro

@macro clapack{}
@acronym{CLAPACK}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro ssh{}
@acronym{SSH}
@end macro

@macro ssl{}
@acronym{SSL}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro tls{}
@acronym{TLS}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      LAPACK for Nausicaa

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@lapack{}

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-lapack

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2010

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a
distribution of libraries for @rnrs{6} Scheme implementations; it
provides a binding to the @clapack{} C language library.  It is built
upon Nausicaa/Scheme, making use of its foreign--functions interface.

The libraries support Ikarus, Mosh and Ypsilon Scheme; the package
supports @gnu{}+Linux systems.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/nausicaa/downloads}

@noindent
the project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/tree/master}

@noindent
@clapack{} is available at:

@center @url{http://www.netlib.org/clapack/}

@noindent
original documentation for @lapack{} and @clapack{} can be found at:

@center @url{http://www.netlib.org/lapack/lug/lapack_lug.html}

@noindent
and in printed form:

@quotation
``LAPACK Users' Guide''.  E. Anderson, Z. Bai, C. Bischof, S. Blackford,
J. Demmel, J. Dongarra, J. Du Croz, A. Greenbaum, S. Hammarling,
A. McKenney, D. and Sorensen.  Third Edition.  Society for Industrial
and Applied Mathematics, 1999.  Philadelphia, PA.  @acronym{ISBN}
0-89871-447-8 (paperback).
@end quotation

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-lapack: (nausicaa-lapack).   @clapack{} for Nausicaa.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* typedefs::                    Type accessors and mutators.
* conditions::                  Condition objects.
* vm::                          Basic vector and matrix library.
* lineq::                       Linear equations.
* factor::                      Factorisations.
* inverse::                     Inverse computation.
* eigenproblem::                Computing eigenvalues and
                                eigenvectors.
* perms::                       Permutations.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* ipiv::                        On the meaning of the pivot indices
                                and the permutation matrix.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Overview of the package

* overview intro::              Introduction to @lapack{}
                                for end users.
* overview libraries::          Installed libraries.
* overview primitives::         The primitives @api{}.
* overview names::              Function naming conventions.

Type accessors and mutators

* typedefs common::             Common C language types.
* typedefs callbacks::          Callback types.
* typedefs structs::            Data structures.

Condition objects

* conditions error::            Basic error condition.
* conditions argument::         Invalid argument error condition.
* conditions step::             Failed computation step error
                                condition.

Basic vector and matrix library

* vm real vectors::             Real vectors.
* vm complex vectors::          Complex vectors.
* vm real matrices::            Real matrices.
* vm complex matrices::         Complex matrices.
* vm pivots::                   Vectors of integers as permutation
                                indices.

Linear equations

* lineq general::               General problem.

Factorisations

* factor lu::                   @math{LU} matrix factorisation.

Inverse computation

* inverse lu::                  Inverse matrix computation using
                                @math{LU} factorisation.

Computing eigenvalues and eigenvectors

* eigenproblem general::        Eigenvalues and eigenvectors
                                of general matrices.

@end detailmenu
@end menu

@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @version{} of @value{PACKAGE}, a
distribution of libraries for @rnrs{6} Scheme implementations; it
provides bindings to the @clapack{} C language library, the @ansi{} C
translation of the @lapack{} library.  It is built upon Nausicaa/Scheme,
making use of its foreign--functions interface.

The libraries support Ikarus, Mosh and Ypsilon Scheme; the package
supports @gnu{}+Linux systems.

@menu
* overview intro::              Introduction to @lapack{}
                                for end users.
* overview libraries::          Installed libraries.
* overview primitives::         The primitives @api{}.
* overview names::              Function naming conventions.
@end menu

@c page
@node overview intro
@section Introduction to @lapack{} for end users


For end users only interested in solving math equations, @clapack{} can
be intimidating with its 1200+ exported functions; but we do not really
need to read the documentation of all of them.  Rather let's start by
acknowledging that almost each algorithm comes in a version for
@code{float} numbers and a version for @code{double} numbers; so the
count of ``distinct'' algorithms is ~600+.  Then let's acknowledge that
almost each algorithm comes in a version for real numbers and a version
for complex numbers; so the count of ``distinct'' algorithms is down to
~300+.

Finally let's acknowledge @clapack{}'s architecture:

@example
 -----------------------------------------------
|               driver functions                |
|-----------------------------------------------|
| computational functions | auxiliary functions |
 -----------------------------------------------
@end example

@noindent
as end users we are concerned only with the high--level ``driver''
functions, which address the following basic math problems:

@enumerate
@item
Solve a system of linear equations.

@item
Compute eigenvalues and eigenvectors.

@item
Compute the singular value decomposition.
@end enumerate

The original @lapack{} user's guide:

@center @url{http://www.netlib.org/lapack/lug/lapack_lug.html}

@noindent
is a good introductory read, but unfortunately the documentation of the
functions is in the source code itself; for example, the documentation
of @cfunc{dgesvd_} is in the file @file{CLAPACK/SRC/dgesvd.c}.

@c page
@node overview libraries
@section Installed libraries


The installed libraries are:

@table @library
@item foreign math lapack shared-object
Exports the single binding @code{clapack-shared-object} which references
the foreign shared library.

@item foreign math lapack sizeof
Exports bindings to constant values and data structures accessors.

@item foreign math lapack conditions
Exports definitions for condition objects used by this package.

@item foreign math lapack platform
Exports one binding for each foreign function; the bindings to the
Scheme function callouts have the same name of the C functions, so
@cfunc{dgesv_} is available as @func{dgesv_}.  This library makes the
original @lapack{} documentation relevant for this package.

@item foreign math lapack primitives
Exports one binding for each foreign function, implementing, marshaling
of arguments and return values where it makes sense.  The bindings to
the Scheme functions have the same name of the C functions, but with the
trailing underscore removed; so @cfunc{dgesv_} is available as
@func{dgesv}.  @ref{overview primitives} for details on the primitives
@api{}.

This library is @strong{not} thread--safe.

@item foreign math lapack
Compound library exporting the high--level @api{}; it reexports bindings
from the @samp{primitives} library and some bindings from the
@samp{sizeof} library.

@item foreign math lapack vm
Exports a very basic vector and matrix @api{}, mostly intended for
testing.  @ref{vm, Basic vector and matrix library}.
@end table

@c page
@node overview primitives
@section The primitives @api{}


The primitives @api{} is exported by the @library{foreign math lapack
primitives} library and reexported by the @library{foreign math lapack}
library.  The original documentation of @lapack{} is valid as
documentation of this @api{}, when we take into accounts the following
notes.

It was decided that @value{PACKAGE} must impose to the client code
neither a format for vectors and matrices, nor a model for the
associated data structures, nor a model for raw memory handling.  So
whenever a @clapack{} function accepts a pointer to an array of integer
or floating--point numbers, the associated Scheme wrapper function
accepts a pointer object referencing a raw memory array.  @nauref{ffi
pointers, Pointer objects}.

The original @lapack{} library is coded in Fortran 77, which means the
arguments to functions are passed by reference; this convention is
maintained in the @clapack{} translation to @ansi{} C, so whenever a
function needs a value of type @code{char}, @code{integer} or
@code{logical}, the associated argument is a pointer of type @code{char
*}, @code{integer *} or @code{logical *}.  This inconvenience is handled
by the primitives @api{}: non--array arguments must be handed as simple
values.

Many functions (but not all) report error conditions through an argument
called @var{info}@footnote{See
@url{http://www.netlib.org/lapack/lug/node119.html}.}; this argument is
handled internally by the library and must not be given in function
calls; in case of error, detected by inspecting the @var{info} value
after a function call, an exception is raised using an appropriate
condition object.  @ref{conditions, Condition objects}.

For example, the @cfunc{dgesv_} function has prototype:

@example
int dgesv_ (integer *n, integer *nrhs,
            doublereal *a, integer *lda,
            integer *ipiv,
            doublereal *b, integer *ldb,
            integer *info);
@end example

@noindent
but with marshaling of arguments and automatic handling of @var{info},
we call the primitive Scheme function @func{dgesv} as if the prototype
is:

@example
int dgesv_ (integer n, integer nrhs,
            doublereal *a, integer lda,
            integer *ipiv,
            doublereal *b, integer ldb);
@end example

@quotation
@strong{NOTE} Marshaling of arguments for the 1200+ functions exported
by the primitives @api{} is automatically generated, using as
informations the argument type name and its proper name; unfortunately
some couples type/name do not identify how the argument is used.

For example, we know that the argument @code{real* scale} is always a
single real value, while the argument @code{real* s} some times is a
single real value and other times is an array of real values.

This will cause incorrect handling of arguments for some functions until
all the errors are catched and fixed; fixing these errors is easy and
can be done quickly.  If you stumble on such problem please file a bug
report.
@end quotation

@c page
@node overview names
@section Function naming conventions


The following description comes from the @lapack{} user's guide and the
@acronym{FAQ} web page
(@url{http://@/www.netlib.org/@/lapack/@/faq.html}).

The name of each @lapack{} routine is a coded specification of its
function (within the very tight limits of standard Fortran 77
6-character names).  All driver and computational routines have names of
the form @samp{XYYZZZ}, where for some driver routines the 6th character
is blank.

@itemize
@item
The first letter, @samp{X}, indicates the data type as follows:

@table @code
@item S
Real.

@item D
Double precision.

@item C
Complex.

@item Z
@code{COMPLEX*16} or double complex.
@end table

@item
The next two letters, @samp{YY}, indicate the type of matrix (or of the
most significant matrix).  Most of these two--letter codes apply to both
real and complex matrices; a few apply specifically to one or the other.

@table @code
@item BD
Bidiagonal.

@item DI
Diagonal.

@item GB
General band.

@item GE
General (i.e., unsymmetric, in some cases rectangular).

@item GG
General matrices, generalized problem (i.e., a pair of general
matrices).

@item GT
General tridiagonal.

@item HB
(Complex) Hermitian band.

@item HE
(Complex) Hermitian.

@item HG
Upper Hessenberg matrix, generalized problem (i.e a Hessenberg and a
triangular matrix).

@item HP
(Complex) Hermitian, packed storage.

@item HS
Upper Hessenberg.

@item OP
(Real) orthogonal, packed storage.

@item OR
(Real) orthogonal.

@item PB
Symmetric or Hermitian positive definite band.

@item PO
Symmetric or Hermitian positive definite.

@item PP
Symmetric or Hermitian positive definite, packed storage.

@item PT
Symmetric or Hermitian positive definite tridiagonal.

@item SB
(Real) symmetric band.

@item SP
Symmetric, packed storage.

@item ST
(Real) symmetric tridiagonal.

@item SY
Symmetric.

@item TB
Triangular band.

@item TG
Triangular matrices, generalized problem (i.e., a pair of triangular
matrices).

@item TP
Triangular, packed storage.

@item TR
Triangular (or in some cases quasi--triangular).

@item TZ
Trapezoidal.

@item UN
Complex unitary.

@item UP
Complex unitary, packed storage.
@end table

@item
The last three letters @samp{ZZZ} indicate the computation performed;
for example, @samp{SGEBRD} is a single precision routine that performs a
bidiagonal reduction (@acronym{BRD}) of a real general matrix.
@end itemize

@c page
@node typedefs
@chapter Type accessors and mutators


The bindings described in this chapter are exported by the
@library{foreign math lapack sizeof} library and reexported by the
@library{foreign math lapack} library.  The types for which the @api{}
documented here provides handling are defined in the C language header
file @file{f2c.h}, which comes with @clapack{}.

@menu
* typedefs common::             Common C language types.
* typedefs callbacks::          Callback types.
* typedefs structs::            Data structures.
@end menu

@c page
@node typedefs common
@section Common C language types


@deftp {Type Alias} integer
Usually bound to the Scheme symbol @code{signed-int}, it is used to
specify the signed integer arguments to functions.
@end deftp


@defvr Constant sizeof-integer
@defvrx Constant alignof-integer
@defvrx Constant strideof-integer
Size, structure alignment and array stride of @code{integer}.
@end defvr


@defun pointer-ref-c-integer @var{pointer} @var{offset}
@defunx pointer-set-c-integer! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{integer}
value.
@end defun


@defun array-ref-c-integer @var{pointer} @var{index}
Accessor for the elements of an array of @code{integer} values; return
the value at index @var{index}.
@end defun


@deftp {Type Alias} uinteger
Usually bound to the Scheme symbol @code{unsigned-int}, it is used to
specify the unsigned integer arguments to functions.
@end deftp


@defvr Constant sizeof-uinteger
@defvrx Constant alignof-uinteger
@defvrx Constant strideof-uinteger
Size, structure alignment and array stride of @code{uinteger}.
@end defvr


@defun pointer-ref-c-uinteger @var{pointer} @var{offset}
@defunx pointer-set-c-uinteger! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{uinteger}
value.
@end defun


@deftp {Type Alias} shortint
Usually bound to the Scheme symbol @code{signed-short}, it is used to
specify the small signed integer arguments to functions.
@end deftp


@defvr Constant sizeof-shortint
@defvrx Constant alignof-shortint
@defvrx Constant strideof-shortint
Size, structure alignment and array stride of @code{shortint}.
@end defvr


@defun pointer-ref-c-shortint @var{pointer} @var{offset}
@defunx pointer-set-c-shortint! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{shortint}
value.
@end defun


@deftp {Type Alias} real
Usually bound to the Scheme symbol @code{float}, it is used to specify
the single--precision floating point arguments to functions.
@end deftp


@defvr Constant sizeof-real
@defvrx Constant alignof-real
@defvrx Constant strideof-real
Size, structure alignment and array stride of @code{real}.
@end defvr


@defun pointer-ref-c-real @var{pointer} @var{offset}
@defunx pointer-set-c-real! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{real} value.
@end defun


@deftp {Type Alias} doublereal
Usually bound to the Scheme symbol @code{double}, it is used to specify
the double--precision floating point arguments to functions.
@end deftp


@defvr Constant sizeof-doublereal
@defvrx Constant alignof-doublereal
@defvrx Constant strideof-doublereal
Size, structure alignment and array stride of @code{doublereal}.
@end defvr


@defun pointer-ref-c-doublereal @var{pointer} @var{offset}
@defunx pointer-set-c-doublereal! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{doublereal}
value.
@end defun


@deftp {Type Alias} logical
Usually bound to the Scheme symbol @code{signed-int}, it is used to
specify some integer arguments to functions.
@end deftp


@defvr Constant sizeof-logical
@defvrx Constant alignof-logical
@defvrx Constant strideof-logical
Size, structure alignment and array stride of @code{logical}.
@end defvr


@defun pointer-ref-c-logical @var{pointer} @var{offset}
@defunx pointer-set-c-logical! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{logical}
value.
@end defun


@deftp {Type Alias} shortlogical
Usually bound to the Scheme symbol @code{signed-short}, it is used to
specify some nteger arguments to functions.
@end deftp


@defvr Constant sizeof-shortlogical
@defvrx Constant alignof-shortlogical
@defvrx Constant strideof-shortlogical
Size, structure alignment and array stride of @code{shortlogical}.
@end defvr


@defun pointer-ref-c-shortlogical @var{pointer} @var{offset}
@defunx pointer-set-c-shortlogical! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{shortlogical}
value.
@end defun


@deftp {Type Alias} logical1
Usually bound to the Scheme symbol @code{signed-char}, it is used to
specify some signed integer arguments to functions.
@end deftp


@defvr Constant sizeof-logical1
@defvrx Constant alignof-logical1
@defvrx Constant strideof-logical1
Size, structure alignment and array stride of @code{logical1}.
@end defvr


@defun pointer-ref-c-logical1 @var{pointer} @var{offset}
@defunx pointer-set-c-logical1! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{logical1}
value.
@end defun


@deftp {Type Alias} integer1
Usually bound to the Scheme symbol @code{signed-char}, it is used to
specify some integer arguments to functions.
@end deftp


@defvr Constant sizeof-integer1
@defvrx Constant alignof-integer1
@defvrx Constant strideof-integer1
Size, structure alignment and array stride of @code{integer1}.
@end defvr


@defun pointer-ref-c-integer1 @var{pointer} @var{offset}
@defunx pointer-set-c-integer1! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{integer1}
value.
@end defun


@deftp {Type Alias} ftnlen
Usually bound to the Scheme symbol @code{signed-int}, it is used to
specify some integer arguments to functions.
@end deftp


@defvr Constant sizeof-ftnlen
@defvrx Constant alignof-ftnlen
@defvrx Constant strideof-ftnlen
Size, structure alignment and array stride of @code{ftnlen}.
@end defvr


@defun pointer-ref-c-ftnlen @var{pointer} @var{offset}
@defunx pointer-set-c-ftnlen! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{ftnlen}
value.
@end defun


@deftp {Type Alias} flag
Usually bound to the Scheme symbol @code{signed-int}, it is used to
specify some integer arguments to functions.
@end deftp


@defvr Constant sizeof-flag
@defvrx Constant alignof-flag
@defvrx Constant strideof-flag
Size, structure alignment and array stride of @code{flag}.
@end defvr


@defun pointer-ref-c-flag @var{pointer} @var{offset}
@defunx pointer-set-c-flag! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{flag} value.
@end defun


@deftp {Type Alias} ftnint
Usually bound to the Scheme symbol @code{signed-int}, it is used to
specify some integer arguments to functions.
@end deftp


@defvr Constant sizeof-ftnint
@defvrx Constant alignof-ftnint
@defvrx Constant strideof-ftnint
Size, structure alignment and array stride of @code{ftnint}.
@end defvr


@defun pointer-ref-c-ftnint @var{pointer} @var{offset}
@defunx pointer-set-c-ftnint! @var{pointer} @var{offset} @var{value}
Accessor and mutator for memory locations holding an @code{ftnint}
value.
@end defun


@deftp {Type Alias} address
Bound to the Scheme symbol @code{void*}.
@end deftp

@c page
@node typedefs callbacks
@section Callback types


@defvr Constant C_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
void C_fp ()
@end example
@end defvr


@defvr Constant D_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
doublereal D_fp ()
@end example
@end defvr


@defvr Constant E_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
doublereal E_fp ()
@end example
@end defvr


@defvr Constant H_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
functionwith prototype:

@example
void H_fp ()
@end example
@end defvr


@defvr Constant I_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
integer I_fp ()
@end example
@end defvr


@defvr Constant J_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
shortint J_fp ()
@end example
@end defvr


@defvr Constant K_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
shortlogical K_fp ()
@end example
@end defvr


@defvr Constant L_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
logical L_fp ()
@end example
@end defvr


@defvr Constant R_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example

@end example
@end defvr


@defvr Constant S_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
int S_fp ()
@end example
@end defvr

@defvr Constant U_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
int U_fp ()
@end example
@end defvr

@defvr Constant Z_fp
Bound to the Scheme symbol @code{callback}, it represents a pointer to a
function with prototype:

@example
void Z_fp ()
@end example
@end defvr

@c page
@node typedefs structs
@section Data structures


The C language data structure @code{complex} has the following
definition:

@example
typedef struct @{
  real r, i;
@} complex;
@end example


@defvr Constant sizeof-complex
@defvrx Constant alignof-complex
@defvrx Constant strideof-complex
Size, structure alignment and array stride of the @code{complex} C
language data structure.
@end defvr


@deffn Syntax struct-complex-r-ref @var{pointer}
@deffnx Syntax struct-complex-r-set! @var{pointer} @var{value}
@deffnx Syntax struct-complex-i-ref @var{pointer}
@deffnx Syntax struct-complex-i-set! @var{pointer} @var{value}
Accessor and mutator for the fields of the @code{complex} C language
data structure.
@end deffn


The C language data structure @code{doublecomplex} has the following
definition:

@example
typedef struct @{
   doublereal r, i;
@} doublecomplex;
@end example


@defvr Constant sizeof-doublecomplex
@defvrx Constant alignof-doublecomplex
@defvrx Constant strideof-doublecomplex
Size, structure alignment and array stride of the @code{doublecomplex} C
language data structure.
@end defvr


@deffn Syntax struct-doublecomplex-r-ref @var{pointer}
@deffnx Syntax struct-doublecomplex-r-set! @var{pointer} @var{value}
@deffnx Syntax struct-doublecomplex-i-ref @var{pointer}
@deffnx Syntax struct-doublecomplex-i-set! @var{pointer} @var{value}
Accessor and mutator for the fields of the @code{doublecomplex} C
language data structure.
@end deffn

@c page
@node conditions
@chapter Condition objects


The bindings documented here are exported by the @library{foreign math
lapack conditions} library and reexported by the @library{foreign math
lapack} library.

@menu
* conditions error::            Basic error condition.
* conditions argument::         Invalid argument error condition.
* conditions step::             Failed computation step error
                                condition.
@end menu

@c page
@node conditions error
@section Basic error condition


@deftp {Condition Type} &lapack-error
Base condition type for all the conditions used by @value{PACKAGE}.  It
is derived from @condition{error}.  It has no fields.
@end deftp


@defun make-lapack-error-condition
@defunx lapack-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{lapack-error}.
@end defun

@c page
@node conditions argument
@section Invalid argument error condition


@deftp {Condition Type} &lapack-invalid-argument
Condition type used to represent ``invalid argument'' errors; it is
derived from @condition{lapack-error}.  It has the following fields:

@table @code
@item argument-position
The position of the invalid argument, starting from @math{1}.  This is
the value of the @var{info} argument to @clapack{} callouts.

@item argument-name
A Scheme symbol representing the invalid argument name.

@item argument-value
The invalid argument value.
@end table
@end deftp


@defun make-lapack-invalid-argument-condition @var{position} @var{name} @var{value}
@defunx lapack-invalid-argument-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{lapack-invalid-argument}.
@end defun


@defun condition-lapack-argument-position @var{condition}
@defunx condition-lapack-argument-name @var{condition}
@defunx condition-lapack-argument-value @var{condition}
Field accessors for the condition objects of type
@condition{lapack-invalid-argument}.
@end defun

@c page
@node conditions step
@section Failed computation step error condition


@deftp {Condition Type} &lapack-failed-step
Condition type used to represent ``invalid argument'' errors; it is
derived from @condition{lapack-error}.  It has the following fields:

@table @code
@item failed-step
The failed step number.  This is the value of the @var{info} argument to
@clapack{} callouts.
@end table
@end deftp


@defun make-lapack-failed-step-condition @var{step}
@defunx lapack-failed-step-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{lapack-failed-step}.
@end defun


@defun condition-lapack-failed-step @var{condition}
Field accessor for condition objects of type
@condition{lapack-failed-step}.
@end defun

@c page
@node vm
@chapter Basic vector and matrix library


The bindings documented here are exported by the @library{foreign math
lapack vm} library.  Vectors and matrices supported by this library are
composed of real and complex numbers under @code{double} representation.

@menu
* vm real vectors::             Real vectors.
* vm complex vectors::          Complex vectors.
* vm real matrices::            Real matrices.
* vm complex matrices::         Complex matrices.
* vm pivots::                   Vectors of integers as permutation
                                indices.
@end menu

@c page
@node vm real vectors
@section Real vectors


@defun rvc/c @var{len}
Allocate an array capable of holding a real vector of @var{len}
elements; return a pointer to it.  The appropriate free function is
pushed to the current compensations stack.  @nauref{compensations,
Compensation stacks}.
@end defun


@defun rvc-set! @var{rvc} @var{idx} @var{val}
Store the real number @var{val} at location @var{IDX} in the real vector
referenced by the pointer object @var{rvc}.
@end defun


@defun rvc-ref @var{rvc} @var{idx}
Return the real number at location @var{idx} in the real vector
referenced by the pointer object @var{rvc}.
@end defun


@defun rvc-fill! @var{rvc} @var{m}
Fill the real vector referenced by the pointer object @var{rvc} with
values from the list @var{m}.
@end defun


@defun rvc->list @var{rvc} @var{len}
Build and return a list holding the values from the real vector
referenced by the pointer @var{rvc} and length @var{len}.
@end defun

@c page
@node vm complex vectors
@section Complex vectors


@defun rvc/c @var{len}
Allocate an array capable of holding a complex vector of @var{len}
elements; return a pointer to it.  The appropriate free function is
pushed to the current compensations stack.  @nauref{compensations,
Compensation stacks}.
@end defun


@defun rvc-set! @var{rvc} @var{idx} @var{val}
Store the complex number @var{val} at location @var{IDX} in the complex
vector referenced by the pointer object @var{rvc}.
@end defun


@defun rvc-ref @var{rvc} @var{idx}
Return the complex number at location @var{idx} in the complex vector
referenced by the pointer object @var{rvc}.
@end defun


@defun rvc-fill! @var{rvc} @var{m}
Fill the complex vector referenced by the pointer object @var{rvc} with
values from the list @var{m}.
@end defun


@defun rvc->list @var{rvc} @var{len}
Build and return a list holding the values from the complex vector
referenced by the pointer @var{rvc} and length @var{len}.
@end defun

@c page
@node vm real matrices
@section Real matrices


For all the following descriptions: the @var{ld} argument is the
``leading dimension'' of the matrix, in @lapack{} jargon, and the matrix
is accessed in column--major order.


@defun rmx/c @var{rows-num} @var{cols-num}
Allocate an array capable of holding a real matrix of @var{rows-num}
rows and @var{cols-num} columns; return a pointer to it.  The
appropriate free function is pushed to the current compensations stack.
@nauref{compensations, Compensation stacks}.
@end defun


@defun rmx-set! @var{rmx} @var{ldm} @var{row} @var{col} @var{val}
Store the real value @var{val} at location @var{row}, @var{col} in the
real matrix referenced by the pointer object @var{rmx} and column length
@var{ldm}.
@end defun


@defun rmx-ref @var{rmx} @var{ldm} @var{row} @var{col}
Return the real value at location @var{row}, @var{col} in the real
matrix referenced by the pointer object @var{rmx} and column length
@var{ldm}.
@end defun


@defun rmx-fill! @var{rmx} @var{ldm} @var{m}
Fill the real matrix referenced by the pointer object @var{rmx} and
column length @var{ldm}, with values from the list @var{m}.  @var{m} is
a list of lists in row--major order:

@example
((a_11 a_12 a_13)
 (a_21 a_22 a_23)
 (a_31 a_32 a_33))
@end example
@end defun


@defun rmx->list @var{rmx} @var{ldm} @var{rows-num} @var{cols-num}
Build and return a list of lists holding the values, in row--major
order, from the matrix referenced by the pointer @var{rmx}.  @var{ldm}
is the length of a column.  @var{rows-num} and @var{cols-num} are the
numbers of rows and columns.
@end defun

@c page
@node vm complex matrices
@section Complex matrices


For all the following descriptions: the @var{ld} argument is the
``leading dimension'' of the matrix, in @lapack{} jargon, and the matrix
is accessed in column--major order.


@defun cmx/c @var{rows-num} @var{cols-num}
Allocate an array capable of holding a complex matrix of @var{rows-num}
rows and @var{cols-num} columns; return a pointer to it.  The
appropriate free function is pushed to the current compensations stack.
@nauref{compensations, Compensation stacks}.
@end defun


@defun cmx-set! @var{cmx} @var{ldm} @var{row} @var{col} @var{val}
Store the complex value @var{val} at location @var{row}, @var{col} in
the complex matrix referenced by the pointer object @var{cmx} and column
length @var{ldm}.
@end defun


@defun cmx-ref @var{cmx} @var{ldm} @var{row} @var{col}
Return the complex value at location @var{row}, @var{col} in the complex
matrix referenced by the pointer object @var{cmx} and column length
@var{ldm}.
@end defun


@defun cmx-fill! @var{cmx} @var{ldm} @var{m}
Fill the complex matrix referenced by the pointer object @var{cmx} and
column length @var{ldm}, with values from the list @var{m}.  @var{m} is
a list of lists in row--major order:

@example
((a_11 a_12 a_13)
 (a_21 a_22 a_23)
 (a_31 a_32 a_33))
@end example
@end defun


@defun cmx->list @var{cmx} @var{ldm} @var{rows-num} @var{cols-num}
Build and return a list of lists holding the values, in row--major
order, from the matrix referenced by the pointer @var{cmx}.  @var{ldm}
is the length of a column.  @var{rows-num} and @var{cols-num} are the
numbers of rows and columns.
@end defun

@c page
@node vm pivots
@section Vectors of integers as permutation indices


Vectors of @code{integer} numbers are used to store the pivot indices
defining permutation matrices.  @ref{ipiv, On the meaning of the pivot
indices and the permutation matrix}.


@defun piv/c @var{len}
Allocate an array capable of holding a vector of @code{integer} values
of @var{len} elements; return a pointer to it.  The appropriate free
function is pushed to the current compensations stack.
@nauref{compensations, Compensation stacks}.
@end defun


@defun piv-set! @var{piv} @var{idx} @var{val}
Store the exact integer number @var{val} at location @var{IDX} in the
integer vector referenced by the pointer object @var{piv}.
@end defun


@defun piv-ref @var{piv} @var{idx}
Return the exact integer number at location @var{idx} in the integer
vector referenced by the pointer object @var{piv}.
@end defun


@defun piv-fill! @var{piv} @var{m}
Fill the integer vector referenced by the pointer object @var{piv} with
values from the list @var{m}.
@end defun


@defun piv->list @var{piv} @var{len}
Build and return a list holding the values from the integer vector
referenced by the pointer @var{piv} and length @var{len}.
@end defun

@c page
@node lineq
@chapter Linear equations


The functions documented in this chapter solve systems of linear
equations.  The bindings are exported by the @library{foreign math
lapack primitives} library and reexported by the @library{foreign math
lapack} library.

@menu
* lineq general::               General problem.
@end menu

@c page
@node lineq general
@section General problem


@defun dgesv @var{n} @var{nrhs} @var{a-mat} @var{lda} @var{ipiv} @var{b-mat} @var{ldb}
@defunx zgesv @var{n} @var{nrhs} @var{a-mat} @var{lda} @var{ipiv} @var{b-mat} @var{ldb}
Compute the solution to a real or complex system of linear equations:

@example
A * X = B
@end example

@noindent
where @math{A} is an @var{n}-by-@var{n} matrix and @math{X} and @math{B}
are @var{n}-by-@var{nrhs} matrices; @math{A} is a generic matrix.

The LU decomposition with partial pivoting and row interchanges is used
to factor @math{A} as:

@example
A = P * L * U
@end example

@noindent
where @math{P} is a permutation matrix, @math{L} is unit lower
triangular, and @math{U} is upper triangular.  The factored form of
@math{A} is then used to solve the system of equations @math{A * X = B}.

@var{n} must be a non--negative exact integer representing is the number
of linear equations: the order of the matrix @var{a-mat}.  @var{nrhs}
(number of right--hand sides) must be a non--negative exact integer
representing the number of right hand sides: the number of columns of
the matrix @var{b-mat}.

@var{a-mat} must be a pointer object referencing an array of
@code{double} real or complex numbers with dimension @var{lda}:@var{n};
on entry, the array must hold the coefficient matrix; on exit, the array
holds the factors @math{L} and @math{U} from the factorization @math{A =
P*L*U}; the unit diagonal elements of @math{L} are not stored.

@var{lda} must be a positive integer: the leading dimension of the array
@var{a-mat}.  @math{@var{lda} >= max(1, @var{n})}.

@var{ipiv} must be a pointer object referencing an array of
@code{integer} values with dimension @var{n}; on exit, the array holds
the pivot indices that define the permutation matrix @math{P}.
@ref{ipiv, On the meaning of the pivot indices and the permutation
matrix}.

To apply the permutation defined by @var{ipiv} see the functions
@func{dlaswp} and @func{zlaswp}, @ref{perms, Permutations}.  Notice that
the permutation is associated only to the factorisation of @math{A} and
@strong{not} to the solution matrix @var{X}.

@var{b-mat} must be a pointer object referencing an array of
@code{double} real or complex numbers with dimension
@var{ldb}:@var{nrhs}; on entry, the array must hold the right hand side
matrix @math{B}; on exit, it holds the solution matrix @math{X}.

@var{ldb} must be a positive exact integer representing the the leading
dimension of the array @math{B}.  @math{@var{ldb} >= max(1, @var{n})}.

@example
(import (rnrs)
  (compensations)
  (foreign math lapack)
  (foreign math lapack vm))

(with-compensations
  (let* ((n   4)
         (A   (rmx/c n n))
         (B   (rvc/c n))
         (piv (piv/c n)))

    (rmx-fill! A n '(( 1.80   2.88   2.05  -0.89)
                     ( 5.25  -2.95  -0.95  -3.80)
                     ( 1.58  -2.69  -2.90  -1.04)
                     (-1.11  -0.66  -0.59   0.80)))

    (rvc-fill! B '(9.52  24.35  0.77  -6.22))

    (dgesv n 1 A n piv B n)

    (rvc->list B n) @result{} (1. -1. 3. -5.)

    (piv->list piv n))) @result{} (2 2 3 4)

(with-compensations
  (let* ((n   4)
         (A   (cmx/c n n))
         (B   (cvc/c n))
         (piv (piv/c n)))

    (cmx-fill! A n
       '((-1.34+2.55i  0.28+3.17i -6.39-2.20i  0.72-0.92i)
         (-0.17-1.41i  3.31-0.15i -0.15+1.34i  1.29+1.38i)
         (-3.29-2.39i -1.91+4.42i -0.14-1.35i  1.72+1.35i)
         ( 2.41+0.39i -0.56+1.47i -0.83-0.69i -1.96+0.67i)))

    (cvc-fill! B
        '(26.26+51.78i 6.43-8.68i -5.75+25.31i 1.16+2.57i))

    (zgesv n 1 A n piv B n)

    (cvc->list B n) @result{} (1.+1.i 2.-3.i -4.-5.i -0.+6.i)

    (piv->list piv n))) @result{} (3 2 3 4)
@end example
@end defun

@c page
@node factor
@chapter Factorisations


@menu
* factor lu::                   @math{LU} matrix factorisation.
@end menu

@c page
@node factor lu
@section @math{LU} matrix factorisation


@defun dgetrf @var{m} @var{n} @var{a-mat} @var{lda} @var{ipiv}
@defunx zgetrf @var{m} @var{n} @var{a-mat} @var{lda} @var{ipiv}
Compute an @math{LU} factorization of a general @var{m}-by-@var{n}
matrix @math{a}, of real or complex number, using partial pivoting with
row interchanges.  The factorization has the form:

@example
A = P * L * U
@end example

@noindent
where @math{P} is a permutation matrix, @math{L} is lower triangular
with unit diagonal elements (lower trapezoidal if @math{m > n}), and
@math{U} is upper triangular (upper trapezoidal if @math{m < n}).

This is the right--looking Level 3 BLAS version of the algorithm.

@var{m} and @var{n} must be exact non--negative integers representing,
respectively, the number of rows and columns of the matrix @math{A}.

@var{a-mat} must be a pointer object referencing an array of
@code{double} real or complex numbers with dimension @var{lda}:@var{n}.
On entry, the array must hold the matrix to be factored.  On exit, it
holds the factors @math{L} and @math{U} from the factorization @math{A =
P L U}; the unit diagonal elements of @math{L} are not stored.

@var{lda} must be a positive exact integer representing the leading
dimension of the array @var{a-mat}.  @math{@var{lda} >= max(1,
@var{m})}.

@var{ipiv} must be a pointer object referencing an array of
@code{integer} numbers with dimension @math{min(@var{m}, @var{n})}.  On
exit, the array holds the pivot indices describing the permutation.
@ref{ipiv, On the meaning of the pivot indices and the permutation
matrix}.

@example
(import (rnrs)
  (compensations)
  (foreign math lapack)
  (foreign math lapack vm))

(with-compensations
  (let* ((M   6)
         (N   4)
         (A   (rmx/c M N))
         (piv (piv/c N)))

    (rmx-fill! A M '(( 2.27  -1.54   1.15  -1.94)
                     ( 0.28  -1.67   0.94  -0.78)
                     (-0.48  -3.09   0.99  -0.21)
                     ( 1.07   1.22   0.79   0.63)
                     (-2.35   2.93  -1.45   2.30)
                     ( 0.62  -7.39   1.03  -2.57)))

    (dgetrf M N A M piv)

    (rmx->list A M M N)
    @result{} ((-2.35     2.93    -1.45     2.3)
        (-0.26383 -6.617    0.64745 -1.9632)
        (+0.20426  0.55742  0.92527  0.41454)
        (-0.45532 -0.38599  0.41036  0.74935)
        (-0.96596 -0.19499 -0.13444 -0.06055)
        (-0.11915  0.19962  0.68952 -0.53366))

    (piv->list piv N))) @result{} (5 6 3 4)

(with-compensations

  (let* ((M   4)
         (N   4)
         (A   (cmx/c M N))
         (piv (piv/c N)))

    (cmx-fill! A M '((-1.34+2.55i   0.28+3.17i
                        -6.39-2.20i   0.72-0.92i)
                     (-0.17-1.41i   3.31-0.15i
                        -0.15+1.34i   1.29+1.38i)
                     (-3.29-2.39i  -1.91+4.42i
                        -0.14-1.35i   1.72+1.35i)
                     ( 2.41+0.39i  -0.56+1.47i
                        -0.83-0.69i  -1.96+0.67i)))

    (zgetrf M N A M piv)

    (cmx->list A M M N)
    @result{} ((-3.29-2.39i       -1.91+4.42i
           -0.14-1.35i         1.72+1.35i)
        ( 0.23761+0.25596i  4.8952-0.71136i
           -0.46228+1.6966i    1.2269+0.61897i)
        (-0.10195-0.70101i -0.66915+0.36887i
           -5.1414-1.13i       0.99826+0.38502i)
        (-0.53585+0.27073i -0.20402+0.86012i
           0.008233+0.12106i  0.14824-0.12522i))

    (piv->list piv N)) @result{} (3 2 3 4)
@end example
@end defun

@c page
@node inverse
@chapter Inverse computation


@menu
* inverse lu::                  Inverse matrix computation using
                                @math{LU} factorisation.
@end menu

@c page
@node inverse lu
@section Inverse matrix computation using @math{LU} factorisation


@defun dgetri @var{n} @var{a-mat} @var{lda} @var{ipiv} @var{work} @var{lwork}
@defunx zgetri @var{n} @var{a-mat} @var{lda} @var{ipiv} @var{work} @var{lwork}
Compute the inverse of a matrix using the @math{LU} factorization
computed by @func{dgetrf} or @func{zgetrf}.  This method inverts
@math{U} and then computes @math{inv(A)} by solving the system
@math{inv(A)*L = inv(U)} for @math{inv(A)}.

@var{n} must be an exact non--negative integer representing the order of
the matrix @math{A}.

@var{a-mat} must be a pointer object referencing an array of
@code{double} real or complex numbers with dimension @var{lda}:@var{n}.
On entry, the array must hold the factors @math{L} and @math{U} from the
factorization @math{A = P L U} as computed by @func{dgetrf}.  On exit,
the array holds the inverse of the original matrix @math{A}.

@math{lda} must be an exact integer representing the leading dimension
of the matrix @math{A}.  @math{@var{lda} >= max(1, @var{n})}.

@var{ipiv} must be a pointer object referencing an array of
@code{integer} numbers with dimension @var{n}.  On entry, the array must
hold the pivot indices as computed by @func{dgetrf} or @func{zgetrf}.

@var{work} must be a pointer object referencing an array of
@code{double} real or complex numbers with dimension @var{lwork}; the
array is used as work space.  On exit, the first element of the array is
the optimal @var{lwork}.

@var{lwork} must be a positive exact integer representing the dimension
of the array referenced by @var{work}.  @math{@var{lwork} >= max(1,
@var{n})}.  For optimal performance @math{@var{lwork} >= @var{n} * nb},
where @math{nb} is the optimal block size returned by @func{ilaenv}.

If @math{@var{lwork} = -1}, then a workspace query is assumed; the
routine only calculates the optimal size of the @var{work} array,
returns this value as the first entry of the @var{work} array, and no
error message related to @var{lwork} is issued by @func{xerbla}.

@example
(import (rnrs)
  (compensations)
  (foreign math lapack)
  (foreign math lapack vm))

(with-compensations
  (let* ((N   4)
         (A   (rmx/c N N))
         (piv (piv/c N)))

    (rmx-fill! A N '(( 2.27  -1.54   1.15  -1.94)
                     ( 0.28  -1.67   0.94  -0.78)
                     (-0.48  -3.09   0.99  -0.21)
                     ( 1.07   1.22   0.79   0.63)))

    (dgetrf N N A N piv)

    (let* ((lwork (let ((work (rvc/c 1)))
                    (dgetri N A N piv work -1)
                    (exact (pointer-ref-c-double work 0))))
           (work  (rvc/c lwork)))

      (dgetri N A N piv work lwork)

      (rmx->list A N N N))))
      @result{} (( 0.70187 -1.7582  0.68437  0.21266)
          (-0.31892  1.0523 -0.6987   0.087803)
          (-0.61374  2.0798 -0.63068  0.47487)
          ( 0.19515 -1.6596  0.98156  0.46062))

(with-compensations
  (let* ((N   4)
         (A   (cmx/c N N))
         (piv (piv/c N)))

    (cmx-fill! A N '((-1.34+2.55i   0.28+3.17i
                        -6.39-2.20i   0.72-0.92i)
                     (-0.17-1.41i   3.31-0.15i
                        -0.15+1.34i   1.29+1.38i)
                     (-3.29-2.39i  -1.91+4.42i
                        -0.14-1.35i   1.72+1.35i)
                     ( 2.41+0.39i  -0.56+1.47i
                        -0.83-0.69i  -1.96+0.67i)))

    (zgetrf N N A N piv)

    (let* ((lwork (let ((work (cvc/c 1)))
                    (zgetri N A N piv work -1)
                    (exact (pointer-ref-c-double work 0))))
           (work  (cvc/c lwork)))

      (zgetri N A N piv work lwork)

      (cmx->list A N N N))))
      @result{} (( 0.075662-0.43236i   1.6512-3.1342i
             1.2663+0.041789i   3.8181+1.1195i)
          (-0.19415+0.079808i  -1.19-0.14264i
             -0.24014-0.58887i  -0.010076-1.4969i)
          (-0.095676-0.049102i  0.73711-0.42897i
             0.32242+0.077566i  0.68875+0.7891i)
          ( 0.37018-0.50397i    3.7253-3.1813i
             1.7014+0.72673i    3.9367+3.3255i))
@end example
@end defun

@c page
@node eigenproblem
@chapter Computing eigenvalues and eigenvectors


@menu
* eigenproblem general::        Eigenvalues and eigenvectors
                                of general matrices.
@end menu

@c page
@node eigenproblem general
@section Eigenvalues and eigenvectors of general matrices


@defun dgeev @var{jobvl} @var{jobvr} @var{n} @var{a-mat} @var{lda} @var{wr} @var{wi} @var{vl} @var{ldvl} @var{vr} @var{ldvr} @var{work} @var{lwork}
Compute for an @var{n}--by--@var{n} real nonsymmetric matrix @math{A},
the eigenvalues and, optionally, the left and/or right eigenvectors.

The right eigenvector @math{v(j)} of @math{A} satisfies:

@example
A * v(j) = lambda(j) * v(j)
@end example

@noindent
where @math{lambda(j)} is its eigenvalue.  The left eigenvector
@math{u(j)} of @math{A} satisfies:

@example
u(j)^H * A = lambda(j) * u(j)^H
@end example

@noindent
where @math{u(j)^H} denotes the conjugate transpose of @math{u(j)}.

The computed eigenvectors are normalized to have Euclidean norm equal to
@math{1} and largest component real.

@var{jobvl} must be a Scheme character.  @samp{#\N} means that left
eigenvectors of @math{A} are not computed; @samp{#\V} means that left
eigenvectors of @math{A} are computed.

@var{jobvr} must be a Scheme character.  @samp{#\N} means that right
eigenvectors of @math{A} are not computed; @samp{#\V} means that right
eigenvectors of @math{A} are computed.

@var{n} must be a non--negative exact integer: the order of the matrix
@math{A}.

@var{a-mat} must be a pointer object referencing an array of
@code{double} real numbers with dimension @var{lda}:@var{n}.  On entry,
the array must hold the @var{n}--by--@var{n} matrix @math{A}.  On exit,
the array has been overwritten.

@var{lda} must be an exact integer: the leading dimension of the array
@var{a-mat}.  @math{@var{lda} >= max(1, @var{n})}.

@var{wr} and @var{wi} must be pointer objects to arrays of @code{double}
real numbers with dimension @var{n}.  On exit, the arrays contain the
real and imaginary parts, respectively, of the computed eigenvalues.
Complex conjugate pairs of eigenvalues appear consecutively with the
eigenvalue having the positive imaginary part first.

@var{vl} must be a pointer object referencing an array of @code{double}
real numbers with dimension @var{ldvl}:@var{n}.  On exit:

@itemize
@item
If @var{jobvl} is @samp{#\V}, the left eigenvectors @math{u(j)} are
stored one after another in the columns of @var{vl}, in the same order
as their eigenvalues.

@item
If @var{jobvl} is @samp{#\N}, @var{vl} is not referenced.

@item
If the @math{j}-th eigenvalue is real, then @math{u(j) = @var{vl}(:,j)},
the @math{j}-th column of @math{vl}.

@item
If the @math{j}-th and @math{(j+1)}-st eigenvalues form a complex
conjugate pair, then:

@example
u(j) = @var{vl}(:,j) + i * @var{vl}(:,j+1)
@end example

@noindent
and:

@example
u(j+1) = @var{vl}(:,j) - i * @var{vl}(:,j+1)
@end example
@end itemize

@var{ldvl} must be an exact integer: the leading dimension of the array
@var{vl}.  @math{@var{ldvl} >= 1}; if @var{jobvl} is @samp{#\V},
@math{@var{ldvl} >= @var{n}}.

@var{vr} must be a pointer to an array of @code{double} real values with
dimension @var{ldvr}:@var{n}.  On exit:

@itemize
@item
If @var{jobvr} is @samp{#\V}, the right eigenvectors @math{v(j)} are
stored one after another in the columns of @var{vr}, in the same order
as their eigenvalues.

@item
If @var{jobvr} is @samp{#\N}, @var{vr} is not referenced.

@item
If the @math{j}-th eigenvalue is real, then @math{v(j) = @var{vr}(:,j)},
the @math{j}-th column of @var{vr}.

@item
If the @math{j}-th and @math{(j+1)}-st eigenvalues form a complex
conjugate pair, then:

@example
v(j) = @var{vr}(:,j) + i * @var{vr}(:,j+1)
@end example

@noindent
and:

@example
v(j+1) = @var{vr}(:,j) - i * @var{vr}(:,j+1)
@end example
@end itemize

@var{ldvr} must be an exact integer: the leading dimension of the array
@var{vr}.  @math{@var{ldvr} >= 1}; if @var{jobvr} is @samp{#\V},
@math{@var{ldvr} >= @var{n}}.

@var{work} must be a pointer object referencing an array of
@code{double} real numbers with dimension @var{lwork}; it is used as
workspace.  On exit, its first element is the optimal value for
@var{lwork}.

@var{lwork} must be an exact integer: the dimension of the array
@var{work}.  @math{@var{lwork} >= max(1, 3 * @var{n})}, and if
@var{jobvl} is @samp{#\V} or @var{jobvr} is @samp{#\V},
@math{@var{LWORK} >= 4 * @var{n}}.  For good performance, @var{lwork}
must generally be larger.

If @var{lwork} is @math{-1}, then a workspace query is assumed; the
routine only calculates the optimal size of the @var{work} array,
returns this value as the first entry of the @var{work} array, and no
error message related to @var{lwork} is issued by @func{xerbla}.
@end defun

@c page
@node perms
@chapter Permutations


The functions documented in this chapter apply permutations to matrices.
The bindings are exported by the @library{foreign math lapack
primitives} library and reexported by the @library{foreign math lapack}
library.


@defun dlaswp @var{n} @var{a-mat} @var{lda} @vari{k} @varii{k} @var{ipiv} @var{incx}
@defunx zlaswp @var{n} @var{a-mat} @var{lda} @vari{k} @varii{k} @var{ipiv} @var{incx}
Perform a series of row interchanges on the matrix referenced by the
pointer @var{a-mat}.  One row interchange is initiated for each of rows
@vari{k} through @varii{K} of @var{a-mat}.

@var{n} must be an exact integer representing the number of columns of
the matrix @var{a-mat}.

@var{a-mat} must be a pointer to an array of @code{double} real or
complex numbers with dimension @var{lda}:@var{n}.  On entry, the array
must hold the matrix of column dimension @var{n} to which the row
interchanges will be applied.  On exit, the array holds the permuted
matrix.

@var{lda} must be an exact integer representing the leading dimension of
the array @var{a-mat}.

@vari{k} and @varii{k} must be exact integers representing the first and
last elements (inclusive) of @var{ipiv} for which a row interchange will
be done.

@var{ipiv} must be a pointer to an array of @code{integer} numbers, with
dimension @math{@var{n} * abs(@var{incx})}; it must hold the vector of
pivot indices.  Only the elements in positions @vari{k} through
@varii{K} of @var{ipiv} are accessed.  @math{@var{ipiv}(K) = L} implies
rows @math{K} and @math{L} are to be interchanged.

@var{incx} must be an exact integer representing the stride between
successive values of @var{ipiv}.  If @var{ipiv} is negative, the pivots
are applied in reverse order.
@end defun

@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node ipiv
@appendix On the meaning of the pivot indices and the permutation matrix

@cindex @var{ipiv}
@cindex Pivot indices
@cindex Permutation matrix
@cindex Indices, pivot

In this appendix we try to understand the meaning of the @var{ipiv}
vector we get, for example, out of @func{dgetrf}.  The ``pivot indices''
stored in the vector represent the sequence of row--permutations to be
applied to a matrix.

Let's say we have factored a matrix @math{A}, with @math{6} rows and
@math{4} columns, using the @math{LU} decomposition; we have @math{A =
PLU}, where @math{P} is the permutation matrix.  Let's say the
permutations are represented by the following array of pivot indices:

@example
(5 6 3 4)               ;; Fortran convention
@end example

@noindent
we have to understand that rows and columns are indexed starting from
@math{1}, following the Fortran convention: the pivot index @math{5} is
associated to row @math{1}, the pivot index @math{6} is associated to
row @math{2}, the pivot index @math{3} is associated to row @math{3},
@dots{}

The meaning of the array is that the following sequence of operations
must be applied to the matrix:

@enumerate
@item
Swap row @math{1} with row @math{5}.

@item
Swap row @math{2} with row @math{6}.

@item
Swap row @math{3} with row @math{3}, that is: leave it untouched.

@item
Swap row @math{4} with row @math{4}, that is: leave it untouched.
@end enumerate

Let's say instead that the matrix @math{A} is square with dimension
@math{4} and we got the following array of pivot indices:

@example
(3 2 3 4)               ;; Fortran convention
@end example

@noindent
notice that @math{3} appears twice; its meaning is that the following
sequence of operations must be applied to the matrix:

@enumerate
@item
Swap row @math{1} with row @math{3}.

@item
Swap row @math{2} with row @math{2}, that is: leave it untouched.

@item
Swap row @math{3} with row @math{3}, that is: leave it untouched; we
have already swapped the third row with the first, so we need to do
nothing now.

@item
Swap row @math{4} with row @math{4}, that is: leave it untouched.
@end enumerate

Now given the pivots for the @math{6}--by--@math{4} matrix:

@example
(5 6 3 4)               ;; Fortran convention
@end example

@noindent
to obtain the permutation matrix @math{P} which left--multiplies
@math{LU} using the zero--based C language indexing:

@enumerate
@item
Subtract @math{1} from all the indices in @var{ipiv}:

@example
(4 5 2 3)               ;; C convention
@end example

@item
Reallocate @var{ipiv} so that it has a number of elements equal to the
number of rows in the original @math{A} matrix:

@example
(4 5 2 3 x x)           ;; C convention
@end example

@item
Initialise the added positions with the position index itself:

@example
(4 5 2 3 4 5)           ;; C convention
@end example

@item
Scan the whole @var{ipiv} using @math{i} as counter, if @math{i =
ipiv(i)} enter the following subloop:

@enumerate a
@item
Scan @var{ipiv} using the counter @math{j = 0, ..., i-1}.

@item
If @math{i = ipiv(j)} set @math{ipiv(i) <- j}.
@end enumerate

@noindent
we understand that the array is mutated to:

@example
(4 5 2 3 0 1)           ;; C convention
@end example

@item
Build a zero--filled matrix @math{6}-by-@math{6} (the dimension must be
equal to the number of rows of the original matrix @math{A}), and poke
@math{1} to the positions:

@example
(0, 4)  (1, 5)  (2, 2)   ;; C convention
(3, 3)  (4, 0)  (5, 1)
@end example

@noindent
obtaining:

@example
    0 1 2 3 4 5
   ------------
0 | 0 0 0 0 1 0
1 | 0 0 0 0 0 1
2 | 0 0 1 0 0 0
3 | 0 0 0 1 0 0
4 | 1 0 0 0 0 0
5 | 0 1 0 0 0 0
@end example
@end enumerate

Following the same procedure for the @math{4}--by--@math{4} matrix
having pivots array:

@example
(3 2 3 4)               ;; Fortran convention
@end example

@noindent
decrementing by @math{1}:

@example
(2 1 2 3)               ;; C convention
@end example

@noindent
mutating it:

@example
(2 1 0 3)               ;; C convention
@end example

@noindent
we get the following permutation matrix:

@example
    0 1 2 3
   --------
0 | 0 0 1 0
1 | 0 1 0 0
2 | 1 0 0 0
3 | 0 0 0 1
@end example

The following is a C program printing the permutation matrix from a
given @var{ipiv}:

@example
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void print_perm (const int * ipiv,
                        size_t number_of_indices,
                        int number_of_rows);

int
main (void)
@{
  @{
    static const int ipiv[4] = @{ 5, 6, 3, 4 @};
    print_perm(ipiv, 4, 6);
  @}
  @{
    static const int ipiv[4] = @{ 3, 2, 3, 4 @};
    print_perm(ipiv, 4, 4);
  @}
  exit(EXIT_SUCCESS);
@}

void
print_perm (const int * ipiv,
            size_t number_of_indices, int number_of_rows)
@{
  int           full_ipiv[number_of_rows];
  int           P[number_of_rows][number_of_rows];
  size_t        i, j;

  for (i=0; i<number_of_indices; ++i)
    @{
      full_ipiv[i] = ipiv[i] - 1;
      if (full_ipiv[i] == i) @{
        for (j=0; j<i; ++j)
          if (i == full_ipiv[j])
            @{
              full_ipiv[i] = j;
              break;
            @}
      @}
    @}

  for (; i<number_of_rows; ++i)
    @{
      full_ipiv[i] = i;
      for (j=0; j<number_of_indices; ++j)
        if (i == full_ipiv[j])
          @{
            full_ipiv[i] = j;
            break;
          @}
    @}

  memset(&P, '\0', number_of_rows * number_of_rows * sizeof(int));

  for (i=0; i<number_of_rows; ++i)
    P[i][full_ipiv[i]] = 1;

  printf("\nFull ipiv: ");
  for (i=0; i<number_of_rows; ++i)
    printf("%d ", full_ipiv[i]);
  printf("\n\n");

  printf("Permutation matrix:\n");
  for (i=0; i<number_of_rows; ++i)
    @{
      for (j=0; j<number_of_rows; ++j)
        printf("%d ", P[i][j]);
      printf("\n");
    @}
@}
@end example

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
