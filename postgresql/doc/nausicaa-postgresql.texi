\input texinfo.tex
@c %**start of header
@setfilename nausicaa-postgresql.info
@settitle PostgreSQL for Nausicaa
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@macro objtype{NAME}
@code{\NAME\}
@end macro

@macro enum{NAME}
@code{enum-\NAME\}
@end macro

@macro condition{NAME}
@code{&\NAME\}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro sql{}
@acronym{SQL}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@macro axml{}
@acronym{XML}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@macro pg{}
PostgreSQL
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro ssh{}
@acronym{SSH}
@end macro

@macro ssl{}
@acronym{SSL}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro tls{}
@acronym{TLS}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @pg{} for Nausicaa

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@pg{}

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-postgresql

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2010

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a
distribution of libraries for @rnrs{6} Scheme implementations; it
provides a binding to the Libpq C language library, a client @api{} for
@pg{} databases.  It is built upon Nausicaa/Scheme, making use of its
foreign--functions interface.

The libraries support Ikarus, Mosh and Ypsilon Scheme; the package
supports @gnu{}+Linux systems.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/nausicaa/downloads}

@noindent
the project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/tree/master}

@noindent
@pg{} is available at:

@center @url{http://www.postgresql.org/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-postgresql: (nausicaa-postgresql).   @pg{} for Nausicaa.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* typedefs::                    Object type definitions.
* enumerations::                Enumeration type definitions.
* conditions::                  Condition object definitions.
* connect::                     Connecting to a database.
* inspect::                     Inspection.
* exec::                        Performing a database query.
* query::                       Handling query results.
* escapes::                     Escaping strings.
* misc::                        Miscellaneous functions.
* primitives::                  Miscellaneous primitive bindings.
* compensations::               Compensated constructors.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Object type definitions

* typedefs connection::         Database connection object.
* typedefs cancel::             Command cancellation handler.
* typedefs result::             Query result object.
* typedefs option::             Connection option object.
* typedefs parameter::          Parameters for prepared queries.
* typedefs notification::       Asynchronous notification object.
* typedefs fd::                 File descriptor object.
* typedefs file::               Stream descriptor object.
* typedefs pid::                Process identifier object.
* typedefs ssl::                Reference to OpenSSL structure.

Enumeration type definitions

* enumerations connect::        Connection status.
* enumerations polling::        Polling status.
* enumerations trans::          Transaction status.
* enumerations exec::           Query execution status.
* enumerations errfield::       Error fields.
* enumerations format::         Format codes.
* enumerations verbosity::      Error verbosity.

Condition object definitions

* conditions data::             Data condition objects.
* conditions error::            Error condition objects.

Data condition objects

* conditions data connect::     Database connection object.
* conditions data cancel::      Command cancellation handler.
* conditions data query::       @sql{} query string object.
* conditions data parameters::  @sql{} query parameters.
* conditions data statement::   Prepared statement name object.
* conditions data portal::      Portal name object.
* conditions data result::      @sql{} query result object.

Error condition objects

* conditions error error::      Error condition object.
* conditions error cancel::     @sql{} command cancel error.
* conditions error copy::       @code{COPY} command errors.

Connecting to a database

* connect sync::                Connecting synchronously.
* connect async::               Connecting asynchronously.
* connect misc::                Other connect--related functions.

Performing a database query

* exec sync commands::          Synchronous commands execution.
* exec sync prepared::          Synchronous prepared statements
                                execution.
* exec async commands::         Asynchronous commands execution.
* exec async prepared::         Asynchronous prepared statements
                                execution.
* exec async result::           Acquiring the result of
                                asynchronous operations.
* exec async writes::           Handling asynchronous write
                                operations.
* exec async example::          Example program.
* exec cancel::                 Cancelling queries in progress.
* exec notify::                 Asynchronous notifications.
* exec copy::                   Executing @code{COPY} commands.

Handling query results

* query inspect::               Inspecting query results.
* query result::                Retrieving query results.
* query misc::                  Miscellaneous functions.

@end detailmenu
@end menu

@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @version{} of @value{PACKAGE}, a
distribution of libraries for @rnrs{6} Scheme implementations; it
provides a binding to the Libpq C language library, a client @api{} for
@pg{} databases.  It is built upon Nausicaa/Scheme, making use of its
foreign--functions interface.

The libraries support Ikarus, Mosh and Ypsilon Scheme; the package
supports @gnu{}+Linux systems.

The installed libraries are:

@table @library
@item foreign databases postgresql shared-object
Exports the single binding @code{postgresql-shared-object} which
references the foreign shared library.

@item foreign databases postgresql sizeof
Exports bindings to constant values and data structures accessors.

@item foreign databases postgresql typedefs
Exports bindings for record type definitions.

@item foreign databases postgresql conditions
Exports bindings for condition object type definitions.

@item foreign databases postgresql enumerations
Exports bindings for enumeration type definitions.

@item foreign databases postgresql platform
Exports one binding for each foreign function; the bindings to the
Scheme function callouts have the same name of the C functions, so
@cfunc{PQconnectStart} is available as @func{PQconnectStart}.  This
library makes the original @pg{} documentation relevant for this
package.

@item foreign databases postgresql primitives
Exports one binding for each foreign function, implementing, for some
functions, marshaling of arguments and return values.  The bindings to
the Scheme functions have heavily modified names, for example
@cfunc{PQconnectStart} is available as @func{connect-start}; the
@samp{PQ} and @samp{pg} prefixes are always stripped, so it is suggested
to import this library with the @samp{pg:} prefix.

This document describes the @code{primitives} @api{} giving a brief
description for each function, we have to refer to the original
documentation for the true description; only the functions implementing
marshaling of values are documented: if a function is not documented, it
means that it is reexported ``as is'' from the @code{platform} library.
@ref{primitives} for the list of undocumented functions and the name
change.

@item foreign databases postgresql
Compound library exporting the high--level @api{}; it reexports bindings
from the @samp{primitives}, @samp{typedefs}, @samp{enumeration} and
@samp{conditions} libraries and the constant values from the
@samp{sizeof} library.

@item foreign databases postgresql compensated
Exports bindings to constructor functions making use of the
@library{compensations} library from Nausicaa/Scheme.
@nauref{compensations, Compensation stacks}.
@end table

@c page
@node typedefs
@chapter Object type definitions


The bindings documented in this chapter are exported by the
@library{foreign databases postgresql typedefs} library and reexported
by the @library{foreign databases postgresql} library.  It is suggested
to import these libraries by prefixing the bindings, for example with
@code{pg:}.

@menu
* typedefs connection::         Database connection object.
* typedefs cancel::             Command cancellation handler.
* typedefs result::             Query result object.
* typedefs option::             Connection option object.
* typedefs parameter::          Parameters for prepared queries.
* typedefs notification::       Asynchronous notification object.
* typedefs fd::                 File descriptor object.
* typedefs file::               Stream descriptor object.
* typedefs pid::                Process identifier object.
* typedefs ssl::                Reference to OpenSSL structure.
@end menu

@c page
@node typedefs connection
@section Database connection object


@deftp {Record Type Name} connection
Record type used to tag pointer objects referencing database
connections, structures of type @code{PGconn}.  @nauref{ffi pointers,
Pointer objects}.
@end deftp


@defun connection? @var{obj}
Return @true{} if @var{obj} is a record of type @objtype{connection}.
@end defun


@defun pointer->connection @var{pointer}
@defunx connection->pointer @var{conn}
Convert to and from a pointer object and a record of type
@objtype{connection}.
@end defun

@c page
@node typedefs cancel
@section Command cancellation handler


@deftp {Record Type Name} cancel-handler
Record type used to tag pointer objects referencing database
cancel-handlers, structures of type @code{PGcancel}.  @nauref{ffi
pointers, Pointer objects}.
@end deftp


@defun cancel-handler? @var{obj}
Return @true{} if @var{obj} is a record of type
@objtype{cancel-handler}.
@end defun


@defun pointer->cancel-handler @var{pointer}
@defunx cancel-handler->pointer @var{conn}
Convert to and from a pointer object and a record of type
@objtype{cancel-handler}.
@end defun

@c page
@node typedefs result
@section Query result object


@deftp {Record Type Name} query-result
Record type used to tag pointer objects referencing query results,
structures of type @code{PGresult}.  @nauref{ffi pointers, Pointer
objects}.
@end deftp


@defun query-result? @var{obj}
Return @true{} if @var{obj} is a record of type @objtype{query-result}.
@end defun


@defun pointer->query-result @var{pointer}
@defunx query-result->pointer @var{conn}
Convert to and from a pointer object and a record of type
@objtype{query-result}.
@end defun

@c page
@node typedefs option
@section Connection option object


@deftp {Record Type Name} <connect-option>
@deftpx {Record Type Descriptor} <connect-option-rtd>
Record type used to mirror structures of type @code{PQconninfoOption}.
It has the following immutable fields:

@table @code
@item keyword
The keyword of the option.  A Scheme string.

@item envvar
Fallback environment variable name.  A Scheme string.

@item compiled
Fallback compiled--in default value.  A Scheme string or @false{} if the
value is not set.

@item val
Option's current value.  A Scheme string or @false{} if the value is not
set.

@item label
Label for field in connect dialog.  A Scheme string.

@item dispchar
Indicates how to display this field in a connect dialog.  A Scheme
string.

@item dispsize
Field size in characters for dialog.  An exact intger.
@end table
@end deftp


@defun make-<connect-option>
@defunx <connect-option>? @var{obj}
Constructor and predicate for records of type @class{connect-option}.
@end defun


@defun <connect-option>-keyword @var{option}
@defunx <connect-option>-envvar @var{option}
@defunx <connect-option>-compiled @var{option}
@defunx <connect-option>-val @var{option}
@defunx <connect-option>-label @var{option}
@defunx <connect-option>-dispchar @var{option}
@defunx <connect-option>-dispsize @var{option}
Accessors for the fields of records of type @class{connect-option}.
@end defun


@defun pointer-><connect-option> @var{pointer}
Given a pointer object to a structure of type @code{PQconninfoOption}
build and return a record of type @class{connect-option} initialised
with values from the structure.
@end defun

@c page
@node typedefs parameter
@section Parameters for prepared queries


@deftp {Record Type Name} <parameter>
@deftpx {Record Type Descriptor} <parameter-rtd>
Record type used as descriptor for prepared @sql{} statements'
parameters.  It has the following immutable fields:

@table @code
@item value
The parameter's value; can be a Scheme string or byte vector, or a
pointer object.  @nauref{ffi pointers, Pointer objects}.

@item size
The number of bytes in the raw memory block referenced by the value;
used only in case the value is a pointer object.

@item text?
Set to @true{} if the value is to be interpresed as textual data; else
it is to be interpreted as binary data.

@item oid
An exact integer representing the type @acronym{OID} of the value.
@end table
@end deftp


@defun make-<parameter> @var{value} @var{size} @var{text?} @var{oid}
@defunx <parameter>? @var{obj}
Constructor and predicate for records of type @class{parameter}.
@end defun


@defun <parameter>-value @var{obj}
@defunx <parameter>-size @var{obj}
@defunx <parameter>-text? @var{obj}
@defunx <parameter>-oid @var{obj}
Accessors for the fields of records of type @class{parameter}.
@end defun


@deffn Syntax parameter (value @ameta{val}) (size @ameta{len}) (text? @ameta{text}) (oid @ameta{oid})
@deffnx Syntax parameter (value @ameta{val}) (size @ameta{len}) (text? @ameta{text})
@deffnx Syntax parameter (value @ameta{val}) (text? @ameta{text}) (oid @ameta{oid})
@deffnx Syntax parameter (value @ameta{val}) (text? @ameta{text})
@deffnx Syntax parameter (value @ameta{val}) (oid @ameta{oid})
@deffnx Syntax parameter (value @ameta{val})
@deffnx Syntax parameter @ameta{val}
@deffnx {Auxiliary Syntax} value
@deffnx {Auxiliary Syntax} size
@deffnx {Auxiliary Syntax} text?
@deffnx {Auxiliary Syntax} oid
Wrapper for @func{make-<parameter>} which allows the specification of a
@class{parameter} as a human readable S--expression.

@ameta{val} is stored in the @code{value} field; @ameta{len} is stored
in the @code{size} field and defaults to @false{}; @ameta{text} is
stored in the @code{text?} field and defaults to @true{}; @ameta{oid} is
stored in the @code{oid} field and defaults to @code{InvalidOid}.
@end deffn

@c page
@node typedefs notification
@section Asynchronous notification object


@deftp {Record Type Name} <notification>
@deftpx {Record Type Descriptor} <notification-rtd>
Record type used to mirror C language structures of type
@code{PGnotify}.  It has the following fields:

@table @code
@item relname
Scheme string representing the notification condition name.

@item pid
Scheme object of type @objtype{pid} representing the process
@acronym{ID} of notifying server process.

@item extra
Scheme string representing an extra notification parameter.
@end table
@end deftp


@defun make-<notification> @var{relname} @var{pid} @var{extra}
@defunx <notification>? @var{obj}
Constructor and predicate for records of type @class{notification}.
@end defun


@defun <notification>-relname @var{notify}
@defunx <notification>-pid @var{notify}
@defunx <notification>-extra @var{notify}
Accessors for records of type @class{notification}.
@end defun

@c page
@node typedefs fd
@section File descriptor object


@deftp {Record Type Name} fd
Record type used to tag exact integers representing file descriptors.
This type is compatible with the same defined by the Nausicaa/@posix{}
package.
@end deftp


@defun fd? @var{obj}
Return @true{} if @var{obj} is an object of type @objtype{fd}.
@end defun


@defun integer->fd @var{integer}
@defunx fd->integer @var{fd}
Convert to and from objects of type @objtype{fd} and the associated exact
integers.
@end defun

@c page
@node typedefs file
@section Stream descriptor object


@deftp {Record Type Name} FILE*
Record type used to tag pointer objects of type @code{FILE *}.  This
type is compatible with the same defined by the Nausicaa/@posix{}
package.
@end deftp


@defun FILE*? @var{obj}
Return @true{} if @var{obj} is an object of type @objtype{FILE*}.
@end defun


@defun pointer->FILE* @var{integer}
@defunx FILE*->pointer @var{fd}
Convert to and from objects of type @objtype{FILE*} and the associated
pointer objects.
@end defun

@c page
@node typedefs pid
@section Process identifier object


@deftp {Record Type Name} pid
Record type used to tag exact integers representing process identifiers.
This type is compatible with the same defined by the Nausicaa/@posix{}
package.
@end deftp


@defun pid? @var{obj}
Return @true{} if @var{obj} is an object of type @code{pid}.
@end defun


@defun integer->pid @var{integer}
@defunx pid->integer @var{fd}
Convert to and from objects of type @code{pid} and the associated exact
integers.
@end defun

@c page
@node typedefs ssl
@section Process identifier object


@deftp {Record Type Name} ssl
Record type used to tag pointers referencing OpenSSL structures of type
@code{SSL}.

@quotation
@strong{NOTE} Whenever an interface to OpenSSL is added to Nausicaa,
this type will be made compatible with the same defined in that package
(Wed Feb 17, 2010).
@end quotation
@end deftp


@defun ssl? @var{obj}
Return @true{} if @var{obj} is an object of type @code{ssl}.
@end defun


@defun pointer->ssl @var{pointer}
@defunx ssl->pointer @var{ssl}
Convert to and from objects of type @code{ssl} and the associated
pointers.
@end defun

@c page
@node enumerations
@chapter Enumeration type definitions


The bindings documented in this chapter are exported by the
@library{foreign databases postgresql enumerations} library and
reexported by the @library{foreign databases postgresql} library.  It is
suggested to import these libraries by prefixing the bindings, for
example with @code{pg:}.

@menu
* enumerations connect::        Connection status.
* enumerations polling::        Polling status.
* enumerations trans::          Transaction status.
* enumerations exec::           Query execution status.
* enumerations errfield::       Error fields.
* enumerations format::         Format codes.
* enumerations verbosity::      Error verbosity.
@end menu

@c page
@node enumerations connect
@section Connection status


@deftp {Enumeration Type} enum-connection-status
Enumeration type representing the current status of a @objtype{connection}
object.  It holds the following symbols:

@example
ok                 bad
started            made
awaiting-response  auth-ok
setenv             ssl-startup
needed
@end example
@end deftp


@deffn Syntax connection-status @ameta{symbol}
Expand to an enumeration set of type @enum{connection-status}
holding the argument symbol.
@end deffn


@defun value->connection-status @var{integer}
@defunx connection-status->value @var{enum-set}
Convert to and from exact integers and enumeration sets of type
@enum{connection-status}.
@end defun

@c page
@node enumerations polling
@section Polling status


@deftp {Enumeration Type} enum-polling-status
Enumeration type representing the result of polling operations performed
with @func{connect-poll}.  It holds the following symbols:

@example
ok       failed
reading  writing  active
@end example
@end deftp


@deffn Syntax polling-status @ameta{symbol}
Expand to an enumeration set of type @enum{polling-status} holding
the argument symbol.
@end deffn


@defun value->polling-status @var{integer}
@defunx polling-status->value @var{enum-set}
Convert to and from exact integers and enumeration sets of type
@enum{polling-status}.
@end defun


@defun polling-status->symbol @var{enum-set}
Given the result of an expansion of the syntax @func{polling-status},
return the symbol in it.
@end defun

@c page
@node enumerations trans
@section Transaction status


@deftp {Enumeration Type} enum-transaction-status
Enumeration type representing the transaction status of a connection.
It holds the following symbols:

@example
idle     active
intrans  inerror
unknown
@end example
@end deftp


@deffn Syntax transaction-status @ameta{symbol}
Expand to an enumeration set of type @enum{transaction-status} holding
the argument symbol.
@end deffn


@defun value->transaction-status @var{integer}
@defunx transaction-status->value @var{enum-set}
Convert to and from exact integers and enumeration sets of type
@enum{transaction-status}.
@end defun

@c page
@node enumerations exec
@section Query execution status


@deftp {Enumeration Type} enum-exec-status
Enumeration type representing the result of queries execution.  It holds
the following symbols:

@example
empty-query     command-ok
tuples-ok       copy-out
copy-in         bad-response
nonfatal-error  fatal-error
@end example
@end deftp


@deffn Syntax exec-status @ameta{symbol}
Expand to an enumeration set of type @enum{exec-status} holding
the argument symbol.
@end deffn


@defun value->exec-status @var{integer}
@defunx exec-status->value @var{enum-set}
Convert to and from exact integers and enumeration sets of type
@enum{exec-status}.
@end defun

@c page
@node enumerations errfield
@section Error fields


@deftp {Enumeration Type} enum-error-field
Enumeration type used to select an error field in a
@objtype{query-result} structure; it is used by
@func{result-error-field}.  It holds the following symbols:

@example
severity           sqlstate
message-primary    message-detail
message-hint       statement-position
internal-position  internal-query
context            source-file
source-line        source-function
@end example
@end deftp


@deffn Syntax error-field @ameta{symbol}
Expand to an enumeration set of type @enum{error-field} holding
the argument symbol.
@end deffn


@defun value->error-field @var{integer}
@defunx error-field->value @var{enum-set}
Convert to and from exact integers and enumeration sets of type
@enum{error-field}.
@end defun

@c page
@node enumerations format
@section Format codes


@deftp {Enumeration Type} enum-format-code
Enumeration type representing the format of a column in a table.  It
holds the following symbols:

@example
text  binary
@end example
@end deftp


@deffn Syntax format-code @ameta{symbol}
Expand to an enumeration set of type @enum{format-code} holding
the argument symbol.
@end deffn


@defun value->format-code @var{integer}
@defunx format-code->value @var{enum-set}
Convert to and from exact integers and enumeration sets of type
@enum{format-code}.
@end defun

@c page
@node enumerations verbosity
@section Error verbosity


@deftp {Enumeration Type} enum-error-verbosity
Enumeration type representing the error verbosity level; it is used by
@func{connection-error-verbosity-set!}.  It holds the following symbols:

@example
terse  default  verbose
@end example
@end deftp


@deffn Syntax error-verbosity @ameta{symbol}
Expand to an enumeration set of type @enum{error-verbosity} holding
the argument symbol.
@end deffn


@defun value->error-verbosity @var{integer}
@defunx error-verbosity->value @var{enum-set}
Convert to and from exact integers and enumeration sets of type
@enum{error-verbosity}.
@end defun

@c page
@node conditions
@chapter Condition object definitions


The bindings documented in this chapter are exported by the
@library{foreign databases postgresql conditions} library and reexported
by the @library{foreign databases postgresql} library.  It is suggested
to import these libraries by prefixing the bindings, for example with
@code{pg:}.

@menu
* conditions data::             Data condition objects.
* conditions error::            Error condition objects.
@end menu

@c page
@node conditions data
@section Data condition objects


@menu
* conditions data connect::     Database connection object.
* conditions data into::        Connection info object.
* conditions data cancel::      Command cancellation handler.
* conditions data query::       @sql{} query string object.
* conditions data parameters::  @sql{} query parameters.
* conditions data statement::   Prepared statement name object.
* conditions data portal::      Portal name object.
* conditions data result::      @sql{} query result object.
@end menu

@c page
@node conditions data connect
@subsection Database connection object


@deftp {Condition Type} &connection
Condition object type used to hold objects of type @objtype{connection}
which were involved in an exception; it is derived from
@condition{condition}.  It has the following fields:

@table @code
@item connection
The @objtype{connection} object.
@end table
@end deftp


@defun make-connection-condition @var{conn}
@defunx connection-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{connection}.
@end defun


@defun connection-condition @var{condition}
Accessor for the field of condition objects of type
@condition{connection}.
@end defun

@c page
@node conditions data into
@subsection Connection info object


@deftp {Condition Type} &connect-info
Condition object type used to hold the Scheme string representing
connection informations handed to @func{connect-db}; it is derived from
@condition{condition}.  It has the following fields:

@table @code
@item connect-info
Scheme string.
@end table
@end deftp


@defun make-connect-info-condition @var{info-string}
@defunx connect-info-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{connect-info}.
@end defun


@defun connect-info-condition @var{condition}
Accessor for the field of condition objects of type
@condition{connect-info}.
@end defun

@c page
@node conditions data cancel
@subsection Command cancellation handler


@deftp {Condition Type} &cancel-handler
Condition object type used to hold objects of type
@objtype{cancel-handler} which were involved in an exception; it is
derived from @condition{condition}.  It has the following fields:

@table @code
@item cancel-handler
The @objtype{cancel-handler} object.
@end table
@end deftp


@defun make-cancel-handler-condition @var{cancel}
@defunx cancel-handler-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{cancel-handler}.
@end defun


@defun cancel-handler-condition @var{condition}
Accessor for the field of condition objects of type
@condition{cancel-handler}.
@end defun

@c page
@node conditions data query
@subsection @sql{} query string object


@deftp {Condition Type} &query-string
Condition object type used to hold @sql{} queries as Scheme strings; it
is derived from @condition{condition}.  It has the following fields:

@table @code
@item string
Scheme string representing the @sql{} query.
@end table
@end deftp


@defun make-query-string-condition @var{query-string}
@defunx query-string-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{query-string}.
@end defun


@defun query-string-condition @var{condition}
Accessor for the field of condition objects of type
@condition{query-string}.
@end defun

@c page
@node conditions data parameters
@subsection @sql{} query parameters


@deftp {Condition Type} &parameters
Condition object type used to hold a list of @class{parameter} objects
involved in a prepared @sql{} statement; it is derived from
@condition{condition}.  It has the following fields:

@table @code
@item parameters
A list of @class{parameter} records.
@end table
@end deftp


@defun make-parameters-condition @var{parameters}
@defunx parameters-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{parameters}.
@end defun


@defun parameters-condition @var{condition}
Accessor for the field of condition objects of type
@condition{parameters}.
@end defun

@c page
@node conditions data statement
@subsection Prepared statement name object


@deftp {Condition Type} &statement-name
Condition object type used to hold a the name of a prepared statement;
it is derived from @condition{condition}.  It has the following fields:

@table @code
@item statement-name
A Scheme string or symbol representing the name; if set to @false{} the
statement is unnamed.
@end table
@end deftp


@defun make-statement-name-condition @var{stmt-name}
@defunx statement-name-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{statement-name}.
@end defun


@defun statement-name-condition @var{condition}
Accessor for the field of condition objects of type
@condition{statement-name}.
@end defun

@c page
@node conditions data portal
@subsection Portal name object


@deftp {Condition Type} &portal-name
Condition object type used to hold a the name of a portal; it is derived
from @condition{condition}.  It has the following fields:

@table @code
@item portal-name
A Scheme string or symbol representing the name; if set to @false{} the
portal is unnamed.
@end table
@end deftp


@defun make-portal-name-condition @var{portal-name}
@defunx portal-name-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{portal-name}.
@end defun


@defun portal-name-condition @var{condition}
Accessor for the field of condition objects of type
@condition{portal-name}.
@end defun

@c page
@node conditions data result
@subsection @sql{} query result object


@deftp {Condition Type} &query-result
Condition object type used to hold @objtype{query-result} objects; it is
derived from @condition{condition}.  It has the following fields:

@table @code
@item result
Scheme object of type @objtype{query-result}.
@end table
@end deftp


@defun make-query-result-condition @var{query-result}
@defunx query-result-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{query-result}.
@end defun


@defun query-result-condition @var{condition}
Accessor for the field of condition objects of type
@condition{query-result}.
@end defun

@c page
@node conditions error
@section Error condition objects


@menu
* conditions error error::      Error condition object.
* conditions error info::       Connection info error.
* conditions error poll::       Connection polling error.
* conditions error cancel::     @sql{} command cancel error.
* conditions error copy::       @code{COPY} command errors.
@end menu

@c page
@node conditions error error
@subsection Error condition object


@deftp {Condition Type} &postgresql-error
Base condition type which tags compound condition objects associated to
@value{PACKAGE}; it is derived from @condition{error}.  It has no
fields.
@end deftp


@defun make-postgresql-error-condition
@defunx postgresql-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{postgresql-error}.
@end defun

@c page
@node conditions error info
@subsection Connection info error


@deftp {Condition Type} &postgresql-info-error
Condition type which tags compound condition objects used to signal an
invalid connection info string; it is derived from
@condition{postgresql-error}.  It has no fields.
@end deftp


@defun make-postgresql-info-error-condition
@defunx postgresql-info-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{postgresql-info-error}.
@end defun

@c page
@node conditions error poll
@subsection Connection polling error


@deftp {Condition Type} &postgresql-poll-error
Condition type which tags compound condition objects used to signal a
connection polling error; it is derived from
@condition{postgresql-error}.  It has no fields.
@end deftp


@defun make-postgresql-poll-error-condition
@defunx postgresql-poll-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{postgresql-poll-error}.
@end defun

@c page
@node conditions error cancel
@subsection @sql{} command cancel error


@deftp {Condition Type} &postgresql-cancel-error
Condition type which tags compound condition objects used to signal a
@sql{} command cancellation error; it is derived from
@condition{postgresql-error}.  It has no fields.

This condition type indicates that: there was an error in submitting the
request to cancel a @sql{} command; it is not related to the success or
failure in actually canceling the command.
@end deftp


@defun make-postgresql-cancel-error-condition
@defunx postgresql-cancel-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{postgresql-cancel-error}.
@end defun

@c page
@node conditions error copy
@subsection @code{COPY} command errors


@deftp {Condition Type} &postgresql-copy-error
Condition type which tags compound condition objects used to signal a
@code{COPY} command error; it is derived from
@condition{postgresql-error}.  It has no fields.
@end deftp


@defun make-postgresql-copy-error-condition
@defunx postgresql-copy-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{postgresql-copy-error}.
@end defun

@c ------------------------------------------------------------

@deftp {Condition Type} &postgresql-copy-in-error
Condition type which tags compound condition objects used to signal a
@code{COPY} input command error; it is derived from
@condition{postgresql-copy-error}.  It has no fields.
@end deftp


@defun make-postgresql-copy-in-error-condition
@defunx postgresql-copy-in-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{postgresql-copy-in-error}.
@end defun

@c ------------------------------------------------------------

@deftp {Condition Type} &postgresql-copy-out-error
Condition type which tags compound condition objects used to signal a
@code{COPY} output command error; it is derived from
@condition{postgresql-copy-error}.  It has no fields.
@end deftp


@defun make-postgresql-copy-out-error-condition
@defunx postgresql-copy-out-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{postgresql-copy-out-error}.
@end defun

@c ------------------------------------------------------------

@deftp {Condition Type} &postgresql-copy-end-error
Condition type which tags compound condition objects used to signal a
@code{COPY} end command error; it is derived from
@condition{postgresql-copy-error}.  It has no fields.
@end deftp


@defun make-postgresql-copy-end-error-condition
@defunx postgresql-copy-end-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{postgresql-copy-end-error}.
@end defun

@c page
@node connect
@chapter Connecting to a database


The bindings documented in this chapter are exported by the
@library{foreign databases postgresql primitives} library and reexported
by the @library{foreign databases postgresql} library.  It is suggested
to import these libraries by prefixing the bindings, for example with
@code{pg:}.

@menu
* connect sync::                Connecting synchronously.
* connect async::               Connecting asynchronously.
* connect misc::                Other connect--related functions.
@end menu

@c page
@node connect sync
@section Connecting synchronously


The following operations are executed synchronously: when a function
returns from a call, the operation is complete either successfully or
not.  In the following descriptions, the @var{conn} argument is always a
Scheme object of type @objtype{connection}.


@defun connect-db
@defunx connect-db @var{info-string}
@findex @func{PQconnectdb}
Wrapper for @func{PQconnectdb}.  Connect to a database according to the
parameters in the Scheme string @var{info-string}, or the default
parameters when the string is not given; it is the simpler method to
open a connection.

Return an object of type @objtype{connection} (which must be finalised
with @func{connect-finish}) or raise an @condition{out-of-memory}
exception if not enough memory was available to allocate it.

@example
(import (rnrs)
  (compensations)
  (prefix (foreign databases postgresql) pg:))

(with-compensations
  (letrec
      ((conn (compensate
                 (pg:connect-db "dbname=nausicaa-test")
               (with
                (pg:connect-finish conn)))))
    (if (enum-set=? (pg:connection-status ok)
                    (pg:status conn))
         ---)))
@end example
@end defun


@defun reset @var{conn}
@findex @func{PQreset}
Wrapper for @func{PQreset}.  Reset the database connection referenced by
@var{conn}: close the connection and try to open it again with the same
parameters.  Notice that this function does @strong{not} directly report
success or failure; however we can inspect the status of the connection
with @func{status}.  @ref{inspect, Inspection}.
@end defun

@c ------------------------------------------------------------

@subsubheading Deprecated functions

@defun set-db-login @var{pghost} @var{pgport} @var{pgoptions} @var{pgtty} @var{dbname} @var{login} @var{pwd}
@findex @func{PQsetdbLogin}
Wrapper for @func{PQsetdbLogin}.  Connect to a database according to the
given arguments, which must be Scheme strings (like in the
@var{info-string} argument to @func{connect-db}) or @false{} when the
default value is desired.

Return an object of type @objtype{connection} (which must be finalised
with @func{connect-finish}) or raise an @condition{out-of-memory}
exception if not enough memory was available to allocate it.
@end defun


@defun set-db @var{pghost} @var{pgport} @var{pgoptions} @var{pgtty} @var{dbname}
@findex @func{PQsetdb}
Call @func{set-db-login} with @var{login} and @var{pwd} set to @false{}.
@end defun

@c page
@node connect async
@section Connecting asynchronously


We can use the following functions to execute the connection operations
asynchronously; lengthy connection operations can be interleaved with
other tasks by means of an event loop.  In the following descriptions,
the @var{conn} argument is always a Scheme object of type
@objtype{connection}.


@defun connect-start
@defunx connect-start @var{info-string}
@findex @func{PQconnectStart}
Wrapper for @func{PQconnectStart}.  Begin connecting to a database
without blocking; the argument is the same as the one to
@func{connect-db}.

Return an object of type @objtype{connection} (which must be finalised
with @func{connect-finish}) or raise an @condition{out-of-memory}
exception if not enough memory was available to allocate it.
@end defun


@defun connect-poll @var{conn}
@findex @func{PQconnectPoll}
Wrapper for @func{PQconnectPoll}.  Query the connection object
@var{conn} for the next action to perform in a non--blocking connection
operation.  If successful: return an enumeration set of type
@enum{polling-status}.

If the polling status is @code{PGRES_POLLING_FAILED}: raise an exception
with compound condition object of types
@condition{postgresql-poll-error}, @condition{connection},
@condition{who}, @condition{message}.

The following example shows the mechanics of @func{connect-poll} usage:

@smallexample
(import (nausicaa)
  (compensations)
  (foreign memory)
  (records)
  (prefix (foreign databases postgresql) pg:)
  (prefix (posix sizeof) posix:)
  (prefix (posix fd) posix:)
  (for (prefix (posix typedefs) posix:) expand run)
  (for (prefix (posix extensions) posix:) expand))

(with-compensations
  (letrec ((conn (compensate
                     (pg:connect-start "dbname=nausicaa-test")
                   (with
                    (pg:connect-finish conn)))))
    (let ((fd       (pg:socket conn))
          (rd-fdset (posix:make-fdset malloc-block/c))
          (wr-fdset (posix:make-fdset malloc-block/c))
          (ex-fdset (posix:make-fdset malloc-block/c))
          (timeout  (posix:make-struct-timeval malloc-block/c)))

      (define (%poll set)
        (let loop ()
          (posix:FD_ZERO rd-fdset)
          (posix:FD_ZERO wr-fdset)
          (posix:FD_ZERO ex-fdset)
          (posix:FD_SET fd set)
          (posix:select posix:FD_SETSIZE
                        rd-fdset wr-fdset ex-fdset timeout)
          (unless (posix:FD_ISSET fd set)
            (loop))))

      (with-fields* (((sec usec) posix:struct-timeval* timeout))
        (set! timeout.sec  2)
        (set! timeout.usec 0))

      (let loop ((status (pg:polling-status writing)))
        (case (pg:polling-status->symbol status)

          ((ok)  #t)

          ((reading)
           (%poll rd-fdset)
           (loop (pg:connect-poll conn)))

          ((writing)
           (%poll wr-fdset)
           (loop (pg:connect-poll conn)))

          (else  #f))))

      ---))
@end smallexample
@end defun


@defun connect-poll* @var{conn}
Like @func{connect-poll} but do @strong{not} raise an exception if the
polling status is @code{PGRES_POLLING_FAILED}: just return an
enumeration set holding the symbol @code{failed}.
@end defun


@defun reset-start @var{conn}
@findex @func{PQresetStart}
Wrapper for @func{PQresetStart}.  Start an asynchronous reset of the
connection referenced by @var{conn}; return @true{} if the operation
succeeds and we can go on by calling @func{reset-poll}.
@end defun


@defun reset-poll @var{conn}
@findex @func{PQresetPoll}
Wrapper for @func{PQresetPoll}.  Query the connection object @var{conn}
for the next action to perform in a non--blocking reset operation;
return an enumeration set of type @enum{polling-status}.

If the polling status is @code{PGRES_POLLING_FAILED}: raise an exception
with compound condition object of types
@condition{postgresql-poll-error}, @condition{connection},
@condition{who}, @condition{message}.

Usage of this function is equal to the usage of @func{connect-poll}.
@end defun


@defun reset-poll* @var{conn}
Like @func{reset-poll} but do @strong{not} raise an exception if the
polling status is @code{PGRES_POLLING_FAILED}: just return an
enumeration set holding the symbol @code{failed}.
@end defun

@c page
@node connect misc
@section Other connect--related functions


@defun connect-finish @var{conn}
@findex @func{PQfinish}
Wrapper for @func{PQfinish}.  Finalise the database connection
referenced by @var{conn}.
@end defun


@defun connection-defaults
@findex @func{PQconndefaults}
Wrapper for @func{PQconndefaults}.  Return a list of records of type
@class{connect-option} representing the default connection options.

Raise an @condition{out-of-memory} exception if not enough memory is
available.
@end defun


@defun connection-info-parse @var{info-string}
@findex @func{PQconninfoParse}
Wrapper for @func{PQconninfoParse}.  Parse the Scheme string
@var{info-string} as a list of connection options; return a list of
records of type @class{connect-option}.

If the string is invalid, raise an exception with compound condition
object of types: @condition{postgresql-info-error},
@condition{connect-info}, @condition{who}, @condition{message}.  Raise
an @condition{out-of-memory} exception if not enough memory is
available.
@end defun

@c page
@node inspect
@chapter Inspection


The following bindings are exported by the @library{foreign databases
postgresql primitives} library and reexported by the @library{foreign
databases postgresql} library; it is suggested to import these libraries
by prefixing the bindings, for example with @code{pg:}.  In the
following descriptions, the @var{conn} argument is always a Scheme
object of type @objtype{connection}.


@defun status @var{conn}
Wrapper for @func{PQstatus}.  Return an enumeration set of type
@enum{connection-status} describing the current state of the
@objtype{connection} object @var{conn}.
@end defun


@defun status/ok? @var{conn}
@defunx status/bad? @var{conn}
@defunx status/started? @var{conn}
@defunx status/made? @var{conn}
@defunx status/awaiting-response? @var{conn}
@defunx status/auth-ok? @var{conn}
@defunx status/setenv? @var{conn}
@defunx status/ssl-startup? @var{conn}
@defunx status/needed? @var{conn}
Return @true{} if the state of the @objtype{connection} object
@var{conn} is the named one.
@end defun


@defun connection-database @var{conn}
@findex @func{PQdb}
Wrapper for @func{PQdb}.  Return a Scheme string representing the
database name associated to the connection @var{conn}, or @false{} if
the value is not set.
@end defun


@defun connection-user @var{conn}
@findex @func{PQuser}
Wrapper for @func{PQuser}.  Return a Scheme string representing the user
name associated to the connection @var{conn}, or @false{} if the value
is not set.
@end defun


@defun connection-password @var{conn}
@findex @func{PQpass}
Wrapper for @func{PQpass}.  Return a Scheme string representing the
user's password associated to the connection @var{conn}, or @false{} if
the value is not set.
@end defun


@defun connection-host @var{conn}
@findex @func{PQhost}
Wrapper for @func{PQhost}.  Return a Scheme string representing the host
name associated to the connection @var{conn}, or @false{} if the value
is not set.
@end defun


@defun connection-port @var{conn}
@findex @func{PQport}
Wrapper for @func{PQport}.  Return a Scheme string representing the port
associated to the connection @var{conn}, or @false{} if the value is not
set.
@end defun


@defun connection-tty
@findex @func{PQtty}
Wrapper for @func{PQtty}.  Return a Scheme string representing the tty
associated to the connection @var{conn}, or @false{} if the value is not
set.
@end defun


@defun connection-options
@findex @func{PQoptions}
Wrapper for @func{PQoptions}.  Return a Scheme string representing the
command line options associated to the connection @var{conn}, or
@false{} if the value is not set.
@end defun


@defun connection-socket @var{conn}
@findex @func{PQsocket}
Wrapper for @func{PQsocket}.  Return a @objtype{fd} object representing
the socket used by the @objtype{connection} object @var{conn}.
@end defun


@defun connection-transaction-status @var{conn}
@findex @func{PQtransactionStatus}
Wrapper for @func{PQtransactionStatus}.  Return an enumeration set of
type @enum{transaction-status} representing the current transaction
status of the connection @var{conn}.
@end defun


@defun connection-parameter-status @var{conn} @var{parameter-name}
@findex @func{PQparameterStatus}
Wrapper for @func{PQparameterStatus}.  Return a Scheme string
representing the value of @var{parameter-name} for the connection
@var{conn}; @var{parameter-name} must be a Scheme string or symbol.
Return @false{} if parameter's value is not known.

@example
(with-compensations
  (let ((conn (pg:connect-db/c "dbname=nausicaa-test")))
    (pg:connection-parameter-status conn 'server_version)))
@result{} "8.4.2"
@end example
@end defun


@defun connection-protocol-version @var{conn}
@findex @func{PQprotocolVersion}
Wrapper for @func{PQprotocolVersion}.  Return an exact integer
representing the frontend/backend protocol version.
@end defun


@defun connection-server-version @var{conn}
@findex @func{PQserverVersion}
Wrapper for @func{PQserverVersion}.  Return an exact integer
representing the server version.
@end defun


@defun connection-error-message @var{conn}
@findex @func{PQerrorMessage}
Wrapper for @func{PQerrorMessage}.  Return a Scheme string representing
the error message from the most recent failed operation; return @false{}
if no message is set.
@end defun


@defun connection-backend-pid @var{conn}
@findex @func{PQbackendPID}
Wrapper for @func{PQbackendPID}.  Return an object of type @code{pid}
representing the @acronym{PID} of the backend process (on the backend
host).
@end defun


@defun connection-needs-password? @var{conn}
@findex @func{PQconnectionNeedsPassword}
Wrapper for @func{PQconnectionNeedsPassword}.  Return @true{} if the
connection authentication method required a password, but none was
available.
@end defun


@defun connection-used-password? @var{conn}
@findex @func{PQconnectionUsedPassword}
Wrapper for @func{PQconnectionUsedPassword}.  Return @true{} if the
connection authentication method used a password.
@end defun


@defun connectin-get-ssl @var{conn}
@findex @func{PQgetssl}
Wrapper for @func{PQgetssl}.  Return an object of type @code{ssl}
referencing an OpenSSL structure of type @code{SSL}; return @false{} is
@ssl{} is not in use.
@end defun

@c page
@node exec
@chapter Performing a database query


The bindings documented in this chapter are exported by the
@library{foreign databases postgresql primitives} library and reexported
by the @library{foreign databases postgresql} library; it is suggested
to import these libraries by prefixing the bindings, for example with
@code{pg:}.

In the descriptions: the @var{conn} argument is always a Scheme object
of type @objtype{connection}; the @var{cancel} argument is always a
Scheme object of type @objtype{cancel-handler}; the @var{result}
argument is always a Scheme object of type @objtype{query-result}.

@quotation
@strong{NOTE} For an explanation of @acronym{OID} numbers in @pg{}, see
the ``Objects Identifier Types'' in the original documentation (@aurl{}
last verified Thu Feb 18, 2010):

@center @url{http://www.postgresql.org/docs/8.4/static/datatype-oid.html}

@noindent
and notice that @acronym{OID} numbers are by definition of type
@code{uint32_t}.
@end quotation

@menu
* exec sync commands::          Synchronous commands execution.
* exec sync prepared::          Synchronous prepared statements
                                execution.
* exec async commands::         Asynchronous commands execution.
* exec async prepared::         Asynchronous prepared statements
                                execution.
* exec async result::           Acquiring the result of
                                asynchronous operations.
* exec async writes::           Handling asynchronous write
                                operations.
* exec async example::          Example program.
* exec cancel::                 Cancelling queries in progress.
* exec notify::                 Asynchronous notifications.
* exec copy::                   Executing @code{COPY} commands.
@end menu

@c page
@node exec sync commands
@section Synchronous commands execution


The functions raise an exception in case a non--result error is
detected; the client code should test the returned
@objtype{query-result} object for errors by itself.


@defun exec-script @var{conn} @var{query-string}
@findex @func{PQexec}
Wrapper for @func{PQexec}.  Submit the query to the server and wait for
the result, return a @objtype{query-result} object; in case of error
raise an exception.
@end defun


@defun exec-parametrised-query @var{conn} @var{query-string} @var{query-parms} @var{textual-result?}
@findex @func{PQexecParams}
Wrapper for @func{PQexecParams}.  Execute the parametrised
@var{query-string} in the context of the connection @var{conn}; wait for
the query to complete and return a @objtype{query-result} object.

@var{query-string} must be the template for a query embedding place
holders like @samp{$1}, @samp{$2}, @dots{} which are substituted by the
parameters in @var{query-parms}.  @var{query-parms} must be a list of
@class{parameter} records.

If @var{textual-result?} is true, the result holds textual data; else it
holds binary data.
@end defun

@c page
@node exec sync prepared
@section Synchronous prepared statements execution


@defun prepare-statement @var{conn} @var{stmt-name} @var{query-string} @var{number-of-parms}
@defunx prepare-statement @var{conn} @var{stmt-name} @var{query-string} @var{number-of-parms} @var{parms-oid}
@findex @func{PQprepare}
Wrapper for @func{PQprepare}.  Build a new prepared statement in the
context of the connection @var{conn} and wait for completion of the
operation; return a @objtype{query-result} object.

@var{stmt-name} must be a Scheme string or symbol representing the name
of the statement; if it is @false{}, the statement is unnamed.
@var{query-string} must be a Scheme string representing the @sql{}
command.  @var{number-of-parms} is the number of parameters in the
@sql{} command.  The optional @var{parms-oid} must be a list of exact
integers representing the @acronym{OID}s of the parameter's types; if
@false{} or not given, types are left unspecified.
@end defun


@defun describe-prepared-statement @var{conn} @var{stmt-name}
@findex @func{PQdescribePrepared}
Wrapper for @func{PQdescribePrepared}.  Obtain informations about the
specified prepared statement in the context of the connection
@var{conn}, and waits for completion; return a @objtype{query-result}
object.

@var{stmt-name} must be a Scheme string or symbol representing the name
of the statement; if it is @false{}, it the statement is unnamed.
@end defun


@defun exec-prepared-statement @var{conn} @var{stmt-name} @var{query-parms} @var{textual-result?}
@findex @func{PQexecPrepared}
Wrapper for @func{PQexecPrepared}.  Execute the prepared statement named
@var{stmt-name} in the context of the connection @var{conn}; wait for
the query to complete and return a @objtype{query-result} object.

@var{stmt-name} must be a Scheme string or symbol representing the name
of the statement; if it is @false{}, the statement is unnamed.
@var{query-parms} must be a list of @class{parameter} records.

If @var{textual-result?} is true, the result holds textual data; else it
holds binary data.
@end defun

@c page
@node exec async commands
@section Asynchronous commands execution


The functions raise an exception in case a non--result error is
detected; the client code should test the returned
@objtype{query-result} object for errors by itself.


@defun exec-script/send @var{conn} @var{query-string}
@findex @func{PQsendQuery}
Wrapper for @func{PQsendQuery}.  Send @var{query-string} to be executed
asynchronously in the context of @var{conn}; return @true{} is
successful, raise an exception if failure.
@end defun


@defun exec-parametrised-query/send @var{conn} @var{query-string} @var{query-parms} @var{textual-result?}
@findex @func{PQsendQueryParams}
Wrapper for @func{PQsendQueryParams}.  Send the request to execute the
parametrised @var{query-string} in the context of the connection
@var{conn}; return @true{} if successful, raise an exception if failure.

@var{query-string} must be the template for a query embedding place
holders like @samp{$1}, @samp{$2}, @dots{} which are substituted by the
parameters in @var{query-parms}.  @var{query-parms} must be a list of
@class{parameter} records.

If @var{textual-result?} is true, the result holds textual data; else it
holds binary data.
@end defun

@c page
@node exec async prepared
@section Asynchronous prepared statements execution


@defun prepare-statement/send @var{conn} @var{stmt-name} @var{query-string} @var{number-of-parms}
@defunx prepare-statement/send @var{conn} @var{stmt-name} @var{query-string} @var{number-of-parms} @var{parms-oid}
@findex @func{PQsendPrepare}
Wrapper for @func{PQsendPrepare}.  Send the request to build a new
prepared statement in the context of the connection @var{conn} and wait
for completion of the operation; return @true{} if successful, raise an
exception if failure.

@var{stmt-name} must be a Scheme string or symbol representing the name
of the statement; if it is @false{}, the statement is unnamed.
@var{query-string} must be a Scheme string representing the @sql{}
command.  @var{number-of-parms} is the number of parameters in the
@sql{} command.  The optional @var{parms-oid} must be a list of exact
integers representing the @acronym{OID}s of the parameter's types; if
@false{} or not given, types are left unspecified.
@end defun


@defun describe-prepared-statement/send @var{conn} @var{stmt-name}
@findex @func{PQsendDescribePrepared}
Wrapper for @func{PQsendDescribePrepared}.  Send the request to obtain
information about the specified prepared statement in the context of the
connection @var{conn}, and waits for completion; return @true{} is
successful, raise an exception if failure.

@var{stmt-name} must be a Scheme string or symbol representing the name
of the statement; if it is @false{}, it the statement is unnamed.
@end defun


@defun exec-prepared-statement/send @var{conn} @var{stmt-name} @var{query-parms} @var{textual-result?}
@findex @func{PQsendQueryPrepared}
Wrapper for @func{PQsendQueryPrepared}.  Send the request to execute the
prepared statement named @var{stmt-name} in the context of the
connection @var{conn}; return @true{} if successful, raise an exception
if failure.

@var{stmt-name} must be a Scheme string or symbol representing the name
of the statement; if it is @false{}, the statement is unnamed.
@var{query-parms} must be a list of @class{parameter} records.

If @var{textual-result?} is true, the result holds textual data; else it
holds binary data.
@end defun

@c page
@node exec async result
@section Acquiring the result of asynchronous operations


@defun connection-get-result @var{conn}
@findex @func{PQgetResult}
Wrapper for @func{PQgetResult}.  Return a @objtype{query-result} object
representing the current status of the last asynchronous operation in
the context of @var{conn}; return @false{} if the last operation is
complete.  Block until the result is available.

Notice that when the operation is the execution of more @sql{}
statements, a result for each statement is produced.
@end defun


@defun connection-consume-input @var{conn}
@findex @func{PQconsumeInput}
Wrapper for @func{PQconsumeInput}.  Consume incoming input from
@var{conn} and store it internally, to be retrieved later with
@func{connection-get-result}.  Raise an exception if an error occurs.

Notice that a single call to this function can make available data for
more @objtype{query-result} objects; so more calls to
@func{connection-get-result} may be needed to consume all the received
data.
@end defun


@defun connection-is-busy? @var{conn}
@findex @func{PQisBusy}
Wrapper for @func{PQisBusy}.  Return @true{} if calling
@func{connection-get-result} would block; @false{} otherwise.  It makes
sense to call this function only after a call to
@func{connection-consume-input}.
@end defun

@c page
@node exec async writes
@section Handling asynchronous write operations


@defun connection-set-non-blocking @var{conn}
@findex @func{PQsetnonblocking}
Wrapper for @func{PQsetnonblocking}.  Set the non--blocking mode for
@var{conn}.  Raise an exception in case of error.
@end defun


@defun connection-set-blocking @var{conn}
@findex @func{PQsetnonblocking}
Wrapper for @func{PQsetnonblocking}.  Set the blocking mode for
@var{conn}.  Raise an exception in case of error.
@end defun


@defun connection-is-non-blocking? @var{conn}
@findex @func{PQisnonblocking}
Wrapper for @func{PQisnonblocking}.  Return @true{} if @var{conn} is in
non--blocking mode, @false{} otherwise.
@end defun


@defun connection-flush @var{conn}
@findex @func{PQflush}
Wrapper for @func{PQflush}.  Attempt to flush to the server pending data
in @var{conn}; return @true{} if more data is pending and needs to be
flushed, return @false{} if all the data has been flushed.  Raise an
exception if an error occurs.
@end defun

@c page
@node exec async example
@section Example program


The following example program shows the mechanics of database access
through a non--blocking connection for both reading and writing.

@smallexample
(import (nausicaa)
  (formations)
  (records)
  (compensations)
  (deferred-exceptions)
  (foreign memory)
  (prefix (foreign databases postgresql) pg:)
  (prefix (foreign databases postgresql compensated) pg:)
  (prefix (posix sizeof) px:)
  (prefix (posix fd) px:)
  (for (prefix (posix typedefs) px:) expand run)
  (for (prefix (posix extensions) px:) expand))

(define (main)
  (with-deferred-exceptions-handler
      (lambda (E)
        (exception-handler "deferred exception" E))
    (lambda ()
      (with-exception-handler
          (lambda (E)
            (exception-handler "error" E))
        (lambda ()
          (with-compensations

            (define $sql-create-table
              "create table accounts (nickname TEXT,
                                      password TEXT);")

            (define $sql-insert-data "
               insert into accounts (nickname, password)
                 values ('ichigo', 'abcde');
               insert into accounts (nickname, password)
                 values ('rukia', '12345');
               insert into accounts (nickname, password)
                 values ('chad', 'fist');")

            (define $sql-query
              "select * from accounts where nickname = $1;")

            (let ((conn (database-connect/c "dbname=nausicaa-test")))

              (database-send/c
               conn (pg:exec-status command-ok)
               (lambda (conn)
                 (pg:exec-script/send conn $sql-create-table)))

              (database-send/c
               conn (pg:exec-status command-ok)
               (lambda (conn)
                 (pg:exec-script/send conn $sql-insert-data)))

              (database-send/c
               conn (pg:exec-status command-ok)
               (lambda (conn)
                 (pg:prepare-statement/send conn
                    'the-row $sql-query 1)))

              (let ((result (database-send/c
                             conn (pg:exec-status tuples-ok)
                             (lambda (conn)
                               (pg:exec-prepared-statement/send
                                conn 'the-row
                                (list (pg:parameter "rukia"))
                                #t)))))

                (format #t
                  "number of tuples: ~a~%password: ~a~%"
                  (pg:result-number-of-tuples result)
                  (pg:result-get-value/text result 0 1)))))
          (exit))))))

(define (database-connect/c connect-info)
  (let ((conn (pg:connect-start/c connect-info)))
    (if (pg:status/bad? conn)
        (error 'database-conenct
          "unable to start connection")
      (let loop ((status (pg:polling-status writing)))
        (case (enum->symbol status)
          ((ok)
           (pg:connection-set-non-blocking conn)
           conn)
          ((reading)
           (connection-wait-for-read-ready conn)
           (loop (pg:connect-poll conn)))
          ((writing)
           (connection-wait-for-write-ready conn)
           (loop (pg:connect-poll conn)))
          (else
           (error 'database-connect/c
             "unable to complete connection")))))))

(define (database-send/c conn expected-status action)
  (action conn)
  (do-while (pg:connection-flush conn)
    (connection-wait-for-write-ready conn))
  (let next-result ((last-result #f))
    (while (pg:connection-is-busy? conn)
      (connection-wait-for-read-ready conn)
      (pg:connection-consume-input conn))
    (let ((result (pg:connection-get-result/c conn)))
      (if result
          (if (enum-set=? expected-status
                          (pg:result-status result))
              (next-result result)
            (error 'database-exec-command/c
              "unexpected result status"))
        last-result))))

(define-enumeration socket-event
  (read-ready write-ready exception)
  socket-events)

(define-syntax connection-wait-for-read-ready
  (syntax-rules ()
    ((_ ?conn)
     (connection-wait-for-event ?conn
        (socket-event read-ready)))))

(define-syntax connection-wait-for-write-ready
  (syntax-rules ()
    ((_ ?conn)
     (connection-wait-for-event ?conn
        (socket-event write-ready)))))

(define (connection-wait-for-event conn which)
  (with-compensations
    (let ((fd       (pg:connection-socket conn))
          (rd-fdset (px:make-fdset malloc-block/c))
          (wr-fdset (px:make-fdset malloc-block/c))
          (ex-fdset (px:make-fdset malloc-block/c))
          (timeout  (px:make-struct-timeval malloc-block/c)))
      (with-fields* (((sec usec) px:struct-timeval* timeout))
        (set! timeout.sec  10)
        (set! timeout.usec 0))
      (px:FD_ZERO rd-fdset)
      (px:FD_ZERO wr-fdset)
      (px:FD_ZERO ex-fdset)
      (let ((set (case which
                   ((read-ready)   rd-fdset)
                   ((write-ready)  wr-fdset)
                   ((exception)    ex-fdset))))
        (px:FD_SET fd set)
        (px:select px:FD_SETSIZE
           rd-fdset wr-fdset ex-fdset timeout)
        (unless (px:FD_ISSET fd set)
          (error 'connection-wait-for-event
            "timeout expired while polling socket"))))))

(define (enum->symbol set)
  (car (enum-set->list set)))

(define (exception-handler prefix E)
  (cond ((message-condition? E)
         (format (current-error-port)
           "~a: ~a: ~a\n" prefix
           (condition-who E) (condition-message E))
         (exit 1))
        (else (raise E))))

(main)
@end smallexample

@c page
@node exec cancel
@section Cancelling queries in progress


@defun connection-get-cancel-handler @var{conn}
@findex @func{PQgetCancel}
Wrapper for @func{PQgetCancel}.  Return an object of type
@objtype{cancel-handler} which can be used to request the cancellation
of the current @sql{} command.
@end defun


@defun free-cancel-handler @var{cancel}
@findex @func{PQfreeCancel}
Wrapper for @func{PQfreeCancel}.  Release all the resources associated
to the cancellation handler @var{cancel}.
@end defun


@defun cancel-command @var{cancel}
@findex @func{PQcancel}
Wrapper for @func{PQcancel}.  Submit a request to cancel the current
@sql{} command; raise an exception if an error occurs dispatching the
request.
@end defun

@c page
@node exec notify
@section Asynchronous notifications


@defun connection-notification @var{conn}
@findex @func{PQnotifies}
Wrapper for @func{PQnotifies}.  Return an object of type
@class{notification} representing the next notification object from a
list of unhandled notification messages received from the server; return
@false{} if there are no pending notifications.
@end defun

@c page
@node exec copy
@section Executing @code{COPY} commands


To execute a @code{COPY} command, we have to use one of the functions
described above: @func{exec-script}, @func{exec-parametrised-query},
@func{exec-prepared-statement}, or one of their asynchronous
equivalents; then we have to obtain a result object with status
@code{copy-in} or @code{copy-out}.

@c ------------------------------------------------------------

@subsubheading Sending data to the server


Here is a @code{COPY FROM} example without error checking:

@example
(import (nausicaa)
  (compensations)
  (prefix (foreign databases postgresql) pg:)
  (prefix (foreign databases postgresql compensated) pg:))

(with-compensations
  (let ((conn (pg:connect-db/c "dbname=nausicaa-test")))

    (pg:exec-script/c conn
       "create table accounts (nickname TEXT,
                               password TEXT);")

    (pg:exec-script/c conn
       "COPY accounts FROM STDIN WITH DELIMITER '|';")

    (pg:connection-put-copy-data/string conn
       "ichigo|abcde\nrukia|12345\nchad|fist\n")))
@end example

@noindent
table columns are delimited by @samp{#\|}, table rows are delimited by
@samp{#\newline}.


@defun connection-put-copy-data @var{conn} @var{mb}
@findex @func{PQputCopyData}
Wrapper for @func{PQputCopyData}.  Send data to the server during
@code{copy-in} state; @var{mb} must be a @class{memblock} object
referencing the raw data to send.  @nauref{memory blocks, Memory
blocks}.

Return @true{} if the data was sent; return @false{} if the data was not
sent because the connection would block (this case is only possible if
the connection is in non--blocking mode, we must wait for the
write--ready socket state and try again).  Raise a
@condition{postgresql-copy-in-error} object if an error occurs.
@end defun


@defun connection-put-copy-data/string @var{conn} @var{str}
@defunx connection-put-copy-data/bytevector @var{conn} @var{bv}
Wrappers for @func{connection-put-copy-data} which send data from the
Scheme string @var{str} or the Scheme bytevector @var{bv}.
@end defun


@defun connection-put-copy-end @var{conn}
@defunx connection-put-copy-fail @var{conn} @var{error-message}
@findex @func{PQputCopyEnd}
Wrappers for @func{PQputCopyEnd}.  @func{connection-put-copy-end}
requests the successful termination of a @code{COPY} command.
@func{connection-put-copy-fail} forces a failed termination of a
@code{COPY} command and instructs the server to fail with the Scheme
string @var{error-message} as error description.

Return @true{} if the termination data was sent; return @false{} if the
data was not sent because the connection would block (this case is only
possible if the connection is in non--blocking mode, we must wait for
the write--ready socket state and try again).  Raise a
@condition{postgresql-copy-end-error} object if an error occurs.
@end defun

@c ------------------------------------------------------------

@subsubheading Receiving data from the server


Here is a @code{COPY TO} example without error checking:

@example
(import (nausicaa)
  (compensations)
  (prefix (foreign databases postgresql) pg:)
  (prefix (foreign databases postgresql compensated) pg:))

(with-compensations
  (let ((conn (pg:connect-db/c "dbname=nausicaa-test")))

    (pg:exec-script/c conn "
       create table accounts (nickname TEXT, password TEXT);
       insert into accounts (nickname, password)
          values ('ichigo', 'abcde');
       insert into accounts (nickname, password)
          values ('rukia', '12345');
       insert into accounts (nickname, password)
          values ('chad', 'fist');")

    (pg:exec-script/c conn
       "COPY accounts TO STDOUT WITH DELIMITER '|';")

    (let-values (((more? str)
                  (pg:connection-get-copy-data/string conn)))
      str) @result{} "ichigo|abcde\n"

    (let-values (((more? str)
                  (pg:connection-get-copy-data/string conn)))
      str) @result{} "rukia|12345\n"

    (let-values (((more? str)
                  (pg:connection-get-copy-data/string conn)))
      str) @result{} "chad|fist\n"

    (let-values (((more? str)
                  (pg:connection-get-copy-data/string conn)))
      more?) @result{} #f

    (let ((result (pg:connection-get-result conn)))
      (pg:result-status/command-ok? result)))) @result{} #t
@end example


@defun connection-get-copy-data @var{conn}
@findex @func{PQgetCopyData}
Wrapper for @func{PQgetCopyData}.  Receive a row of data from the server
during @code{copy-out} state; return two values:

@enumerate
@item
@true{} if more rows are to be received; @false{} if the copy is
finished.

@item
This value is meaningful only when the first returned value is @true{}.
If a row was available: it is a @class{memblock} object referencing the
data; memory must be freed with @func{PQfreemem}.  If no row was
available: it is @false{}, which means that the copy of the next row is
still in progress.
@end enumerate

If an error occurs: raise an exception with condition object
@condition{postgresql-copy-out-error}.  The function acts in synchronous
mode if @var{conn} is in synchronous mode, otherwise asynchronous mode
is selected.
@end defun


@defun connection-get-copy-data/string @var{conn}
@defunx connection-get-copy-data/bytevector @var{conn}
Wrappers for @func{connection-get-copy-data}.
@func{connection-get-copy-data/string} returns a Scheme string to
represent the row of data.  @func{connection-get-copy-data/bytevector}
returns a Scheme bytevector to represent the row of data.
@end defun

@c page
@node query
@chapter Handling query results


The bindings documented in this chapter are exported by the
@library{foreign databases postgresql primitives} library and reexported
by the @library{foreign databases postgresql} library.  It is suggested
to import these libraries by prefixing the bindings, for example with
@code{pg:}.

@menu
* query inspect::               Inspecting query results.
* query result::                Retrieving query results.
* query misc::                  Miscellaneous functions.
@end menu

@c page
@node query inspect
@section Inspecting query results


In the following descriptions: the @var{result} argument is always a
Scheme object of type @objtype{query-result}.


@defun result-status @var{result}
@findex @func{PQresultStatus}
Wrapper for @func{PQresultStatus}.  Inspect the result object
@var{result} and return its status: an enumeration set of type
@enum{exec-status}.
@end defun


@defun result-status/empty-query? @var{result}
@defunx result-status/command-ok? @var{result}
@defunx result-status/tuples-ok? @var{result}
@defunx result-status/copy-out? @var{result}
@defunx result-status/copy-in? @var{result}
@defunx result-status/bad-response? @var{result}
@defunx result-status/nonfatal-error? @var{result}
@defunx result-status/fatal-error? @var{result}
Return @true{} if the status of @var{result} is the named one.
@end defun


@defun result-status/bad? @var{result}
Return @true{} if the status of @var{result} is one among:
@code{bad-response}, @code{nonfatal-error}, @code{fatal-error}.
@end defun


@defun status->string @var{result/code}
@findex @func{PQresStatus}
Wrappre for @func{PQresStatus}.  Convert an enumeration set of type
@enum{exec-status} or a @pg{} result code into a Scheme string
describing the result; the string is the identifier of the @pg{}
constant, for example @samp{PGRES_COMMAND_OK}.
@end defun


@defun result-error-message @var{result}
@findex @func{PQresultErrorMessage}
Wrapper for @func{PQresultErrorMessage}.  Return a Scheme string
describing the error in the @var{result}; return @false{} if no error
occurred.
@end defun


@defun result-error-field @var{result} @var{field-set}
@findex @func{PQresultErrorField}
Wrapper for @func{PQresultErrorField}.  Return a Scheme string
representing an error field in @var{result}; return @false{} is the
field is not set.  @var{field-set} must be an enumeration set of type
@enum{error-field}.
@end defun

@c page
@node query result
@section Retrieving query results


The elements of a database table are called @dfn{rows} and
@dfn{columns}; the elements of a @objtype{query-result} object are
called @dfn{tuples} and @dfn{fields}.  Rows and columns are indexed with
base @math{1}, while tuples and fields are indexed with base @math{0};
prepared statements parameters are indexed with base @math{0}.  In the
following descriptions:

@itemize
@item
The @var{result} argument is always a Scheme object of type
@objtype{query-result}.

@item
If the @var{field-index}, @var{tuple-index} or @var{parm-index} argument
is out of range, an assertion violation is raised.

@item
If the @var{field-name} is invalid, an assertion violation is raised.
@end itemize


@c ------------------------------------------------------------

@subsubheading Result size


@defun result-number-of-tuples @var{result}
@findex @func{PQntuples}
Wrapper for @func{PQntuples}.  When applied to the result of a query
command: return the number of tuples in @var{result}; when applied to
the result of a @code{COPY} command: return the number of columns to be
copied.
@end defun


@defun result-tuple-index? @var{result} @var{tuple-index}
Return @true{} if @var{tuple-index} is a valid tuple index for
@var{result}.
@end defun


@defun assert-result-tuple-index @var{who} @var{result} @var{tuple-index}
Raise an assertion violation if @var{tuple-index} is not a valid tuple
index for @var{result}.  @var{who} is used for the @condition{who}
condition object.
@end defun


@defun result-number-of-fields @var{result}
@findex @func{PQnfields}
Wrapper for @func{PQnfields}.  Return the number of columns in each
tuple in @var{result}.
@end defun


@defun result-field-index? @var{result} @var{field-index}
Return @true{} if @var{field-index} is a valid field index for
@var{result}.
@end defun


@defun assert-result-field-index @var{who} @var{result} @var{field-index}
Raise an assertion violation if @var{field-index} is not a valid field
index for @var{result}.  @var{who} is used for the @condition{who}
condition object.
@end defun

@c ------------------------------------------------------------

@subsubheading Result values


@defun result-null-value? @var{result} @var{tuple-index} @var{field-index}
@findex @func{PQgetisnull}
Wrapper for @func{PQgetisnull}.  Return @true{} if the selected value is
null.
@end defun


@defun result-value-length @var{result} @var{tuple-index} @var{field-index}
@findex @func{PQgetlength}
Wrapper for @func{PQgetlength}.  Return the length in bytes of the
selected element.
@end defun


@defun result-get-value @var{result} @var{tuple-index} @var{field-index}
@defunx result-get-value/text @var{result} @var{tuple-index} @var{field-index}
@defunx result-get-value/binary @var{result} @var{tuple-index} @var{field-index}
@findex @func{PQgetvalue}
Wrappers for @func{PQgetvalue}.  Return the value of the selected
element; the plain variant returns a pointer object referencing the
first byte of the result, the @code{/text} variant returns a Scheme
string, the @code{/binary} variant returns a Scheme bytevector.
@end defun

@c ------------------------------------------------------------

@subsubheading Results of prepared statements


@defun result-number-of-parameters @var{result}
@findex @func{PQnparams}
Wrapper for @func{PQnparams}.  Return the number of parameters of a
prepared statement; this function is only useful when inspecting the
result of @func{PQdescribePrepared}, for other types of queries it will
return zero.
@end defun


@defun result-parameter-index? @var{result} @var{parm-index}
Return @true{} if @var{parm-index} is a valid parameter index for the
query that generated @var{result}.
@end defun


@defun assert-result-parameter-index @var{who} @var{result} @var{parm-index}
Raise an assertion violation if @var{parm-name} is not a valid parameter
index for the query that generated @var{result}.  @var{who} is used for
the @condition{who} condition object.
@end defun


@defun result-parameter-type-oid @var{result} @var{parm-index}
@findex @func{PQparamtype}
Wrapper for @func{PQparamtype}.  Returns the data type of the indicated
statement parameter; return @false{} if the information is unavailable.
@end defun

@c ------------------------------------------------------------

@subsubheading Other functions


@defun result-field-name @var{result} @var{field-index}
@findex @func{PQfname}
Wrapper for @func{PQfname}.  Return a Scheme string representing the
name of the column at @var{field-index} in @var{result}.
@end defun


@defun result-field-name? @var{result} @var{field-name}
Return @true{} if the Scheme string or symbol @var{field-name} is a
column name in @var{result}.
@end defun


@defun assert-result-field-name @var{who} @var{result} @var{field-name}
Raise an assertion violation if @var{field-name} is not a valid field
name in @var{result}.  @var{who} is used for the @condition{who}
condition object.
@end defun


@defun result-field-number @var{result} @var{field-name}
@findex @func{PQfnumber}
Wrapper for @func{PQfnumber}.  Return an exact integer representing the
index of the column having @var{field-name}, which must be a Scheme
string or symbol.  Return @false{} if @var{field-name} is not a column
name in @var{result}.
@end defun


@defun result-column-table-oid @var{result} @var{field-index}
@findex @func{PQftable}
Wrapper for @func{PQftable}.  Return the @acronym{OID} of the table from
which the column at @var{field-index} in @var{result} was extracted.
Return @false{} if @var{field-index} is out of range.
@end defun


@defun result-table-column-number @var{result} @var{field-index}
@findex @func{PQftablecol}
Wrapper for @func{PQftablecol}.  Return the column number (within its
table) of the column making up the specified query result column.
@end defun


@defun result-binary-tuples? @var{result}
@findex @func{PQbinaryTuples}
Wrapper for @func{PQbinaryTuples}.  When applied to the result of a
@code{COPY} command: return @true{} if the @code{COPY} command has
binary format.
@end defun


@defun result-column-format-code @var{result} @var{field-index}
@findex @func{PQfformat}
Wrapper for @func{PQfformat}.  Return an enumeration set of type
@enum{format-code}; when applied to the result of a query command: it
represents the format of the column at @var{field-index} in
@var{result}; when applied to the result of a @code{COPY} command: it
represents the format of the columns to be copied.
@end defun


@defun result-column-type-oid @var{result} @var{field-index}
@findex @func{PQftype}
Wrapper for @func{PQftype}.  Return the @acronym{OID} of the type
associated with the column at @var{field-index} in @var{result}; return
@false{} if @var{field-index} is out of range.
@end defun


@defun result-type-modifier @var{result} @var{field-index}
@findex @func{PQfmod}
Wrapper for @func{PQfmod}.  Return an exact integer representing the
type modifier for the column at @var{field-index} in @var{result};
return @false{} if no information is available.
@end defun


@defun result-column-size @var{result} @var{field-index}
@findex @func{PQfsize}
Wrapper for @func{PQfsize}.  Return an exact integer representing the
amount of space in byte allocated by the server to hold values in the
column at @var{field-index} in @var{result}; return @false{} if the
storage is variable in size.
@end defun


@defun result-command-status @var{result}
@findex @func{PQcmdStatus}
Wrapper for @func{PQcmdStatus}.  Return the command status tag from the
@sql{} command which generated @var{result}.
@end defun


@defun result-affected-rows @var{result}
@findex @func{PQcmdTuples}
Wrapper for @func{PQcmdTuples}.  Return an exact integer representing
the number of rows affected by the @sql{} command which generated
@var{result}; return @false{} if the command could not affect any row.
@end defun


@defun result-new-row-oid @var{result}
@findex @func{PQoidValue}
Wrapper for @func{PQoidValue}.  Return the @acronym{OID} of the inserted
row, if the @sql{} command was an @code{INSERT} that inserted exactly
one row into a table that has @acronym{OID}s, or a @code{EXECUTE} of a
prepared query containing a suitable @code{INSERT} statement.  Return
@false{} if the command was not suitable.
@end defun

@c page
@node query misc
@section Miscellaneous functions


In the following descriptions: the @var{result} argument is always a
Scheme object of type @objtype{query-result}.


@defun clear-result @var{result}
@findex @func{PQclear}
Wrapper for @func{PQclear}.  Finalises @var{result}, releasing all
its resources.
@end defun

@c page
@node escapes
@chapter Escaping strings


The bindings documented in this chapter are exported by the
@library{foreign databases postgresql primitives} library and reexported
by the @library{foreign databases postgresql} library.  It is suggested
to import these libraries by prefixing the bindings, for example with
@code{pg:}.

In the following description: the @var{conn} argument is always an
object of type @objtype{connection}.  As an easy mnemonic rule,
@samp{bytea} in the @pg{} documentation stands for ``bytes array''.


@defun escape-string-conn @var{conn} @var{string}
@findex @func{PQescapeStringConn}
Wrapper for @func{PQescapeStringConn}.  Escape @var{string} so that it
can be safely inserted in a @sql{} command; return the escaped string.
If @var{string} is invalid, raise an error.

The @var{conn} argument is required to adjust the conversion attributes,
like the string encoding.
@end defun


@defun escape-bytes-conn @var{conn} @var{ptr} @var{len}
@findex @func{PQescapeByteaConn}
Wrapper for @func{PQescapeByteaConn}.  Escape @var{len} bytes of binary
data starting at the byte referenced by the pointer object @var{ptr}, so
that it can be safely inserted in a @sql{} command.  Return two values:
a pointer object referencing the first byte of the escaped string, the
number of bytes in the escaped string.  The returned memory must be
released with call to @func{PQfreemem}.
@end defun


@defun escape-bytes-conn/bv @var{conn} @var{bv}
Wrapper for @func{escape-bytes-conn} which escapes the Scheme bytevector
@var{bv} and return an escaped Scheme string.
@end defun


@defun unescape-bytes @var{ptr}
@findex @func{PQunescapeBytea}
Wrapper for @func{PQunescapeBytea}.  Unescape a zero--terminated string
whose first byte is referenced by the pointer object @var{ptr}.  Return
two values: a pointer object to the first byte of the unescaped string,
the number of bytes in the unescaped string.  The returned memory must
be released with @func{primitive-free} from the @library{foreign memory}
library.  @nauref{memory alloc primitive, Primitive functions}.
@end defun


@defun unescape-bytes/bv @var{str}
Unescape the Scheme string @var{str} and return the unescaped data as a
Scheme bytevector.
@end defun

@c page
@node misc
@chapter Miscellaneous functions


The following bindings are exported by the @library{foreign databases
postgresql primitives} library and reexported by the @library{foreign
databases postgresql} library.  It is suggested to import these
libraries by prefixing the bindings, for example with @code{pg:}.

In the descriptions: the @var{conn} argument is always a Scheme object
of type @objtype{connection}.


@defun describe-portal @var{conn} @var{portal-name}
@findex @func{PQdescribePortal}
Wrapper for @func{PQdescribePortal}.  Obtain informations about the
specified prepared portal in the context of the connection @var{conn},
and waits for completion; return a @objtype{query-result} object.

@var{stmt-name} must be a Scheme string or symbol representing the name
of the portal; if it is @false{}, it the portal is unnamed.
@end defun


@defun describe-portal/send @var{conn} @var{portal-name}
@findex @func{PQsendDescribePortal}
Wrapper for @func{PQsendDescribePortal}.  Send a request to obtain
informations about the specified prepared portal in the context of the
connection @var{conn}; return @true{} if successful, raise an exception
if failure.

@var{stmt-name} must be a Scheme string or symbol representing the name
of the portal; if it is @false{}, it the portal is unnamed.
@end defun


@defun connection-client-encoding @var{conn}
@findex @func{PQclientEncoding}
Wrapper for @func{PQclientEncoding}.  Return a Scheme string
representing the current encoding for the connection @var{conn}.
@end defun


@defun connection-client-encoding-set! @var{conn} @var{encoding-string}
@findex @func{PQsetClientEncoding}
Wrapper for @func{PQsetClientEncoding}.  Set the encoding for the
connection @var{conn} to the one specified by the Scheme string
@var{encoding-string}.
@end defun


@defun connection-error-verbosity-set! @var{conn} @var{verb}
@findex @func{PQsetErrorVerbosity}
Wrapper for @func{PQsetErrorVerbosity}.  Set the connection verbosity
level, return the previous level.  Both @var{verb} and the returned
value are enumeration sets of type @enum{error-verbosity}.
@end defun


@defun connection-set-notice-receiver @var{conn} @var{callback}
@findex @func{PQsetNoticeReceiver}
Wrapper for @func{PQsetNoticeReceiver}.  Set the notice receiver callback.
@end defun


@defun make-notice-receiver-callback @var{scheme-function}
Build and return a callback object wrapping @var{scheme-function}.  It
is defined as:

@example
(define (make-notice-receiver-callback scheme-function)
  (make-c-callback*
   void
   (lambda (result)
     (scheme-function pointer-null (query-result->pointer result)))
   (void* void*)))
@end example
@end defun


@defun connection-set-notice-processor
@findex @func{PQsetNoticeProcessor}
Wrapper for @func{PQsetNoticeProcessor}.  Set the notice processor
callback.
@end defun


@defun make-notice-processor-callback @var{scheme-function}
Build and return a callback object wrapping @var{scheme-function}.  It
is defined as:

@example
(define (make-notice-processor-callback scheme-function)
  (make-c-callback*
   (lambda (message-pointer)
     (scheme-function pointer-null
                      (cstring->string message-pointer)))
   (void* char*)))
@end example
@end defun

@c page
@node primitives
@chapter Miscellaneous primitive bindings


The following bindings are exported by the @library{foreign databases
postgresql primitives} library.  The functions are reexported ``as is''
from the @library{foreign databases postgresql platform} library.  It is
suggested to import these libraries by prefixing the bindings, for
example with @code{pg:}.


@defun conninfo-free
@findex @func{PQconninfoFree}
Alias for @func{PQconninfoFree}.
@end defun


@defun request-cancel
@findex @func{PQrequestCancel}
Alias for @func{PQrequestCancel}.
@end defun


@defun init-ssl
@findex @func{PQinitSSL}
Alias for @func{PQinitSSL}.
@end defun


@defun init-open-ssl
@findex @func{PQinitOpenSSL}
Alias for @func{PQinitOpenSSL}.
@end defun


@defun trace
@findex @func{PQtrace}
Alias for @func{PQtrace}.
@end defun


@defun untrace
@findex @func{PQuntrace}
Alias for @func{PQuntrace}.
@end defun


@defun register-thread-lock
@findex @func{PQregisterThreadLock}
Alias for @func{PQregisterThreadLock}.
@end defun


@defun getline
@findex @func{PQgetline}
Alias for @func{PQgetline}.
@end defun


@defun putline
@findex @func{PQputline}
Alias for @func{PQputline}.
@end defun


@defun getline-async
@findex @func{PQgetlineAsync}
Alias for @func{PQgetlineAsync}.
@end defun


@defun putnbytes
@findex @func{PQputnbytes}
Alias for @func{PQputnbytes}.
@end defun


@defun endcopy
@findex @func{PQendcopy}
Alias for @func{PQendcopy}.
@end defun


@defun isthreadsafe
@findex @func{PQisthreadsafe}
Alias for @func{PQisthreadsafe}.
@end defun


@defun fn
@findex @func{PQfn}
Alias for @func{PQfn}.
@end defun


@defun oid-status
@findex @func{PQoidStatus}
Alias for @func{PQoidStatus}.
@end defun


@defun freemem
@findex @func{PQfreemem}
Alias for @func{PQfreemem}.
@end defun


@defun make-empty-pg-result
@findex @func{PQmakeEmptyPGresult}
Alias for @func{PQmakeEmptyPGresult}.
@end defun


@defun copy-result
@findex @func{PQcopyResult}
Alias for @func{PQcopyResult}.
@end defun


@defun set-result-attrs
@findex @func{PQsetResultAttrs}
Alias for @func{PQsetResultAttrs}.
@end defun


@defun result-alloc
@findex @func{PQresultAlloc}
Alias for @func{PQresultAlloc}.
@end defun


@defun setvalue
@findex @func{PQsetvalue}
Alias for @func{PQsetvalue}.
@end defun


@defun print
@findex @func{PQprint}
Alias for @func{PQprint}.
@end defun


@defun display-tuples
@findex @func{PQdisplayTuples}
Alias for @func{PQdisplayTuples}.
@end defun


@defun print-tuples
@findex @func{PQprintTuples}
Alias for @func{PQprintTuples}.
@end defun


@defun lo-open
@findex @func{lo_open}
Alias for @func{lo_open}.
@end defun


@defun lo-close
@findex @func{lo_close}
Alias for @func{lo_close}.
@end defun


@defun lo-read
@findex @func{lo_read}
Alias for @func{lo_read}.
@end defun


@defun lo-write
@findex @func{lo_write}
Alias for @func{lo_write}.
@end defun


@defun lo-lseek
@findex @func{lo_lseek}
Alias for @func{lo_lseek}.
@end defun


@defun lo-creat
@findex @func{lo_creat}
Alias for @func{lo_creat}.
@end defun


@defun lo-create
@findex @func{lo_create}
Alias for @func{lo_create}.
@end defun


@defun lo-tell
@findex @func{lo_tell}
Alias for @func{lo_tell}.
@end defun


@defun lo-truncate
@findex @func{lo_truncate}
Alias for @func{lo_truncate}.
@end defun


@defun lo-unlink
@findex @func{lo_unlink}
Alias for @func{lo_unlink}.
@end defun


@defun lo-import
@findex @func{lo_import}
Alias for @func{lo_import}.
@end defun


@defun lo-import-with-oid
@findex @func{lo_import_with_oid}
Alias for @func{lo_import_with_oid}.
@end defun


@defun lo-export
@findex @func{lo_export}
Alias for @func{lo_export}.
@end defun


@defun mblen
@findex @func{PQmblen}
Alias for @func{PQmblen}.
@end defun


@defun dsplen
@findex @func{PQdsplen}
Alias for @func{PQdsplen}.
@end defun


@defun env2encoding
@findex @func{PQenv2encoding}
Alias for @func{PQenv2encoding}.
@end defun


@defun encrypt-password
@findex @func{PQencryptPassword}
Alias for @func{PQencryptPassword}.
@end defun


@defun char-to-encoding
@findex @func{pg_char_to_encoding}
Alias for @func{pg_char_to_encoding}.
@end defun


@defun encoding-to-char
@findex @func{pg_encoding_to_char}
Alias for @func{pg_encoding_to_char}.
@end defun


@defun valid-server-encoding-id
@findex @func{pg_valid_server_encoding_id}
Alias for @func{pg_valid_server_encoding_id}
@end defun


@defun free-notify
@findex @func{PQfreeNotify}
Alias for @func{PQfreeNotify}.
@end defun


@defvr Constant invalid-oid
@vindex @func{InvalidOid}
Alias for @func{InvalidOid}.
@end defvr


@defvr Constant no-password-supplied
@vindex @func{PQnoPasswordSupplied}
Alias for @func{PQnoPasswordSupplied}.
@end defvr


@defun escape-string
@findex @func{PQescapeString}
Alias for @func{PQescapeString}.
@end defun


@defun escape-bytea
@findex @func{PQescapeBytea}
Alias for @func{PQescapeBytea}.
@end defun

@c page
@node compensations
@chapter Compensated constructors


The following bindings are exported by the @library{foreign databases
postgresql compensated} library.  This @api{} makes use of the
@library{compensations} library, @nauref{compensations, Compensation
stacks}.


@defun connect-db/c @var{connect-info}
Wrapper for @func{connect-db} which pushes, on the current compensation
stack, the appropriate call to @func{connect-finish} to close the
database connection.
@end defun


@defun connect-start/c @var{connect-info}
Wrapper for @func{connect-start} which pushes, on the current
compensation stack, the appropriate call to @func{connect-finish} to
close the database connection.
@end defun


@defun exec-script/c @var{conn} @var{query-string}
Wrapper for @func{exec-script} which pushes, on the current compensation stack,
the appropriate call to @func{clear-result}.
@end defun


@defun exec-parametrised-query/c @var{conn} @var{query-string} @var{query-parms} @var{textual-result?}
Wrapper for @func{exec-parametrised-query} which pushes, on the current
compensation stack, the appropriate call to @func{clear-result}.
@end defun


@defun prepare-statement/c @var{conn} @var{stmt-name} @var{query-string} @var{number-of-parms}
@defunx prepare-statement/c @var{conn} @var{stmt-name} @var{query-string} @var{number-of-parms} @var{parms-oid}
Wrapper for @func{prepare-statement} which pushes, on the current
compensation stack, the appropriate call to @func{clear-result}.
@end defun


@defun describe-prepared-statement/c @var{conn} @var{stmt-name}
Wrapper for @func{describe-prepared-statement} which pushes, on the
current compensation stack, the appropriate call to @func{clear-result}.
@end defun


@defun exec-prepared-statement/c @var{conn} @var{stmt-name} @var{parms} @var{textual-result?}
Wrapper for @func{exec-prepared-statement/c} which pushes, on the
current compensation stack, the appropriate call to @func{clear-result}.
@end defun


@defun connection-get-result/c @var{conn}
Wrapper for @func{get-result} which pushes, on the current compensation
stack, the appropriate call to @func{clear-result}; if @func{get-result}
returns @false{}, nothing is pushed on the stack.
@end defun


@defun connection-get-cancel-handler/c @var{conn}
Wrapper for @func{connection-get-cancel-handler} which pushes, on the
current compensation stack, the appropriate call to
@func{free-cancel-handler}.
@end defun


@defun describe-portal/c @var{conn} @var{portal-name}
Wrapper for @func{describe-portal} which pushes, on the current
compensation stack, the appropriate call to @func{clear-result}.
@end defun

@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
