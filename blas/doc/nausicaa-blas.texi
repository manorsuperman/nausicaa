\input texinfo.tex
@c %**start of header
@setfilename nausicaa-blas.info
@settitle BLAS for Nausicaa
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@macro condition{NAME}
@code{&\NAME\}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro sql{}
@acronym{SQL}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@macro axml{}
@acronym{XML}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@macro blas{}
@acronym{BLAS}
@end macro

@macro cblas{}
@acronym{CBLAS}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro ssh{}
@acronym{SSH}
@end macro

@macro ssl{}
@acronym{SSL}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro tls{}
@acronym{TLS}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @blas{} for Nausicaa

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@blas{}

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-blas

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2010

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a
distribution of libraries for @rnrs{6} Scheme implementations; it
provides a binding to the @blas{}/@cblas{} C language library.  It is
built upon Nausicaa/Scheme, making use of its foreign--functions
interface.

The libraries support Ikarus, Mosh and Ypsilon Scheme; the package
supports @gnu{}+Linux systems.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/nausicaa/downloads}

@noindent
the project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/tree/master}

@noindent
@blas{} is available at:

@center @url{http://www.netlib.org/blas/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation

The portion of this document describing the @blas{} interface is derived
from the documentation of the @gnu{} Scientific library; the material
has been modified by Marco Maggi.
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-blas: (nausicaa-blas).       @blas{} for Nausicaa.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* constants::                   Constant values.
* examples::                    Examples.
* level1::                      @blas{} interface level 1.
* level2::                      @blas{} interface level 2.
* level3::                      @blas{} interface level 3.
* vm::                          Basic vector and matrix library.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Overview of the package

* overview intro::              Introduction to @blas{}.
* overview libraries::          Installed libraries.
* overview funcs::              Function naming conventions.
* overview args::               Argument naming conventions.

@blas{} interface level 1

* level1 single real::          Level 1 single--precision real
                                numbers.
* level1 double real::          Level 1 double--precision real
                                numbers.
* level1 single complex::       Level 1 single--precision complex
                                numbers.
* level1 double complex::       Level 1 double--precision complex
                                numbers.

Basic vector and matrix library

* vm conventions::              Arguments naming conventions.
* vm vectors::                  Real and complex vectors.
* vm matrices::                 Real and complex matrices.

@end detailmenu
@end menu

@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @version{} of @value{PACKAGE}, a
distribution of libraries for @rnrs{6} Scheme implementations; it
provides a binding to the @blas{}/@cblas{} C language library.  It is
built upon Nausicaa/Scheme, making use of its foreign--functions
interface.

The libraries support Ikarus, Mosh and Ypsilon Scheme; the package
supports @gnu{}+Linux systems.

@menu
* overview intro::              Introduction to @blas{}.
* overview libraries::          Installed libraries.
* overview funcs::              Function naming conventions.
* overview args::               Argument naming conventions.
@end menu

@c page
@node overview intro
@section Introduction to @blas{}


There are three levels of @blas{} operations:

@table @strong
@item Level 1
Vector operations:

@example
y = alpha x + y
@end example

@item Level 2
Matrix--vector operations:

@example
y = alpha A x + beta y
@end example

@item Level 3
Matrix--matrix operations:

@example
C = alpha A B + C
@end example
@end table

@c page
@node overview libraries
@section Installed libraries


The installed libraries are:

@table @library
@item foreign math blas shared-object
Exports the single binding @code{cblas-shared-object} which references
the foreign shared library.

@item foreign math blas sizeof
Exports bindings to constant values.

@item foreign math blas platform
Exports one binding for each foreign function; the bindings to the
Scheme function callouts have the same name of the C functions, so
@cfunc{cblas_sdsdot} is available as @func{cblas_sdsdot}.  This library
makes the original @blas{} documentation relevant for this package.

@item foreign math blas primitives
Exports one binding for each foreign function, reexporting bindings from
the platform library.  The bindings to the Scheme functions have the
same name of the C functions, but the prefix @code{cblas_} is stripped;
so @cfunc{cblas_sdsdot} is available as @func{sdsdot}.

Some platform functions are wrapped by a primitive function which
implements marshaling of arguments; these functions are @strong{not}
reentrant.

@item foreign math blas
Compound library exporting the high--level @api{}; it reexports bindings
from the @samp{primitives} library and the constant values from the
@samp{sizeof} library.

The bindings to constant values are stripped of the prefix @code{Cblas},
converted to lower case and with camel case replaced by dash separators.
@ref{constants, Constant values}.

@item foreign math blas vm
Exports a very basic vector and matrix @api{}, mostly intended for
testing.  @ref{vm, Basic vector and matrix library}.
@end table

@c page
@node overview funcs
@section Function naming conventions


Each @blas{} routine has a name which specifies the operation, the type
of matrices involved and their precisions.  Some of the most common
operations and their names are given below:

@multitable {AXPY} {Matrix--vector product} {Basic formula}
@headitem Name @tab Description @tab Basic formula
@item DOT @tab scalar product @tab @math{x^T y}
@item AXPY @tab vector sum @tab @math{\alpha x + y}
@item MV @tab matrix--vector product @tab @math{A x}
@item SV @tab matrix--vector solve @tab @math{inv(A) x}
@item MM @tab matrix--matrix product @tab @math{A B}
@item SM @tab matrix--matrix solve @tab @math{inv(A) B}
@end multitable

@noindent
the types of matrices are:

@multitable {GE} {triangular packed}
@headitem Name @tab Description
@item GE @tab general
@item GB @tab general band
@item SY @tab symmetric
@item SB @tab symmetric band
@item SP @tab symmetric packed
@item HE @tab hermitian
@item HB @tab hermitian band
@item HP @tab hermitian packed
@item TR @tab triangular
@item TB @tab triangular band
@item TP @tab triangular packed
@end multitable

@noindent
each operation is defined for four precisions:

@multitable {Name} {double complex}
@headitem Name @tab Description
@item S @tab single real
@item D @tab double real
@item C @tab single complex
@item Z @tab double complex
@end multitable

For example, the name @func{sgemm} stands for ``single--precision
general matrix--matrix multiply'' and @func{zgemm} stands for
``double-precision complex matrix--matrix multiply''.

@c page
@node overview args
@section Argument naming conventions


In this document the meaning of the function arguments is as follows.

@table @asis
@item @var{N}
An exact non--negative integer representing the dimension of the
problem; for example the number of elements in vector arguments.

@item @var{SA} @var{SB} @var{SC} @var{SS} @var{SD}
Single--precision floating point number.

@item @var{SX} @var{SY}
Pointers to storage arrays of single--precision floating point numbers
which are meant to hold the elements of logical vectors.  The arrays can
be used both as input values and as storage areas for output values.

An argument @var{SX} is always followed by an argument @var{INC-X}
associated to it.  When these arguments appear, they are always preceded
by an argument @var{N} representing the number of elements to be
accessed.

@item @var{INC-X} @var{INC-Y}
Exact integers representing array strides; an argument @var{INC-X} is
always preceded by an argument @var{SX} associated to it.  The elements
of an array @var{SX} with stride @var{INC-X} are visited as follows
using the counter @math{I} under the Fortran convention of indexing with
base @math{1}:

@example
I = 0 ... (N-1)       SX(LX + I * INC-X)
@end example

@noindent
where:

@example
      -
     | 1                   if INC-X >= 0
LX = |
     | 1 + (1-N) * INC-X   if INC-X < 0
      -
@end example

@noindent
Notice that when @math{INC-X = 0}: a logical vector of @var{N} elements
collapses to an array with a single element; the logical vector has all
the elements equal to the single array element.

@quotation
@strong{EXAMPLE} When @math{INC-X = 2} and @math{N = 5}, the elements
are accessed at array indexes:

@example
1  3  5  7  9
@end example

@noindent
while when @math{INC-X = -2} and @math{N = 5}, it is:

@example
LX = 1+(1-5)*(-2) = 1+(-4)*(-2) = 1+8 = 9
@end example

and the elements are accessed at array indexes:

@example
9  7  5  3  1
@end example

So the array can be accessed forwards or backwards, but the offset with
respect to @var{SX} is always positive.
@end quotation
@end table



@c page
@node constants
@chapter Constant values


The bindings with prefix @code{Cblas} are exported by the
@library{foreign math blas sizeof} library; the bindings without such
prefix are exported by the @library{foreign math blas} library.


@defvr Constant CblasRowMajor
@defvrx Constant row-major
Indicates that elements of each row of a matrix are contiguous in
memory.
@end defvr


@defvr Constant CblasColMajor
@defvrx Constant col-major
Indicates that elements of each column of a matrix are contiguous in
memory.
@end defvr


@defvr Constant CblasNoTrans
@defvrx Constant no-trans
No transpose.
@end defvr


@defvr Constant CblasTrans
@defvrx Constant trans
Transpose.
@end defvr


@defvr Constant CblasConjTrans
@defvrx Constant conj-trans
Conjugate transpose.
@end defvr


@defvr Constant CblasUpper
@defvrx Constant upper
Upper triangular.
@end defvr


@defvr Constant CblasLower
@defvrx Constant lower
Lower triangular.
@end defvr


@defvr Constant CblasNonUnit
@defvrx Constant non-unit
Non--unit triangular.
@end defvr


@defvr Constant CblasUnit
@defvrx Constant unit
Unit triangular.
@end defvr


@defvr Constant CblasLeft
@defvrx Constant left
Left.
@end defvr


@defvr Constant CblasRight
@defvrx Constant right
Right.
@end defvr

@c page
@node examples
@chapter Examples


The following is the example from the file @file{cblas_example1.c} in
the @cblas{} distribution by Netlib.

@example
(import (nausicaa)
  (compensations)
  (only (foreign ffi sizeof) sizeof-double)
  (only (foreign ffi)
        array-set-c-double!
        array-ref-c-double)
  (only (foreign memory) malloc/c)
  (prefix (foreign math blas) blas:))


(with-compensations
  (let* ((order   blas:col-major)
         (transa  blas:no-trans)
         (m       4) ;Size of Column (the number of rows)
         (n       4) ;Size of Row (the number of columns)
         (lda     4) ;Leading dimension of 5 * 4 matrix is 5
         (incx    1)
         (incy    1)
         (alpha   1.)
         (beta    0.)
         (a       (malloc/c (* sizeof-double m n)))
         (x       (malloc/c (* sizeof-double n)))
         (y       (malloc/c (* sizeof-double n))))

    ;; the elements of the first column
    (array-set-c-double! a 0 1.)
    (array-set-c-double! a 1 2.)
    (array-set-c-double! a 2 3.)
    (array-set-c-double! a 3 4.)

    ;; the elements of the second column
    (array-set-c-double! a m  1.)
    (array-set-c-double! a (+ m 1) 1.)
    (array-set-c-double! a (+ m 2) 1.)
    (array-set-c-double! a (+ m 3) 1.)

    ;; the elements of the third column
    (array-set-c-double! a (* m 2)  3.)
    (array-set-c-double! a (+ 1 (* m 2)) 4.)
    (array-set-c-double! a (+ 2 (* m 2)) 5.)
    (array-set-c-double! a (+ 3 (* m 2)) 6.)

    ;; the elements of the fourth column
    (array-set-c-double! a (* m 3)  5.)
    (array-set-c-double! a (+ 1 (* m 3)) 6.)
    (array-set-c-double! a (+ 2 (* m 3)) 7.)
    (array-set-c-double! a (+ 3 (* m 3)) 8.)

    ;; the elements of x and y
    (array-set-c-double! x 0 1.)
    (array-set-c-double! x 1 2.)
    (array-set-c-double! x 2 1.)
    (array-set-c-double! x 3 1.)
    (array-set-c-double! y 0 0.)
    (array-set-c-double! y 1 0.)
    (array-set-c-double! y 2 0.)
    (array-set-c-double! y 3 0.)

    (blas:dgemv order transa m n alpha a lda x incx beta y incy)

    (map (lambda (i)
           (array-ref-c-double y i))
      '(0 1 2 3))))
@result{} (11. 14. 17. 20.)
@end example

@c page
@node level1
@chapter @blas{} interface level 1


@menu
* level1 single real::          Level 1 single--precision real
                                numbers.
* level1 double real::          Level 1 double--precision real
                                numbers.
* level1 single complex::       Level 1 single--precision complex
                                numbers.
* level1 double complex::       Level 1 double--precision complex
                                numbers.
@end menu

@c page
@node level1 single real
@section Level 1 single--precision real numbers


@defun sdot @var{N} @var{SX} @var{INC-X} @var{SY} @var{INC-Y}
Compute the inner (dot) product of two vectors with single--precision
accumulation; return a single--precision result.

@example
SDOT = SX * SY^T
@end example
@end defun


@defun sdsdot @var{N} @var{SB} @var{SX} @var{INC-X} @var{SY} @var{INC-Y}
Compute the inner (dot) product of two vectors with extended--precision
accumulation; return a single--precision result.  The return value is
equal to @var{SB} if @code{N <= 0}.

@example
SDSDOT = SB + SX * SY^T
@end example
@end defun


@defun snrm2 @var{N} @var{SX} @var{INC-X}
Return the euclidean norm of a vector.

@example
SNRM2 = sqrt( SX * SX^T )
@end example
@end defun


@defun sasum @var{N} @var{SX} @var{INC-X}
Return the sum of the absolute values of the elements of a vector.

@example
SASUM = sum_i abs( SX(i) )
@end example
@end defun


@defun isamax @var{N} @var{SX} @var{INC-X}
Return the index of a vector element having maximum absolute value.
@end defun


@defun sswap @var{N} @var{SX} @var{INC-X} @var{SY} @var{INC-Y}
Interchange the elements of two vectors.

@example
(import (rnrs)
  (prefix (foreign math blas vm) vm:)
  (prefix (foreign math blas) blas:))

(with-compensations
  (let* ((N       3)
         (SX      (vm:svec/c N))
         (SY      (vm:svec/c N)))
    (vm:svec-fill! SX 1 '(1. 2. 3.))
    (vm:svec-fill! SY 1 '(4. 5. 6.))
    (blas:sswap N SX 1 SY 1)

    (vm:svec->list N SX 1) @result{} (4. 5. 6.)
    (vm:svec->list N SY 1) @result{} (1. 2. 3.)
    ))
@end example
@end defun


@defun scopy @var{N} @var{SX} @var{INC-X} @var{SY} @var{INC-Y}
Copy elements from @var{SX} to @var{SY}.
@end defun


@defun saxpy @var{N} @var{SA} @var{SX} @var{INC-X} @var{SY} @var{INC-Y}
Mutate the elements of @var{SY} as follows:

@example
SY(i) = SA * SX(i) + SY(i)
@end example
@end defun


@defun srotg @var{SA} @var{SB}
Compute a Givens rotation@footnote{For an introduction see (@aurl{} last
verified Wed Mar 17, 2010):

@center @url{http://en.wikipedia.org/wiki/Givens_rotation}
}
which zeroes the second component of the vector of elements @var{SA} and
@var{SB}; that is, compute @math{SC} and @math{SS} such that:

@example
 SC * SA + SS * SB = SR      SR = sqrt( SA^2 + SB^2 )
-SS * SA + SC * SB = 0
@end example

@noindent
return two values being @var{SC} and @var{SS}.

@example
(receive (SC SS)
    (blas:srotg 2. 3.)
  ---)
@end example
@end defun


@defun srot @var{N} @var{SX} @var{INC-X} @var{SY} @var{INC-Y} @var{SC} @var{SS}
Apply a Givens rotation to the vectors @var{SX} and @var{SY}; the
vectors are mutated to the result.  The mutated elements are computed
as:

@example
SX(i) =  SC * SX(i) + SS * SY(i)
SY(i) = -SS * SX(i) + SC * SY(i)
@end example

@noindent
and the vectors can be of any length.

@example
(import (rnrs)
  (prefix (foreign math blas vm) vm:)
  (prefix (foreign math blas) blas:))

(let* ((SA    2.)
       (SB    3.)
       (SR    (sqrt (+ (sqr SA) (sqr SB)))))
  (receive (SC SS)
      (blas:srotg SA SB)
    (with-compensations
      (let* ((N   2)
             (SX  (vm:svec/c N))
             (SY  (vm:svec/c N)))
        (vm:svec-fill! SX 1 (list SA SA))
        (vm:svec-fill! SY 1 (list SB SB))
        (blas:srot N SX 1 SY 1 SC SS)

        (vm:svec->list N SX 1) @result{} `(,SR ,SR)
        (vm:svec->list N SY 1) @result{} (0. 0.)
        ))))
@end example
@end defun


@defun srotmg @var{SD1} @var{SD2} @var{SX1} @var{SY1} @var{SPARAM}
Construct the modified Givens transformation matrix @math{SH} which
zeros the second component of the vector with elements @math{SA} and
@math{SB}:

@example
SA = sqrt(SD1) * SX1
SB = sqrt(SD2) * SY2
@end example

@noindent
that is:

@example
SH(1,1) * SA + SH(1,2) * SB = SR
SH(2,1) * SA + SH(2,2) * SB = 0
@end example


with sparam(1)=SFLAG, @math{H} has one of the following forms:

@example
SFLAG=-1     SFLAG=0        SFLAG=1     SFLAG=-2

  (SH11  SH12)    (1  SH12)    (SH11  1)    (1  0)
H=(          )    (       )    (       )    (    )
  (SH21  SH22),   (SH21  1),   (-1 SH22),   (0  1).
@end example

locations 2-4 of sparam contain SH11,SH21,SH12, AND SH22 respectively.
(values of 1, -1, or 0 implied by the value of SPARAM(1) are
not stored in SPARAM.)

Arguments
=========

SD1    (input/output) REAL

SD2    (input/output) REAL

SX1    (input/output) REAL

SY1    (input) REAL


SPARAM (input/output)  REAL array, dimension 5
SPARAM(1)=SFLAG
SPARAM(2)=SH11
SPARAM(3)=SH21
SPARAM(4)=SH12
SPARAM(5)=SH22
@end defun

@c page
@node level1 double real
@section Level 1 double--precision real numbers

@c page
@node level1 single complex
@section Level 1 single--precision complex numbers



@defun scnrm2 @var{N} @var{CX} @var{INC-X}
Return the euclidean norm of a vector.

@example
SCNRM2 = sqrt( conjg( CX^T ) * CX )
@end example
@end defun



@c page
@node level1 double complex
@section Level 1 double--precision complex numbers



@defun dsdot @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y}
@defunx ddot @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y}
Compute the scalar product @math{x^T y} for the vectors @var{x} and
@var{y}; return the result.
@end defun


@defun cdotu @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y} @var{dotu}
@defunx zdotu @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y} @var{dotu}
These functions compute the complex scalar product @math{x^T y} for the
vectors @var{x} and @var{y}, returning the result in @var{dotu}.
@end defun


@defun cdotc @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y} @var{dotc}
@defunx zdotc @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y} @var{dotc}
These functions compute the complex conjugate scalar product @math{x^H
y} for the vectors @var{x} and @var{y}, returning the result in
@var{dotc}.
@end defun


@defun dnrm2 @var{n} @var{x} @var{inc-x}
These functions compute the Euclidean norm @math{||x||_2 = \sqrt @{\sum
x_i^2@}} of the vector @var{x}.
@end defun


@defun dznrm2 @var{n} @var{x} @var{inc-x}
These functions compute the Euclidean norm of the complex vector
@var{x}:

@example
||x||_2 = \sqrt @{\sum (\Re(x_i)^2 + \Im(x_i)^2)@}.
@end example
@end defun


@defun dasum @var{n} @var{x} @var{inc-x}
These functions compute the absolute sum @math{\sum |x_i|} of the
elements of the vector @var{x}.
@end defun


@defun scasum @var{n} @var{x} @var{inc-x}
@defunx dzasum @var{n} @var{x} @var{inc-x}
These functions compute the sum of the magnitudes of the real and
imaginary parts of the complex vector @var{x}:

@example
\sum |\Re(x_i)| + |\Im(x_i)|
@end example
@end defun


@defun idamax @var{n} @var{x} @var{inc-x}
@defunx icamax @var{n} @var{x} @var{inc-x}
@defunx izamax @var{n} @var{x} @var{inc-x}
These functions return the index of the largest element of the vector
@var{x}.  If the largest value occurs several times then the index of
the first occurrence is returned.

The largest element is determined by its absolute magnitude for real
vectors and by the sum of the magnitudes of the real and imaginary parts
@math{|\Re(x_i)| + |\Im(x_i)|} for complex vectors.
@end defun


@defun dswap @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y}
@defunx cswap @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y}
@defunx zswap @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y}
These functions exchange the elements of the vectors @var{x} and
@var{y}.
@end defun


@defun dcopy @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y}
@defunx ccopy @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y}
@defunx zcopy @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y}
These functions copy the elements of the vector @var{x} into the vector
@var{y}.
@end defun


@defun daxpy @var{n} @var{alpha} @var{x} @var{inc-x} @var{y} @var{inc-y}
@defunx caxpy @var{n} @var{alpha} @var{x} @var{inc-x} @var{y} @var{inc-y}
@defunx zaxpy @var{n} @var{alpha} @var{x} @var{inc-x} @var{y} @var{inc-y}
These functions compute the sum @math{y = \alpha x + y} for the vectors
@var{x} and @var{y}.
@end defun


@defun drotg (double @var{a}[], double @var{b}[], double @var{c}[], double @var{s}[])
These functions compute a Givens rotation @math{(c,s)} which zeroes the
vector @math{(a,b)}:

@example
[  c  s ] [ a ] = [ r ]
[ -s  c ] [ b ]   [ 0 ]
@end example

@noindent
the variables @var{a} and @var{b} are overwritten by the routine.
@end defun


@defun drot @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y} @var{c} @var{s}
These functions apply a Givens rotation:

@example
x' =  c x + s y
y' = -s x + c y
@end example

@noindent
to the vectors @var{x}, @var{y}.
@end defun


@defun drotmg (double @var{d1}[], double @var{d2}[], double @var{b1}[], double @var{b2}, double @var{P}[])
These functions compute a modified Givens transformation.  The modified
Givens transformation is defined in the original Level-1 @sc{blas}
specification, given in the references.
@end defun


@defun srotm @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y} @var{p}
@defunx drotm @var{n} @var{x} @var{inc-x} @var{y} @var{inc-y} @var{p}
These functions apply a modified Givens transformation.
@end defun


@defun sscal @var{n} @var{alpha} @var{x} @var{inc-x}
@defunx dscal @var{n} @var{alpha} @var{x} @var{inc-x}
@defunx cscal @var{n} @var{alpha} @var{x} @var{inc-x}
@defunx zscal @var{n} @var{alpha} @var{x} @var{inc-x}
@defunx csscal @var{n} @var{alpha} @var{x} @var{inc-x}
@defunx zdscal @var{n} @var{alpha} @var{x} @var{inc-x}
These functions rescale the vector @var{x} by the multiplicative factor
@var{alpha}.
@end defun

@c page
@node level2
@chapter @blas{} interface level 2


@subsubheading Routines with standard 4 prefixes (S, D, C, Z)


@defun sgemv @var{order} @var{tr-a} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx dgemv @var{order} @var{tr-a} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx cgemv @var{order} @var{tr-a} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx zgemv @var{order} @var{tr-a} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@end defun


@defun sgbmv @var{order} @var{tr-a} @var{M} @var{N} @var{KL} @var{KU} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx dgbmv @var{order} @var{tr-a} @var{M} @var{N} @var{KL} @var{KU} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx cgbmv @var{order} @var{tr-a} @var{M} @var{N} @var{KL} @var{KU} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx zgbmv @var{order} @var{tr-a} @var{M} @var{N} @var{KL} @var{KU} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@end defun


@defun strmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx dtrmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx ctrmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx ztrmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{lda} @var{X} @var{inc-X}
@end defun


@defun stbmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{K} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx dtbmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{K} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx ctbmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{K} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx ztbmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{K} @var{A} @var{lda} @var{X} @var{inc-X}
@end defun


@defun stpmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{X} @var{inc-X}
@defunx dtpmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{X} @var{inc-X}
@defunx ctpmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{X} @var{inc-X}
@defunx ztpmv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{X} @var{inc-X}
@end defun



@defun strsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx dtrsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx ctrsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx ztrsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{lda} @var{X} @var{inc-X}
@end defun


@defun stbsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{K} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx dtbsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{K} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx ctbsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{K} @var{A} @var{lda} @var{X} @var{inc-X}
@defunx ztbsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{K} @var{A} @var{lda} @var{X} @var{inc-X}
@end defun


@defun stpsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{X} @var{inc-X}
@defunx dtpsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{X} @var{inc-X}
@defunx ctpsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{X} @var{inc-X}
@defunx ztpsv @var{order} @var{uplo} @var{tr-a} @var{diag} @var{N} @var{A} @var{X} @var{inc-X}

@end defun


@subsubheading Routines with S and D prefixes only


@defun ssymv @var{order} @var{uplo} @var{N} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx dsymv @var{order} @var{uplo} @var{N} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@end defun


@defun ssbmv @var{order} @var{uplo} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx dsbmv @var{order} @var{uplo} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@end defun


@defun sspmv @var{order} @var{uplo} @var{N} @var{alpha} @var{A} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx dspmv @var{order} @var{uplo} @var{N} @var{alpha} @var{A} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@end defun


@defun sger @var{order} @var{M} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A} @var{lda}
@defunx dger @var{order} @var{M} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A} @var{lda}
@end defun


@defun ssyr @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{A} @var{lda}
@defunx dsyr @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{A} @var{lda}
@end defun


@defun sspr @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{A}
@defunx dspr @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{A}
@end defun


@defun ssyr2 @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A} @var{lda}
@defunx dsyr2 @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A} @var{lda}
@end defun


@defun sspr2 @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A}
@defunx dspr2 @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A}
@end defun


@subsubheading Routines with C and Z prefixes only


@defun chemv @var{order} @var{uplo} @var{N} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx zhemv @var{order} @var{uplo} @var{N} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@end defun


@defun chbmv @var{order} @var{uplo} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx zhbmv @var{order} @var{uplo} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@end defun


@defun chpmv @var{order} @var{uplo} @var{N} @var{alpha} @var{A} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@defunx zhpmv @var{order} @var{uplo} @var{N} @var{alpha} @var{A} @var{X} @var{inc-X} @var{beta} @var{Y} @var{inc-Y}
@end defun


@defun cgeru @var{order} @var{M} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A} @var{lda}
@defunx zgeru @var{order} @var{M} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A} @var{lda}
@end defun


@defun cgerc @var{order} @var{M} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A} @var{lda}
@defunx zgerc @var{order} @var{M} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A} @var{lda}
@end defun


@defun cher @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{A} @var{lda}
@defunx zher @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{A} @var{lda}
@end defun


@defun chpr @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{A}
@defunx zhpr @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{A}
@end defun


@defun cher2 @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A} @var{lda}
@defunx zher2 @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A} @var{lda}
@end defun


@defun chpr2 @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A}
@defunx zhpr2 @var{order} @var{uplo} @var{N} @var{alpha} @var{X} @var{inc-X} @var{Y} @var{inc-Y} @var{A}
@end defun

@c page
@node level3
@chapter @blas{} interface level 3


@subsubheading Routines with standard 4 prefixes (S D C Z)


@defun sgemm @var{order} @var{tr-A} @var{tr-B} @var{M} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx dgemm @var{order} @var{tr-A} @var{tr-B} @var{M} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx cgemm @var{order} @var{tr-A} @var{tr-B} @var{M} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx zgemm @var{order} @var{tr-A} @var{tr-B} @var{M} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@end defun


@defun ssymm @var{order} @var{side} @var{uplo} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx dsymm @var{order} @var{side} @var{uplo} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx csymm @var{order} @var{side} @var{uplo} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx zsymm @var{order} @var{side} @var{uplo} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@end defun


@defun ssyrk @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{beta} @var{C} @var{ldc}
@defunx dsyrk @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{beta} @var{C} @var{ldc}
@defunx csyrk @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{beta} @var{C} @var{ldc}
@defunx zsyrk @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{beta} @var{C} @var{ldc}
@end defun


@defun ssyr2k @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx dsyr2k @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx csyr2k @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx zsyr2k @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@end defun


@defun strmm @var{order} @var{side} @var{uplo} @var{tr-A} @var{diag} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb}
@defunx dtrmm @var{order} @var{side} @var{uplo} @var{tr-A} @var{diag} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb}
@defunx ctrmm @var{order} @var{side} @var{uplo} @var{tr-A} @var{diag} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb}
@defunx ztrmm @var{order} @var{side} @var{uplo} @var{tr-A} @var{diag} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb}
@end defun


@defun strsm @var{order} @var{side} @var{uplo} @var{tr-A} @var{diag} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb}
@defunx dtrsm @var{order} @var{side} @var{uplo} @var{tr-A} @var{diag} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb}
@defunx ctrsm @var{order} @var{side} @var{uplo} @var{tr-A} @var{diag} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb}
@defunx ztrsm @var{order} @var{side} @var{uplo} @var{tr-A} @var{diag} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb}
@end defun


@subsubheading Routines with prefixes C and Z only


@defun chemm @var{order} @var{side} @var{uplo} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx zhemm @var{order} @var{side} @var{uplo} @var{M} @var{N} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@end defun


@defun cherk @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{beta} @var{C} @var{ldc}
@defunx zherk @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{beta} @var{C} @var{ldc}
@end defun


@defun cher2k @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@defunx zher2k @var{order} @var{uplo} @var{trans} @var{N} @var{K} @var{alpha} @var{A} @var{lda} @var{B} @var{ldb} @var{beta} @var{C} @var{ldc}
@end defun

@c page
@node vm
@chapter Basic vector and matrix library


The bindings documented here are exported by the @library{foreign math
blas vm} library.  Vectors and matrices supported by this library are
composed of real and complex numbers under @code{float} and
@code{double} representation, following @blas{}' conventions of
prefixing function names with @samp{s}, @samp{d}, @samp{c} and @samp{z}.

@menu
* vm conventions::              Arguments naming conventions.
* vm vectors::                  Real and complex vectors.
* vm matrices::                 Real and complex matrices.
@end menu

@c page
@node vm conventions
@section Arguments naming conventions


Arguments names follow the @blas{} conventions.  The arguments @var{M}
and @var{N} come first; the arguments @var{X} and @var{inc-X} come
together in this order; the arguments @var{A} and @var{lda} come
together in this order.

@table @var
@item M
The number of rows in the matrix arguments.

@item N
The number of columns in the matrix arguments; or the number of rows and
columns in the square matrix arguments; or the number of elements in a
vector.

@item X
@itemx Y
@itemx R
@itemx I
Pointer objects to array of numbers to be interpreted as vectors.  They
must come together with an array stride argument.

@item inc-X
@itemx inc-Y
@itemx inc-R
@itemx inc-I
Exact integers representing the array strides for the arrays referenced
by the associated @var{X}, @var{Y}, @var{R} and @var{I} arguments.

@item A
Pointer object referencing an array of numbers to be interpreted as
matrix.  It must come together with a leading dimension argument
@var{lda}.  It is implied that the layout is column--major and the
elements of a column are laid out as a contiguous array with stride
@math{1}.

@item lda
Exact integer representing the leading dimension of the associated
argument @var{A}.  It is the number of steps, in units of number size,
between the beginning of a column and the beginning of the subsequent
column.

@item val
A generic single number argument.

@item idx
Exact integer representing an element's index in a vector.

@item row
@itemx col
Exact integers representing the row and column indices used to identify
a value in a matrix.
@end table

@c page
@node vm vectors
@section Real and complex vectors


@defun svec/c @var{N}
@defunx dvec/c @var{N}
@defunx cvec/c @var{N}
@defunx zvec/c @var{N}
Allocate an array capable of holding a vector of @var{N} elements;
return a pointer to it.  The appropriate free function is pushed to the
current compensations stack.  @nauref{compensations, Compensation
stacks}.
@end defun


@defun svec-set! @var{X} @var{inc-X} @var{idx} @var{val}
@defunx dvec-set! @var{X} @var{inc-X} @var{idx} @var{val}
@defunx cvec-set! @var{X} @var{inc-X} @var{idx} @var{val}
@defunx zvec-set! @var{X} @var{inc-X} @var{idx} @var{val}
Store the number @var{val} at location @var{IDX} in the vector
referenced by the pointer object @var{X}.
@end defun


@defun svec-ref @var{X} @var{inc-X} @var{idx}
@defunx dvec-ref @var{X} @var{inc-X} @var{idx}
Return the number at location @var{idx} in the vector referenced by the
pointer object @var{X}.
@end defun


@defun svec-fill! @var{X} @var{inc-X} @var{ell}
@defunx dvec-fill! @var{X} @var{inc-X} @var{ell}
@defunx cvec-fill! @var{X} @var{inc-X} @var{ell}
@defunx zvec-fill! @var{X} @var{inc-X} @var{ell}
Fill the vector referenced by the pointer object @var{X} with values
from the list @var{ell}.
@end defun


@defun svec->list @var{N} @var{X} @var{inc-X}
@defunx dvec->list @var{N} @var{X} @var{inc-X}
@defunx cvec->list @var{N} @var{X} @var{inc-X}
@defunx zvec->list @var{N} @var{X} @var{inc-X}
Build and return a list holding the values from the vector referenced by
the pointer @var{X} and length @var{N}.
@end defun


@defun cvec-make-rectangular! @var{N} @var{X} @var{inc-X} @var{R} @var{inc-R} @var{I} @var{inc-I}
@defunx zvec-make-rectangular! @var{N} @var{X} @var{inc-X} @var{R} @var{inc-R} @var{I} @var{inc-I}
Store in @var{X}, a vector of complex numbers, the vectors of real
numbers @var{R} and @var{I} holding, respectively, the real parts and
the imaginary parts.  @var{N} is the length of the vectors.
@end defun

@c page
@node vm matrices
@section Real and complex matrices


For all the following descriptions: the @var{ld} argument is the
``leading dimension'' of the matrix, in @blas{} jargon, and the matrix
is accessed in column--major order.


@defun smat/c @var{M} @var{N}
@defunx dmat/c @var{M} @var{N}
@defunx cmat/c @var{M} @var{N}
@defunx zmat/c @var{M} @var{N}
Allocate an array capable of holding a matrix of @var{M} rows and
@var{N} columns; return a pointer to it.  The appropriate free
function is pushed to the current compensations stack.
@nauref{compensations, Compensation stacks}.
@end defun


@defun smat-set! @var{A} @var{lda} @var{row} @var{col} @var{val}
@defunx dmat-set! @var{A} @var{lda} @var{row} @var{col} @var{val}
@defunx cmat-set! @var{A} @var{lda} @var{row} @var{col} @var{val}
@defunx zmat-set! @var{A} @var{lda} @var{row} @var{col} @var{val}
Store the value @var{val} at location @var{row}, @var{col} in the matrix
referenced by the pointer object @var{A} and column length @var{lda}.
@end defun


@defun smat-ref @var{A} @var{lda} @var{row} @var{col}
@defunx dmat-ref @var{A} @var{lda} @var{row} @var{col}
@defunx cmat-ref @var{A} @var{lda} @var{row} @var{col}
@defunx zmat-ref @var{A} @var{lda} @var{row} @var{col}
Return the value at location @var{row}, @var{col} in the matrix
referenced by the pointer object @var{A} and column length @var{lda}.
@end defun


@defun smat-fill! @var{A} @var{lda} @var{ell}
@defunx dmat-fill! @var{A} @var{lda} @var{ell}
@defunx cmat-fill! @var{A} @var{lda} @var{ell}
@defunx zmat-fill! @var{A} @var{lda} @var{ell}
Fill the matrix referenced by the pointer object @var{A} and column
length @var{lda}, with values from the list @var{ell}.  @var{ell} is a
list of lists in row--major order:

@example
((a_11 a_12 a_13)
 (a_21 a_22 a_23)
 (a_31 a_32 a_33))
@end example
@end defun


@defun smat->list @var{M} @var{N} @var{A} @var{lda}
@defunx dmat->list @var{M} @var{N} @var{A} @var{lda}
@defunx cmat->list @var{M} @var{N} @var{A} @var{lda}
@defunx zmat->list @var{M} @var{N} @var{A} @var{lda}
Build and return a list of lists holding the values, in row--major
order, from the matrix referenced by the pointer @var{A}.  @var{lda} is
the length of a column.  @var{M} and @var{N} are the numbers of rows and
columns.
@end defun

@c page

@include gpl-3.0.texiinc
@include fdl-1.3.texiinc

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
