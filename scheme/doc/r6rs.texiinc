@node r6rs
@chapter Tools for handling @rnrs{6} source code


The libraries under the @library{nausicaa r6rs ---} hierarchy provide
tools to manipulate the Scheme source code compliant with the @rnrs{6}
standard.

@menu
* r6rs lexer::                  Tokenising @rnrs{6} source code.
@end menu

@c page
@node r6rs lexer
@section Tokenising @rnrs{6} source code


The library @library{nausicaa r6rs lexer} implements a lexer compliant
with the @rnrs{6} specification for Scheme source code; the lexer is
built on top of the @library{silex} parser generator.  @ref{silex} for
details about using the @library{silex} library.

@menu
* r6rs lexer strings::          Reading strings.
* r6rs lexer characters::       Reading characters.
* r6rs lexer identifiers::      Reading identifiers.
* r6rs lexer numbers::          Reading numbers.
* r6rs lexer nested comments::  Reading nested comments.
* r6rs lexer line comments::    Reading line comments.
@end menu


@defvr Constant r6rs-lexer-table
A @library{silex} lexer table to parse @rnrs{6} compliant Scheme source
code.
@end defvr

@c page
@node r6rs lexer strings
@subsection Reading strings


@cindex Reading Scheme strings
@cindex Lexer, Scheme strings
@cindex Scheme strings, reading
@cindex Scheme strings, lexer
@cindex Strings in Scheme, lexer
@cindex Strings in Scheme, reader


The following bindings are exported by the @library{nausicaa r6rs lexer}
library.


@defvr Constant r6rs-string-lexer-table
A @library{silex} lexer table to read @rnrs{6} compliant Scheme strings.
A lexer using this table must be used after the opening double quote of
the string has been consumed from the input system.  See the
documentation of @func{read-string} for a usage example.

A lexer function using this table returns:

@itemize
@item
Scheme characters read from the input system.

@item
Scheme strings read from the input system.

@item
A record of class @class{lexical-token} with category @code{*eoi*} when
the end--of--input is found.

@item
A record of class @class{lexical-token} with category
@code{*lexer-error*} when a lexical error is detected in the input
system.

@item
The symbol @code{STRING} when a double quote is read from the input
system.  This symbol signals that the string is finished, we may want to
continue reading with a different lexer function.
@end itemize
@end defvr


@defun read-string @var{IS}
Given a @library{silex} input system from which a double quote character
has already been consumed, read characters composing an @rnrs{6} string
stopping at the ending double quote.  Return the Scheme string.

If an error occurs reading the string: a condition object is raised with
components @condition{lexical}, @condition{message}, @condition{who},
@condition{irritants}; the single value in the @condition{irritants}
list is the string that caused the error.

If end of input is found reading the string: a condition object is
raised with components @condition{lexical}, @condition{message},
@condition{who}, @condition{irritants}; the single value in the
@condition{irritants} list is the end--of--file object.

The implementation of this function is a useful example of usage for
@code{r6rs-string-lexer-table}:

@example
(define (read-string IS)
  (let-values
      (((port getter) (open-string-output-port))
       ((lexer) (lexer-make-lexer r6rs-string-lexer-table IS)))
    (let next (((T <lexical-token>) (lexer)))
      (define (%error message)
        (raise
         (condition (make-lexical-violation)
                    (make-message-condition message)
                    (make-who-condition read-string)
                    (make-irritants-condition (list T.value)))))
      (cond (T.end-of-input?
             (%error "end of input found while reading string"))
            (T.lexer-error?
             (%error "lexical violation while reading string"))
            ((eq? T 'STRING)
             (getter))
            (else
             (display T port)
             (next (lexer)))))))
@end example
@end defun

@c page
@node r6rs lexer characters
@subsection Reading characters


@cindex Reading Scheme characters
@cindex Lexer, Scheme characters
@cindex Scheme characters, reading
@cindex Scheme characters, lexer
@cindex Characters in Scheme, lexer
@cindex Characters in Scheme, reader


The following bindings are exported by the @library{nausicaa r6rs lexer}
library.


@defvr Constant r6rs-character-lexer-table
A @library{silex} lexer table to read @rnrs{6} compliant Scheme
characters.  See the documentation of @func{read-character} for a usage
example.  A lexer function using this table returns:

@itemize
@item
Scheme characters read from the input system.

@item
A record of class @class{lexical-token} with category @code{*eoi*} when
the end--of--input is found.

@item
A record of class @class{lexical-token} with category
@code{*lexer-error*} when a lexical error is detected in the input
system.
@end itemize
@end defvr


@defun read-character @var{IS}
Given an input system, read a single character datum compliant with
@rnrs{6}; return the Scheme character.

If an error occurs reading the character: a condition object is raised
with components @condition{lexical}, @condition{message},
@condition{who}, @condition{irritants}; the single value in the
@condition{irritants} list is the string that caused the error.

If end of input is found reading the character: a condition object is
raised with components @condition{lexical}, @condition{message},
@condition{who}, @condition{irritants}.  The single value in the
irritants list is the end--of--file object.

The implementation of this function is a useful example of usage for
@code{r6rs-character-lexer-table}:

@example
(define (read-character IS)
  (let (((T <lexical-token>)
        ((lexer-make-lexer r6rs-character-lexer-table IS))))
    (define (%error message)
      (raise
       (condition (make-lexical-violation)
                  (make-message-condition message)
                  (make-who-condition 'read-string)
                  (make-irritants-condition (list T.value)))))
    (cond (T.end-of-input?
           (%error "end of input found while reading character"))
          (T.lexer-error?
           (%error "lexical violation while reading character"))
          (else T))))
@end example
@end defun

@c page
@node r6rs lexer identifiers
@subsection Reading identifiers


@cindex Reading Scheme identifiers
@cindex Lexer, Scheme identifiers
@cindex Scheme identifiers, reading
@cindex Scheme identifiers, lexer
@cindex Identifiers in Scheme, lexer
@cindex Identifiers in Scheme, reader


The following bindings are exported by the @library{nausicaa r6rs lexer}
library.


@defvr Constant r6rs-identifier-lexer-table
A @library{silex} lexer table to read @rnrs{6} compliant Scheme
identifiers.  See the documentation of @func{read-identifier} for a
usage example.  A lexer function using this table returns:

@itemize
@item
Scheme symbols read from the input system.

@item
A record of class @class{lexical-token} with category @code{*eoi*} when
the end--of--input is found.

@item
A record of class @class{lexical-token} with category
@code{*lexer-error*} when a lexical error is detected in the input
system.
@end itemize
@end defvr


@defun read-identifier @var{IS}
Given an input system, read a single identifier datum compliant with
@rnrs{6}; return the Scheme symbol.

If an error occurs reading the identifier: a condition object is raised
with components @condition{lexical}, @condition{message},
@condition{who}, @condition{irritants}; the single value in the
@condition{irritants} list is the string that caused the error.

If end of input is found reading the identifier: a condition object is
raised with components @condition{lexical}, @condition{message},
@condition{who}, @condition{irritants}.  The single value in the
irritants list is the end--of--file object.

The implementation of this function is a useful example of usage for
@code{r6rs-identifier-lexer-table}:

@example
(define (read-identifier IS)
  (let (((T <lexical-token>)
        ((lexer-make-lexer r6rs-identifier-lexer-table IS))))
    (define (%error message)
      (raise
       (condition (make-lexical-violation)
                  (make-message-condition message)
                  (make-who-condition 'read-string)
                  (make-irritants-condition (list T.value)))))
    (cond (T.end-of-input?
           (%error
            "end of input found while reading identifier"))
          (T.lexer-error?
           (%error
            "lexical violation while reading identifier"))
          (else T))))
@end example
@end defun

@c page
@node r6rs lexer numbers
@subsection Reading numbers


@cindex Reading Scheme numbers
@cindex Lexer, Scheme numbers
@cindex Scheme numbers, reading
@cindex Scheme numbers, lexer
@cindex Numbers in Scheme, lexer
@cindex Numbers in Scheme, reader


The following bindings are exported by the @library{nausicaa r6rs lexer}
library.


@defvr Constant r6rs-number-lexer-table
A @library{silex} lexer table to read @rnrs{6} compliant Scheme numbers.
See the documentation of @func{read-number} for a usage example.  A
lexer function using this table returns:

@itemize
@item
Scheme numbers read from the input system.

@item
A record of class @class{lexical-token} with category @code{*eoi*} when
the end--of--input is found.

@item
A record of class @class{lexical-token} with category
@code{*lexer-error*} when a lexical error is detected in the input
system.
@end itemize
@end defvr


@defun read-number @var{IS}
Given an input system, read a single number datum compliant with
@rnrs{6}; return the Scheme number.

If an error occurs reading the number: a condition object is raised with
components @condition{lexical}, @condition{message}, @condition{who},
@condition{irritants}; the single value in the @condition{irritants}
list is the string that caused the error.

If end of input is found reading the number: a condition object is
raised with components @condition{lexical}, @condition{message},
@condition{who}, @condition{irritants}.  The single value in the
irritants list is the end--of--file object.

The implementation of this function is a useful example of usage for
@code{r6rs-number-lexer-table}:

@example
(define (read-number IS)
  (let (((T <lexical-token>)
        ((lexer-make-lexer r6rs-number-lexer-table IS))))
    (define (%error message)
      (raise
       (condition (make-lexical-violation)
                  (make-message-condition message)
                  (make-who-condition 'read-string)
                  (make-irritants-condition (list T.value)))))
    (cond (T.end-of-input?
           (%error
            "end of input found while reading number"))
          (T.lexer-error?
           (%error
            "lexical violation while reading number"))
          (else T))))
@end example
@end defun

@c page
@node r6rs lexer nested comments
@subsection Reading nested comments


@cindex Reading Scheme nested comments
@cindex Lexer, Scheme nested comments
@cindex Scheme nested comments, reading
@cindex Scheme nested comments, lexer
@cindex Nested comments in Scheme, lexer
@cindex Nested comments in Scheme, reader


The following bindings are exported by the @library{nausicaa r6rs lexer}
library.


@defvr Constant r6rs-nested-comment-lexer-table
A @library{silex} lexer table to read @rnrs{6} compliant nested comments
of the form @code{#| ... |#}.  See the documentation of
@func{read-nested-comment} for a usage example.  A lexer function using
this table returns:

@itemize
@item
The symbol @code{OPEN} when the sequence @samp{#|} is read from the
input system.

@item
The symbol @code{CLOSE} when the sequence @samp{|#} is read from the
input system.

@item
The single character value read from the input system.

@item
A record of class @class{lexical-token} with category @code{*eoi*} when
the end--of--input is found.

@item
A record of class @class{lexical-token} with category
@code{*lexer-error*} when a lexical error is detected in the input
system.  Notice that this should never happen.
@end itemize
@end defvr


@defun read-nested-comment @var{IS}
Given an input system from which the opening sequence of nested comments
@samp{#|} has already been consumed, read characters composing an
@rnrs{6} nested comment matching sequence @samp{|#}.  Return the comment
as Scheme string enclosed in @samp{#|} and @samp{|#} sequences.

If an error occurs reading the nested comment: a condition object is
raised with components @condition{lexical}, @condition{message},
@condition{who}, @condition{irritants}; the single value in the
&irritants list is the string that caused the error.  Notice that this
should never happen.

If end of input is found reading the nested comment: a condition object
is raised with components @condition{lexical}, @condition{message},
@condition{who}, @condition{irritants}.  The single value in the
irritants list is the end--of--file object.

The implementation of this function is a useful example of usage for
@code{r6rs-nested-comment-lexer-table}:

@example
(define (read-nested-comment IS)
  (let-values
      (((port getter) (open-string-output-port))
       ((lexer) (lexer-make-lexer
                   r6rs-nested-comment-lexer-table IS))
       ((count) 1))
    (display "#|" port)
    (let next (((T <lexical-token>) (lexer)))
      (define (%error message)
        (raise
         (condition (make-lexical-violation)
                    (make-message-condition message)
                    (make-who-condition 'read-nested-comment)
                    (make-irritants-condition (list T.value)))))
      (cond (T.end-of-input?
             (%error
              "end of input found while reading nested comment"))
            (T.lexer-error? ;this should never happen
             (%error
              "lexical violation while reading nested comment"))
            ((eq? T 'CLOSE)
             (decr! count)
             (display "|#" port)
             (if (zero? count)
                 (getter)
               (next (lexer))))
            ((eq? T 'OPEN)
             (incr! count)
             (display "#|" port)
             (next (lexer)))
            (else
             (display T port)
             (next (lexer)))))))
@end example
@end defun

@c page
@node r6rs lexer line comments
@subsection Reading line comments


@cindex Reading Scheme line comments
@cindex Lexer, Scheme line comments
@cindex Scheme line comments, reading
@cindex Scheme line comments, lexer
@cindex Line comments in Scheme, lexer
@cindex Line comments in Scheme, reader


The following bindings are exported by the @library{nausicaa r6rs lexer}
library.


@defvr Constant r6rs-line-comment-lexer-table
A @library{silex} lexer table to read @rnrs{6} compliant line comments;
the comment @strong{must} include the end of line, truncated lines will
cause a lexer error.  See the documentation of @func{read-line-comment}
for a usage example.  A lexer function using this table returns:

@itemize
@item
The comment as a string.

@item
A record of class @class{lexical-token} with category @code{*eoi*} when
the end--of--input is found.

@item
A record of class @class{lexical-token} with category
@code{*lexer-error*} when a lexical error is detected in the input
system.
@end itemize
@end defvr


@defun read-line-comment @var{IS}
Given an input system, read characters composing an @rnrs{6} line
comment.  Return the string representing the comment.

If an error occurs reading the line comment: a condition object is
raised with components @condition{lexical}, @condition{message},
@condition{who}, @condition{irritants}; the single value in the
&irritants list is the string that caused the error.

If end of input is found reading the line comment: a condition object
is raised with components @condition{lexical}, @condition{message},
@condition{who}, @condition{irritants}.  The single value in the
irritants list is the end--of--file object.

The implementation of this function is a useful example of usage for
@code{r6rs-line-comment-lexer-table}:

@example
(define (read-line-comment IS)
  (let (((T <lexical-token>)
        ((lexer-make-lexer r6rs-line-comment-lexer-table IS))))
    (define (%error message)
      (raise
       (condition (make-lexical-violation)
                  (make-message-condition message)
                  (make-who-condition 'read-line-comment)
                  (make-irritants-condition (list T.value)))))
    (cond (T.end-of-input?
           (%error
            "end of input found while reading line comment"))
          (T.lexer-error?
           (%error
           "lexical violation while reading line comment"))
          (else T))))
@end example
@end defun


@c end of file
