@node packrat
@chapter Packrat parser


The @library{packrat} library implements parsing combinators using the
Packrat parsing algorithm: A memoizing, backtracking, recursive descent
parsing technique that runs in time and space linear in the size of the
input text.  There is no single Scheme object which can be named
``Packrat parser'', rather a parser is a collection of combinator
functions calling each other.

The library makes use of the @class{lexical-token} and
@class{source-location} record types, and follows their protocol for
end--of--input and lexer errors handling.  @ref{parser-tools, Lexer and
parser utilities}.

When first experimenting with it, we sould import the library with the
following directive:

@example
(import (rnrs)
  (prefix (packrat) packrat:))
@end example

@noindent
to avoid imported bindings name conflicts.

@menu
* packrat intro::               Introduction to the algorithm.
* packrat calc::                Calculator example.
* packrat types::               Parser state and results.
* packrat comb::                Combinators.
@end menu

@c page
@node packrat intro
@section Introduction to the algorithm


For a generic introduction to parsers, see the tutorial for the
@library{lalr} library.  @ref{lalr intro, Introduction to the LR parser}

@menu
* packrat intro state::         Handling the parser state.
* packrat intro comb::          Combinator functions.
@end menu

@c page
@node packrat intro state
@subsection Handling the parser state


The parser state is represented by a linked list of @class{state}
records, terminated by a thunk which, if evaluated, returns the next
@class{state} record in the list, already chained.  The list is
@strong{not} a Scheme list.

@example
 -----------
|  <state>  |
|           |
| lookahead +--> #<first lexical-token>
|           |
|   next    |
 -----+-----
      |
      v
 -----------
|  <state>  |
|           |
| lookahead +--> #<second lexical-token>
|           |
|    next   |
 -----------
      |
      v
 -----------
|  <state>  |
|           |
| lookahead +--> #<third lexical-token>
|           |
|    next   |
 -----------
      |
      v
 #<procedure>
@end example

Each @class{state} record represents the sequence of subsequent tokens
drawn from the lexer.  By keeping a referenct to a @class{state} record,
we can reparse the same sequence any number of times; this is used to
backtrack from a state to a previous one.

@c page
@node packrat intro comb
@subsection Combinator functions


A @dfn{combinator} is a function accepting a single @class{state} record
as argument and returning a @class{success} or @class{error} record.
The returned record is generated by analysing the tokens in the
@class{state} records; a combinator consuming a single token looks like
this:

@example
(define (combinator state)
  (let* ((token (<state>-lookahead state))
         (value (some-operation token)))
    (if value
        (make-<success> (next-state state) value)
      (make-<error> state "an error description"))))
@end example

@noindent
notice how the returned record holds the next state if it is a
@class{success} and the current state if it is an @class{error}.  A
combinator analysing three tokens looks like this:

@example
(define (combinator state-1)
  (let* ((state-2 (next-state state-1))
         (state-3 (next-state state-2))
         (token-1 (<state>-lookahead state-1))
         (token-2 (<state>-lookahead state-2))
         (token-3 (<state>-lookahead state-3))
         (value (some-operation token-1 token-2 token-3)))
    (if value
        (make-<success> (next-state state-3) value)
      (make-<error> state-1 "an error description"))))
@end example

@noindent
here the successful return record keeps a reference to the state next to
the @strong{last} @class{state} record used to generate it; this means
that given the result of a combinator application, we can access the
deepest parser @class{state} and so continue parsing from there.

Often we chain combinator functions so the second combinator is applied
only if the first one succeeds:

@example
(define (first state)
  (let* ((token (<state>-lookahead state))
         (value (some-operation token)))
    (if value
        (second (next-state state))
      (make-<error> state "an error description"))))

(define (second state)
  (let* ((token (<state>-lookahead state))
         (value (some-operation token)))
    (if value
        (make-<success> (next-state state) value)
      (make-<error> state "an error description"))))

(first init-state)
@end example

@noindent
notice how @func{first} takes care of generating a new @class{state}
record with @func{next-state}.

There are many ways, and so much freedom, in composing combinators to
parse the tokens.  @library{packrat} provides a handful of standard ways
to compose client supplied combinators.

@c page
@node packrat calc
@section Calculator example


The following example implements a simple arithmetics calculator.  First
let's see an S--expressions lexer; the parser expects a lexer closure
returning records of type @class{lexical-token} having terminal category
symbols in the set:

@example
NUMBER OPEN-PAREN CLOSE-PAREN + - * /
@end example

@noindent
the lexer first converts an S--expression into a list of pairs:

@example
(sexp->stream '(1 + 2 + 3))
@result{} ((NUMBER . 1)
    (+)
    (NUMBER . 2)
    (+)
    (NUMBER . 3))

(sexp->stream '((1 + 2) * 3))
@result{} ((OPEN-PAREN)
    (NUMBER . 1)
    (+)
    (NUMBER . 2)
    (CLOSE-PAREN)
    (*)
    (NUMBER . 3))
@end example

@noindent
notice that @samp{(NUMBER . 3)} is a token representation with terminal
category @samp{NUMBER} and semantic value @samp{3}; also, @samp{(+)} is
a token representation with terminal category @samp{+} and semantic
value null.

@example
(define (sexp->stream sexp)
  (define (lexer sexp)
    (let loop ((sexp   (if (pair? sexp)
                           sexp
                         (list sexp)))
               (result '()))
      (if (null? sexp)
          result
        (let ((atom (car sexp)))
          (loop (cdr sexp)
                (cond ((number? atom)
                       `((NUMBER . ,atom) . ,result))
                      ((memq atom '(+ - * /))
                       `((,atom) . ,result))
                      ((pair? atom)
                       (append '((CLOSE-PAREN))
                               (lexer atom)
                               '((OPEN-PAREN))
                               result))
                      (else
                       (error #f "invalid token" atom))))))))
  (reverse (lexer sexp)))
@end example

Then let's see the lexer closure; it takes an S--expression and returns
a thunk which, when evaluated, returns records of type
@class{lexical-token}.  The source location field is set to @false{},
because for an S--expression there is no such information available.

@example
(define (make-lexer-closure sexp)
  (let ((stream (sexp->stream sexp)))
    (lambda ()
      (if (null? stream)
          (make-<lexical-token>/end-of-input #f)
        (let ((token (car stream)))
          (set! stream (cdr stream))
          (make-<lexical-token> (car token) #f
                                (cdr token) 0))))))
@end example

Finally the parser definition; it defines the following non--terminal
symbols:

@table @samp
@item expr
It is the start symbol and represents a general arithmetic expression.

@item mul-expr
It represents a multiplication, a division or a subexpression.  It is
subordinate to @samp{expr} to allow multiplication and division to have
precedence over addition and subtraction.  Also, it allows parenthesised
subexpressions to be evaluated first.

@item simple
It represents subexpressions.  It includes: simple numbers; negated
expressions; expressions preceeded by a standalone plus sign;
parenthesised subexpressions.
@end table

The @func{make-grammar-combinator} macro returns a combinator function
which can be used any number of times to parse S--expressions.

@example
(define calc
  (make-grammar-combinator expr

    (expr     ((a <- mul-expr '+ b <- expr)
               (+ a b))
              ((a <- mul-expr '- b <- expr)
               (- a b))
              ((a <- mul-expr)
               a))

    (mul-expr ((a <- simple '* b <- simple)
               (* a b))
              ((a <- simple '/ b <- simple)
               (/ a b))
              ((a <- simple)
               a))

    (simple   ((a <- 'NUMBER)
               a)
              (('+ a <- expr)
               a)
              (('- a <- expr)
               (- a))
              (('OPEN-PAREN a <- expr 'CLOSE-PAREN)
               a))))
@end example

@noindent
typical usage of the interface is represented by the following function:

@example
(define (doit sexp)
  (let* ((lexer   (make-lexer-closure sexp))
         (result  (calc (initialise-state lexer))))
    (if (<success>? result)
        (<result>-value result)
      (<error>-message result))))
@end example

@noindent
it works like this:

@example
(doit 1)
@result{} 1

(doit '(+ 1))
@result{} 1

(doit '(- 1))
@result{} -1

(doit '(- - + + - + 1))
@result{} -1

(doit '(1 * 2 - 3))
@result{} -1

(doit '((1 + 2) * 3))
@result{} 9

(doit '(+ *))
@result{} "expected token with category OPEN-PAREN"
@end example

@noindent
there are ways to return better error messages.

@c page
@node packrat types
@section Parser state and results


@menu
* packrat types state::         The parser state.
* packrat types result::        Combinators results.
@end menu

@c page
@node packrat types state
@subsection The parser state


@deftp {Record Type} <state>
Represents the state of the parser at a specific point in the input
stream.  Records of this type are the argument for the combinator
functions.  Fields description follows:

@table @samp
@item lookahead
A @class{lexical-token} record from the input stream.  It is the first
token examined by combinators.  This field is immutable.

@item next-state
A @class{state} record or a thunk returning a @class{state} record.  It
represents the next state generated by parsing the token in the
@samp{lookahead} field.  To generate a new state we must do:

@example
(let* ((state ---)
       (next  (<state>-next-state state)))
  (if (<state>? next)
      next
    (next)))
@end example

@noindent
or just call @func{next-state}.

@item memoized-results
An alist mapping keywords to @class{result} records; it represents the
result of applying a combinator to this record.  Each memoizing
combinator must have a unique symbol associated to it, to be used as
keyword for this alist.

Only combinators generated by @func{make-memoize-combinator} access this
field.
@end table
@end deftp


@defun <state>? @var{obj}
Return @true{} if @var{obj} is a record of type @class{state}.
@end defun


@defun <state>-lookahead @var{state}
@defunx <state>-next-state @var{state}
@defunx <state>-memoized-results @var{state}
Field accessors.
@end defun


@defun initialise-state @var{lexer}
Return a @class{state} record representing the whole input stream
generated by @var{lexer}.  @var{lexer} must be a thunk returning
@class{lexical-token} records.
@end defun


@defun next-state @var{state}
Return a @class{state} record representing the input stream after the
token in @var{state}, which must be a @class{state} record.
@end defun


@defun pushback @var{token} @var{state}
Return a @class{state} record representing the input stream
@strong{before} the token in @var{state}, which must be a @class{state}
record.  It can be used to fake reading tokens from the input.
@end defun


@deffn Syntax memoize-acons @var{keyword} @var{result} @var{state}
Memoize the @class{result} record @var{result} in the @class{state}
record @var{state}, associating it to @var{keyword} which must be a
value comparable with @func{eq?}.
@end deffn


@deffn Syntax memoize-assq @var{keyword} @var{state}
Search the memoized result associated to @var{keyword} in the
@class{state} record @var{state}; return @false{} if not found, else a
pair whose car is @var{keyword} and whose cdr is a @class{success} or
@class{error} record.
@end deffn


@deffn Syntax memoize-set! @var{keyword} @var{result} @var{state}
Search the memoized result associated to @var{keyword} in the
@class{state} record @var{state}, then store @var{result} in the cdr of
the entry.  It is an error if the @var{state} has no memoized result
associated to @var{keyword}.
@end deffn

@c page
@node packrat types result
@subsection Combinators results


@deftp {Record Type} <result>
Base type for the return value of the combinator functions.  It is an
``abstract'' type, meaning that it is incorrect to instantiate it
directly.  Fields description follows:

@table @samp
@item state
Immutable field holding a @class{state} record.  If the record is a
@class{success}, this state is the next, still unparsed, one; if the
record is an @class{error}, this state is the one that generated the
error.
@end table
@end deftp


@deftp {Record Type} <success>
Record type derived from @class{result}; it represents the successful
application of a combinator to a @class{state} record.  Fields
description follows:

@table @samp
@item value
An immutable field holding the semantic value generated by the
combinator application.
@end table
@end deftp


@deftp {Record Type} <error>
Record type derived from @class{result}; it represents the failed
application of a combinator to a @class{state} record.  Fields
description follows:

@table @samp
@item message
An immutable field holding a Scheme string describing the error.
@end table
@end deftp


@defun make-<success> @var{next-state} @var{value}
@defunx make-<error> @var{state} @var{error-message}
Record constructors.
@end defun


@defun <result>? @var{obj}
@defunx <success>? @var{obj}
@defunx <error>? @var{obj}
Return @true{} if @var{obj} is a record of type @class{result},
@class{success} or @class{error}.
@end defun


@defun <result>-state @var{result}
@defunx <success>-value @var{success}
@defunx <error>-message @var{error}
Field accessors.
@end defun

@c page
@node packrat comb
@section Combinators


The @dfn{parsing combinators} are functions taking as argument a
@class{state} record and returning a @class{result} record.
@library{packrat} provides a set of combinator makers which can be used
to generate commonly used combinator procedures.

@menu
* packrat comb terminal::       Expecting a token category.
* packrat comb sequence::       Applying combinators in sequence.
* packrat comb or::             Applying alternative combinators.
* packrat comb unless::         Applying failure combinators.
* packrat comb memoize::        Memoizing combinators.
* packrat comb error::          Returning error results.
* packrat comb grammar::        The grammar combinator.
* packrat comb left::           Left recursion problem.
@end menu

@c page
@node packrat comb terminal
@subsection Expecting a token category


One of the most common operations is to verify that the next token
belongs to a specific category; in the end, the state of the parser is
advanced when a combinator matches one or more tokens with the specified
category.  This is used also to check that a @class{state} record
represents the end of input, that is if it has category @samp{*eoi*}.

Basically, a combinator matching a token with category @samp{NUMBER}
should look like this:

@example
(lambda (state)
  (let ((token (<state>-lookahead state)))
    (if (eq? 'NUMBER (<lexical-token>-category token))
        (make-<success> (next-state state)
                        (<lexical-token>-value token))
      (make-<error> state "expected NUMBER token"))))
@end example

@noindent
notice how the returned @class{result} record holds the next state if it
is a @class{success}, and the current state if it is an @class{error}.
We want a method to generate such combinators with the category as
parameter.


@defun make-terminal-combinator @var{category} @var{acceptor}
Return a combinator which, if the next token has category @func{eq?} to
@var{category}, applies the procedure @var{acceptor} to its semantic
value.  The result of this application must be a combinator, which is
applied to the @class{state} record representing the remainder of the
input stream.
@end defun


The following example defines a combinator which checks that the next
token has category @samp{NUMBER} and, if successful, returns a
@samp{success} record (holding the next @class{state} record).  The
acceptor discards the semantic value and returns a combinator which just
builds a @class{success} record.

@example
(define comb
  (make-terminal-combinator 'NUMBER
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))
@end example

The following example defines combinators which check that the next two
tokens have categories @samp{A} and @samp{B} and, if successful, return
a @samp{success} record holding the semantic value of the second.

@example
(define comb-a
  (make-terminal-combinator 'A
    (lambda (semantic-value)
      comb-b)))

(define comb-b
  (make-terminal-combinator 'B
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))
@end example

The following example defines a combinator which checks that the next
two tokens have category @samp{NUMBER} and, if successful, returns a
@samp{success} record holding the sum of the semantic values; the second
combinator is dynamically generated, so that it can reference the
semantic value of the first result:

@example
(define comb
  (make-terminal-combinator 'NUMBER
    (lambda (a)
      (make-terminal-combinator 'NUMBER
        (lambda (b)
          (lambda (state)
            (make-<success> state (+ a b))))))))
@end example

@c page
@node packrat comb sequence
@subsection Applying combinators in sequence.


One of the most common operations is to apply a combinator to a
@class{state} record and, if success, apply another one to the new
state; basically, ``application if success'' goes like this:

@example
(define comb-a
  (lambda (state)
    ---))

(define comb-b
  (lambda (state)
    ---))

(lambda (state)
  (let ((result (comb-a state)))
    (if (<success>? result)
        (comb-b (<result>-state result))
      result)))
@end example

@noindent
we want a method to generate such a combinator with the sequenced
combinators as parameters.


@defun make-sequence-combinator @var{combinator} @var{acceptor}
Return a new combinator which applies @var{combinator} to the state and,
if successful, hands the resulting semantic value to the procedure
@var{acceptor}.  The result of this application must be a combinator,
which is applied to the @class{state} record representing the remainder
of the input stream.
@end defun


The following example defines a sequence combinator which checks if the
next two tokens have categories @samp{A} and @samp{B}:

@example
(define comb-a
  (make-terminal-combinator 'A
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))

(define comb-b
  (make-terminal-combinator 'B
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))

(define comb
  (make-sequence-combinator comb-a
    (lambda (discarded) comb-b)))
@end example

The following example defines a combinator which checks that the next
two tokens have category @samp{NUMBER} and, if successful, returns a
@samp{success} record holding the sum of the semantic values; the second
combinator is dynamically generated:

@example
(define comb
  (packrat:make-sequence-combinator
       (packrat:make-terminal-combinator 'NUMBER
          (lambda (a)
            (lambda (state)
              (packrat:make-<success> state a))))
    (lambda (a)
      (packrat:make-terminal-combinator 'NUMBER
         (lambda (b)
           (lambda (state)
             (packrat:make-<success> state (+ a b))))))))
@end example

@c page
@node packrat comb or
@subsection Applying alternative combinators


A common operation is to apply a combinator when another one has already
failed to match the input; basically, it is like this:

@example
(define comb-a
  (lambda (state)
    ---))

(define comb-b
  (lambda (state)
    ---))

(lambda (state)
  (let ((result (comb-a state)))
    (if (<success>? result)
        result
      (comb-b state))))
@end example

@noindent
we want a method to generate such a combinator with the alternative
combinators as parameters.


@defun make-or-combinator @vari{combinator} @varii{combinator}
Return a new combinator which applies @vari{combinator} to the state; if
successful returns the result, else applies @varii{combinator} and
returns its result.
@end defun


The following example defines an OR combinator which matches if the next
token has category @samp{A} or @samp{B}:

@example
(define comb-a
  (make-terminal-combinator 'A
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))

(define comb-b
  (make-terminal-combinator 'B
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))

(define comb
  (make-or-combinator comb-a comb-b))
@end example

The following example defines an OR combinator which is used to generate
a specific error message:

@example
(define comb
  (make-or-combinator
     (make-terminal-combinator 'A
       (lambda (semantic-value)
         (lambda (state)
           (make-<success> state semantic-value))))
     (lambda (state)
       (make-<error> state "it is not A, dammit!"))))
@end example

@c page
@node packrat comb unless
@subsection Applying failure combinators


It is possible to assert that a particular sequence of tokens does
@strong{not} occur in the current state of the parser; it goes like
this:

@example
(define comb-a
  (lambda (state)
    ---))

(define comb-b
  (lambda (state)
    ---))

(lambda (state)
  (let ((result (comb-a state)))
    (if (<error>? result)
        (comb-b (<result>-state result))
      (make-<error> state "unexpected match"))))
@end example

@noindent
we want a method to generate such a combinator with the combinators as
parameters.


@defun make-unless-combinator @vari{combinator} @varii{combinator}
Return a new combinator which applies @vari{combinator} to the state
and, if error, applies @varii{combinator} to the @class{state} record
representing the remainder of the input stream.
@end defun

@c page
@node packrat comb memoize
@subsection Memoizing combinators


It is possible to memoize the result of applying a combinator into the
@class{state} record itself; simplifying, it goes like this:

@example
(define comb
  (lambda (state)
    ---))

(lambda (state)
  (cond ((memoize-assq 'keyword state) => cdr)
        (else
         (begin0-let ((result (comb state))
           (memoize-acons 'keyword result state)))))))
@end example

@noindent
if a result has been already computed for the state and associated to
@samp{keyword} in the internal alist, then that result is returned; else
the combinator is applied.  We want a method to generate such a
combinator with the keyword and combinator as parameters.


@defun make-memoize-combinator @var{combinator}
@defunx make-memoize-combinator @var{combinator} @var{keyword}
Return a new combinator which first searches @var{keyword} between the
memoized results of the state:

@itemize
@item
If it is found, return the associated @class{result} record.

@item
Else applies @var{combinator} to the state, memoizes the result, then
returns it.
@end itemize

@var{keyword} is the key associated to the result in the @class{state}
record, it must be a value comparable with @func{eq?}; if not supplied,
it defaults to an automatically generated, @func{eq?} comparable value
(actually a sentinel value, @nauref{sentinel, The sentinel value}).
@end defun

@c page
@node packrat comb error
@subsection Returning error results


@defun make-error-combinator @var{error-message}
Return a new combinator which returns an @class{error} record with
@var{error-message} in the @samp{message} field.  The error combinator
can be used to end a sequence, which is known to be invalid, with a
descriptive error message.
@end defun




@c page
@node packrat comb grammar
@subsection The grammar combinator


@deffn Syntax make-grammar-combinator @ameta{start} @ameta{nonterminal} ...
Provide syntactic sugar for building complex parser combinators from
simpler combinators.  Each @meta{nonterminal} must be like this:

@example
@cmeta{nonterminal} -> (@cmeta{identifier} @cmeta{rule}*)

@cmeta{rule} -> (@cmeta{sequence} @cmeta{semantic-clause})

@cmeta{sequence} -> (@cmeta{part}*)
           |  (@cmeta{part}* :error @cmeta{message})
           |  (@cmeta{part}* :exception)

@cmeta{part} -> (:not @cmeta{part}*)
       |  @cmeta{var} <- (quote @cmeta{terminal})
       |  @cmeta{var} <- @cmeta{identifier}
       |  @cmeta{var} <- :source-location
       |  (quote @cmeta{terminal})
       |  @cmeta{identifier}
@end example

@noindent
and it expands into a combinator:

@example
(make-memoize-combinator (lambda (state) ---))
@end example

@noindent
each non--terminal combinator is bound by a @func{letrec*} form to the
respective @meta{identifier}:

@example
(letrec* ((@cmeta{identifier} (make-memoize-combinator ---))
          ...)
  @cmeta{start})
@end example

@noindent
the last expression in the body of the generated @func{letrec*} is
@meta{start}, which can be any expression but must evaluate to a
combinator function.  The simplest @meta{start} is an @meta{identifier},
which causes the macro to return the combinator bound to it.

Since @func{begin} forms within @func{letrec*} forms are flattened
(spliced into the @meta{body}, @nauref{baselib bodies, Bodies}): By
making @meta{start} a @func{begin} form we can introduce bindings to
hand--written combinators which can call (and can be called by) the
non--terminal combinators.

Each @meta{sequence} expands into a combinator; the @meta{sequence}
combinators of a non--terminal combinator, are all alternatives for its
matching.

When a non--terminal combinator is applied to a @class{state} record, it
attempts to match the input tokens against the @meta{sequence}
combinators in its @meta{rule} elements.  The first @meta{rule} is tried
first, then the second and so on, stopping at the first match.  If
matching is successful, the @meta{semantic-clause} is evaluated to
produce a value returned as field of a @class{success} record; else an
@class{error} record is returned.

Each @meta{part} expands to a combinator which, if successful, invokes
the combinator generated by its subsequent @meta{part}; the first
@meta{part} combinator of a @meta{sequence} is invoked by the
@meta{sequence} combinator; the last @meta{part} combinator of a
@meta{sequence} must generate a @class{result} record by itself.

If a @meta{part} combinator, which is not the last in a @meta{sequence},
matches one or more tokens: It must call @func{next-state} to generate a
new @class{state} record and hand it to the next @meta{part} combinator.

If all the @meta{part} combinators in a @meta{sequence} match the
tokens, a @class{success} record is generated by the last one and
returned.  The @class{success} record is registered in the memoized
results of the @class{state} record that started a non--terminal match,
using @meta{identifier} as keyword.

If a @meta{sequence} combinator matches, but its last @meta{part} is
@samp{:error}, an @class{error} record is returned and registered in the
memoized results of the @class{state} record that started the
non--terminal match.

If a @meta{sequence} matches, but its last @meta{part} is
@samp{:exception}, a continuable exception is raised.

If a @meta{part} fails to match: An @class{error} record is generated
and returned.  The @class{error} record is registered in the memoized
results of the @class{state} record that started the non--terminal
mismatch.

The @meta{part} elements can be of the following forms.

@table @samp
@item (quote @cmeta{terminal})
Matches if the lookahead token has category @func{eq?} to
@meta{terminal}; the semantic value of the token is discarded.  Consume
one token.  This @meta{part} makes use of a combinator generated by
@func{make-terminal-combinator}.

@item @cmeta{var} <- (quote @cmeta{terminal})
Matches if the lookahead token has category @func{eq?} to
@meta{terminal}; bind the token's semantic value to @meta{var} and
continue parsing; the subsequent combinators are evaluated in the
augmented environment.  Consume one token.  This @meta{part} makes use
of a combinator generated by @func{make-terminal-combinator}.

@item @cmeta{identifier}
Apply the combinator bound to @meta{identifier} to the current state.
The applied combinator may consume any number of tokens.

@item @cmeta{var} <- @cmeta{identifier}
Apply the combinator bound to @meta{identifier} to the current state.
If successful, bind the resulting semantic value to @meta{var}; the
subsequent combinators are evaluated in the augmented environment.  The
applied combinator may consume any number of tokens.

@item (:not @cmeta{fail-part} ...)
Matches if the lookahead tokens do not match the @meta{fail-part}
elements.  This @meta{part} makes use of a combinator generated by
@func{make-unless-combinator}.

@item @cmeta{var} <- :source-location
Bind the @class{source-location} record in the lookahead token to
@cmeta{var}; the subsequent combinators are evaluated in the augmented
environement.  Consumes no tokens.  This can be used to annotate
abstract syntax trees with source location informations.

@item :error @cmeta{message}
Matches only as last @meta{part} of a @meta{sequence} and consumes no
tokens.  Return an @class{error} record using @cmeta{message} as value
for the @samp{message} field.

@item :exception
Matches only as last @meta{part} of a @meta{sequence} and consumes no
tokens.  The @meta{semantic-clause} of the @meta{rule} is evaluated and
it must return a condition object, which is handed to
@func{raise-continuable}.  If the exception handler returns, it must
return a @class{result} record.  @nauref{stdlib exceptions conditions,
Conditions}
@end table
@end deffn

@c page
@node packrat comb left
@subsection Left recursion problem


The @library{packrat} library implements no special handling to support
left recursive combinators; the implementation of @library{packrat} has
the purpose of keeping the code simple (it is not the only parser
library distributed with @value{PACKAGE}).

To understand the left recursion problem of the Packrat algorithm, let's
examine the following example:

@example
(make-grammar-combinator digits
  (digits  ((a <- digits b <- 'NUM)
            (+ a b))
           ((d <- 'NUM)
            d)))
@end example

@noindent
this grammar defines a non--terminal @samp{digits} whose first
right--hand side rule requires matching of @samp{digits} itself as first
@meta{part}; the combinator bound to @samp{digits} is invoked once when
attempting to match the non--terminal and again when attempting to match
the first rule; the two applications are on the same @class{state}
record, so the result is an infinite recursion.

The same happens with the following grammar, in which the recursion is
indirect:

@example
(make-grammar-combinator digits
  (digits       ((a <- X b <- 'NUM)
                 (+ a b))
                ((d <- 'NUM)
                 d))
  (X            ((d <- digits)
                d)))
@end example

@c end of file
