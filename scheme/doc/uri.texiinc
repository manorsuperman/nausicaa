@node uri
@chapter Uniform resource identifiers


@cindex @library{nausicaa uri}, library
@cindex Library @library{nausicaa uri}


The @library{nausicaa uri} library implements a parser and class type to
handle @uri{}s compliant with @rfc{} 3986 (@aurl{} last verified Thu Jun
17, 2010):

@center @url{http://datatracker.ietf.org/doc/rfc3986/}

@noindent
for an introduction to @uri{}s see (@aurl{} last verified Thu Mar 24,
2011):

@center @url{http://en.wikipedia.org/wiki/Uniform_Resource_Identifier}

The purpose of @library{nausicaa uri} is to convert a @uri{}
representation as bytevector into an instance of @class{uri} class (as
defined by the library @library{nausicaa language classes}), in which
the @uri{} components are available as Scheme strings.

@menu
* uri intro::                   Introduction to @uri{} elements.
* uri conditions::              Condition object types.
* uri string::                  Plain conversion between strings
                                and bytevectors.
* uri percent::                 Percent encoding of characters.
* uri parser::                  @uri{} parser functions.
@end menu

@c page
@node uri intro
@section Introduction to @uri{} elements


@rfc{} 3986 defines the following @uri{} grammar (from ``Appendix A''):

@smallexample
URI-reference = URI | relative-ref

URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

relative-ref  = relative-part [ "?" query ] [ "#" fragment ]

absolute-URI  = scheme ":" hier-part [ "?" query ]

hier-part     = "//" authority path-abempty
              | path-absolute
              | path-rootless
              | path-empty

relative-part = "//" authority path-abempty
              | path-absolute
              | path-noscheme
              | path-empty

scheme        = ALPHA *( ALPHA | DIGIT | "+" | "-" | "." )

authority     = [ userinfo "@@" ] host [ ":" port ]
userinfo      = *( unreserved | pct-encoded | sub-delims | ":" )
host          = IP-literal | IPv4address | reg-name
port          = *DIGIT

IP-literal    = "[" ( IPv6address | IPvFuture  ) "]"

IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved | sub-delims | ":" )

IPv6address   =                            6( h16 ":" ) ls32
              |                       "::" 5( h16 ":" ) ls32
              | [               h16 ] "::" 4( h16 ":" ) ls32
              | [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
              | [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
              | [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
              | [ *4( h16 ":" ) h16 ] "::"              ls32
              | [ *5( h16 ":" ) h16 ] "::"              h16
              | [ *6( h16 ":" ) h16 ] "::"

h16           = 1*4HEXDIG
ls32          = ( h16 ":" h16 ) | IPv4address
IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet

dec-octet     = DIGIT                 ; 0-9
              | %x31-39 DIGIT         ; 10-99
              | "1" 2DIGIT            ; 100-199
              | "2" %x30-34 DIGIT     ; 200-249
              | "25" %x30-35          ; 250-255

reg-name      = *( unreserved | pct-encoded | sub-delims )

path          = path-abempty    ; begins with "/" or is empty
              | path-absolute   ; begins with "/" but not "//"
              | path-noscheme   ; begins with a non-colon segment
              | path-rootless   ; begins with a segment
              | path-empty      ; zero characters

path-abempty  = *( "/" segment )
path-absolute = "/" [ segment-nz *( "/" segment ) ]
path-noscheme = segment-nz-nc *( "/" segment )
path-rootless = segment-nz *( "/" segment )
path-empty    = 0<pchar>

segment       = *pchar
segment-nz    = 1*pchar
segment-nz-nc = 1*( unreserved | pct-encoded | sub-delims | "@@" )
              ; non-zero-length segment without any colon ":"

pchar         = unreserved | pct-encoded | sub-delims | ":" | "@@"

query         = *( pchar | "/" | "?" )

fragment      = *( pchar | "/" | "?" )

pct-encoded   = "%" HEXDIG HEXDIG

unreserved    = ALPHA | DIGIT | "-" | "." | "_" | "~"
reserved      = gen-delims | sub-delims
gen-delims    = ":" | "/" | "?" | "#" | "[" | "]" | "@@"
sub-delims    = "!" | "$" | "&" | "'" | "(" | ")"
              | "*" | "+" | "," | ";" | "="
@end smallexample

@c page
@node uri conditions
@section Condition object types


@menu
* uri conditions parser::       @uri{} parser error condition type.
@end menu

@c page
@node uri conditions parser
@subsection @uri{} parser error condition type


The following bindings are exported by the @library{uri conditions}
library; it is suggested to prefix the bindings when importing the
library.


@deftp {Condition Type} &parser-error
Tag a compound condition object as being an @uri{} parser error; it is
derived from @condition{error}.  It has the following fields:

@table @code
@item offset
Zero--based offset of the byte which caused the error from the beginning
of the input.  Whether it is the offset from the beginning of a full
@uri{} or @uri{} reference or other input depends on the function
raising the exception.
@end table
@end deftp


@defun make-parser-error @var{offset}
Build and return a new condition object of type
@condition{parser-error}.
@end defun


@defun parser-error-condition? @var{obj}
Return true if @var{obj} is a condition object of type
@condition{parser-error}.
@end defun


@defun condition-parser-error/offset @var{obj}
Getter for the field of condition objects of type
@condition{parser-error}.
@end defun

@c page
@node uri string
@section Plain conversion between strings and bytevectors


The following bindings are exported by the @library{uri low} library; it
is suggested to prefix them when importing this library.


@defun to-bytevector @var{obj}
If @var{obj} is a bytevector: @var{obj} itself is returned.  If
@var{obj} is a string: convert it to a bytevector representation;
characters are taken from @var{obj} and inserted into the resulting
bytevector after decoding them, char to byte, as @ascii{}.

If the string has a character whose integer representation is not in the
range @math{[0, 255]}: raise a condition object with components
@condition{parser-error}, @condition{who}, @condition{message},
@condition{irritants}; the irritants value is a list holding @var{obj}.
@end defun


@defun to-string @var{obj}
If @var{obj} is a string: @var{obj} itself is returned.  If @var{obj} is
a bytevector: convert it to a string representation; bytes are taken
from @var{obj} and inserted into the resulting string after encoding
them, byte to char, as @ascii{}.
@end defun

@c page
@node uri percent
@section Percent encoding of characters


A bytevector, whose bytes are interpreted as @ascii{} characters, is
valid as @uri{} component only if its characters match the following
@library{nausicaa silex} specification (@pxref{silex syntax} for the
syntax of the specification):

@example
ALPHA           [a-zA-Z]
DIGIT           [0-9]
HEXDIG          [0-9a-fA-F]

pct-encoded     %@{HEXDIG@}@{HEXDIG@}

gen-delims      [:/\?#\[\]@@]
sub-delims      [\!\$&\'()\*\+,\;=]

reserved        @{gen-delims@}|@{sub-delims@}
unreserved      @{ALPHA@}|@{DIGIT@}|[\-\._~]
@end example

@noindent
all the characters which are not unreserved are meant to be
percent--encoded in a @uri{} string; in particular the following must be
encoded:

@example
: / ? # [ ] @ \ ! $ & ' ( ) * + , ; =
@end example

@noindent
the characters in the unreserved set can, but should not, be encoded.

The following bindings are exported by the @library{uri low} library; it
is suggested to prefix them when importing this library.


@defun unreserved-char? @var{obj}
Return true if @var{obj} represents an unreserved character according to
@rfc{} 3986.  @var{obj} can be either a character or an integer
representing a character according to @func{char->integer}.
@end defun


@deffn Syntax percent-encode @ameta{obj} @ameta{clause} ...
This syntax is a maker, @nauref{makers, Maker syntaxes}.
Percent--encode the given object, return the result; characters outside
a selected range are percent--encoded.

@var{obj} must be an expression evaluating to any character, or string,
or bytevector; the character is converted to a string and the string is
converted to a bytevector with @func{string->utf8}.

The following clauses are supported:

@table @code
@item :char-selector @var{pred}
@var{pred} must be a predicate function which, applied to an integer
representing a character according to @func{char->integer}, returns true
if the character must be percent encoded.  The default is to encode all
the character not unreserved.

@item :string-result? @var{bool}
If @var{bool} is true: return a string, else return a bytevector; the
default is to return a bytevector.
@end table
@end deffn


@deffn Syntax percent-decode @ameta{obj} @ameta{clause} ...
This syntax is a maker, @nauref{makers, Maker syntaxes}.
Percent--decode the given @var{obj}, return the result.

@var{obj} must be an expression evaluating to any string or bytevector;
the string is converted to a bytevector with @func{string->utf8}.

The following clauses are supported:

@table @code
@item :string-result? @var{bool}
If @var{bool} is true: return a string, else return a bytevector; the
default is to return a bytevector.
@end table
@end deffn


@defun normalise-percent-encoded-bytevector @var{bv}
Normalise the given percent--encoded bytevector; bytes that are encoded
but should not are decoded; return the normalised bytevector, in which
percent--encoded characters are displayed in upper case.  Assume that
@var{bv} is composed by bytes in the valid range for @uri{}s.

Notice that this function does @strong{not} percent--encode bytes which
are already not so.
@end defun


@defun normalise-percent-encoded-string @var{str}
Normalise the given percent--encoded string; characters that are encoded
but should not are decoded; return the normalised string, in which
percent--encoded characters are displayed in upper case.  Assume that
@var{str} is composed by characters in the valid range for @uri{}s.

Notice that this function does @strong{not} percent--encode characters
which are already not so.
@end defun

@c page
@node uri parser
@section @uri{} parser functions


All the parser functions attempt to read an @uri{} component from a
binary input port; all of them follow this protocol:

@itemize
@item
If the result of the first read operation is @eof{}: the return value is
@eof{}, which means that the component is not there and it is useless to
try alternatives.

@item
If the result of the read operations matches the desired component or
components: a bytevector or a possibly empty list of bytevectors is
returned; the operation is successful.

@item
If the result of the read operations does not match the desired
component: the return value is the boolean false.

@item
If an invalid input is read, for example an incomplete percent--encoded
sequence, an exception is raised with compound condition object of type
@condition{parser-error}.
@end itemize


@menu
* uri parser basic::            Basic @uri{} component parser functions.
* uri parser authority::        Authority @uri{} components parser
                                functions.
* uri parser segment::          Path segment @uri{} component parser
                                functions.
* uri parser path::             Path @uri{} component parser functions.
* uri parser misc::             Miscellaneous @uri{} parser functions.
@end menu

@c page
@node uri parser basic
@subsection Basic @uri{} component parser functions


The functions can be used to parse the elements of an @uri{}; all the
functions accept a @var{port} argument: it must be a binary input port
drawing characters from an @uri{} bytevector.

The following bindings are exported by the @library{uri low} library; it
is suggested to prefix them when importing this library.


@defun parse-scheme @var{port}
Accumulate bytes from @var{port} while they are valid for the
@code{scheme} component of an @uri{}.  If a colon is found: return a
bytevector holding the accumulated bytes, colon excluded; else return
false.

When successful: leave the port position to the byte after the one
representing the colon; if an error occurs: rewind the port position to
the one before this function call.
@end defun


@defun parse-hier-part @var{port}
Accumulate bytes from @var{port} while they are valid for a
@code{hier-part} @uri{} component.  If an @eof{} or a question mark or a
number sign is found: return a bytevector holding the accumulated bytes,
question mark or number sign excluded; else return false.

Leave the port position to the byte after the last byte of the
@code{hier-part}.  An empty @code{hier-part} is not accepted: if the
first value from the port is @eof{}, the return value is false.

No validation is performed on the returned bytevector.
@end defun


@defun parse-query @var{port}
Accumulate bytes from @var{port} while they are valid for a @code{query}
@uri{} component; the first byte read from @var{port} must be a question
mark.  If an @eof{} or a number sign (@samp{#}) is read: return a
bytevector holding the accumulated bytes, starting question mark
excluded and ending number sign excluded; else return false.

If successful: leave the port position to the byte after the last byte
of the @code{query} component; if an error occurs: rewind the port
position to the one before this function call.

Notice that an empty @code{query} component is valid (a question mark
followed by @eof{}).
@end defun


@defun parse-fragment @var{port}
Accumulate bytes from @var{port} while they are valid for a
@code{fragment} @uri{} component; the first byte read from @var{port}
must be a number sign.  If an @eof{} is read: return a bytevector
holding the accumulated bytes, starting number sign excluded; else
return false.

If successful: leave the port position to the byte after the last byte
of the @code{fragment} component; if an error occurs: rewind the port
position to the one before this function call.

Notice that an empty @code{fragment} component is valid (a question mark
followed by @eof{}).
@end defun

@c page
@node uri parser authority
@subsection Authority @uri{} components parser functions


The functions can be used to parse the elements of an @uri{}; all the
functions accept a @var{port} argument: it must be a binary input port
drawing characters from an @uri{} bytevector.

The following bindings are exported by the @library{uri low} library; it
is suggested to prefix them when importing this library.


@defun parse-authority @var{port}
Accumulate bytes from @var{port} while they are valid for an
@code{authority} component in the @code{hier-part} of an @uri{}.  The
first two bytes read must represent, in @ascii{} encoding, two slash
characters; after the two slashes, if @eof{} or a byte representing a
slash is read: return a bytevector holding the accumulated bytes, ending
slash excluded; else return false.

If successful: leave the port position to the byte after the last
accumulated byte; if an error occurs: rewind the port position to the
one before this function call.

Notice that an empty @code{authority} (after the two slashes) is valid,
corresponding to the case of @code{authority} equal to a @code{host}
component, equal to a @code{reg-name} component which can be empty.
@end defun


@defun parse-userinfo @var{port}
Accumulate bytes from @var{port} while they are valid for an
@code{userinfo} component in the @code{hier-part} of an @uri{}.  If a
byte representing an at sign (@samp{@@}), in @ascii{} encoding, is read:
return a bytevector holding the accumulated bytes, ending at sign
excluded; else return false.

If successful: leave the port position to the byte after the ending at
sign; if an error occurs: rewind the port position to the one before
this function call.

Notice that an empty @code{userinfo} component is valid (an at sign
preceded by nothing).
@end defun


@defun parse-ip-literal @var{port}
Accumulate bytes from @var{port} while they are valid for an
@code{IP-literal} component in the @code{hier-part} of an @uri{}.  The
first byte must represent an open bracket (@samp{[}) character in
@ascii{} encoding; if a byte representing a closed bracket (@samp{]}) is
read: return a bytevector holding the accumulated bytes, brackets
excluded; else return false.

If successful: leave the port position to the byte after the closing
bracket; if an error occurs: rewind the port position to the one before
this function call.

No validation is performed on the returned bytevector contents; the
returned bytevector can be empty even though an @code{IP-literal}
component cannot be of zero length inside the brackets.
@end defun


@defun parse-ipvfuture @var{port}
Accumulate bytes from @var{port} while they are valid for an
@code{IPvFuture} component in the @code{authority} component of an
@uri{}.  The first byte must represent the character @code{v} in
@ascii{} encoding and the second byte must represent a single
hexadecimal digit in @ascii{} encoding; after the prolog is read, bytes
are accumulated until @eof{} is found.

Return two values: an exact integer representing the hexadecimal digit
in @ascii{} encoding, a bytevector holding the accumulated bytes; else
return false and false.

If successful: leave the port position to the byte after the last one
read from the port; if an error occurs: rewind the port position to the
one before this function call.

No validation is performed on the returned bytevector contents; the
returned bytevector can be empty even though an @code{IPvFuture}
component cannot be of zero length inside the brackets.
@end defun


@defun parse-reg-name @var{port}
Accumulate bytes from @var{port} while they are valid for a
@code{reg-name} component in the @code{authority} of an @uri{}; a
@code{reg-name} is one of the alternatives for a @code{host} component.
If @eof{} or a byte representing a colon or a slash, in @ascii{}
encoding, is read: return a bytevector holding the accumulated bytes,
ending colon or slash excluded; else return false.

If successful: leave the port position to the byte after last one read
from the port, ending colon or slash excluded; if an error occurs:
rewind the port position to the one before this function call.

Notice that an empty @code{reg-name} component is valid.
@end defun

@c page
@node uri parser segment
@subsection Path segment @uri{} component parser functions


The following functions can be used to parse the @code{segment},
@code{segment-nz} and @code{segment-nz-nc} components of an @uri{}; the
relevant portion of the grammar is:

@example
segment       = *pchar
segment-nz    = 1*pchar
segment-nz-nc = 1*( unreserved | pct-encoded | sub-delims | "@@" )

pchar         = unreserved | pct-encoded | sub-delims | ":" | "@@"

unreserved    = ALPHA | DIGIT | "-" | "." | "_" | "~"
pct-encoded   = "%" HEXDIG HEXDIG
sub-delims    = "!" | "$" | "&" | "'" | "(" | ")"
              | "*" | "+" | "," | ";" | "="
@end example

The following bindings are exported by the @library{uri low} library; it
is suggested to prefix them when importing this library.  All the
functions accept a @var{port} argument: it must be a binary input port
drawing characters from an @uri{} bytevector.


@defun parse-segment @var{port}
Accumulate bytes from @var{port} while they are valid for a
@code{segment} @uri{} component; notice that an empty @code{segment} is
valid.

If @eof{} or a byte not valid for a @code{segment} is read: return a
bytevector holding the bytes accumulated so far, invalid byte excluded;
the port position is left pointing to the byte after the last
accumulated one.

If an invalid percent--encoded sequence is read, an exception is raised
with type @condition{parser-error}; the port position is rewind to the
one before this function call.
@end defun


@defun parse-segment-nz @var{port}
Accumulate bytes from @var{port} while they are valid for a
@code{segment-nz} @uri{} component; notice that an empty
@code{segment-nz} is @strong{not} valid.

If the first read operation returns @eof{} or an invalid byte: the port
position is restored to the one before this function call and the return
value is false.

If, after at least one valid byte is read, @eof{} or an invalid byte is
read: return a bytevector holding the bytes accumulated so far, invalid
byte excluded; the port position is left pointing to the byte after the
last accumulated one.

If an invalid percent--encoded sequence is read, an exception is raised
with type @condition{parser-error}; the port position is rewind to the
one before this function call.
@end defun


@defun parse-segment-nz-nc @var{port}
Like @func{parse-segment-nz}, but parses the @code{segment-nz-nc}
component which cannot be empty and cannot hold bytes representing colon
characters in @ascii{} encoding.
@end defun


@defun parse-slash-and-segment @var{port}
Attempt to read from @var{port} the sequence: byte representing a slash
character in @ascii{} encoding, @code{segment} component; notice that an
empty @code{segment} is valid.

If these components are successfully read: return a bytevector (possibly
empty) holding the accumulated @code{segment} bytes; the port position
is left pointing to the byte after the last accumulated byte from the
@code{segment}.  Otherwise:

@itemize
@item
If @eof{} is read as first byte: return @eof{}.

@item
If a byte different from slash is read as first byte: return false.

@item
If an invalid percent--encoded sequence is read, an exception is raised
with type @condition{parser-error}; the port position is rewind to the
one before this function call.
@end itemize
@end defun

@c page
@node uri parser path
@subsection Path @uri{} component parser functions


The functions can be used to parse the @code{path-abempty},
@code{path-absolute}, @code{path-noscheme}, @code{path-rootless} and
@code{path-empty} components of an @uri{}; the relevant portion of the
grammar is:

@example
path-abempty  = *( "/" segment )
path-absolute = "/" [ segment-nz *( "/" segment ) ]
path-noscheme = segment-nz-nc *( "/" segment )
path-rootless = segment-nz *( "/" segment )
path-empty    = 0<pchar>
@end example

@noindent
notice that all the @code{path-*} components appear in the grammar as
last components of a @code{hier-part} or @code{relative-part} component,
which in turn can be followed only by a query (starting with a @samp{?}
byte) or a fragment (starting with a @samp{#} byte).

The following bindings are exported by the @library{uri low} library; it
is suggested to prefix them when importing this library.  All the
functions accept a @var{port} argument: it must be a binary input port
drawing characters from an @uri{} bytevector.


@defun parse-path-empty @var{port}
Parse a @code{path-empty} @uri{} component.  Read one byte from
@var{port}: if it is @eof{} return @eof{}; if it represents a question
mark (@samp{?}) or number sign (@samp{#}) in @ascii{} encoding: return
null; else return false.

In any case leave the port position where it was before the function
call.
@end defun


@defun parse-path-abempty @var{port}
Parse from @var{port} a, possibly empty, sequence of sequences: byte
representing the slash character in @ascii{} encoding, @code{segment}
component.  Return a, possibly empty, list holding bytevectors
representing the segments.

If successful: leave the port position to the byte after the last read
byte; if an error occurs: rewind the port position to the one before
this function call.

If an invalid percent--encoded sequence is read, an exception is raised
with type @condition{parser-error}; the port position is rewind to the
one before this function call.
@end defun


@defun parse-path-absolute @var{port}
Parse from @var{port} a @code{path-absolute} @uri{} component.  Return a
list holding bytevectors representing the segments, or false.

If successful: leave the port position to the byte after the last read
byte; if an error occurs: rewind the port position to the one before
this function call.

Notice that a @code{path-absolute} can be just a slash character, with
no segments attached.
@end defun


@defun parse-path-noscheme @var{port}
Parse from @var{port} a @code{path-noscheme} @uri{} component.  Return a
list holding bytevectors representing the segments, or false.

If successful: leave the port position to the byte after the last read
byte; if an error occurs: rewind the port position to the one before
this function call.

Notice that a @code{path-noscheme} must not start with a slash
character, and then it must have at least one non--empty @code{segment}
component.
@end defun


@defun parse-path-rootless @var{port}
Parse from @var{port} a @code{path-rootless} @uri{} component.  Return a
list holding bytevectors representing the segments, or false.

If successful: leave the port position to the byte after the last read
byte; if an error occurs: rewind the port position to the one before
this function call.

Notice that a @code{path-rootless} must not start with a slash
character, and then it must have at least one non--empty @code{segment}
component.
@end defun


@defun parse-path @var{port}
Parse from @var{port} a @code{path} @uri{} component.  Return two
values: false or one of the symbols @code{path-absolute},
@code{path-rootless}; the list of bytevectors representing the segments,
possibly null.

If successful: leave the port position to the byte after the last read
byte; if an error occurs: rewind the port position to the one before
this function call.
@end defun

@c page
@node uri parser misc
@subsection Miscellaneous @uri{} parser functions


The functions can be used to parse the elements of an @uri{}; all the
functions accept a @var{port} argument: it must be a binary input port
drawing characters from an @uri{} bytevector.

The following bindings are exported by the @library{uri low} library; it
is suggested to prefix them when importing this library.


@defun valid-component? @var{port}
Scan bytes from @var{port} until @eof{} is found; return two values: a
boolean, true if the read bytes are valid for a @uri{} component, false
otherwise; an exact integer representing the port position of last byte
read from the port.  The port position is left unchanged when this
function returns.

Ensure that:

@itemize
@item
A byte representing the percent character in @ascii{} encoding is
followed by two bytes representing hexadecimal digits in @ascii{}
encoding.

@item
All the non percent--encoded bytes are in the unreserved set defined by
@rfc{} 3986.
@end itemize
@end defun

@c page
@ignore
The @library{nausicaa uri} library implements a parser and class type to
handle @uri{}s compliant with @rfc{} 3986.@footnote{@aurl{} last
verified Thu Jun 17, 2010:

@center @url{http://datatracker.ietf.org/doc/rfc3986/}
}

@menu
* uri string::                  Plain conversion between strings
                                and bytevectors.
* uri percent::                 Percent encoding of characters.
@end menu

@c page
@node uri string
@section Plain conversion between strings and bytevectors


The following bindings are exported by the @library{nausicaa uri low}
library; it is suggested to prefix them when importing this library.


@defun to-bytevector @var{obj}
If @var{obj} is a bytevector: @var{obj} itself is returned.  If
@var{obj} is a string: convert it to a bytevector representation;
characters are taken from @var{obj} and inserted into the resulting
bytevector after decoding them, char to byte, as @ascii{}.
@end defun


@defun to-string @var{obj}
If @var{obj} is a string: @var{obj} itself is returned.  If @var{obj} is
a bytevector: convert it to a string representation; bytes are taken
from @var{obj} and inserted into the resulting string after encoding
them, byte to char, as @ascii{}.
@end defun

@c page
@node uri percent
@section Percent encoding of characters


A string is valid as @uri{} component only if its characters match the
following @library{nausicaa silex} specification:

@example
ALPHA           [a-zA-Z]
DIGIT           [0-9]
HEXDIG          [0-9a-fA-F]

pct-encoded     %@{HEXDIG@}@{HEXDIG@}

gen-delims      [:/\?#\[\]@@]
sub-delims      [\!\$&\'()\*\+,\;=]

reserved        @{gen-delims@}|@{sub-delims@}
unreserved      @{ALPHA@}|@{DIGIT@}|[\-\._~]
@end example

@noindent
@ref{silex syntax} for the syntax of the specification.  All the
characters which are not unreserved are meant to be percent--encoded in
a @uri{} string; in particular the following must be encoded:

@example
: / ? # [ ] @ \ ! $ & ' ( ) * + , ; =
@end example

@noindent
the characters in the unreserved set can, but should not, be encoded.

The following bindings are exported by the @library{nausicaa uri low}
library; it is suggested to prefix them when importing this library.


@defun unreserved-char? @var{obj}
Return true if @var{obj} represents an unreserved character according to
@rfc{} 3986.  @var{obj} can be either a character or an integer
representing a character according to @func{char->integer}.
@end defun


@deffn Syntax percent-encode @ameta{obj} @ameta{clause} ...
This syntax is a maker, @nauref{makers, Maker syntaxes}.
Percent--encode the given object, return the result; characters outside
a selected range are percent--encoded.

@var{obj} must be an expression evaluating to any character, or string,
or bytevector; the character is converted to a string and the string is
converted to a bytevector with @func{string->utf8}.

The following clauses are supported:

@table @code
@item :char-selector @var{pred}
@var{pred} must be a predicate function which, applied to an integer
representing a character according to @func{char->integer}, returns true
if the character must be percent encoded.  The default is to encode all
the character not unreserved.

@item :string-result? @var{bool}
If @var{bool} is true: return a string, else return a bytevector; the
default is to return a bytevector.
@end table
@end deffn


@deffn Syntax percent-decode @ameta{obj} @ameta{clause} ...
This syntax is a maker, @nauref{makers, Maker syntaxes}.
Percent--decode the given @var{obj}, return the result.

@var{obj} must be an expression evaluating to any string or bytevector;
the string is converted to a bytevector with @func{string->utf8}.

The following clauses are supported:

@table @code
@item :string-result? @var{bool}
If @var{bool} is true: return a string, else return a bytevector; the
default is to return a bytevector.
@end table
@end deffn


@defun normalise-percent-encoded-bytevector @var{bv}
Normalise the given percent--encoded bytevector; bytes that are encoded
but should not are decoded; return the normalised bytevector.  Assume
that @var{bv} is composed by bytes in the valid range for @uri{}s.

Notice that this function does @strong{not} percent--encode bytes which
are already not so.
@end defun


@defun normalise-percent-encoded-string @var{str}
Normalise the given percent--encoded string; characters that are encoded
but should not are decoded; return the normalised string.  Assume that
@var{str} is composed by characters in the valid range for @uri{}s.

Notice that this function does @strong{not} percent--encode characters
which are already not so.
@end defun

@end ignore

@c end of file
