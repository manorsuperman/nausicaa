@node foreign
@chapter Foreign--functions interface


Nausicaa implements a foreign--functions interface towards C language
libraries built upon the interfaces provided by the underlying Scheme
implementations.  The @api{} is exported by the following libraries:

@example
(foreign memory)
(foreign ffi)
(foreign ffi sizeof)
(foreign cstrings)
(foreign errno)
@end example

At present it supports only @gnu{}+Linux systems.

@quotation
@strong{FOR LARCENY} Unfortunately, interfacing with the @ffi{} of
Larceny Scheme has miscellaneous problems; for this reason, the
@library{foreign ---} hierarchy of libraries officially does not support
Larceny.

When a Nausicaa package making use of the @ffi{} is released, we are
authorised to try it with Larceny Scheme, too: if it works, we are all
happy; if it does not work, that is life for us.
@end quotation

@menu
* ffi::                         Foreign--functions interface.
* memory::                      Low level memory handling.
* cstrings::                    C language strings handling.
* errno::                       C language system errors.
@end menu

@c page
@node ffi
@section Foreign--functions interface


@value{PACKAGE} implements an @api{} that allows access to foreign
shared libraries coded in the C language; it is a common interface to
the foreign--functions interfaces of the underlying Scheme
implementations.

The following libraries are installed:

@table @library
@item foreign ffi sizeof
Exports bindings to constant values like the size of C language data
types.

@item foreign ffi conditions
Definition of condition object related to the foreign--functions
interface.

@item foreign ffi pointers
Exports an interface to memory pointer values.

@item foreign ffi peekers-and-pokers
Exports an interface for raw memory access.

@item foreign ffi platform
Exports an adapter interface to the foreign--functions interfaces of the
underlying Scheme implementation.  This library is not meant to be used
directly by client code.

@item foreign ffi primitives
Exports a function--based interface to the constructors of callout and
callback functions.  This library is rarely used by client code.

@item foreign ffi
Exports the high level @api{}, mostly based on macros for user
friendliness.  It re--exports bindings from the following libraries:

@example
(foreign ffi pointers)
(foreign ffi peekers-and-pokers)
@end example
@end table

@menu
* ffi conditions::              Condition objects.
* ffi sizeof::                  Sizes and limits.
* ffi pointers::                Pointer objects.
* ffi access::                  Direct access to memory blocks.
* ffi call::                    Callouts and callbacks.
* ffi struct::                  Accessing data structures.
* ffi headers::                 Inspecting foreign header files.
@end menu

@c page
@node ffi conditions
@subsection Condition objects


@menu
* ffi conditions shared-object::        Shared objects.
* ffi conditions foreign-symbol::       Foreign symbols.
* ffi conditions unknown-shared::       Unknown shared objects.
* ffi conditions unknown-foreign::      Unknown foreign symbols.
@end menu

@c page
@node ffi conditions shared-object
@subsubsection Shared objects


@deftp {Condition Type} &shared-object
Describes a shared object; it is derived from @code{&condition}.  It
holds the following fields:

@table @code
@item object
A foreign library descriptor.
@end table
@end deftp


@defun make-shared-object-condition @var{shared-object}
Build and return a new @code{&shared-object} condition object.
@end defun


@defun shared-object-condition? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@code{&shared-object}.
@end defun


@defun condition-shared-object @var{obj}
If @var{obj} is a condition object of type @code{&shared-object}, return
the value stored in its @code{object} field.
@end defun

@c page
@node ffi conditions foreign-symbol
@subsubsection Foreign symbols


@deftp {Condition Type} &foreign-symbol
Describes a foreign symbol exported by a shared library; it is derived
from @code{&condition}.  It holds the following fields:

@table @code
@item symbol
A Scheme string representing the foreign symbol.
@end table
@end deftp


@defun make-foreign-symbol-condition @var{foreign-symbol}
Build and return a new @code{&foreign-symbol} condition object.
@end defun


@defun foreign-symbol-condition? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@code{&foreign-symbol}.
@end defun


@defun condition-foreign-symbol @var{obj}
If @var{obj} is a condition object of type @code{&foreign-symbol},
return the value stored in its @code{symbol} field.
@end defun

@c page
@node ffi conditions unknown-shared
@subsubsection Unknown shared objects


@deftp {Condition Type} &unknown-shared-object
Describes a failed attempt to open a shared library; it is derived from
@code{&error}.
@end deftp


@defun make-unknown-shared-object-condition
Build and return a new @code{&unknown-shared-object} condition object.
@end defun


@defun unknown-shared-object-condition? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@code{&unknown-shared-object}.
@end defun


@defun raise-unknown-shared-object @var{lib-spec}
@defunx raise-unknown-shared-object @var{lib-spec} @var{who}
@defunx raise-unknown-shared-object @var{lib-spec} @var{who} @var{message}
Build a new composite condition object, as the union of condition
objects of type: @code{&shared-object}, @code{&who}, @code{&message};
raise a continuable exception using the object.

@var{lib-spec} must be a shared library descriptor.  @var{who} must be
the value of the @code{&who} condition; it defaults to @false{}.
@var{message} must be the value of the @code{&message} condition; it
defaults to a standard Scheme string.
@end defun

@c page
@node ffi conditions unknown-foreign
@subsubsection Unknown foreign symbols


@deftp {Condition Type} &unknown-foreign-symbol
Describes a failed attempt to retrieve the address of a foreign symbol
from a shared library; it is derived from @code{&error}.
@end deftp


@defun make-unknown-foreign-symbol-condition
Build and return a new @code{&unknown-foreign-symbol} condition object.
@end defun


@defun unknown-foreign-symbol-condition? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@code{&unknown-foreign-symbol}.
@end defun


@defun raise-unknown-foreign-symbol @var{lib-spec} @var{foreign-symbol}
@defunx raise-unknown-foreign-symbol @var{lib-spec} @var{foreign-symbol} @var{who}
@defunx raise-unknown-foreign-symbol @var{lib-spec} @var{foreign-symbol} @var{who} @var{message}
Build a new composite condition object, as the union of condition
objects of type: @code{&foreign-symbol}, @code{&shared-object},
@code{&who}, @code{&message}; raise a continuable exception using the
object.

@var{lib-spec} must be a shared library descriptor.
@var{foreign-symbol} must be the value of the @code{&foreign-symbol}
condition; @var{who} must be the value of the @code{&who} condition; it
defaults to @false{}.  @var{message} must be the value of the
@code{&message} condition; it defaults to the Scheme string
@code{unknown shared object}.
@end defun

@c page
@node ffi sizeof
@subsection Sizes and limits


The @library{foreign ffi sizeof} library exports a set of bindings to
allow interface libraries to be aware of C language type sizes and
limits.


@defvr Constant pointer-integer
Set to a symbol representing one of the unsigned integer types for
callout arguments and return values.  It is meant to be the integer type
that is equal in size to a pointer, so it can be used in place of the
@samp{pointer} type for Scheme implementations that do not have it (for
example: Larceny checkout 5877).
@end defvr


@defvr Constant sizeof-int8
@defvrx Constant sizeof-int16
@defvrx Constant sizeof-int32
@defvrx Constant sizeof-int64
@defvrx Constant sizeof-char
@defvrx Constant sizeof-short
@defvrx Constant sizeof-int
@defvrx Constant sizeof-long
@defvrx Constant sizeof-long-long
@defvrx Constant sizeof-float
@defvrx Constant sizeof-double
@defvrx Constant sizeof-long-double
@defvrx Constant sizeof-pointer
@defvrx Constant sizeof-size_t
@defvrx Constant sizeof-ssize_t
The number of bytes in the specified type.
@end defvr


@defvr Constant alignof-int8
@defvrx Constant alignof-int16
@defvrx Constant alignof-int32
@defvrx Constant alignof-int64
@defvrx Constant alignof-char
@defvrx Constant alignof-short
@defvrx Constant alignof-int
@defvrx Constant alignof-long
@defvrx Constant alignof-long-long
@defvrx Constant alignof-float
@defvrx Constant alignof-double
@defvrx Constant alignof-long-double
@defvrx Constant alignof-pointer
@defvrx Constant alignof-size_t
@defvrx Constant alignof-ssize_t
The number of bytes of the alignment in data structures for the
specified type.
@end defvr


@defvr Constant strideof-int8
@defvrx Constant strideof-int16
@defvrx Constant strideof-int32
@defvrx Constant strideof-int64
@defvrx Constant strideof-char
@defvrx Constant strideof-short
@defvrx Constant strideof-int
@defvrx Constant strideof-long
@defvrx Constant strideof-long-long
@defvrx Constant strideof-float
@defvrx Constant strideof-double
@defvrx Constant strideof-long-double
@defvrx Constant strideof-pointer
@defvrx Constant strideof-size_t
@defvrx Constant strideof-ssize_t
The number of bytes of the array stride for the specified type.
@end defvr


@deffn Syntax sizeof-int8-array @var{number-of-elements}
@deffnx Syntax sizeof-int16-array @var{number-of-elements}
@deffnx Syntax sizeof-int32-array @var{number-of-elements}
@deffnx Syntax sizeof-int64-array @var{number-of-elements}
@deffnx Syntax sizeof-char-array @var{number-of-elements}
@deffnx Syntax sizeof-short-array @var{number-of-elements}
@deffnx Syntax sizeof-int-array @var{number-of-elements}
@deffnx Syntax sizeof-long-array @var{number-of-elements}
@deffnx Syntax sizeof-long-long-array @var{number-of-elements}
@deffnx Syntax sizeof-float-array @var{number-of-elements}
@deffnx Syntax sizeof-double-array @var{number-of-elements}
@deffnx Syntax sizeof-long-double-array @var{number-of-elements}
@deffnx Syntax sizeof-pointer-array @var{number-of-elements}
@deffnx Syntax sizeof-size_t-array @var{number-of-elements}
@deffnx Syntax sizeof-ssize_t-array @var{number-of-elements}
Compute the number of bytes to allocate to hold an array of the
specified type.
@end deffn


@defvr Constant valueof-char-max
@defvrx Constant valueof-char-min
@defvrx Constant valueof-schar-max
@defvrx Constant valueof-schar-min
@defvrx Constant valueof-uchar-max
@defvrx Constant valueof-shrt-max
@defvrx Constant valueof-shrt-min
@defvrx Constant valueof-ushrt-max
@defvrx Constant valueof-int-max
@defvrx Constant valueof-int-min
@defvrx Constant valueof-uint-max
@defvrx Constant valueof-long-max
@defvrx Constant valueof-long-min
@defvrx Constant valueof-wchar-max
@defvrx Constant valueof-ssize-max
The value of the specified constant.  For example: the value of
@code{valueof-int-max} is the C language constant @code{INT_MAX}.
@end defvr


@defvr Constant words-bigendian
Bound to @true{} if the platform is big endian, @false{} otherwise.
Notice that this information is also available with the @rnrs{6}
function @func{native-endianness}.
@end defvr


@defvr Constant on-32-bits-system
@defvrx Constant on-32-bits-systems
@defvrx Constant on-64-bits-system
@defvrx Constant on-64-bits-systems
Bound to true if the platform has words of @math{32} or @math{64} bits
respectively.
@end defvr

@c page
@node ffi pointers
@subsection Pointer objects


Pointer values are values that the Scheme implementation uses to
represent memory blocks; they are defined by the predicate
@func{pointer?}.  Pointers are disjoint from other Scheme object, but
the specific type used to represent them depends upon the underlying
Scheme implementation.  The only pointer constructor is
@func{integer->pointer}.

The following bindings are exported by @library{foreign ffi pointers}
and re--exported by @library{foreign ffi} and @library{foreign memory}.


@defun pointer? @var{x}
Return @true{} if the value of @var{x} is a value that the Scheme
implementation uses to represent memory blocks, return @false{}
otherwise.
@end defun


@defun pointer-null? @var{pointer}
Return @true{} if @var{pointer} represents a null pointer according to
the underlying Scheme implementation, @false{} otherwise.
@end defun


@deffn Constant pointer-null
Holds a null pointer: If @func{pointer->integer} is applied to it the
result is 0.  This binding exists to hold a prebuilt null pointer to be
used as return value or function argument, whenever it can make
algorithms simpler.
@end deffn


@defun pointer->integer @var{pointer}
Convert a pointer value to an exact integer.
@end defun


@defun integer->pointer @var{exact-integer}
Convert an exact integer to a pointer value.
@end defun


@defun pointer-diff @var{pointer-1} @var{pointer-2}
Return the difference between the pointers.  It is implemented as:

@example
(define (pointer-diff pointer-1 pointer-2)
  (- (pointer->integer pointer-1)
     (pointer->integer pointer-2)))
@end example
@end defun


@defun pointer-add @var{pointer} @var{offset}
Add an offset to a pointer and return the resulting pointer.  It is
implemented as:

@example
(define (pointer-add pointer offset)
  (integer->pointer (+ (pointer->integer pointer)
                       offset)))
@end example
@end defun


@deffn Syntax pointer-incr! @ameta{pointer-var} @ameta{expr}
Expands to:

@example
(set! @cmeta{pointer-var} (pointer-add @cmeta{pointer-var} @cmeta{expr}))
@end example
@end deffn


@defun pointer=? @var{pointer0} @var{pointer} ...
@defunx pointer<? @var{pointer0} @var{pointer} ...
@defunx pointer>? @var{pointer0} @var{pointer} ...
@defunx pointer<=? @var{pointer0} @var{pointer} ...
@defunx pointer>=? @var{pointer0} @var{pointer} ...
@defunx pointer<>? @var{pointer0} @var{pointer} ...
All the arguments must be pointer values and are internally converted to
integers.  Return @true{} if the integers satisfy the selected predicate
(@code{=}, @code{<}, @code{>}, @code{<=}, @code{>=}), otherwise return
@false{}.  @func{pointer<>?} returns @true{} if all the pointers are
different.

With the single exception of @func{pointer<>?}: All the functions return
@true{} when applied to a single argument.
@end defun

@c page
@node ffi access
@subsection Direct access to memory blocks


A rich set of procedures is implemented to access directly memory blocks
referenced by pointer values.  The bindings described in this section
are exported by @library{foreign ffi peekers-and-pokers} and
re--exported by @library{foreign ffi} and @library{foreign memory}.

@menu
* ffi access intro::            Introduction.
* ffi peekers::                 Peeking values.
* ffi pokers::                  Poking values.
* ffi array peekers::           Peeking values into arrays.
* ffi array pokers::            Poking values into arrays.
* ffi array pointers::          Computing pointers into arrays.
@end menu

@c page
@node ffi access intro
@subsubsection Introduction


With all the memory access functions the following notices have to be
considered.

@itemize
@item
The names of the formal arguments follow these conventions:

@table @var
@item pointer
It must be a value used to reference a memory block.  @ref{ffi pointers,
Pointer objects}

@item offset
It must be an exact integer, a fixnum, representing the offset of a byte
into an allocated block of memory; it can be a negative offset.
@end table

@item
When specifying ranges of exact integers: @math{[1, 3]} means a range
that is left--inclusive and right--inclusive; @math{[1, 3)} means a
range that is left--inclusive and right--exclusive, that is @math{[1,
2]}.
@end itemize

@c page
@node ffi peekers
@subsubsection Peeking values


When adding an offset to a pointer: All the following functions
@strong{do not} scale the offset to the size of the peeked value.
Pointer arithmetics is performed with byte offsets.  @ref{ffi array
peekers} for functions that do scale the index.


@subsubheading Peeking fixed--size exact integers


@defun pointer-ref-c-int8 @var{pointer} @var{offset}
@defunx peek-int8 @var{pointer} @var{offset}
Peek the single byte located at @var{offset} from @var{pointer} and
return an exact integer representing the sign--extended integer value of
that byte.  The returned value is in the range @math{[-2^7, 2^7)}, that
is @math{[-128, 127]}.
@end defun


@defun pointer-ref-c-uint8 @var{pointer} @var{offset}
@defunx peek-uint8 @var{pointer} @var{offset}
Peek the single byte located at @var{offset} from @var{pointer} and
return an exact integer representing the unsigned integer value of that
byte.  The returned value is in the range @math{[0, 2^8)}, that is
@math{[0, 255]}.
@end defun


@defun pointer-ref-c-int16 @var{pointer} @var{offset}
@defunx peek-int16 @var{pointer} @var{offset}
Peek two bytes at @var{offset} from @var{pointer} and return an exact
integer representing the sign--extended integer value of the sequence.
The returned value is in the range @math{[-2^15, 2^15)}, that is
@math{[-32768, 32767]}.
@end defun


@defun pointer-ref-c-uint16 @var{pointer} @var{offset}
@defunx peek-uint16 @var{pointer} @var{offset}
Peek two bytes at @var{offset} from @var{pointer} and return an exact
integer representing the unsigned integer value of the sequence.  The
returned value is in the range @math{[0, 2^16)}, that is @math{[0,
65535]}.
@end defun


@defun pointer-ref-c-int32 @var{pointer} @var{offset}
@defunx peek-int32 @var{pointer} @var{offset}
Peek four bytes at @var{offset} from @var{pointer} and return an exact
integer in the range @math{[-2^31, 2^31)}, that is @math{[-2147483648,
2147483647]}.
@end defun


@defun pointer-ref-c-uint32 @var{pointer} @var{offset}
@defunx peek-uint32 @var{pointer} @var{offset}
Peek four bytes at @var{offset} from @var{pointer} and return an exact
integer in the range @math{[0, 2^32)}, that is @math{[0, 4294967295]}.
@end defun


@defun pointer-ref-c-int64 @var{pointer} @var{offset}
@defunx peek-int64 @var{pointer} @var{offset}
Peek eight bytes at @var{offset} from @var{pointer} and return an exact
integer in the range @math{[-2^63, 2^63)}, that is
@math{[9223372036854775808, 9223372036854775807]}.
@end defun


@defun pointer-ref-c-uint64 @var{pointer} @var{offset}
@defunx peek-uint64 @var{pointer} @var{offset}
Peek eight bytes at @var{offset} from @var{pointer} and return an exact
integer in the range @math{[0, 2^64)}, that is @math{[0,
18446744073709551615]}.
@end defun


@subsubheading Peeking C language exact integers


@deffn Procedure pointer-ref-c-signed-char @var{pointer} @var{offset}
@deffnx Procedure peek-signed-char @var{pointer} @var{offset}
Aliases for the fixed--size @samp{int8} peeker.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-char @var{pointer} @var{offset}
@deffnx Procedure peek-unsigned-char @var{pointer} @var{offset}
Aliases for the fixed--size @samp{uint8} peeker.
@end deffn


@deffn Procedure pointer-ref-c-signed-short @var{pointer} @var{offset}
@deffnx Procedure peek-signed-short @var{pointer} @var{offset}
Aliases for the fixed--size peeker whose target matches the size and
range of the @samp{short int} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-short @var{pointer} @var{offset}
@deffnx Procedure peek-unsigned-short @var{pointer} @var{offset}
Aliases for the fixed--size peeker whose target matches the size and
range of the @samp{unsigned short int} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-ref-c-signed-int @var{pointer} @var{offset}
@deffnx Procedure peek-signed-int @var{pointer} @var{offset}
Aliases for the fixed--size peeker whose target matches the size and
range of the @samp{int} C language type of the underlying platform.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-int @var{pointer} @var{offset}
@deffnx Procedure peek-unsigned-int @var{pointer} @var{offset}
Aliases for the fixed--size peeker whose target matches the size and
range of the @samp{unsigned int} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-ref-c-signed-long @var{pointer} @var{offset}
@deffnx Procedure peek-signed-long @var{pointer} @var{offset}
Aliases for the fixed--size peeker whose target matches the size and
range of the @samp{long} C language type of the underlying platform.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-long @var{pointer} @var{offset}
@deffnx Procedure peek-unsigned-long @var{pointer} @var{offset}
Aliases for the fixed--size peeker whose target matches the size and
range of the @samp{unsigned long} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-ref-c-signed-long-long @var{pointer} @var{offset}
@deffnx Procedure peek-signed-long-long @var{pointer} @var{offset}
Aliases for the fixed--size peeker whose target matches the size and
range of the @samp{long long} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-long-long @var{pointer} @var{offset}
@deffnx Procedure peek-unsigned-long-long @var{pointer} @var{offset}
Aliases for the fixed--size peeker whose target matches the size and
range of the @samp{unsigned long long} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-ref-c-size_t @var{pointer} @var{offset}
@deffnx Procedure peek-size_t @var{pointer} @var{offset}
Aliases for the fixed--size peeker whose target matches the size and
range of the @samp{size_t} C language type of the underlying platform.
@end deffn


@deffn Procedure pointer-ref-c-ssize_t @var{pointer} @var{offset}
@deffnx Procedure peek-ssize_t @var{pointer} @var{offset}
Aliases for the fixed--size peeker whose target matches the size and
range of the @samp{ssize_t} C language type of the underlying platform.
@end deffn


@subsubheading Peeking C language floating point numbers


@deffn Procedure pointer-ref-c-float @var{pointer} @var{offset}
@deffnx Procedure peek-float @var{pointer} @var{offset}
Return a flonum Scheme object representing the four--byte @samp{float}
(represented as @ieee{} 754 single precision floating point number)
stored at @var{offset} from @var{pointer}.
@end deffn


@deffn Procedure pointer-ref-c-double @var{pointer} @var{offset}
@deffnx Procedure peek-double @var{pointer} @var{offset}
Return a flonum Scheme object representing the eight--byte @samp{double}
(represented as @ieee{} 754 double precision floating point number)
stored at @var{offset} from @var{pointer}.
@end deffn


@subsubheading Peeking pointers


@deffn Procedure pointer-ref-c-pointer @var{pointer} @var{offset}
@deffnx Procedure pointer-ref-c-void* @var{pointer} @var{offset}
@deffnx Procedure peek-pointer @var{pointer} @var{offset}
@deffnx Procedure peek-void* @var{pointer} @var{offset}
Return a @samp{pointer} value representing the pointer stored at
@var{offset} from @var{pointer}.  The size of the pointer (also the
number of bytes loaded) depends on the architecture: it is @math{4}
bytes on @math{32}-bit systems and @math{8} bytes on @math{64}-bit
systems.
@end deffn

@c page
@node ffi pokers
@subsubsection Poking values


When adding an offset to a pointer: All the following functions
@strong{do not} scale the offset to the size of the poked value.
Pointer arithmetics is performed with byte offsets.  @ref{ffi array
pokers}, for functions that do scale the index.


@subsubheading Poking fixed--size exact integers


@defun pointer-set-c-int8! @var{pointer} @var{offset} @var{value}
@defunx poke-int8! @var{pointer} @var{offset} @var{value}
Set to @var{value} the single byte located at @var{offset} from
@var{pointer}.  @var{value} must be an exact integer in the range
@math{[-2^7, 2^7)}, that is @math{[-128, 127]}.
@end defun


@defun pointer-set-c-uint8! @var{pointer} @var{offset} @var{value}
@defunx poke-uint8! @var{pointer} @var{offset} @var{value}
Set to @var{value} the single byte located at @var{offset} from
@var{pointer}.  @var{value} must be an exact integer in the range
@math{[0, 2^8)}, that is @math{[0, 255]}.
@end defun


@defun pointer-set-c-int16! @var{pointer} @var{offset} @var{value}
@defunx poke-int16! @var{pointer} @var{offset} @var{value}
Setto @var{value} the two bytes at @var{offset} from @var{pointer}.
@var{value} must be an exact integer in the range @math{[-2^15, 2^15)},
that is @math{[-32768, 32767]}.
@end defun


@defun pointer-set-c-uint16! @var{pointer} @var{offset} @var{value}
@defunx poke-uint16! @var{pointer} @var{offset} @var{value}
Set to @var{value} the two bytes at @var{offset} from @var{pointer}.
@var{value} must be an exact integer in the range @math{[0, 2^16)}, that
is @math{[0, 65535]}.
@end defun


@defun pointer-set-c-int32! @var{pointer} @var{offset} @var{value}
@defunx poke-int32! @var{pointer} @var{offset} @var{value}
Set to @var{value} the four bytes at @var{offset} from @var{pointer}.
@var{value} must be an exact integer in the range @math{[-2^31, 2^31)},
that is @math{[-2147483648, 2147483647]}.
@end defun


@defun pointer-set-c-uint32! @var{pointer} @var{offset} @var{value}
@defunx poke-uint32! @var{pointer} @var{offset} @var{value}
Set to @var{value} the four bytes at @var{offset} from @var{pointer}.
@var{value} must be an exact integer in the range @math{[0, 2^32)}, that
is @math{[0, 4294967295]}.
@end defun


@defun pointer-set-c-int64! @var{pointer} @var{offset} @var{value}
@defunx poke-int64! @var{pointer} @var{offset} @var{value}
Set to @var{value} the eight bytes at @var{offset} from @var{pointer}.
@var{value} must be an exact integer in the range @math{[-2^63, 2^63)},
that is @math{[9223372036854775808, 9223372036854775807]}.
@end defun


@defun pointer-set-c-uint64! @var{pointer} @var{offset} @var{value}
@defunx poke-uint64! @var{pointer} @var{offset} @var{value}
Set to @var{value} the eight bytes at @var{offset} from @var{pointer}.
@var{value} must be an exact integer in the range @math{[0, 2^64)}, that
is @math{[0, 18446744073709551615]}.
@end defun


@subsubheading Poking C language exact integers


@deffn Procedure pointer-set-c-signed-char! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-signed-char! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size @samp{int8} pokers.
@end deffn


@deffn Procedure pointer-set-c-unsigned-char! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-unsigned-char! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size @samp{uint8} pokers.
@end deffn


@deffn Procedure pointer-set-c-signed-short! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-signed-short! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size pokers whose target matches the size and
range of the @samp{short int} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-set-c-unsigned-short! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-unsigned-short! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size pokers whose target matches the size and
range of the @samp{unsigned short int} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-set-c-signed-int! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-signed-int! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size pokers whose target matches the size and
range of the @samp{int} C language type of the underlying platform.
@end deffn


@deffn Procedure pointer-set-c-unsigned-int! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-unsigned-int! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size pokers whose target matches the size and
range of the @samp{unsigned int} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-set-c-signed-long! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-signed-long! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size pokers whose target matches the size and
range of the @samp{long} C language type of the underlying platform.
@end deffn


@deffn Procedure pointer-set-c-unsigned-long! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-unsigned-long! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size pokers whose target matches the size and
range of the @samp{unsigned long} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-set-c-signed-long-long! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-signed-long-long! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size pokers whose target matches the size and
range of the @samp{long long} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-set-c-unsigned-long-long! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-unsigned-long-long! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size pokers whose target matches the size and
range of the @samp{unsigned long long} C language type of the underlying
platform.
@end deffn


@deffn Procedure pointer-set-c-size_t! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-size_t! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size pokers whose target matches the size and
range of the @samp{size_t} C language type of the underlying platform.
@end deffn


@deffn Procedure pointer-set-c-ssize_t! @var{pointer} @var{offset} @var{value}
@deffnx Procedure poke-ssize_t! @var{pointer} @var{offset} @var{value}
Aliases for the fixed--size pokers whose target matches the size and
range of the @samp{ssize_t} C language type of the underlying platform.
@end deffn


@subsubheading Poking C language floating point numbers


@deffn Procedure pointer-set-c-float! @var{pointer} @var{offset} @var{flonum}
@deffnx Procedure poke-float! @var{pointer} @var{offset} @var{flonum}
Convert the Scheme floating point number @var{flonum} to a C language
@samp{float} (an @ieee{} 754 single precision floating point number) and
store the result in the four bytes at @var{offset} from @var{pointer}.
@end deffn


@deffn Procedure pointer-set-c-double! @var{pointer} @var{offset} @var{flonum}
@deffnx Procedure poke-double! @var{pointer} @var{offset} @var{flonum}
Convert the Scheme floating point number @var{flonum} to a C language
@samp{double} (an @ieee{} 754 double precision floating point number)
and store the result in the eight bytes at @var{offset} from
@var{pointer}.
@end deffn


@subsubheading Poking pointers


@deffn Procedure pointer-set-c-pointer! @var{pointer} @var{offset} @var{pointer-value}
@deffnx Procedure pointer-set-c-void*! @var{pointer} @var{offset} @var{pointer-value}
@deffnx Procedure poke-pointer! @var{pointer} @var{offset} @var{pointer-value}
@deffnx Procedure poke-void*! @var{pointer} @var{offset} @var{pointer-value}
Set to @var{pointer-value}, which must be a @samp{pointer}, the location
at @var{offset} from @var{pointer}.  The size of the pointer (also the
number of bytes stored) depends on the architecture: it is @math{4}
bytes on @math{32}-bit systems and @math{8} bytes on @math{64}-bit
systems.
@end deffn

@c page
@node ffi array peekers
@subsubsection Peeking values into arrays


The following functions make use of the peekers to access an array of
basic C language data types.  The index is used to compute the position
of the first byte taking into account the element stride of the data
type.

To allocate an array of a given type, we can compute the correct size
using the @samp{sizeof-*-array} bindings.  @ref{ffi sizeof,
sizeof-char-array}


@subsubheading Peeking fixed--size exact integers


@defun array-ref-c-int8 @var{pointer} @var{index}
@defunx peek-array-int8 @var{pointer} @var{index}
Return the value at @var{index} in the signed bytes array referenced by
@var{pointer}.  The returned value is in the range @math{[-2^7, 2^7)},
that is @math{[-128, 127]}.
@end defun


@defun array-ref-c-uint8 @var{pointer} @var{index}
@defunx peek-array-uint8 @var{pointer} @var{index}
Return the value at @var{index} in the unsigned bytes array referenced
by @var{pointer}.  The returned value is in the range @math{[0, 2^8)},
that is @math{[0, 255]}.
@end defun


@defun array-ref-c-int16 @var{pointer} @var{index}
@defunx peek-array-int16 @var{pointer} @var{index}
Return the signed exact integer represented by the two bytes at
@var{index} in the array referenced by @var{pointer}.  The returned
value is in the range @math{[-2^15, 2^15)}, that is @math{[-32768,
32767]}.
@end defun


@defun array-ref-c-uint16 @var{pointer} @var{index}
@defunx peek-array-uint16 @var{pointer} @var{index}
Return the unsigned exact integer represented by the two bytes at
@var{index} in the array referenced by @var{pointer}.  The returned
value is in the range @math{[0, 2^16)}, that is @math{[0, 65535]}.
@end defun


@defun array-ref-c-int32 @var{pointer} @var{index}
@defunx peek-array-int32 @var{pointer} @var{index}
Return the signed exact integer represented by the four bytes at
@var{index} in the array referenced by @var{pointer}.  The returned
value is in the range @math{[-2^31, 2^31)}, that is @math{[-2147483648,
2147483647]}.
@end defun


@defun array-ref-c-uint32 @var{pointer} @var{index}
@defunx peek-array-uint32 @var{pointer} @var{index}
Return the unsigned exact integer represented by the four bytes at
@var{index} in the array referenced by @var{pointer}.  The returned
value is in the range @math{[0, 2^32)}, that is @math{[0, 4294967295]}.
@end defun


@defun array-ref-c-int64 @var{pointer} @var{index}
@defunx peek-array-int64 @var{pointer} @var{index}
Return the signed exact integer represented by the eight bytes at
@var{index} in the array referenced by @var{pointer}.  The returned
value is in the range @math{[-2^63, 2^63)}, that is
@math{[9223372036854775808, 9223372036854775807]}.
@end defun


@defun array-ref-c-uint64 @var{pointer} @var{index}
@defunx peek-array-uint64 @var{pointer} @var{index}
Return the unsigned exact integer represented by the eight bytes at
@var{index} in the array referenced by @var{pointer}.  The returned
value is in the range @math{[0, 2^64)}, that is @math{[0,
18446744073709551615]}.
@end defun


@subsubheading Peeking C language exact integers


@defun array-ref-c-signed-char @var{pointer} @var{index}
@defunx peek-array-signed-char @var{pointer} @var{index}
Aliases for the @samp{int8} fixed--size array peeker.
@end defun


@defun array-ref-c-unsigned-char @var{pointer} @var{index}
@defunx peek-array-unsigned-char @var{pointer} @var{index}
Aliases for the @samp{uint8} fixed--size array peeker.
@end defun


@defun array-ref-c-signed-short @var{pointer} @var{index}
@defunx peek-array-signed-short @var{pointer} @var{index}
Aliases for the fixed--size array peeker whose target matches the size
and range of the @samp{short int} C language type of the underlying
platform.
@end defun


@defun array-ref-c-unsigned-short @var{pointer} @var{index}
@defunx peek-array-unsigned-short @var{pointer} @var{index}
Aliases for the fixed--size array peeker whose target matches the size
and range of the @samp{unsigned short int} C language type of the
underlying platform.
@end defun


@defun array-ref-c-signed-int @var{pointer} @var{index}
@defunx peek-array-signed-int @var{pointer} @var{index}
Aliases for the fixed--size array peeker whose target matches the size
and range of the @samp{int} C language type of the underlying platform.
@end defun


@defun array-ref-c-unsigned-int @var{pointer} @var{index}
@defunx peek-array-unsigned-int @var{pointer} @var{index}
Aliases for the fixed--size array peeker whose target matches the size
and range of the @samp{unsigned int} C language type of the underlying
platform.
@end defun


@defun array-ref-c-signed-long @var{pointer} @var{index}
@defunx peek-array-signed-long @var{pointer} @var{index}
Aliases for the fixed--size array peeker whose target matches the size
and range of the @samp{long} C language type of the underlying platform.
@end defun


@defun array-ref-c-unsigned-long @var{pointer} @var{index}
@defunx peek-array-unsigned-long @var{pointer} @var{index}
Aliases for the fixed--size array peeker whose target matches the size
and range of the @samp{unsigned long} C language type of the underlying
platform.
@end defun


@defun array-ref-c-signed-long-long @var{pointer} @var{index}
@defunx peek-array-signed-long-long @var{pointer} @var{index}
Aliases for the fixed--size array peeker whose target matches the size
and range of the @samp{long long} C language type of the underlying
platform.
@end defun


@defun array-ref-c-unsigned-long-long @var{pointer} @var{index}
@defunx peek-array-unsigned-long-long @var{pointer} @var{index}
Aliases for the fixed--size array peeker whose target matches the size
and range of the @samp{unsigned long long} C language type of the
underlying platform.
@end defun


@subsubheading Peeking C language floating pointer numbers


@defun array-ref-c-float @var{pointer} @var{index}
@defunx peek-array-float @var{pointer} @var{index}
Return a flonum Scheme object representing the four--byte @samp{float}
(represented as @ieee{} 754 single precision floating point number)
stored at @var{index} in the array referenced by @var{pointer}.
@end defun


@defun array-ref-c-double @var{pointer} @var{index}
@defunx peek-array-double @var{pointer} @var{index}
Return a flonum Scheme object representing the eight--byte @samp{double}
(represented as @ieee{} 754 double precision floating point number)
stored at @var{index} in the array referenced by @var{pointer}.
@end defun


@subsubheading Peeking pointers


@defun array-ref-c-pointer @var{pointer} @var{index}
@defunx array-ref-c-void* @var{pointer} @var{index}
@defunx peek-array-pointer @var{pointer} @var{index}
@defunx peek-array-void* @var{pointer} @var{index}
Return a @samp{pointer} value representing the pointer stored at
@var{index} in the array referenced by @var{pointer}.  The size of the
pointer (also the number of bytes loaded) depends on the architecture:
it is @math{4} bytes on @math{32}-bit systems and @math{8} bytes on
@math{64}-bit systems.
@end defun

@c page
@node ffi array pokers
@subsubsection Poking values into arrays


The following functions make use of the pokers to access an array of
basic C language data types.  The index is used to compute the position
of the first byte taking into account the element stride of the data
type.

To allocate an array of a given type, we can compute the correct size
using the @samp{sizeof-*-array} bindings.  @ref{ffi sizeof,
sizeof-char-array}


@subsubheading Poking fixed--size exact integers


@defun array-set-c-int8! @var{pointer} @var{index} @var{value}
@defunx poke-array-int8! @var{pointer} @var{index} @var{value}
Set to @var{value} the single byte at @var{index} in the array
referenced by @var{pointer}.  @var{value} must be in the range
@math{[-2^7, 2^7)}, that is @math{[-128, 127]}.
@end defun


@defun array-set-c-uint8! @var{pointer} @var{index} @var{value}
@defunx poke-array-uint8! @var{pointer} @var{index} @var{value}
Set to @var{value} the single byte at @var{index} in the array
referenced by @var{pointer}.  @var{value} must be in the range @math{[0,
2^8)}, that is @math{[0, 255]}.
@end defun


@defun array-set-c-int16! @var{pointer} @var{index} @var{value}
@defunx poke-array-int16! @var{pointer} @var{index} @var{value}
Set to @var{value} the two bytes at @var{index} in the array referenced
by @var{pointer}.  @var{value} must be in the range @math{[-2^15,
2^15)}, that is @math{[-32768, 32767]}.
@end defun


@defun array-set-c-uint16! @var{pointer} @var{index} @var{value}
@defunx poke-array-uint16! @var{pointer} @var{index} @var{value}
Set to @var{value} the two bytes at @var{index} in the array referenced
by @var{pointer}.  @var{value} must be in the range @math{[0, 2^16)},
that is @math{[0, 65535]}.
@end defun


@defun array-set-c-int32! @var{pointer} @var{index} @var{value}
@defunx poke-array-int32! @var{pointer} @var{index} @var{value}
Set to @var{value} the four bytes at @var{index} in the array referenced
by @var{pointer}.  @var{value} must be is in the range @math{[-2^31,
2^31)}, that is @math{[-2147483648, 2147483647]}.
@end defun


@defun array-set-c-uint32! @var{pointer} @var{index} @var{value}
@defunx poke-array-uint32! @var{pointer} @var{index} @var{value}
Set to @var{value} the four bytes at @var{index} in the array referenced
by @var{pointer}.  @var{value} must be in the range @math{[0, 2^32)},
that is @math{[0, 4294967295]}.
@end defun


@defun array-set-c-int64! @var{pointer} @var{index} @var{value}
@defunx poke-array-int64! @var{pointer} @var{index} @var{value}
Set to @var{value} the eight bytes at @var{index} in the array
referenced by @var{pointer}.  @var{value} must be in the range
@math{[-2^63, 2^63)}, that is @math{[9223372036854775808,
9223372036854775807]}.
@end defun


@defun array-set-c-uint64! @var{pointer} @var{index} @var{value}
@defunx poke-array-uint64! @var{pointer} @var{index} @var{value}
Set to @var{value} the eight bytes at @var{index} in the array
referenced by @var{pointer}.  @var{value} must be in the range @math{[0,
2^64)}, that is @math{[0, 18446744073709551615]}.
@end defun


@subsubheading Poking C language exact integers


@defun array-set-c-signed-char! @var{pointer} @var{index} @var{value}
@defunx poke-array-signed-char! @var{pointer} @var{index} @var{value}
Aliases for the @samp{int8} fixed--size array poker.
@end defun


@defun array-set-c-unsigned-char! @var{pointer} @var{index} @var{value}
@defunx poke-array-unsigned-char! @var{pointer} @var{index} @var{value}
Aliases for the @samp{uint8} fixed--size array poker.
@end defun


@defun array-set-c-signed-short! @var{pointer} @var{index} @var{value}
@defunx poke-array-signed-short! @var{pointer} @var{index} @var{value}
Aliases for the fixed--size array poker whose target matches the size
and range of the @samp{short int} C language type of the underlying
platform.
@end defun


@defun array-set-c-unsigned-short! @var{pointer} @var{index} @var{value}
@defunx poke-array-unsigned-short! @var{pointer} @var{index} @var{value}
Aliases for the fixed--size array poker whose target matches the size
and range of the @samp{unsigned short int} C language type of the
underlying platform.
@end defun


@defun array-set-c-signed-int! @var{pointer} @var{index} @var{value}
@defunx poke-array-signed-int! @var{pointer} @var{index} @var{value}
Aliases for the fixed--size array poker whose target matches the size
and range of the @samp{int} C language type of the underlying platform.
@end defun


@defun array-set-c-unsigned-int! @var{pointer} @var{index} @var{value}
@defunx poke-array-unsigned-int! @var{pointer} @var{index} @var{value}
Aliases for the fixed--size array poker whose target matches the size
and range of the @samp{unsigned int} C language type of the underlying
platform.
@end defun


@defun array-set-c-signed-long! @var{pointer} @var{index} @var{value}
@defunx poke-array-signed-long! @var{pointer} @var{index} @var{value}
Aliases for the fixed--size array poker whose target matches the size
and range of the @samp{long} C language type of the underlying platform.
@end defun


@defun array-set-c-unsigned-long! @var{pointer} @var{index} @var{value}
@defunx poke-array-unsigned-long! @var{pointer} @var{index} @var{value}
Aliases for the fixed--size array poker whose target matches the size
and range of the @samp{unsigned long} C language type of the underlying
platform.
@end defun


@defun array-set-c-signed-long-long! @var{pointer} @var{index} @var{value}
@defunx poke-array-signed-long-long! @var{pointer} @var{index} @var{value}
Aliases for the fixed--size array poker whose target matches the size
and range of the @samp{long long} C language type of the underlying
platform.
@end defun


@defun array-set-c-unsigned-long-long! @var{pointer} @var{index} @var{value}
@defunx poke-array-unsigned-long-long! @var{pointer} @var{index} @var{value}
Aliases for the fixed--size array poker whose target matches the size
and range of the @samp{unsigned long long} C language type of the
underlying platform.
@end defun


@subsubheading Poking C language floating pointer numbers


@defun array-set-c-float! @var{pointer} @var{index} @var{value}
@defunx poke-array-float! @var{pointer} @var{index} @var{value}
Set to @var{value} the four--byte @samp{float} (represented as @ieee{}
754 single precision floating point number) stored at @var{index} in the
array referenced by @var{pointer}.  @var{value} must be a Scheme flonum
object.
@end defun


@defun array-set-c-double! @var{pointer} @var{index} @var{value}
@defunx poke-array-double! @var{pointer} @var{index} @var{value}
Set to @var{value} the eight--byte @samp{double} (represented as @ieee{}
754 double precision floating point number) stored at @var{index} in the
array referenced by @var{pointer}.  @var{value} must be a Scheme flonum
object.
@end defun


@subsubheading Poking pointers


@defun array-set-c-pointer! @var{pointer} @var{index} @var{pointer-value}
@defunx array-set-c-void*! @var{pointer} @var{index} @var{pointer-value}
@defunx poke-array-pointer! @var{pointer} @var{index} @var{pointer-value}
@defunx poke-array-void*! @var{pointer} @var{index} @var{pointer-value}
Set to @var{pointer-value} the bytes stored at @var{index} in the array
referenced by @var{pointer}.  The size of the target depends on the
architecture: it is @math{4} bytes on @math{32}-bit systems and @math{8}
bytes on @math{64}-bit systems.  @var{pointer-value} must be a
@samp{pointer}.
@end defun

@c page
@node ffi array pointers
@subsubsection Computing pointers into arrays


The following functions compute a pointer value referencing an element
of an array of basic C language data types.  The index is used to
compute the position of the first byte taking into account the element
stride of the data type.


@subsubheading Getting fixed--size exact integers pointers


@defun array-ptr-c-int8 @var{pointer} @var{index}
Return a pointer to the value at @var{index} in the signed bytes array
referenced by @var{pointer}.
@end defun


@defun array-ptr-c-uint8 @var{pointer} @var{index}
Return a pointer to the value at @var{index} in the unsigned bytes array
referenced by @var{pointer}.
@end defun


@defun array-ptr-c-int16 @var{pointer} @var{index}
Return a pointer to the the signed exact integer represented by the two
bytes at @var{index} in the array referenced by @var{pointer}.
@end defun


@defun array-ptr-c-uint16 @var{pointer} @var{index}
Return a pointer to the unsigned exact integer represented by the two
bytes at @var{index} in the array referenced by @var{pointer}.
@end defun


@defun array-ptr-c-int32 @var{pointer} @var{index}
Return a pointer to the signed exact integer represented by the four
bytes at @var{index} in the array referenced by @var{pointer}.
@end defun


@defun array-ptr-c-uint32 @var{pointer} @var{index}
Return a pointer to the unsigned exact integer represented by the four
bytes at @var{index} in the array referenced by @var{pointer}.
@end defun


@defun array-ptr-c-int64 @var{pointer} @var{index}
Return a pointer to the signed exact integer represented by the eight
bytes at @var{index} in the array referenced by @var{pointer}.
@end defun


@defun array-ptr-c-uint64 @var{pointer} @var{index}
Return a pointer to the unsigned exact integer represented by the eight
bytes at @var{index} in the array referenced by @var{pointer}.
@end defun


@subsubheading Peeking C language exact integers


@defun array-ptr-c-signed-char @var{pointer} @var{index}
Aliases for the @samp{int8} fixed--size array pointer getter.
@end defun


@defun array-ptr-c-unsigned-char @var{pointer} @var{index}
Aliases for the @samp{uint8} fixed--size array pointer getter.
@end defun


@defun array-ptr-c-signed-short @var{pointer} @var{index}
Aliases for the fixed--size array pointer getter whose target matches
the size and range of the @samp{short int} C language type of the
underlying platform.
@end defun


@defun array-ptr-c-unsigned-short @var{pointer} @var{index}
Aliases for the fixed--size array pointer getter whose target matches
the size and range of the @samp{unsigned short int} C language type of
the underlying platform.
@end defun


@defun array-ptr-c-signed-int @var{pointer} @var{index}
Aliases for the fixed--size array pointer getter whose target matches
the size and range of the @samp{int} C language type of the underlying
platform.
@end defun


@defun array-ptr-c-unsigned-int @var{pointer} @var{index}
Aliases for the fixed--size array pointer getter whose target matches
the size and range of the @samp{unsigned int} C language type of the
underlying platform.
@end defun


@defun array-ptr-c-signed-long @var{pointer} @var{index}
Aliases for the fixed--size array pointer getter whose target matches
the size and range of the @samp{long} C language type of the underlying
platform.
@end defun


@defun array-ptr-c-unsigned-long @var{pointer} @var{index}
Aliases for the fixed--size array pointer getter whose target matches
the size and range of the @samp{unsigned long} C language type of the
underlying platform.
@end defun


@defun array-ptr-c-signed-long-long @var{pointer} @var{index}
Aliases for the fixed--size array pointer getter whose target matches
the size and range of the @samp{long long} C language type of the
underlying platform.
@end defun


@defun array-ptr-c-unsigned-long-long @var{pointer} @var{index}
Aliases for the fixed--size array pointer getter whose target matches
the size and range of the @samp{unsigned long long} C language type of
the underlying platform.
@end defun


@defun array-ptr-c-size_t @var{pointer} @var{index}
Aliases for the fixed--size array pointer getter whose target matches
the size and range of the @samp{size_t} C language type of the
underlying platform.
@end defun


@defun array-ptr-c-ssize_t @var{pointer} @var{index}
Aliases for the fixed--size array pointer getter whose target matches
the size and range of the @samp{ssize_t} C language type of the
underlying platform.
@end defun


@subsubheading Peeking C language floating pointer numbers


@defun array-ptr-c-float @var{pointer} @var{index}
Return a pointer to the four--byte @samp{float} (represented as @ieee{}
754 single precision floating point number) stored at @var{index} in the
array referenced by @var{pointer}.
@end defun


@defun array-ptr-c-double @var{pointer} @var{index}
Return a pointer to the eight--byte @samp{double} (represented as
@ieee{} 754 double precision floating point number) stored at
@var{index} in the array referenced by @var{pointer}.
@end defun


@subsubheading Peeking pointers


@defun array-ptr-c-pointer @var{pointer} @var{index}
@defunx array-ptr-c-void* @var{pointer} @var{index}
Return a pointer to the pointer stored at @var{index} in the array
referenced by @var{pointer}.
@end defun

@c page
@node ffi call
@subsection High level interface


@menu
* ffi call shared::             Dynamic loading of libraries.
* ffi call types::              Interface to C language types.
* ffi call out::                Calling foreign functions.
* ffi call back::               Calling Scheme functions.
* ffi call primitives::         Middle level interface.
* ffi call platform::           Low level interface.
@end menu

@c page
@node ffi call shared
@subsubsection Dynamic loading of libraries


A foreign shared library loadable with the @cfunc{dlopen} @posix{}
interface is called @dfn{shared object}.  Under @value{PACKAGE}, a
shared object can be opened, but not closed.  The @api{} makes use of a
Scheme object to represent a shared object; it allows access to all the
functions exported by the library.

The following bindings are exported by the @library{foreign ffi}
library.


@defun open-shared-object @var{library-name}
@defunx open-shared-object* @var{library-name}
Open a new shared object and return its identifier.  The return value is
meant to be stored in the @code{shared-object} parameter while creating
interface functions for it.  @var{library-name} must be a Scheme string
or symbol representing the file name or pathname to be opened.

If opening the shared object fails, @func{open-shared-object} returns
@false{}, while @func{open-shared-object*} raises a continuable
exception with @func{raise-unknown-shared-object}.  @ref{ffi conditions
unknown-shared, Unknown shared objects}

Examples:

@example
(define mpfr-lib
  (begin0-let ((l (open-shared-object 'libmpfr.so)))
    (shared-object l)))

(define mpfi-lib
  (begin0-let ((l (open-shared-object
                    '/usr/local/lib/libmpfi.so)))
    (shared-object l)))
@end example

In the case of a name (wihtout directory part) the search path for
shared objects is implemenation dependent.

@quotation
@strong{For Unix} We can find documentation about the search path of
shared objects in the manual page of @cfunc{dlopen}.
@end quotation
@end defun


@defvr Constant self-shared-object
Bound to the shared object value identifying the current process; it is
the initial value of @samp{shared-object}.  With this value we can
access symbols exported by the current program and the libraries that
have been already loaded (this may be platform specific, check out the
documentation of your system).

For example, the symbols from the standard C library, like @cfunc{fread}
and @cfunc{fwrite}, can be accessed this way.
@end defvr


@defun lookup-shared-object @var{lib-ref} @var{foreign-symbol}
@defunx lookup-shared-object* @var{lib-ref} @var{foreign-symbol}
Search the shared object referenced by @var{lib-ref} for an exported
symbol matching @var{foreign-symbol}, which must be a Scheme symbol or
string, and return its address in a pointer value.  Shared objects
references are produced with @func{open-shared-object}.

If the foreign symbol is not found, the return value of
@func{lookup-shared-object} is @false{} while
@func{lookup-shared-object*} raises a continuable exception with
@func{raise-unknown-foreign-symbol}.  @ref{ffi conditions
unknown-foreign, Unknown foreign symbols}
@end defun


@deffn Parameter shared-object
Holds a value referencing the ``current'' shared object: The shared
object in which @func{make-c-function} will look for symbols.  The
initial value is @samp{self-shared-object}.  Shared objects references
are produced with @func{open-shared-object}.
@end deffn

@c page
@node ffi call types
@subsubsection Interface to C language types


Nausicaa's foreign--functions interface accepts a number of C language
type identifiers represented by Scheme symbols; these @dfn{external
types} have redundant names to improve user friendlyness; when
processing the definition of an interface, they are first normalised to
@dfn{internal types} as described in the table below.

The @meta{size_t-integer} and @meta{ssize_t-integer} type specifiers
used in the tables, are the unsigned and signed identifiers used on the
hosting platform to represent the @code{size_t} and @code{ssize_t} C
language data types; they are symbols among:

@example
signed-int    signed-long    signed-long-long
unsigned-int  unsigned-long  unsigned-long-long
@end example

Remember that C strings (zero terminated arrays of @samp{char}) must be
converted from/to Scheme strings with @func{string->cstring} and
@func{cstring->string}, and exchanged with foreign functions as
pointers.  @ref{cstrings conversion, Converting to and from cstrings}

@float Table
@multitable {012345678901234567} {0123456789012345678} {01234567890123456789012}
@headitem External type @tab Internal type @tab Description
@item @code{int8_t}             @tab @code{int8_t}              @tab signed integer
@item @code{int16_t}            @tab @code{int16_t}             @tab signed integer
@item @code{int32_t}            @tab @code{int32_t}             @tab signed integer
@item @code{int64_t}            @tab @code{int64_t}             @tab signed integer
@item @code{uint8_t}            @tab @code{uint8_t}             @tab unsigned integer
@item @code{uint16_t}           @tab @code{uint16_t}            @tab unsigned integer
@item @code{uint32_t}           @tab @code{uint32_t}            @tab unsigned integer
@item @code{uint64_t}           @tab @code{uint64_t}            @tab unsigned integer
@item @code{char}               @tab @code{signed-char}         @tab signed char
@item @code{schar}              @tab @code{signed-char}         @tab signed char
@item @code{signed-char}        @tab @code{signed-char}         @tab signed char
@item @code{uchar}              @tab @code{unsigned-char}       @tab unsigned char
@item @code{unsigned-char}      @tab @code{unsigned-char}       @tab unsigned char
@item @code{short}              @tab @code{signed-short}        @tab signed integer
@item @code{signed-short}       @tab @code{signed-short}        @tab signed integer
@item @code{ushort}             @tab @code{unsigned-short}      @tab unsigned integer
@item @code{unsigned-short}     @tab @code{unsigned-short}      @tab unsigned integer
@item @code{int}                @tab @code{signed-int}          @tab signed integer
@item @code{signed-int}         @tab @code{signed-int}          @tab signed integer
@item @code{ssize_t}            @tab @meta{ssize_t-integer}     @tab signed integer
@item @code{uint} @tab          @code{unsigned-int}             @tab unsigned integer
@item @code{unsigned}           @tab @code{unsigned-int}        @tab unsigned integer
@item @code{unsigned-int}       @tab @code{unsigned-int}        @tab unsigned integer
@item @code{size_t}             @tab @meta{size_t-integer}      @tab unsigned integer
@item @code{long}               @tab @code{signed-long}         @tab signed integer
@item @code{signed-long}        @tab @code{signed-long}         @tab signed integer
@item @code{ulong}              @tab @code{unsigned-long}       @tab unsigned integer
@item @code{unsigned-long}      @tab @code{unsigned-long}       @tab unsigned integer
@item @code{long-long}          @tab @code{signed-long-long}    @tab signed integer
@item @code{llong}              @tab @code{signed-long-long}    @tab signed integer
@item @code{signed-long-long}   @tab @code{signed-long-long}    @tab signed integer
@item @code{ulong-long}         @tab @code{unsigned-long-long}  @tab unsigned integer
@item @code{ullong}             @tab @code{unsigned-long-long}  @tab unsigned integer
@item @code{unsigned-long-long} @tab @code{unsigned-long-long}  @tab unsigned integer
@item @code{float}              @tab @code{float}               @tab single precision flonum
@item @code{double}             @tab @code{double}              @tab double precision flonum
@item @code{pointer}            @tab @code{pointer}             @tab pointer
@item @code{void*}              @tab @code{pointer}             @tab pointer
@item @code{char*}              @tab @code{pointer}             @tab pointer
@item @code{FILE*}              @tab @code{pointer}             @tab pointer
@item @code{callback}           @tab @code{callback}            @tab callback function
@item @code{void}               @tab @code{void}                @tab void value
@end multitable
@caption{Mapping from Nausicaa's external types to Nausicaa's internal types.}
@end float

The internal types are further converted to type identifiers recognised
by the underlying Scheme implementation, according to the following
tables.

@float Table
@multitable {0123456789012345678} {0123456789012345678}
@headitem Internal type @tab Ikarus type
@item @code{int8_t}             @tab @code{signed-char}
@item @code{int16_t}            @tab @code{signed-short}
@item @code{int32_t}            @tab @code{signed-int}
@item @code{int64_t}            @tab @code{signed-long-long}
@item @code{uint8_t}            @tab @code{unsigned-char}
@item @code{uint16_t}           @tab @code{unsigned-short}
@item @code{uint32_t}           @tab @code{unsigned-int}
@item @code{uint64_t}           @tab @code{unsigned-long-long}
@item @code{signed-char}        @tab @code{signed-char}
@item @code{unsigned-char}      @tab @code{unsigned-char}
@item @code{signed-short}       @tab @code{signed-short}
@item @code{unsigned-short}     @tab @code{unsigned-short}
@item @code{signed-int}         @tab @code{signed-int}
@item @code{unsigned-int}       @tab @code{unsigned-int}
@item @code{signed-long}        @tab @code{signed-long}
@item @code{unsigned-long}      @tab @code{unsigned-long}
@item @code{signed-long-long}   @tab @code{signed-long-long}
@item @code{unsigned-long-long} @tab @code{unsigned-long-long}
@item @code{float}              @tab @code{float}
@item @code{double}             @tab @code{double}
@item @code{pointer}            @tab @code{pointer}
@item @code{callback}           @tab @code{pointer}
@item @code{void}               @tab @code{void}
@end multitable
@caption{Mapping from Nausicaa's internal types to Ikarus' types,
revision 1865 (last updated Fri Oct 30, 2009).}
@end float


@float Table
@multitable {012345678901234567} {0123456789012345678}
@headitem Internal type @tab Ypsilon type
@item @code{int8_t}             @tab @code{int8_t}
@item @code{int16_t}            @tab @code{int16_t}
@item @code{int32_t}            @tab @code{int32_t}
@item @code{int64_t}            @tab @code{int64_t}
@item @code{uint8_t}            @tab @code{uint8_t}
@item @code{uint16_t}           @tab @code{uint16_t}
@item @code{uint32_t}           @tab @code{uint32_t}
@item @code{uint64_t}           @tab @code{uint64_t}
@item @code{signed-char}        @tab @code{char}
@item @code{unsigned-char}      @tab @code{char}
@item @code{signed-short}       @tab @code{short}
@item @code{unsigned-short}     @tab @code{unsigned-short}
@item @code{signed-int}         @tab @code{int}
@item @code{unsigned-int}       @tab @code{unsigned-int}
@item @code{signed-long}        @tab @code{long}
@item @code{unsigned-long}      @tab @code{unsigned-long}
@item @code{signed-long-long}   @tab @code{long-long}
@item @code{unsigned-long-long} @tab @code{unsigned-long-long}
@item @code{float}              @tab @code{float}
@item @code{double}             @tab @code{double}
@item @code{pointer}            @tab @code{void*}
@item @code{callback}           @tab @code{void*}
@item @code{void}               @tab @code{void}
@end multitable
@caption{Mapping from Nausicaa's internal types to Ypsilon's types,
revision 503 (last updated Fri Oct 30, 2009).}
@end float

@float Table
@multitable {012345678901234567} {0123456789012345678}
@headitem Internal type @tab Mosh type
@item @code{int8_t}             @tab @code{int8_t}
@item @code{int16_t}            @tab @code{int16_t}
@item @code{int32_t}            @tab @code{int32_t}
@item @code{int64_t}            @tab @code{int64_t}
@item @code{uint8_t}            @tab @code{uint8_t}
@item @code{uint16_t}           @tab @code{uint16_t}
@item @code{uint32_t}           @tab @code{uint32_t}
@item @code{uint64_t}           @tab @code{uint64_t}
@item @code{signed-char}        @tab @code{char}
@item @code{unsigned-char}      @tab @code{char}
@item @code{signed-short}       @tab @code{short}
@item @code{unsigned-short}     @tab @code{unsigned-short}
@item @code{signed-int}         @tab @code{int}
@item @code{unsigned-int}       @tab @code{unsigned-int}
@item @code{signed-long}        @tab @code{long}
@item @code{unsigned-long}      @tab @code{unsigned-long}
@item @code{signed-long-long}   @tab @code{long-long}
@item @code{unsigned-long-long} @tab @code{unsigned-long-long}
@item @code{float}              @tab @code{float}
@item @code{double}             @tab @code{double}
@item @code{pointer}            @tab @code{void*}
@item @code{callback}           @tab @code{void*}
@item @code{void}               @tab @code{void}
@end multitable
@caption{Mapping from Nausicaa's internal types to Mosh's types,
revision 2185 (last updated Tue Nov 17, 2009).}
@end float

@float Table
@multitable {012345678901234567} {0123456789012345678}
@headitem Internal type @tab Larceny type
@item @code{int8_t}             @tab @code{int}
@item @code{int16_t}            @tab @code{int}
@item @code{int32_t}            @tab @code{int}
@item @code{int64_t}            @tab @code{long}
@item @code{uint8_t}            @tab @code{unsigned}
@item @code{uint16_t}           @tab @code{unsigned}
@item @code{uint32_t}           @tab @code{unsigned}
@item @code{uint64_t}           @tab @code{ulong}
@item @code{signed-char}        @tab @code{int}
@item @code{unsigned-char}      @tab @code{int}
@item @code{signed-short}       @tab @code{int}
@item @code{unsigned-short}     @tab @code{unsigned}
@item @code{signed-int}         @tab @code{int}
@item @code{unsigned-int}       @tab @code{unsigned}
@item @code{signed-long}        @tab @code{long}
@item @code{unsigned-long}      @tab @code{ulong}
@item @code{signed-long-long}   @tab @code{long}
@item @code{unsigned-long-long} @tab @code{ulong}
@item @code{float}              @tab @code{float}
@item @code{double}             @tab @code{double}
@item @code{pointer}            @tab @code{(maybe void*)}
@item @code{callback}           @tab @code{(maybe void*)}
@item @code{void}               @tab @code{void}
@end multitable
@caption{Mapping from Nausicaa's internal types to Larceny's types,
revision 6404 (last updated Tue Nov 17, 2009).}
@end float

@c page
@node ffi call out
@subsubsection Calling foreign functions


The following bindings are exported by the @library{foreign ffi}
library.


@deffn Syntax make-c-function @ameta{ret-type} @ameta{export-name} (@ameta{arg-type0} @ameta{arg-type} ...)
@deffnx Syntax make-c-function/with-errno @ameta{ret-type} @ameta{export-name} (@ameta{arg-type0} @ameta{arg-type} ...)
Build and return a new Scheme callout closure for a C language foreign
function in the shared object selected by the current value of the
@func{shared-object} parameter.

The closure returned by @func{make-c-function}:

@enumerate
@item
Accepts as many Scheme object arguments as there are @meta{arg-type}
symbols.  To specify an empty list of arguments, we can use
@code{(void)} as list of @meta{arg-type}.

@item
Does marshaling from Scheme arguments to C language values as specified
by the @meta{arg-type} symbols.

@item
Applies the foreign function to the C values.

@item
Returns the return value of the foreign function, marshaled to a Scheme
value as specified by the @meta{ret-type} symbol.
@end enumerate

The closure returned by @func{make-c-function/with-errno} does the same,
but returns two values: the return value from the foreign function,
marshaled as specified by the @meta{ret-type} symbol, and the value of
the @samp{errno} variable (an exact integer) right after the call to the
foreign function.

@quotation
@strong{NOTE} Some @posix{} functions return an integer representing
success or failure and only when the returned value represents failure
the @samp{errno} value is meaningful.
@end quotation

@table @meta
@item ret-type
The type of value returned by the foreign function.  It must be a Scheme
symbol among the ones representing the external C language types
supported by Nausicaa or a binding for a custom symbol; see below for
details.

@item export-name
A Scheme symbol representing the name of the function exported by the
shared object.  Beware that, sometimes, the exported symbols are
different from the ones we write in C language code to call a function.
If the foreign symbol is not found, a continuable exception is raised
with @func{raise-unknown-foreign-symbol}; returning with the
continuation must return the address of the function.  @ref{ffi
conditions unknown-foreign, Unknown foreign symbols}

@item arg-type
The type of an argument required by the foreign function.  It must be a
Scheme symbol among the ones representing the external C language types
supported by Nausicaa or a binding for a custom symbol; see below for
details.
@end table

@quotation
@strong{For Unix} One way to discover the names of symbols exported by a
shared object, is to apply the @command{strings} command to the shared
object itself.  For example, to discover the names of deflate functions
in Zlib:

@example
$ strings /usr/lib/libz.so | grep deflate
deflateInit_
deflate
deflateEnd
...
@end example
@end quotation

As an example, the main deflate functions from Zlib can be defined with:

@example
(define dummy
  (shared-object (open-shared-object 'libz.so)))

(define deflateInit
  (make-c-function int deflateInit_ (pointer int)))

(define deflate
  (make-c-function int deflate (pointer int)))

(define deflateEnd
  (make-c-function int deflateEnd (pointer)))
@end example

@noindent
but we can also take advantage of these macro features to define them
like this:

@example
(define dummy
  (shared-object (open-shared-object 'libz.so)))

(define z_streamp 'pointer)

(define deflateInit
  (make-c-function int deflateInit_ (z_streamp int)))

(define deflate
  (make-c-function int deflate (z_streamp int)))

(define deflateEnd
  (make-c-function int deflateEnd (z_streamp)))
@end example

@noindent
where the binding for @code{z_streamp} is recognised as a custom type
and expanded to @code{pointer}.

Variadic functions, like @cfunc{fprintf}, are @strong{not} supported,
but we can interface with them by fixing the arguments; for example:

@example
(define uuid_make
  (let ((arg-2  (make-c-function int uuid_make
                  (void* unsigned-int)))
        (arg-4  (make-c-function int uuid_make
                  (void* unsigned-int void* char*))))
    (case-lambda
     ((*id mode)
      (arg-2 *id mode))
     ((*id mode uuid name)
      (arg-4 *id mode uuid name)))))
@end example
@end deffn


@deffn Syntax define-c-function @ameta{pub-name} (@ameta{ret-type} @ameta{export-name} (@ameta{arg-type0} @ameta{arg-type} ...))
@deffnx Syntax define-c-function/with-errno @ameta{pub-name} (@ameta{ret-type} @ameta{export-name} (@ameta{arg-type0} @ameta{arg-type} ...))
Wrappers for @func{make-c-function} and
@func{make-c-function/with-errno} that define a binding for the callout
closure.

As an example, the main deflate functions from Zlib can be defined with:

@example
(define dummy
  (shared-object (open-shared-object 'libz.so)))

(define z_streamp 'z_streamp)

(define-c-function deflateInit
  (int deflateInit_ (z_streamp int)))

(define-c-function deflate
  (int deflate (z_streamp int)))

(define-c-function deflateEnd
  (int deflateEnd (z_streamp)))
@end example

@noindent
other, miscellaneous, examples from the C standard library and the
@posix{} interface:

@example
(define dummy
  (shared-object self-shared-object))

(define-c-function fopen
  (void* fopen (void* void*)))

(define-c-function fwrite
  (size_t fwrite (void* size_t size_t void*)))

(define-c-function fread
  (size_t fread (void* size_t size_t void*)))

(define-c-function open
  (int open (void* int)))

(define-c-function write
  (ssize_t write (int void* size_t)))

(define-c-function read
  (ssize_t read (int void* size_t)))
@end example
@end deffn


@deffn Syntax pointer->c-function @ameta{ret-type} @ameta{pointer-expr} (@ameta{arg-type0} @ameta{arg-type} ...)
@deffnx Syntax pointer->c-function/with-errno @ameta{ret-type} @ameta{pointer-expr} (@ameta{arg-type0} @ameta{arg-type} ...)
Like @func{make-c-function} and @func{make-c-function/with-errno}, but
build a callout closure from a raw pointer to the function.
@meta{pointer-expr} must be an expression evaluating to a pointer value
representing the address of the foreign function.

As an example, this interface is required for a proper binding to the
SQLite Amalgamation version 3.6 shared library.
@end deffn


@deffn Syntax define-pointer-c-function @ameta{pub-name} (@ameta{ret-type} @ameta{pointer-expr} (@ameta{arg-type0} @ameta{arg-type} ...))
@deffnx Syntax define-pointer-c-function/with-errno @ameta{pub-name} (@ameta{ret-type} @ameta{pointer-expr} (@ameta{arg-type0} @ameta{arg-type} ...))
Wrappers for @func{pointer->c-function} and
@func{pointer->c-function/with-errno} which define a binding for the
callout closure.
@end deffn

@c page
@node ffi call back
@subsubsection Calling Scheme functions


The following bindings are exported by the @library{foreign ffi}
library.

@deffn Syntax make-c-callback @ameta{ret-type} @ameta{scheme-proc} (@ameta{arg-type0} @ameta{arg-type} ...)
Build and return a callback object to be used as argument to a callout
procedure.  When a foreign function invokes the C language callback, the
callback:

@enumerate
@item
Accepts as many C language arguments as there are @meta{arg-type}
symbols.  To specify an empty list of arguments, we can use
@code{(void)} as list of @meta{arg-type}.

@item
Does marshaling from C language arguments to Scheme objects as specified
by the @meta{arg-type} symbols.

@item
Applies the Scheme function to the Scheme values.

@item
Returns the return value of the Scheme function, marshaled to a C
language value as specified by the @meta{ret-type} symbol.
@end enumerate

@table @meta
@item ret-type
The type of value returned by the foreign callback.  It must be a Scheme
symbol among the ones representing the external C language types
supported by Nausicaa or a binding for a custom symbol.

@item scheme-proc
An expression evaluating to a Scheme function.

@item arg-type
The type of an argument required by the Scheme function.  It must be a
Scheme symbol among the ones representing the external C language types
supported by Nausicaa or a binding for a custom symbol.
@end table

Every time a callback is built, a small amount of memory is allocated;
such memory cannot be subject to garbage collection, so it is leaked
unless we apply @func{free-c-callback} to the callback object.

For example, the following form defines a callback accepting three
@samp{int} as arguments and returning an @samp{int}:

@example
(define (fn a b c)
  (* a b c))

(define cb
  (make-c-callback int fn (int int int)))
@end example
@end deffn


@defun free-c-callback @var{callback}
Release the memory associated to @var{callback}.  On some Scheme
implementations this call does nothing, because they do not allow
releasing such a resource.
@end defun

@c page
@node ffi call primitives
@subsubsection Middle level interface


The following bindings are exported by the @library{foreign ffi
primitives} library.

@c ------------------------------------------------------------

@subsubheading Accessing shared libraries


@defun open-shared-object @var{library-name}
@defunx open-shared-object* @var{library-name}
Open a shared library and return its reference object.
@var{library-name} must be a Scheme string or symbol representing the
file name or pathname to be opened.

If opening the shared object fails, @func{open-shared-object} returns
@false{}, while @func{open-shared-object*} raises a continuable
exception with @func{raise-unknown-shared-object}.  @ref{ffi conditions
unknown-shared, Unknown shared objects}
@end defun


@defun lookup-shared-object @var{lib-ref} @var{foreign-symbol}
@defunx lookup-shared-object* @var{lib-ref} @var{foreign-symbol}
Search the shared object referenced by @var{lib-ref} for an exported
symbol matching @var{foreign-symbol}, which must be a Scheme string or
symbol, and return its address in a pointer value.

If the foreign symbol is not found, the return value of
@func{lookup-shared-object} is @false{} while
@func{lookup-shared-object*} raises a continuable exception with
@func{raise-unknown-foreign-symbol}.  @ref{ffi conditions
unknown-foreign, Unknown foreign symbols}
@end defun


@defvr Constant self-shared-object
Bound to the shared object value that identifies the current process;
with this value we can access symbols exported by the current program
and the libraries that have been already loaded (this may be platform
specific, check out the documentation of your operative system).
@end defvr

@c ------------------------------------------------------------

@subsubheading Making callout closures

A callout is a Scheme closure wrapping a foreign function; it can be
used to apply it to a set of arguments.  It implements basic marshaling
between Scheme objects and C language values.


@defun make-c-function @var{lib-ref} @var{ret-type} @var{funcname} @var{arg-types}
Build and return a new callout closure wrapping a foreign function
exported by the shared library referenced by @var{lib-ref}.  The name
of the foreign function is specified by @var{funcname}, which must be a
Scheme string or symbol.

If the foreign symbol is not found, a continuable exception is raised
with @func{raise-unknown-foreign-symbol}; returning with the
continuation must return the address of the function.  @ref{ffi
conditions unknown-foreign, Unknown foreign symbols}

@var{ret-type} must be a Scheme symbol representing the C language data
type of the foreign function's return value; @var{arg-types} must be a
list of Scheme symbols representing the C language data types of the
foreign function's arguments.  Both the return type and argument type
symbols must be internal types recognised by Nausicaa.  To specify a
foreign function accepting no arguments, @var{arg-types} must be
@code{(void)}.

Variadic functions are not supported.
@end defun


@defun make-c-function/with-errno @var{lib-ref} @var{ret-type} @var{funcname} @var{arg-types}
Like @func{make-c-function}, but the callout closure returns two values:
the marshaled return value from the foreign function and the value of
@code{errno} right after the foreign call.
@end defun


@defun pointer->c-function @var{ret-type} @var{address} @var{arg-types}
Like @func{make-c-function}, but build the callout closure from a raw
pointer value representing the function address.
@end defun


@defun pointer->c-function/with-errno @var{ret-type} @var{address} @var{arg-types}
Like @func{make-c-function/with-errno}, but build the callout closure
from a raw pointer value representing the function address.
@end defun

@c ------------------------------------------------------------

@subsubheading Making callback pointers

A callback is a C language function wrapping a Scheme closure; it can be
used by foreign functions to apply a Scheme function a set of arguments.
It implements basic marshaling between Scheme objects and C language
values.


@defun make-c-callback @var{ret-type} @var{scheme-proc} @var{arg-types}
Build and return a new pointer value referencing a callback object; the
callback, when invoked, applies the @var{scheme-proc} to the marshaled
arguments.

@var{ret-type} must be a Scheme symbol representing the C language data
type of the foreign function's return value; @var{arg-types} must be a
list of Scheme symbols representing the C language data types of the
foreign function's arguments.  Both the return type and argument type
symbols must be internal types recognised by Nausicaa.  To specify a
foreign function accepting no arguments, @var{arg-types} must be
@code{(void)}.

Variadic functions are not supported.
@end defun


@defun free-c-callback @var{callback}
Release all the resources associated to the referenced callback.  This
operation is supported by some Sceme implementations, and unsupported by
other ones; in the latter case, calling this function does nothing.
@end defun

@c ------------------------------------------------------------

@subsubheading Converting data types


@defun external-type->internal-type @var{type}
Convert a Scheme symbol representing a Nausicaa's external C language
type into a Scheme symbol representing a Nausicaa's internal C language
type.
@end defun


@defvr Constant external-data-types
Enumeration object representing the C language data types externally
recognised by Nausicaa.
@end defvr


@defvr Constant internal-data-types
Enumeration object representing the C language data types internally
recognised by Nausicaa.
@end defvr

@c page
@node ffi call platform
@subsubsection Low level interface


The following bindings are exported by the @library{foreign ffi
platform} library.

@c ------------------------------------------------------------

@subsubheading Accessing shared libraries


@defun open-shared-object @var{library-name}
Open a shared library and return its reference object.
@var{library-name} must be a Scheme string representing the file name or
pathname to be opened.
@end defun


@defun lookup-shared-object @var{lib-spec} @var{foreign-symbol}
@defunx lookup-shared-object* @var{lib-ref} @var{foreign-symbol}
Search the shared object referenced by @var{lib-spec} for an exported
symbol matching @var{foreign-symbol}, which must be a Scheme string, and
return its address in a pointer value.

If the foreign symbol is not found, the return value of
@func{lookup-shared-object} is @false{} while
@func{lookup-shared-object*} raises an @code{&error} exception.
@end defun


@defvr Constant self-shared-object
Bound to the shared object value that identifies the current process;
with this value we can access symbols exported by the current program
and the libraries that have been already loaded (this may be platform
specific, check out the documentation of your operative system).
@end defvr

@c ------------------------------------------------------------

@subsubheading Making callout closures

A callout is a Scheme closure wrapping a foreign function; it can be
used to apply it to a set of arguments.  It implements basic marshaling
between Scheme objects and C language values.


@defun make-c-function @var{lib-spec} @var{ret-type} @var{funcname} @var{arg-types}
Build and return a new callout closure wrapping a foreign function
exported by the shared library referenced by @var{lib-spec}.  The name
of the foreign function is specified by @var{funcname}, which must be a
Scheme string.

If the foreign symbol is not found, a continuable exception is raised
with @func{raise-unknown-foreign-symbol}; returning with the
continuation must return the address of the function.  @ref{ffi
conditions unknown-foreign, Unknown foreign symbols}

@var{ret-type} must be a Scheme symbol representing the C language data
type of the foreign function's return value; @var{arg-types} must be a
list of Scheme symbols representing the C language data types of the
foreign function's arguments.  Both the return type and argument type
symbols must be types recognised by the Scheme implementation.  To
specify a foreign function accepting no arguments, @var{arg-types} must
be @code{(void)}.

Variadic functions are not supported.
@end defun


@defun make-c-function/with-errno @var{lib-spec} @var{ret-type} @var{funcname} @var{arg-types}
Like @func{make-c-function}, but the callout closure returns two values:
the marshaled return value from the foreign function and the value of
@code{errno} right after the foreign call.
@end defun


@defun pointer->c-function @var{ret-type} @var{address} @var{arg-types}
Like @func{make-c-function}, but build the callout closure from a raw
pointer value representing the function address.
@end defun


@defun pointer->c-function/with-errno @var{ret-type} @var{address} @var{arg-types}
Like @func{make-c-function/with-errno}, but build the callout closure
from a raw pointer value representing the function address.
@end defun

@c ------------------------------------------------------------

@subsubheading Making callback pointers

A callback is a C language function wrapping a Scheme closure; it can be
used by foreign functions to apply a Scheme function a set of arguments.
It implements basic marshaling between Scheme objects and C language
values.


@defun make-c-callback @var{ret-type} @var{scheme-function} @var{arg-types}
Build and return a new pointer value referencing a callback object; the
callback, when invoked, applies the scheme function

@var{ret-type} must be a Scheme symbol representing the C language data
type of the foreign function's return value; @var{arg-types} must be a
list of Scheme symbols representing the C language data types of the
foreign function's arguments.  Both the return type and argument type
symbols must be types recognised by the Scheme implementation.  To
specify a foreign function accepting no arguments, @var{arg-types} must
be @code{(void)}.

Variadic functions are not supported.
@end defun


@defun free-c-callback @var{callback-pointer}
Release all the resources associated to the referenced callback.  This
operation is supported by some Sceme implementations, and unsupported by
other ones; in the latter case, calling this function does nothing.
@end defun

@c ------------------------------------------------------------

@subsubheading Converting data types


@defun internal-type->implementation-type @var{type}
Convert a Scheme symbol representing a Nausicaa's internal C language
type identifier into a Scheme implementation specific C language type
identifier.
@end defun


@defvr Constant implementation-data-types
Enumeration object representing the C language data types recognised by
the underlying Scheme implementation.
@end defvr

@c page
@node ffi struct
@subsection Accessing data structures


The following macros allow us to define accessors and mutators for
fields in a C language data structure for which we know a pointer to; to
use them, for each field we want to access, we need to know:

@itemize
@item
The offset of the first byte of the field in the structure's memory
block.

@item
The C language data type of the field.  Knowing the data type is
equivalent to knowing the required peeker and poker.  @ref{ffi access,
Direct access to memory blocks}
@end itemize

The following bindings are exported by the @library{foreign ffi}
library.


@deffn Syntax define-c-struct-accessor @ameta{accessor-name} @ameta{field-offset} @ameta{foreign-type-accessor}
Define a macro named @meta{accessor-name} accepting as single argument a
pointer to a foreign data structure; it wraps the peeker
@meta{foreign-type-accessor} to access the field at @meta{field-offset}
in the structure.

@meta{accessor-name} must be a Scheme symbol.
@meta{foreign-type-accessor} must be a peeker among the ones defined in
@ref{ffi peekers, Peeking values}.  @meta{field-offset} must be an exact
non--negative integer, representing the offset of the field's first byte
in the data structure.

As a special case, if @meta{field-offset} is @false{}: The defined macro
expands into an invocation of @func{raise-unimplemented-error}, which
signals that the accessor for the field is not implemented; in this case
@meta{foreign-type-accessor} is ignored.  This is useful in cases where
it is not possible to determine the offset of a field.  @ref{naulib
unimplemented, Unimplemented error condition}
@end deffn


@deffn Syntax define-c-struct-mutator @ameta{mutator-name} @ameta{field-offset} @ameta{foreign-type-mutator}
Define a macro named @meta{mutator-name} accepting as single argument a
pointer to a foreign data structure; it wraps the poker
@meta{foreign-type-mutator} to mutate the field at @meta{field-offset}
in the structure.

@meta{mutator-name} must be a Scheme symbol.
@meta{foreign-type-mutator} must be a poker among the ones defined in
@ref{ffi pokers, Poking values}.  @meta{field-offset} must be an exact
non--negative integer, representing the offset of the field's first byte
in the data structure.

As a special case, if @meta{field-offset} is @false{}: The defined macro
expands into an invocation of @func{raise-unimplemented-error}, which
signals that the mutator for the field is not implemented; in this case
@meta{foreign-type-mutator} is ignored.  This is useful in cases where
it is not possible to determine the offset of a field.  @ref{naulib
unimplemented, Unimplemented error condition}
@end deffn


@deffn Syntax define-c-struct-accessor-and-mutator @ameta{accessor-name} @ameta{mutator-name} @ameta{field-offset} @ameta{foreign-type-accessor} @ameta{foreign-type-mutator}
Expand to the use of both the above macros; the following use:

@example
(define-c-struct-accessor-and-mutator
  @cmeta{accessor-name} @cmeta{mutator-name}
  @cmeta{field-offset}
  @cmeta{foreign-type-accessor} @cmeta{foreign-type-mutator})
@end example

@noindent
is equivalent to:

@example
(define-c-struct-accessor @cmeta{accessor-name}
                          @cmeta{field-offset}
                          @cmeta{foreign-type-accessor})

(define-c-struct-mutator  @cmeta{mutator-name}
                          @cmeta{field-offset}
                          @cmeta{foreign-type-mutator})
@end example
@end deffn

As an example, let's consider the @samp{z_stream} structure from ZLib;
to use it we need to access at least the following fields (and more):

@example
next_in         avail_in        total_in
next_out        avail_out       total_out
@end example

@noindent
@samp{next_in} and @samp{next_out} are pointers, while the others are
unsigned integers; using appropriate inspection tools (@pxref{ffi
headers, Inspecting foreign header files}) we can determine the
associations in the following table.

@multitable {next_int} {Offset} {pointer-ref-c-unsigned-int} {pointer-set-c-unsigned-int!}
@headitem Field @tab Offset @tab Accessor @tab Mutator
@item next_in   @tab  0 @tab pointer-ref-c-pointer @tab pointer-set-c-pointer!
@item next_out  @tab 12 @tab pointer-ref-c-pointer @tab pointer-set-c-pointer!
@item avail_in  @tab  4 @tab pointer-ref-c-unsigned-int @tab pointer-set-c-unsigned-int!
@item avail_out @tab 16 @tab pointer-ref-c-unsigned-int @tab pointer-set-c-unsigned-int!
@item total_in  @tab  8 @tab pointer-ref-c-unsigned-int @tab pointer-set-c-unsigned-int!
@item total_out @tab 20 @tab pointer-ref-c-unsigned-int @tab pointer-set-c-unsigned-int!
@end multitable

So an interface to ZLib should define:

@example
(define-c-struct-accessor-and-mutator
  zstream-next_in-set!          zstream-next_in-ref
  0
  pointer-set-c-pointer!        pointer-ref-c-pointer)

(define-c-struct-accessor-and-mutator
  zstream-avail_in-set!         zstream-avail_in-ref
  4
  pointer-set-c-unsigned-int!   pointer-ref-c-unsigned-int)

(define-c-struct-accessor-and-mutator
  zstream-total_in-set!         zstream-total_in-ref
  8
  pointer-set-c-unsigned-int!   pointer-ref-c-unsigned-int)

(define-c-struct-accessor-and-mutator
  zstream-next_out-set!         zstream-next_out-ref
  12
  pointer-set-c-pointer!        pointer-ref-c-pointer)

(define-c-struct-accessor-and-mutator
  zstream-avail_out-set!        zstream-avail_out-ref
  16
  pointer-set-c-unsigned-int!   pointer-ref-c-unsigned-int)

(define-c-struct-accessor-and-mutator
  zstream-total_out-set!        zstream-total_out-ref
  20
  pointer-set-c-unsigned-int!   pointer-ref-c-unsigned-int)
@end example

Occasionally, a C language data structure embeds an array of values;
this is the case of @samp{struct dirent} defined by @posix{}, which may
be declared like this (from the @gnu{} C library):

@example
struct dirent
@{
  __ino_t               d_ino;
  __off_t               d_off;
  unsigned short int    d_reclen;
  unsigned char         d_type;
  char                  d_name[256];
@};
@end example

@noindent
the field @samp{d_name} cannot be accessed like the other fields; what
we need to do is to take the offset of the first byte of @samp{d_name}
and add it to the structure's pointer: The result is a pointer to the
first byte in the embedded array.  This is what the following macro
does.


@deffn Syntax define-c-struct-field-pointer-accessor @ameta{accessor-name} @ameta{field-offset}
Define a macro named @meta{accessor-name} which accepts as single
argument a pointer to a data structure, its expansion is the sum between
the structure's pointer and @meta{field-offset}: A pointer which can be
used to access the field's contents.

@meta{accessor-name} must be a Scheme symbol.  @meta{field-offset} must
be an exact non--negative integer, representing the offset of the
field's first byte in the data structure.

As a special case, if @meta{field-offset} is @false{}: The defined macro
expands into an invocation of @func{raise-unimplemented-error}, which
signals that the mutator for the field is not implemented.  This is
useful in cases where it is not possible to determine the offset of a
field.  @ref{naulib unimplemented, Unimplemented error condition}
@end deffn


In the case of the @samp{d_name} field of the @samp{struct dirent} we
could define:

@example
(define-c-struct-field-pointer-accessor
  struct-dirent-d_name-ref 11)
@end example

@noindent
and then use code like the following:

@example
(define dir             ;pointer to a directory stream
  (opendir "/home/marco"))

(define entry           ;pointer to a 'struct dirent'
  (readdir dir))

(define directory-name  ;pointer to a C string
  (struct-dirent-d_name-ref entry))
@end example

@c page
@node ffi headers
@subsection Inspecting foreign header files


C language header files inspection is performed with @gnu{} Autoconf.
@value{PACKAGE} is distributed with a library of Autoconf macros in the
file @file{nausicaa.autoconf}; to use it we must use @gnu{} Autoconf to
configure a project and include @file{nausicaa.autoconf} in the
@file{aclocal.m4} file.

The Autoconf macros described here are meant to be used in the
@file{configure.ac} file; they define Autoconf @dfn{output variables}
which should be used to process a Scheme library for substitution of
@samp{@@...@@} symbols.

@menu
* ffi headers setup::           Setting up the C language environment.
* ffi headers includes::        Including header files.
* ffi headers valueof::         Determining the value of expressions.
* ffi headers sizeof::          Determining the size of data types.
* ffi headers typeof::          Determining the basic type of data types.
* ffi headers alignof::         Determining the alignment of data types.
* ffi headers strideof::        Determining the array stride of data types.
* ffi headers offsetof::        Determining the offset of fields in data
                                structures.
* ffi headers access::          Determining the accessors of data types.
* ffi headers inspect::         Full inspection of data types.
* ffi headers string::          Determining string values.
* ffi headers common::          Common groups of tests.
@end menu

@c page
@node ffi headers setup
@subsubsection Setting up the C language environment


@deffn {Autoconf Macro} NAUSICAA_SYSTEM_SETUP
Setup what is needed to inspect the system.  Useful (but probably not
mandatory) when we need to use the C compiler to inspect system
facilities; not needed in the other cases.
@end deffn


@deffn {Autoconf Macro} NAUSICAA_C_LANGUAGE
Setup the C language environment.  Mandatory when we need to use the C
compiler to inspect system and libraries facilities.
@end deffn

@c page
@node ffi headers includes
@subsubsection Including header files


@deffn {Autoconf Macro} NAUSICAA_INCLUDES_DEFAULT (@var{headers})
Expand to the specification of C language headers inclusion.  Its value
is:

@example
AC_INCLUDES_DEFAULT
#ifdef HAVE_ERRNO_H
#  include <errno.h>
#endif
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif
#ifdef HAVE_INTTYPES_H
#  include <inttypes.h>
#endif
#ifdef HAVE_LIMITS_H
#  include <limits.h>
#endif
#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
@end example

@noindent
and additionally: the current value of the
@samp{NAUSICAA_CUSTOM_INCLUDES} macro is appended along with the
optional @var{headers}.  @samp{AC_INCLUDES_DEFAULT} is defined by
Autoconf.  @autoconfref{Default Includes,Default Includes}

For example, it can be used as third argument for @samp{AC_COMPUTE_INT},
without arguments:

@example
AC_COMPUTE_INT([THE_IMAX],[INT_MAX],
  [NAUSICAA_INCLUDES_DEFAULT])
@end example

@noindent
or with arguments:

@example
AC_COMPUTE_INT([SIZEOF_MPFR],[sizeof(mpfr_t)],
  NAUSICAA_INCLUDES_DEFAULT([#include <gmp.h>
#include <mpfr.h>])
@end example
@end deffn


@deffn {Autoconf Macro} NAUSICAA_CUSTOM_INCLUDES
Appended to the expansion of @coode{NAUSICAA_INCLUDES_DEFAULT}; by
default defined to the empty string, it is meant to be redefined in the
@file{configure.ac} template file.

For example an extension for the cURL library can do:

@example
m4_define([NAUSICAA_CUSTOM_INCLUDES],[
#include <curl/curl.h>
])
@end example

@noindent
while an extension for the Zlib library can do:

@example
m4_define([NAUSICAA_CUSTOM_INCLUDES],[
#include <zlib.h>
])
@end example
@end deffn

@c page
@node ffi headers valueof
@subsubsection Determining the value of expressions


It is often needed to know the value of a C language expression.  The
following acquires the value of @samp{INT_MAX} (defined in
@file{limits.h}) and assigns it to the output variable
@samp{VALUEOF_INT_MAX}:

@example
NAUSICAA_VALUEOF_TEST([INT_MAX],[INT_MAX])
@end example

@noindent
while the following acquires the offset of the field @samp{l_start} in
the structure @samp{struct flock} (defined in @file{fcntl.h}):

@example
NAUSICAA_VALUEOF_TEST([OFFSETOF_STRUCT_FLOCK_L_START],
   [offsetof(struct flock,l_start)])
@end example

@noindent
the @samp{offsetof} operator is a C preprocessor macro, which can be
defined as:

@example
#define offsetof(TYPE,FIELD)            \
                                        \
  ((void *) &(((TYPE) *) 0)->(FIELD))
@end example

@noindent
when missing in the C library's headers.


@deffn {Autoconf Macro} NAUSICAA_VALUEOF_TEST (@var{suffix}, @var{expr}, @var{default}, @var{headers})
A wrapper for the Autoconf macro @samp{AC_COMPUTE_INT} that acquires the
value of a C language expression, which must be an integer.

The output variable @samp{VALUEOF_<@var{suffix}>} is set to the result.
If the test fails: The value of the output variable will be
@var{default}, or @false{} if @var{default} is not given.

The optional @var{headers} must be a chunk of code including header
files.  By default the expansion of @samp{NAUSICAA_INCLUDES_DEFAULT} is
included in the test program.
@end deffn


@deffn {Autoconf Macro} NAUSICAA_ENUM_VALUE @var{symbol} @var{headers}
Wrapper for @code{NAUSICAA_VALUEOF_TEST} which expands to:

@example
NAUSICAA_VALUEOF_TEST([@var{symbol}],[@var{symbol}],,[@var{headers}])
@end example
@end deffn


@deffn {Autoconf Macro} NAUSICAA_DEFINE_VALUE @var{symbol} @var{headers}
Wrapper for @code{NAUSICAA_VALUEOF_TEST} which expands to:

@example
NAUSICAA_VALUEOF_TEST([@var{symbol}],[@var{symbol}],,[@var{headers}])
@end example
@end deffn

@c page
@node ffi headers sizeof
@subsubsection Determining the size of data types


It is often needed to know the size of a C language data type.  The
following determines the size in bytes of @samp{unsigned int} and
assigns it to the output variable @samp{SIZEOF_UINT}:

@example
NAUSICAA_SIZEOF_TEST([UINT],[unsigned int])
@end example

@noindent
the following determines the size of the field @samp{l_start} in the
structure @samp{struct flock} (defined in @file{fcntl.h}) and stores it
in the output variable @samp{SIZEOF_STRUCT_FLOCK_L_START}:

@example
NAUSICAA_SIZEOF_FIELD_TEST([OFFSETOF_STRUCT_FLOCK_L_START],
   [struct flock],
   [l_start])
@end example


@deffn {Autoconf Macro} NAUSICAA_SIZEOF_TEST (@var{suffix}, @var{typedef}, @var{default}, @var{headers})
A wrapper for the Autoconf macro @samp{AC_COMPUTE_INT} that acquires the
size of a C language type.

The output variable @samp{SIZEOF_<@var{suffix}>} will be set to the
result.  If the test fails the value of the output variable will be
@var{default}, or @false{} if @var{default} is not given.

The optional @var{headers} must be a chunk of code including header
files.  By default the expansion of @samp{NAUSICAA_INCLUDES_DEFAULT} is
included in the test program.
@end deffn


@deffn {Autoconf Macro} NAUSICAA_SIZEOF_FIELD_TEST (@var{suffix}, @var{struct}, @var{field}, @var{default}, @var{headers})
A wrapper for the Autoconf macro @samp{AC_COMPUTE_INT} that acquires the
size of the field of a C language structure type.

The output variable @samp{SIZEOF_<@var{suffix}>} will be set to the
result.  If the test fails the value of the output variable will be
@var{default}, or @false{} if @var{default} is not given.

@var{struct} must be the type of the structure, usable in a variable
declaration.  @var{field} must be the name of the field.

The optional @var{headers} must be a chunk of code including header
files.  By default the expansion of @samp{NAUSICAA_INCLUDES_DEFAULT} is
included in the test program.
@end deffn

@c page
@node ffi headers typeof
@subsubsection Determining the basic type of data types


It is often needed to know the basic type of a derived or custom C
language data type.  The following determines the type of @samp{ssize_t}
(knowing that it is an signed integer) and assigns it to the output
variable @samp{TYPEOF_SSIZE_T}:

@example
NAUSICAA_SIZEOF_TEST([SIZE_T],[ssize_t])
NAUSICAA_INTTYPE_TEST([SIZE_T],[ssize_t])
@end example

@noindent
the following determines the type of @samp{size_t} (knowing that it is
an unsigned integer) and assigns it to the output variable
@samp{TYPEOF_SIZE_T}:

@example
NAUSICAA_SIZEOF_TEST([SIZE_T],[size_t])
NAUSICAA_UINTTYPE_TEST([SIZE_T],[size_t])
@end example

@noindent
and the following does the same as the above:

@example
NAUSICAA_SIZEOF_TEST([SIZE_T],[size_t])
NAUSICAA_BASE_TYPE_TEST([SIZE_T],[size_t],[unsigned-int])
@end example


@deffn {Autoconf Macro} NAUSICAA_BASE_TYPE_TEST (@var{suffix}, @var{typedef}, @var{type-guess})
Determine the equivalent basic type of the C language type
@var{typedef}.  This is a wrapper for the macros described below, to
which the @var{suffix} and @var{typedef} arguments are handed unchanged.

@var{type-guess} selects which macro to use:

@table @samp
@item signed-int
Selects @samp{NAUSICAA_INTTYPE_TEST}.

@item unsigned-int
Selects @samp{NAUSICAA_UINTTYPE_TEST}.

@item float
Selects @samp{NAUSICAA_FLOATTYPE_TEST}.
@end table

@samp{pointer} is a special value of @var{type-guess} that selects no
macro but sets the output variable @samp{TYPEOF_<@var{suffix}>} to
@samp{pointer}.
@end deffn


@deffn {Autoconf Macro} NAUSICAA_INTTYPE_TEST (@var{suffix}, @var{typedef})
Determine the equivalent basic integer type of the C language type
@var{typedef} among the set:

@example
char
short int
int
long
long long
@end example

The output variable @samp{TYPEOF_<@var{suffix}>} is set to a result
among:

@example
signed-char
signed-int
signed-short
signed-long
signed-long-long
@end example

If the test fails: The output variable is set to @false{}.

The search is performed by comparing the value of the variable
@samp{SIZEOF_<@var{suffix}>} with the values of the variables:

@example
SIZEOF_CHAR
SIZEOF_INT
SIZEOF_SHORT_INT
SIZEOF_LONG
SIZEOF_LLONG
@end example

@noindent
defined by the macro @samp{NAUSICAA_SIZEOF}.
@samp{SIZEOF_<@var{suffix}>} must have been set in precedence using the
macro @samp{NAUSICAA_SIZEOF_TEST} or an equivalent macro.
@end deffn


@deffn {Autoconf Macro} NAUSICAA_UINTTYPE_TEST (@var{suffix}, @var{typedef})
Determine the equivalent basic unsigned integer type of the C language
type @var{typedef} among the set:

@example
unsigned char
unsigned short int
unsigned int
unsigned long
unsigned long long
@end example

The output variable @samp{TYPEOF_<@var{suffix}>} is set to a result
among:

@example
unsigned-char
unsigned-int
unsigned-short
unsigned-long
unsigned-long-long
@end example

If the test fails: The output variable is set to @false{}.

The search is performed by comparing the value of the variable
@samp{SIZEOF_<@var{suffix}>} with the values of the variables:

@example
SIZEOF_CHAR
SIZEOF_UINT
SIZEOF_SHORT_UINT
SIZEOF_ULONG
SIZEOF_ULLONG
@end example

@noindent
defined by the macro @samp{NAUSICAA_SIZEOF}.
@samp{SIZEOF_<@var{suffix}>} must have been set in precedence using the
macro @samp{NAUSICAA_SIZEOF_TEST} or an equivalent macro.
@end deffn


@deffn {Autoconf Macro} NAUSICAA_FLOATTYPE_TEST (@var{suffix}, @var{typedef})
Determine the equivalent basic floating point type of the C language
type @var{typedef} among the set:

@example
float
double
long double
@end example

The output variable @samp{TYPEOF_<@var{suffix}>} is set to a result
among:

@example
float
double
long-double
@end example

If the test fails: The output variable is set to @false{}.

The search is performed by comparing the value of the variable
@samp{SIZEOF_<@var{suffix}>} with the values of the variables:

@example
SIZEOF_FLOAT
SIZEOF_DOUBLE
SIZEOF_LONG_DOUBLE
@end example

@noindent
defined by the macro @samp{NAUSICAA_SIZEOF}.
@samp{SIZEOF_<@var{suffix}>} must have been set in precedence using the
macro @samp{NAUSICAA_SIZEOF_TEST} or an equivalent macro.
@end deffn

@c page
@node ffi headers alignof
@subsubsection Determining the alignment of data types


It is sometimes needed to know the alignment of a C language data type
in data structures.  The following determines the alignment in bytes of
@samp{unsigned int} and assigns it to the output variable
@samp{ALIGNOF_UINT}:

@example
NAUSICAA_ALIGNOF_TEST([UINT],[unsigned int])
@end example


@deffn {Autoconf Macro} NAUSICAA_ALIGNOF_TEST (@var{suffix}, @var{typedef}, @var{default}, @var{headers})
Acquire the alignment of a C language type.

The output variable @samp{ALIGNOF_<@var{suffix}>} will be set to the
result.  If the test fails the value of the output variable will be
@var{default}, or @false{} if @var{default} is not given.

The optional @var{headers} must be a chunk of code including header
files.  By default the expansion of @samp{NAUSICAA_INCLUDES_DEFAULT} is
included in the test program.
@end deffn

@c page
@node ffi headers strideof
@subsubsection Determining the array stride of data types


When accessing a block of memory as an array of values of a given data
type, we must know the stride of the elements: The number of bytes
between the first byte of an element and the first byte of its forward
adjacent.  The following determines the stride in bytes of
@samp{unsigned int} and assigns it to the output variable
@samp{STRIDEOF_UINT}:

@example
NAUSICAA_STRIDEOF_TEST([UINT],[unsigned int])
@end example


@deffn {Autoconf Macro} NAUSICAA_STRIDEOF_TEST (@var{suffix}, @var{typedef}, @var{default}, @var{headers})
Acquire the stride of a C language type.

The output variable @samp{STRIDEOF_<@var{suffix}>} will be set to the
result.  If the test fails the value of the output variable will be
@var{default}, or @false{} if @var{default} is not given.

The optional @var{headers} must be a chunk of code including header
files.  By default the expansion of @samp{NAUSICAA_INCLUDES_DEFAULT} is
included in the test program.
@end deffn

@c page
@node ffi headers offsetof
@subsubsection Determining the offset of fields in data structures


It is often needed to know the offset of a field in a C language data
structure.  From a pointer to the first byte of a data structure and the
offset of one of its fields, we can compute the pointer to the first
byte of the fields by adding the two.

The following determines the offset of the field @samp{l_start} in the
structure @samp{struct flock} (defined in @file{fcntl.h}) and stores it
in the output variable @samp{OFFSETOF_STRUCT_FLOCK_L_START}:

@example
NAUSICAA_OFFSETOF_FIELD_TEST([OFFSETOF_STRUCT_FLOCK_L_START],
   [struct flock],
   [l_start])
@end example

@noindent
the following does the same for the @samp{l_whence} field and stores it
in the output variable @samp{OFFSETOF_STRUCT_FLOCK_L_WHENCE}:

@example
NAUSICAA_OFFSETOF_FIELD_TEST([OFFSETOF_STRUCT_FLOCK_L_WHENCE],
   [struct flock],
   [l_whence])
@end example


@deffn {Autoconf Macro} NAUSICAA_OFFSETOF_FIELD_TEST (@var{suffix}, @var{struct}, @var{field}, @var{headers})
A wrapper for the Autoconf macro @samp{AC_COMPUTE_INT} that acquires the
offset of a field in a C data structure.

@var{struct} is the type of the structure, @var{field} is the name of
the field.

The output variable @samp{OFFSETOF_<@var{SUFFIX}>} is set to the result.
If the test fails the value of the output variable will be @false{}.

The optional @var{headers} must be a chunk of code including header
files.  By default the expansion of @samp{NAUSICAA_INCLUDES_DEFAULT} is
included in the test program.
@end deffn

@c page
@node ffi headers access
@subsubsection Determining the accessors of data types


@deffn {Autoconf Macro} NAUSICAA_ACCESSORS_TEST (@var{suffix}, @var{typedef})
Expands to:

@example
NAUSICAA_GETTER_TEST(@var{suffix},@var{typedef})
NAUSICAA_SETTER_TEST(@var{suffix},@var{typedef})
@end example
@end deffn


@deffn {Autoconf Macro} NAUSICAA_GETTER_TEST (@var{suffix}, @var{typedef})
Determines the getter to be used for the C language type @var{typedef}.

The output variable @samp{GETTEROF_<@var{suffix}>} is set to the name of
the getter, which will be one among:

@example
pointer-ref-c-signed-char
pointer-ref-c-unsigned-char
pointer-ref-c-signed-int
pointer-ref-c-unsigned-int
pointer-ref-c-signed-short
pointer-ref-c-unsigned-short
pointer-ref-c-signed-long
pointer-ref-c-unsigned-long
pointer-ref-c-signed-long-long
pointer-ref-c-unsigned-long-long
pointer-ref-c-float
pointer-ref-c-double
pointer-ref-c-long-double
pointer-ref-c-pointer
@end example

@noindent
if the test fails: The output variable will be set to @false{}.

The search is performed by comparing the value of the variable
@samp{TYPEOF_<@var{suffix}>} with the values:

@example
signed-char             unsigned-char
signed-short            unsigned-short
signed-int              unsigned-int
signed-long             unsigned-long
signed-long-long        unsigned-long-long
float                   double
long-double             pointer
@end example
@end deffn


@deffn {Autoconf Macro} NAUSICAA_SETTER_TEST (@var{suffix}, @var{typedef})
Determines the setter to be used for the C language type @var{typedef}.

The output variable @samp{SETTEROF_<@var{suffix}>} is set to the name of
the setter, which will be one among:

@example
pointer-set-c-signed-char!
pointer-set-c-unigned-char!
pointer-set-c-signed-int!
pointer-set-c-unsigned-int!
pointer-set-c-signed-short!
pointer-set-c-unsigned-short!
pointer-set-c-signed-long!
pointer-set-c-unsigned-long!
pointer-set-c-signed-long-long!
pointer-set-c-unsigned-long-long!
pointer-set-c-float!
pointer-set-c-double!
pointer-set-c-long-double!
pointer-set-c-pointer!
@end example

@noindent
if the test fails: The output variable will be set to @false{}.

The search is performed by comparing the value of the variable
@samp{TYPEOF_<@var{suffix}>} with the values:

@example
signed-char             unsigned-char
signed-short            unsigned-short
signed-int              unsigned-int
signed-long             unsigned-long
signed-long-long        unsigned-long-long
float                   double
long-double             pointer
@end example
@end deffn

@c page
@node ffi headers inspect
@subsubsection Full inspection of data types


@deffn {Autoconf Macro} NAUSICAA_INSPECT_TYPE (@var{suffix}, @var{typedef}, @var{type-guess}, @var{default}, @var{headers})
Perform a full inspection for a C language type definition.  This macro
is a wrapper for other more basic macros, and it expands to:

@example
NAUSICAA_SIZEOF_TEST(@var{suffix},@var{typedef},@var{default},@var{headers})
NAUSICAA_ALIGNOF_TEST(@var{suffix},@var{typedef},@var{default},@var{headers})
NAUSICAA_STRIDEOF_TEST(@var{suffix},@var{typedef},@var{default},@var{headers})
NAUSICAA_BASE_TYPE_TEST(@var{suffix},@var{typedef},@var{type-guess})
NAUSICAA_ACCESSORS_TEST(@var{suffix},@var{typedef})
@end example
@end deffn


@deffn {Autoconf Macro} NAUSICAA_INSPECT_STRUCT_TYPE (@var{suffix}, @var{typedef}, @var{default}, @var{headers})
Perform a full inspection for a C language structure type definition.
This macro is a wrapper for other more basic macros, and it expands to:

@example
NAUSICAA_SIZEOF_TEST(@var{suffix},@var{typedef},@var{default},@var{headers})
NAUSICAA_ALIGNOF_TEST(@var{suffix},@var{typedef},@var{default},@var{headers})
NAUSICAA_STRIDEOF_TEST(@var{suffix},@var{typedef},@var{default},@var{headers})
@end example
@end deffn


@deffn {Autoconf Macro} NAUSICAA_INSPECT_FIELD_TYPE (@var{suffix}, @var{struct-typedef}, @var{field-name}, @var{type-guess}, @var{default}, @var{headers})
Perform a full inspection for a C language field structure type
definition.  This macro is a wrapper for other more basic macros, and it
expands to:

@example
NAUSICAA_OFFSETOF_FIELD_TEST(@var{suffix},@var{struct-typedef},
                             @var{field-name},@var{headers})
NAUSICAA_SIZEOF_FIELD_TEST(@var{suffix},@var{struct-typedef},
                           @var{field-name},@var{default},@var{headers})
NAUSICAA_BASE_TYPE_TEST(@var{suffix},
                        @var{struct-typedef}.@var{field-name},
                        @var{type-guess})
NAUSICAA_ACCESSORS_TEST(@var{suffix},
                        @var{struct-typedef}.@var{field-name})
@end example
@end deffn


@deffn {Autoconf Macro} NAUSICAA_INSPECT_FIELD_TYPE_POINTER (@var{suffix}, @var{struct-typedef}, @var{field-name}, @var{headers})
Perform an inspection for a C language field structure type definition,
but only to acquire the offset.  This macro is required when we need to
access a structure field through a pointer to it; an example is the
@samp{d_name} field of @samp{struct dirent} from @file{dirent.h}.
@ref{ffi struct, Accessing data structures} for a discussion of this
case.

Only the offset of the field (output variable
@samp{OFFSETOF_<@var{SUFFIX}>}) is defined.
@end deffn

@c page
@node ffi headers string
@subsubsection Determining string values


It is often needed to know the string vlaue of a language expression.
The following determines the string value of the @code{SQLITE_VERSION}
preprocessor symbol (defined in @file{sqlite3.h}) and stores it in the
output variable @samp{STRINGOF_SQLITE_version}:

@example
NAUSICAA_STRING_TEST([SQLITE_VERSION],[SQLITE_VERSION],
  [#f],[#include <sqlite3.h>])
@end example


@deffn {Autoconf Macro} NAUSICAA_STRING_TEST (@var{suffix}, @var{expression}, @var{default}, @var{headers})
A wrapper for the Autoconf macro @samp{AC_LANG_PROGRAM} that acquires
the string value of a C language expression.

The output variable @samp{OFFSETOF_<@var{SUFFIX}>} is set to the result.
If the test fails the value of the output variable will be
@var{default}, or @false{} if @var{default} is not given.

The optional @var{headers} must be a chunk of code including header
files.  By default the expansion of @samp{NAUSICAA_INCLUDES_DEFAULT} is
included in the test program.
@end deffn

@c page
@node ffi headers common
@subsubsection Common groups of tests


@deffn {Autoconf Macro} NAUSICAA_SIZEOF
Perform tests to determine the size (the number of bytes) of the common
C language types.  The following output variables are defined:

@multitable {SIZEOF_SHORT_UINT} {unsigned long long}
@headitem Variable @tab Size of C type
@item SIZEOF_INT8
@tab int8_t
@item SIZEOF_INT16
@tab int16_t
@item SIZEOF_INT32
@tab int32_t
@item SIZEOF_INT64
@tab int64_t
@item SIZEOF_CHAR
@tab char
@item SIZEOF_SHORT_INT
@tab short int
@item SIZEOF_SHORT_UINT
@tab unsigned short int
@item SIZEOF_INT
@tab int
@item SIZEOF_UINT
@tab unsigned int
@item SIZEOF_LONG
@tab long
@item SIZEOF_ULONG
@tab unsigned long
@item SIZEOF_LLONG
@tab long long
@item SIZEOF_ULLONG
@tab unsigned long long
@item SIZEOF_FLOAT
@tab float
@item SIZEOF_DOUBLE
@tab double
@item SIZEOF_POINTER
@tab void *
@end multitable

@multitable {ALIGNOF_SHORT_UINT} {unsigned long long}
@headitem Variable @tab Alignment of C type
@item ALIGNOF_INT8
@tab int8_t
@item ALIGNOF_INT16
@tab int16_t
@item ALIGNOF_INT32
@tab int32_t
@item ALIGNOF_INT64
@tab int64_t
@item ALIGNOF_CHAR
@tab char
@item ALIGNOF_SHORT_INT
@tab short int
@item ALIGNOF_SHORT_UINT
@tab unsigned short int
@item ALIGNOF_INT
@tab int
@item ALIGNOF_UINT
@tab unsigned int
@item ALIGNOF_LONG
@tab long
@item ALIGNOF_ULONG
@tab unsigned long
@item ALIGNOF_LLONG
@tab long long
@item ALIGNOF_ULLONG
@tab unsigned long long
@item ALIGNOF_FLOAT
@tab float
@item ALIGNOF_DOUBLE
@tab double
@item ALIGNOF_POINTER
@tab void *
@end multitable

@multitable {STRIDEOF_SHORT_UINT} {unsigned long long 12}
@headitem Variable @tab Array stride of C type
@item STRIDEOF_INT8
@tab int8_t
@item STRIDEOF_INT16
@tab int16_t
@item STRIDEOF_INT32
@tab int32_t
@item STRIDEOF_INT64
@tab int64_t
@item STRIDEOF_CHAR
@tab char
@item STRIDEOF_SHORT_INT
@tab short int
@item STRIDEOF_SHORT_UINT
@tab unsigned short int
@item STRIDEOF_INT
@tab int
@item STRIDEOF_UINT
@tab unsigned int
@item STRIDEOF_LONG
@tab long
@item STRIDEOF_ULONG
@tab unsigned long
@item STRIDEOF_LLONG
@tab long long
@item STRIDEOF_ULLONG
@tab unsigned long long
@item STRIDEOF_FLOAT
@tab float
@item STRIDEOF_DOUBLE
@tab double
@item STRIDEOF_POINTER
@tab void *
@end multitable

Additionally @samp{TYPEOF_POINTER_INTEGER} is set to the type
specification of the integer whose size equals the size of a pointer.
It is one among @samp{unsigned-int} and @samp{unsigned-long}
@end deffn


@deffn {Autoconf Macro} NAUSICAA_C_TYPES_LIMITS
Perform tests to determine the value of limits for the common C language
types.  The following output variables are defined:

@multitable {VALUEOF_ULLONG_MAX} {Original C expression}
@headitem Variable @tab Original C expression
@item VALUEOF_CHAR_MAX
@tab CHAR_MAX
@item VALUEOF_CHAR_MIN
@tab CHAR_MIN
@item VALUEOF_SCHAR_MAX
@tab SCHAR_MAX
@item VALUEOF_SCHAR_MIN
@tab SCHAR_MIN
@item VALUEOF_UCHAR_MAX
@tab UCHAR_MAX
@item VALUEOF_SHRT_MAX
@tab SHRT_MAX
@item VALUEOF_SHRT_MIN
@tab SHRT_MIN
@item VALUEOF_USHRT_MAX
@tab USHRT_MAX
@item VALUEOF_INT_MAX
@tab INT_MAX
@item VALUEOF_INT_MIN
@tab INT_MIN
@item VALUEOF_UINT_MAX
@tab UINT_MAX
@item VALUEOF_LONG_MAX
@tab LONG_MAX
@item VALUEOF_LONG_MIN
@tab LONG_MIN
@item VALUEOF_ULONG_MAX
@tab ULONG_MAX
@item VALUEOF_LLONG_MAX
@tab LLONG_MAX
@item VALUEOF_LLONG_MIN
@tab LLONG_MIN
@item VALUEOF_ULLONG_MAX
@tab ULLONG_MAX
@item VALUEOF_WCHAR_MAX
@tab WCHAR_MAX
@item VALUEOF_SSIZE_MAX
@tab SSIZE_MAX
@end multitable

Additionally the output variable @samp{WORDS_BIGENDIAN} is set to
@true{} if the underlying platform is big endian, to @false{} otherwise.
@end deffn


@deffn {Autoconf Macro} NAUSICAA_C_ERRNO
Perform tests to determine the value of all the known @samp{errno}
predefined values.  The following list of @samp{errno} symbols is used
to define output variables with prefix @samp{VALUEOF_}.

@example
EPERM           ENOENT          ESRCH           EINTR
EIO             ENXIO           E2BIG           ENOEXEC
EBADF           ECHILD          EAGAIN          ENOMEM
EACCES          EFAULT          ENOTBLK         EBUSY
EEXIST          EXDEV           ENODEV          ENOTDIR
EISDIR          EINVAL          ENFILE          EMFILE
ENOTTY          ETXTBSY         EFBIG           ENOSPC
ESPIPE          EROFS           EMLINK          EPIPE
EDOM            ERANGE          EDEADLK         ENAMETOOLONG
ENOLCK          ENOSYS          ENOTEMPTY       ELOOP
EWOULDBLOCK     ENOMSG          EIDRM           ECHRNG
EL2NSYNC        EL3HLT          EL3RST          ELNRNG
EUNATCH         ENOCSI          EL2HLT          EBADE
EBADR           EXFULL          ENOANO          EBADRQC
EBADSLT         EDEADLOCK       EBFONT          ENOSTR
ENODATA         ETIME           ENOSR           ENONET
ENOPKG          EREMOTE         ENOLINK         EADV
ESRMNT          ECOMM           EPROTO          EMULTIHOP
EDOTDOT         EBADMSG         EOVERFLOW       ENOTUNIQ
EBADFD          EREMCHG         ELIBACC         ELIBBAD
ELIBSCN         ELIBMAX         ELIBEXEC        EILSEQ
ERESTART        ESTRPIPE        EUSERS          ENOTSOCK
EDESTADDRREQ    EMSGSIZE        EPROTOTYPE      ENOPROTOOPT
EPROTONOSUPPORT ESOCKTNOSUPPORT EOPNOTSUPP      EPFNOSUPPORT
EAFNOSUPPORT    EADDRINUSE      EADDRNOTAVAIL   ENETDOWN
ENETUNREACH     ENETRESET       ECONNABORTED    ECONNRESET
ENOBUFS         EISCONN         ENOTCONN        ESHUTDOWN
ETOOMANYREFS    ETIMEDOUT       ECONNREFUSED    EHOSTDOWN
EHOSTUNREACH    EALREADY        EINPROGRESS     ESTALE
EUCLEAN         ENOTNAM         ENAVAIL         EISNAM
EREMOTEIO       EDQUOT          ENOMEDIUM       EMEDIUMTYPE
ECANCELED       ENOKEY          EKEYEXPIRED     EKEYREVOKED
EKEYREJECTED    EOWNERDEAD      ENOTRECOVERABLE
@end example
@end deffn

@c page
@node memory
@section Low level memory handling


The @library{foreign memory} library exports a low level @api{} for
memory allocation and access; memory allocated with this @api{} is not
subjected to garbage collection.  It is a compound library re--exporting
@api{}s from the following component libraries:

@example
(foreign memory alloc)
(foreign memory bytevectors)
(foreign memory caches)
(foreign memory conditions)
(foreign memory memblocks)
(foreign memory operations)
(foreign ffi peekers-and-pokers)
(foreign ffi pointers)
@end example

More libraries export other memory related @api{}s.

@menu
* memory conditions::           Out of memory errors.
* memory alloc::                Allocation functions.
* memory blocks::               Memory blocks.
* memory cache::                Caching memory blocks.
* memory compensate::           Compensations.
* memory operations::           Operations.
* memory bytevectors::          Bytevectors conversion.

Independent libraries

* memory mempool::              Allocation from a memory pool.
* memory refcount::             Reference counting.
* memory membuffer::            Memory buffers.
* memory guarded::              Guarded memory allocation.
@end menu

@c page
@node memory conditions
@subsection Out of memory errors


The following bindings are exported by @library{foreign memory
conditions} and re--exported by @library{foreign memory}.


@deftp Condition {&out-of-memory}
Type of condition objects representing a memory allocation error; it is
derived from @condition{error}.  It has the following fields:

@table @code
@item number-of-bytes
An exact non--negative integer representing the number of bytes
requested in the failed memory allocation; it can be set to @false{} if
the number is not known (for example when the error is raised by a
foreign library).
@end table

This condition type is for failed memory allocations @strong{not} meant
to be recoverable by an exception handler.
@end deftp


@deftp Condition {&memory-request}
Type of condition objects representing a memory allocation error; it is
derived from @condition{out-of-memory}.  It has the following fields:

@table @code
@item clean
A boolean value, @true{} if the requested memory was meant to be reset
to zero.
@end table

This condition type is for failed memory allocations meant to be
recoverable by an exception handler.
@end deftp


@deffn {Condition Constructor} make-out-of-memory-condition @var{number-of-bytes}
@deffnx {Condition Predicate} out-of-memory-condition? @var{object}
@deffnx {Field Accessor} condition-out-of-memory/number-of-bytes @var{object}
Functions to handle non--recoverable out of memory condition objects.
@var{number-of-bytes} is the size of the requested allocation that could
not be satisfied.
@end deffn


@deffn {Condition Constructor} make-memory-request-condition @var{number-of-bytes} @var{clean}
@deffnx {Condition Predicate} memory-request-condition? @var{object}
@deffnx {Field Accessor} condition-memory-request/number-of-bytes @var{object}
@deffnx {Field Accessor} condition-memory-request/clean? @var{object}
Functions to handle recoverable out of memory condition objects.
@var{number-of-bytes} is the size of the requested allocation that could
not be satisfied.  @var{clean} must be a boolean value: @true{} if the
requested memory was meant to be reset to zero.
@end deffn


Examples:

@example
(define (malloc size)
  (or (primitive-malloc size)
      (raise
         (condition (make-who-condition 'malloc)
                    (make-message-condition "out of memory")
                    (make-out-of-memory-condition size)))))

(define (malloc* size)
  (or (primitive-malloc size)
      (raise-continuable
         (condition (make-who-condition 'malloc)
                    (make-message-condition "out of memory")
                    (make-memory-request-condition size #f)))))

(define (calloc* size)
  (or (primitive-calloc size)
      (raise-continuable
         (condition (make-who-condition 'malloc)
                    (make-message-condition "out of memory")
                    (make-memory-request-condition size #t)))))
@end example


@defun raise-out-of-memory @var{who} @var{number-of-bytes}
Raise a non--continuable exception representing a non--recoverable
memory allocation failure.  The raised condition object is a compound of
@condition{who}, @condition{message} and @condition{out-of-memory}.
@end defun


@defun raise-memory-request @var{who} @var{number-of-bytes} @var{clean}
Raise a continuable exception representing a recoverable memory
allocation failure.  The raised condition object is a compound of
@condition{who}, @condition{message} and @condition{memory-request}.  Functions
raising this condition should be ready to accept as return value the
requested block of memory (allocated by the exception handler).
@end defun

@c page
@node memory alloc
@subsection Allocation functions


The memory alloction @api{} described in this section is exported by
@library{foreign memory alloc} and re--exported by @library{foreign
memory}.

@menu
* memory alloc system::         System functions.
* memory alloc platform::       Platform functions.
* memory alloc primitive::      Primitive functions.
* memory alloc high::           Exception raising functions.
* memory alloc examples::       Memory allocation examples.
@end menu

@c page
@node memory alloc system
@subsubsection System functions


The system @api{} deals with pointer values as exact integers; it is a
very raw @api{} which should be used only when absolutely required.
Many functions in @library{foreign memory} require pointers to be of
type @samp{pointer}; sometimes, though, foreign libraries require the
raw pointer value, for example to be stored in structure fields.

For some Scheme implementations the @samp{system-} @api{} is a little
faster than the @samp{platform-} one, while for others it is a little
slower.


@defun system-malloc @var{number-of-bytes}
An interface to the system @cfunc{malloc} function.  Allocate a block of
memory and return a pointer to it as an exact integer.  If an allocation
error occurs: Return the integer zero.
@end defun


@defun system-realloc @var{pointer-integer} @var{number-of-bytes}
An interface to the system @cfunc{realloc} function.  Reallocate a block
of memory with different size and return a pointer to it as an exact
integer.  @var{pointer-integer} must be a pointer value expressed as
exact integer.  If an allocation error occurs: Return the integer zero.
@end defun


@defun system-calloc @var{count} @var{element-size}
An interface to the system @cfunc{calloc} function.  Allocate a block of
memory and return a pointer to it as an exact integer.  The block is big
enough to hold @var{count} objects each @var{element-size} wide.  If an
allocation error occurs: Return the integer zero.
@end defun


@defun system-free @var{pointer-integer}
An interface to the system @cfunc{free} function.  Release the block of
memory referenced by @var{pointer-integer}, which must be a pointer
value expressed as exact integer.
@end defun

@c page
@node memory alloc platform
@subsubsection Platform functions


@defun platform-malloc @var{number-of-bytes}
@defunx platform-malloc* @var{number-of-bytes}
An interface to the system @cfunc{malloc} function.  Allocate a block of
memory and return a pointer to it.  If an allocation error occurs:
@func{platform-malloc} returns a null pointer, @func{platform-malloc*}
returns @false{}.
@end defun


@defun platform-realloc @var{pointer} @var{new-number-of-bytes}
@defunx platform-realloc* @var{pointer} @var{new-number-of-bytes}
An interface to the system @cfunc{realloc} function.  Reallocate a block
of memory with different size and return a pointer to it.  If an
allocation error occurs: @func{platform-realloc} returns a null pointer,
@func{platform-realloc*} returns @false{}.
@end defun


@defun platform-calloc @var{count} @var{element-size}
@defunx platform-calloc* @var{count} @var{element-size}
An interface to the system @cfunc{calloc} function.  Allocate a block of
memory and return a pointer to it.  The block is big enough to hold
@var{count} objects each @var{element-size} wide.  Bytes in the block
are reset to zero.  If an allocation error occurs:
@func{platform-calloc} returns a null pointer, @func{platform-calloc*}
returns @false{}.
@end defun


@defun platform-free @var{pointer}
An interface to the system @cfunc{free} function.  Release the block of
memory referenced by @var{pointer}.  The return value is unspecified.
@end defun

@c page
@node memory alloc primitive
@subsubsection Primitive functions


The following functions perform allocation through customisable
functions, which allow allocation logging and validation of error
reactions.


@deffn Function primitive-malloc @var{number-of-bytes}
@deffnx Parameter primitive-malloc-function
@func{primitive-malloc} allocates a block of memory and returns a
pointer to it, or @false{} if an error occurs; the allocation is
performed using the current value of @func{primitive-malloc-function},
which must be a function.

The parameter is preset to @func{platform-malloc*}; if a custom function
is assigned to the parameter, it must match its behaviour.
@end deffn


@deffn Function primitive-realloc @var{pointer} @var{new-number-of-bytes}
@deffnx Parameter primitive-realloc-function
@func{primitive-realloc} reallocates a block of memory with a new size
and returns a pointer to the new block, or @false{} if an error occurs;
the allocation is performed using the current value of
@func{primitive-realloc-function}, which must be a function.

The parameter is preset to @func{platform-realloc*}; if a custom
function is assigned to the parameter, it must match its behaviour.
@end deffn


@deffn Function primitive-calloc @var{count} @var{element-size}
@deffnx Parameter primitive-calloc-function
@func{primitive-calloc} allocates a block of memory (big enough to hold
@var{count} elements of @var{element-size} each) and returns a pointer
to it, or @false{} if an error occurs; the allocation is performed using
the current value of @func{primitive-calloc-function}, which must be a
function.

The parameter is preset to @func{platform-calloc*}; if a custom function
is assigned to the parameter, it must match its behaviour.
@end deffn


@deffn Function primitive-free @var{pointer}
@deffnx Parameter primitive-free-function
@func{primitive-free} releases a block of memory; the release is
performed using the current value of @func{primitive-free-function},
which must be a function.

The parameter is preset to @func{platform-free}.
@end deffn

@c page
@node memory alloc high
@subsubsection Exception raising functions


@defun malloc @var{number-of-bytes}
@defunx realloc @var{pointer} @var{new-number-of-bytes}
@defunx calloc @var{count} @var{element-size}
Wrappers for the corresponding @samp{primitive-} functions that raise a
continuable @condition{memory-request} condition in case of error.  Blocks
of memory allocated with these functions can be freed with
@func{primitive-free}.

In case of error, it is fine to make the exception handler return to the
continuation a pointer to an allocated block of memory.
@end defun

@c page
@node memory alloc examples
@subsubsection Memory allocation examples


Care must be taken when managing memory with the low level functions:
Memory blocks will @strong{not} be garbage collected.  A method to
release memory needed in a form is to use @func{dynamic-wind}:

@example
(let ((p #f))
  (dynamic-wind
    (lambda () (set! p (malloc 123)))
    (lambda () (do-something-with p))
    (lambda () (primitive-free p))))
@end example

@noindent
another is to use a compensation (@pxref{compensations}):

@example
(with-compensations
  (letrec ((p (compensate
                  (malloc 123)
                (with
                  (primitive-free p)))))
    (do-something-with p)))
@end example

@noindent
another method, if supported, is to use @func{malloc/guarded},
@ref{memory guarded, guarded-malloc}

To test memory allocation failure we can do:

@example
(parametrise ((primitive-malloc-function (lambda args #f)))
  (let ((p (malloc 4096)))
    ---))
@end example

To log memory allocations we can do:

@example
(let-values (((port get-string) (open-string-output-port)))
  (define (logging-malloc number-of-bytes)
    (let ((p (platform-malloc number-of-bytes)))
      (display (format "malloc:\t~s ~s\n" p number-of-bytes)
               port)
      p))

  (define (logging-free pointer)
    (display (format "free:\t~s\n" pointer) port)
    (platform-free pointer))

  (parametrise ((primitive-malloc-function logging-malloc)
                (primitive-free-function   logging-free))
    (let ((p (malloc 4096)))
      ---
      (primitive-free p))))
@end example

@c page
@node memory blocks
@subsection Memory blocks


The following bindings are exported by @library{foreign memory memblocks}
and re--exported by @library{foreign memory}.  A number of libraries in
the @library{foreign memory ---} hierarchy makes use of this library.

To use the @class{memblock} record type with the @library{records}
library, we have to import @library{foreign memory memblock} for the
@samp{expand} phase.

A @class{memblock} is a record that holds a pointer to a raw memory
block and its size.  It is meant to reference, but not necessarily own,
a block of raw memory filled with data; a @class{memblock} should not be
used to reference half--filled memory.  For example, it can reference a
C language data structure or an array of data structures.  It is fine if
more @class{memblock} records reference the same block or overlapping
blocks.


@deftp {Record Type Name} <memblock>
@deftpx {Record Type Descriptor} <memblock-rtd>
Type of record used to represent memory blocks.  It has the following
fields:

@table @samp
@item pointer
A pointer value referencing a memory block.

@item size
The number of bytes in the referenced memory block.
@end table
@end deftp


@defun make-<memblock> @var{pointer} @var{number-of-bytes}
Build and return a new @class{memblock} record.
@end defun


@defun <memblock>? @var{obj}
Return true if @var{obj} is a record of type @class{memblock}, return
@false{} otherwise.
@end defun


@defun <memblock>-pointer @var{mb}
@defunx <memblock>-size @var{mb}
Field accessors.
@end defun

@c page
@node memory cache
@subsection Caching memory blocks


The following bindings are exported by @library{foreign memory caches}
and re--exported by @library{foreign memory}.  This library makes use of
@class{memblock} records, whose interface is exported by
@library{foreign memory memblocks}.


@defun make-block-cache @var{number-of-bytes} @var{max-depth}
Build and return a new memory blocks cache, for blocks of
@var{number-of-bytes}, which, at maximum, will cache @var{max-depth}
blocks.  The return value is an interface function with the following
protocol:

@table @emph
@item When the function is invoked with zero arguments
It retrieves a block from the set of cached blocks; if the set is empty:
A new block is allocated with @func{calloc}.  Return a pointer to the
block.

@item When the function is invoked with 1 argument
If the argument is the Scheme symbol @samp{purge}: @func{primitive-free}
is applied to all the blocks in the cache and the cache is reset to
empty.

If the argument is the Scheme symbol @samp{size}: The return value is
@var{number-of-bytes}.

Else the argument must be a pointer previously returned by this
interface function: If the number of blocks in the cache is less than
@var{max-depth}, the pointer is stored in the cache, else
@func{primitive-free} is applied to it.
@end table
@end defun


@defun small-blocks-cache
@defunx small-blocks-cache @var{pointer}
@defunx small-blocks-cache purge
@defunx small-blocks-cache size
Interface function for a cache of memory blocks of size @math{32},
@math{10} blocks deep.  This cache is meant to be used for temporary
storage space of output values from foreign--functions.  The size of
@math{32} should be enough to hold all the output values of C language
standard types.

Blocks are allocated with @func{calloc} and reset to zero with
@func{memset} when released, so they are guaranteed to be set to zero
when acquired.

For example, the @gnu{} Libgcrypt library has a constructor with this
prototype:

@example
gcry_error_t gcry_cipher_open (gcry_cipher_hd_t * hd,
                               int algo, int mode,
                               unsigned int flag);
@end example

@noindent
where @code{gcry_cipher_hd_t} is a @code{typedef} for an opaque pointer
(we can think of it as @code{void *}); the @var{hd} argument must
reference a pointer--sized location in which the function will store a
pointer to a newly allocated data structure; this location is required
only for the construction of a new object, so a Scheme interface could
do (unsafe code, not handling errors):

@example
(let ((hd* (small-blocks-cache)))
  (gcry_cipher_open hd* algo mode flag)
  (begin0
      (pointer-ref-c-pointer hd* 0)
    (small-blocks-cache hd*)))
@end example
@end defun


@defun page-blocks-cache
@defunx page-blocks-cache @var{pointer}
@defunx page-blocks-cache purge
@defunx page-blocks-cache size
Interface function for a cache of memory blocks of size 4096, 10 blocks
deep.
@end defun


@defvr Constant small-blocks-size
@defvrx Constant page-blocks-size
The size of the small and page blocks.
@end defvr


@defun memblocks-cache @var{memblock/size}
Interface function to memblocks allocation and release.  When
@var{memblock/size} is:

@table @emph
@item A record of type @class{memblock}
The function releases the allocated memory block.

@item An unsigned exact integer
The number is meant to represent the number of bytes to be allocated: A
new @class{memblock} record is allocated and returned.
@end table

Allocation and release of memory blocks is done, in this order:

@enumerate
@item
Relying on @func{small-blocks-cache} if the number of bytes is less than
or equal to the size of a small block.

@item
Relying on @func{page-blocks-cache} if the number of bytes is less than
or equal to the size of a page block.

@item
Relying on @func{calloc} and @func{primitive-free} in all the other cases.
@end enumerate
@end defun


@defun make-caching-object-factory @var{init-func} @var{final-func} @var{number-of-bytes} @var{max-depth}
Build and return a new caching object factory.  It is a wrapper for
@func{make-block-cache}, to which the @var{number-of-bytes} and
@var{max-depth} arguments are handed untouched.  The return value is an
interface function with the following protocol:

@table @emph
@item When the function is invoked with zero arguments
It retrieves a block from the cache and applies @var{init-func} to it; a
pointer to the block is returned.

@item When the function is invoked with 1 argument
If the argument is the symbol @samp{purge}: The same symbol is handed to
the block cache, causing the cache to be purged of allocated blocks.

If the argument is the symbol @samp{size}: The same symbol is handed to
the block cache, the return value is the cache memory block size.

Else the argument must be a pointer previously returned by this
interface function: @var{final-func} is applied to it, then it is handed
to the underlying block cache interface function.
@end table

For example, the @acronym{MPFR} library (Multiple Precision
Floating--Point Reliable Library) requires us to allocate structures of
type @code{mpfr_t}, then to use an initialiser and a finaliser with the
following prototypes:

@example
void mpfr_init  (mpfr_ptr p);
void mpfr_clear (mpfr_ptr p);
@end example

@noindent
@code{mpfr_t} values are real numbers with special representation, so we
may need a lot of them to carry on computations; a Scheme interface
could initialise itself like this:

@example
(define sizeof-mpfr 64) ;this must be exactly determined

(define mpfr-lib
  (let ((o (open-shared-object "libmpfr.so")))
    (shared-object o)
    o))

(define mpfr_ptr 'pointer)
(define-c-function mpfr_init  (void mpfr_init  (mpfr_ptr)))
(define-c-function mpfr_clear (void mpfr_clear (mpfr_ptr)))

(define mpfr
  (make-caching-object-factory mpfr_init mpfr_clear
                               sizeof-mpfr 100))

(define (mpfr/c)
  (letrec ((p (compensate (mpfr)
                (with (mpfr p)))))
    p))
@end example

@noindent
and then:

@example
(with-compensations
  (let ((a (mpfr/c))
        (b (mpfr/c)))
    (do-something-with a b)))
@end example

@noindent
at the end of the world, if we feel like it, we can do:

@example
(mpfr 'purge)
@end example
@end defun

@c page
@node memory compensate
@subsection Compensations


The functions described here make use of compensation stacks to handle
semi--automatice release of allocated memory.  @ref{compensations,
Compensation stacks}

The following bindings are exported by @library{foreign memory
compensated} and re--exported by @library{foreign memory}.  This library
makes internal use of @library{foreign memory caches}; the @api{}
requires also the @library{compensations} and @library{foreign memory
memblocks} libraries.


@defun malloc/compensated @var{number-of-bytes}
@defunx calloc/compensated @var{count} @var{element-size}
@defunx malloc/c @var{number-of-bytes}
@defunx calloc/c @var{count} @var{element-size}
Wrappers for @func{malloc} and @func{calloc} that allocate a block of
memory and return a pointer to it.  The appropriate invocation to
@func{primitive-free}, to free the block, is added to the dynamic
environment of the current compensations stack.
@end defun


@defun malloc-small/compensated
@defunx malloc-small/c
Acquire a small block of memory from @func{small-blocks-cache} and
return a pointer to it.  The appropriate invocation to
@func{small-blocks-cache}, to release the block, is added to the dynamic
environment of the current compensations stack.
@end defun


@defun malloc-page/compensated
@defunx malloc-page/c
Acquire a page of memory from @func{page-blocks-cache} and return a
pointer to it.  The appropriate invocation to @func{page-blocks-cache},
to release the block, is added to the dynamic environment of the current
compensations stack.
@end defun


@defun malloc-block/compensated @var{number-of-bytes}
@defunx malloc-block/c @var{number-of-bytes}
Allocate a new memory block and return a pointer to it.  The appropriate
invocation to the release function is added to the dynamic environment
of the current compensations stack.

Allocation and releasing of memory blocks is done, in this order:

@enumerate
@item
Relying on @func{small-blocks-cache} if the number of bytes is less than
or equal to the size of a small block.

@item
Relying on @func{page-blocks-cache} if the number of bytes is less than
or equal to the size of a page block.

@item
Relying on @func{calloc} and @func{primitive-free} in all the other cases.
@end enumerate
@end defun


@defun malloc-memblock/compensated @var{number-of-bytes}
@defunx malloc-memblock/c @var{number-of-bytes}
Acquire a block of memory from @func{memblocks-cache} and return a
record of type @class{memblock}.  The appropriate invocation to
@func{memblocks-cache}, to release the block, is added to the dynamic
environment of the current compensations stack.
@end defun

@c page
@node memory operations
@subsection Operations


The following bindings are exported by @library{foreign memory
operations} and re--exported by @library{foreign memory}.


@defun memcpy @var{dest-pointer} @var{source-pointer} @var{number-of-bytes}
An interface to the @cfunc{memcpy} system function.  Copy
@var{number-of-bytes} bytes from @var{source-pointer} to
@var{dest-pointer}, which must be pointer values.
@end defun


@defun memmove @var{dest-pointer} @var{source-pointer} @var{number-of-bytes}
An interface to the @cfunc{memmove} system function.  Like @func{memcpy}
but allows the blocks to be overlapped.
@end defun


@defun memset @var{pointer} @var{int} @var{number-of-bytes}
An interface to the @cfunc{memset} system function.  Set to @var{int}
the first @var{number-of-bytes} bytes starting from @var{pointer};
@var{int} must be an exact non--negative integer in the range @math{[0,
256)}.
@end defun


@defun memcmp @vari{pointer} @varii{pointer} @var{number-of-bytes}
An interface to the @cfunc{memcmp} system function.  Compare
@var{number-of-bytes} starting at @vari{pointer} and @varii{pointer} and
return an integer having the same sign as the difference between the
first different bytes from the blocks.  If the blocks are equal, the
return value is zero.
@end defun

@c page
@node memory bytevectors
@subsection Bytevectors conversion


The following bindings are exported by @library{foreign memory
bytevectors} and re--exported by @library{foreign memory}.  The @api{}
requires the @library{foreign memory memblocks} library when
@class{memblock} records are used.

In the implementation of the following functions:

@itemize
@item
When copying from a bytevector to a memory block, bytes are peeked with
@func{bytevector-u8-ref} and poked with @func{pointer-set-c-uint8!}.

@item
When copying from a memory block to a bytevector bytes are peeked with
@func{pointer-ref-c-uint8} and poked with @func{bytevector-u8-set!}.
@end itemize

Remember that we can compare two bytevectors with @func{bytevector=?},
but to compare raw blocks of memory we can use the @func{memcpy}
interface function.


@defun bytevector->pointer @var{bvector} @var{malloc}
@defunx bytevector->pointer @var{bvector} @var{malloc} @var{number-of-bytes}
@defunx bytevector->pointer @var{bvector} @var{malloc} @var{number-of-bytes} @var{offset}
Allocate a memory block using @var{malloc} and copy into it the bytes in
@var{bvector}.  Return the pointer.

If @var{number-of-bytes} is given: That number of bytes is taken as size
of the memory block, and only that number of bytes is copied.

If both @var{number-of-bytes} and @var{offset} are given: That number of
bytes is taken as size of the memory block, and only that number of
bytes is copied starting at @var{offset} from the beginning of the
bytevector.

@var{malloc} must accept as single argument the number of bytes to
allocate, and must return a pointer to the allocated memory block.  If
an error occurs allocating memory: @var{malloc} must raise an exception
and not return to the caller.
@end defun


@defun bytevector->memblock @var{bvector} @var{malloc}
@defunx bytevector->memblock @var{bvector} @var{malloc} @var{number-of-bytes}
@defunx bytevector->memblock @var{bvector} @var{malloc} @var{number-of-bytes} @var{offset}
Allocate a memory block using @var{malloc} and copy into it the bytes in
@var{bvector}.  Return a @class{memblock} record.

If @var{number-of-bytes} is given: That number of bytes is taken as size
of the memory block, and only that number of bytes is copied.

If both @var{number-of-bytes} and @var{offset} are given: That number of
bytes is taken as size of the memory block, and only that number of
bytes is copied starting at @var{offset} from the beginning of the
bytevector.

@var{malloc} must accept as single argument the number of bytes to
allocate, and must return a pointer to the allocated memory block.  If
an error occurs allocating memory: @var{malloc} must raise an exception
and not return to the caller.
@end defun


@defun pointer->bytevector @var{pointer} @var{number-of-bytes}
@defunx pointer->bytevector @var{pointer} @var{number-of-bytes} @var{offset}
Build a bytevector of length @var{number-of-bytes} and copy into it the
bytes from the block of memory referenced by @var{pointer}.  If
@var{offset} is given: Start to read bytes at @var{offset} from
@var{pointer}.
@end defun


@defun memblock->bytevector @var{memblock}
@defunx memblock->bytevector @var{memblock} @var{number-of-bytes}
@defunx memblock->bytevector @var{memblock} @var{number-of-bytes} @var{offset}
Duplicate a @class{memblock} record into a bytevector.

If @var{number-of-bytes} is given: That number of bytes is taken as size
of the bytevector, and only that number of bytes is copied.

If both @var{number-of-bytes} and @var{offset} are given: That number of
bytes is taken as size of the bytevector, and only that number of bytes
is copied starting at @var{offset} from the beginning of the block.
@end defun

@c page
@node memory mempool
@subsection Allocation from a memory pool


The @api{} described in this section allows us to allocate memory blocks
contiguously from a preallocated memory block accessed through a
@class{mempool} record.  Requested memory blocks are just marked as used
in the status of the pool.  When using this allocator there is no need
to release individual blocks: Releasing the pool releases all of them.

The following bindings are exported by @library{foreign memory mempool}.


@deftp {Record Type Name} <mempool>
@deftpx {Record Type Descriptor} <mempool-rtd>
@deftpx {Record Extension} <mempool*>
Record type descriptor of the memory pool object; it is derived from
@class{memblock}.  It has the following fields:

@table @samp
@item pointer
Pointer to the allocated block.

@item size
Number of allocated bytes.

@item pointer-free
Pointer to the first free byte in the allocated block.
@end table

The record extension has the following virtual fields:

@table @samp
@item free-size
Number of free bytes in the memory pool.
@end table
@end deftp


@defun make-mempool @var{pointer} @var{number-of-bytes}
Build and return a new @class{mempool} record.  Notice that the
allocated memory must be released explicitly by accessing the
@samp{pointer} field of the record.
@end defun


@deffn Parameter memory-pool
Holds @false{} or the @class{mempool} record from which memory blocks
must be allocated; it is preset to @false{}.
@end deffn


@defun primitive-malloc/mempool @var{number-of-bytes}
Allocates @var{number-of-bytes} in the current memory pool and return a
pointer to the first allocated byte, or @false{} if there is not enough
room in the pool.

Notice that this function has the correct interface to be used as value
for the @func{primitive-malloc-function} parameter.  @ref{memory alloc,
Allocation functions}
@end defun


@defun malloc/mempool @var{number-of-bytes}
A wrapper for @func{primitive-malloc/mempool} that raises an
@condition{out-of-memory} exception if there is not enough room in the pool.
@end defun


Example:

@example
(import (rnrs)
  (foreign memory)
  (for (foreign memory mempool) expand run)
  (records))

(define pool
  (make-mempool (malloc 4096) 4096))

(parametrise ((memory-pool pool))
  (let ((p (malloc/mempool 10))
        (q (malloc/mempool 20)))
    ---))

(with-fields ((pointer <mempool*> pool))
  (primitive-free pointer))
@end example

@noindent
or using compensations:

@example
(import (rnrs)
  (foreign memory compensate)
  (foreign memory mempool)
  (compensations))

(with-compensations
  (parametrise ((memory-pool (make-mempool (malloc/c 4096)
                                           4096)))
    (let ((p (malloc/mempool 10))
          (q (malloc/mempool 20)))
      ---)))
@end example

@c page
@node memory refcount
@subsection Reference counting


Reference counting is implemented by allocating a block of memory with
the requested size plus @samp{strideof-long}.  The block will look like
this:

@example
 strideof-long            data area
|-------------|--------------------------------------|
              ^
              |
pointer returned by MALLOC/REFCOUNT
@end example

@noindent
the reference counter is handled as an @code{unsigned long} and it is
located at a negative offset from the address we use to access data.

The following bindings are exported by @library{foreign memory refcount}.


@defun malloc/refcount @var{number-of-bytes}
@defunx malloc/refcount @var{number-of-bytes} @var{malloc-func}
@defunx malloc/rc @var{number-of-bytes}
@defunx malloc/rc @var{number-of-bytes} @var{malloc-func}
Allocate a block of memory wide enough to hold @var{number-of-bytes}
using reference counting; return a pointer object.  Memory is allocated
with the procedure @var{malloc-func} which defaults to @func{malloc}.
Return a pointer to the first byte in the data area of the allocated
block; the reference counter is initially set to zero.
@end defun


@defun pointer-acquire @var{pointer}
Increment the reference counter of the memory block referenced by
@var{pointer}.  The block must have been allocated with
@func{malloc/rc}.
@end defun


@defun pointer-release @var{pointer}
@defunx pointer-release @var{pointer} @var{free-func}
Decrement the reference counter of the memory block referenced by
@var{pointer}; the block must have been allocated with @func{malloc/rc}.
If the counter reaches zero: The block is freed using the supplied
@var{free-func}, which defaults to @var{primitive-free}.
@end defun


Usage example with @func{dynamic-wind}:

@example
(let ((p (malloc/rc 4096)))
  (dynamic-wind
    (lambda () (pointer-acquire p))
    (lambda () (do-something-with p))
    (lambda () (pointer-release p))))
@end example

@noindent
usage example with compensations (@pxref{compensations}):

@example
(with-compensations
  (letrec ((p (compensate
                  (begin0-let ((p (malloc/rc 4096)))
                    (pointer-acquire p))
                (with
                 (pointer-release p)))))
    (do-something-with p)))))
@end example

@c page
@node memory membuffer
@subsection Memory buffers


The following bindings are exported by @library{foreign memory
membuffers}.  This library is meant to be used with the features of the
@library{records} library and it may require the @library{foreign memory
memblocks} library if @class{memblock} records are used.


@deftp {Record Type Name} <membuffer>
@deftpx {Record Type Descriptor} <membuffer-rtd>
Record type of byte buffers; it is used as a @acronym{FIFO} for bytes or
multi--byte data types.  It is derived from @class{queue}.
@end deftp


@defun membuffer
@defunx membuffer @var{cache}
Build and return a new @class{membuffer} record.  @var{cache} must be a
memory block cache interface function returned by
@func{make-block-cache}; when not given, it defaults to
@func{page-blocks-cache}.

The cache function must raise an @condition{out-of-memory} condition if
memory allocation fails.
@end defun


@defun membuffer-push-memblock! @var{mb} @var{blk}
@defunx membuffer-push-memblock! @var{mb} @var{blk} @var{blk.start}
@defunx membuffer-push-memblock! @var{mb} @var{blk} @var{blk.start} @var{blk.past}
Enqueue in the @class{membuffer} record @var{mb} bytes from the
@class{memblock} record @var{blk}; bytes are read from @var{blk}
starting at offset @var{blk.start} and stopping before offset
@var{blk.past}.

If no error occurs allocating memory, all the bytes in the selected
range of @var{blk} are enqueued in @var{mb}.  If an error occurs
allocating memory, @var{mb} is left in a consistent state and an
exception is raised with a condition object of type
@condition{membuffer-incomplete-push}.
@end defun


@defun membuffer-pop-memblock! @var{mb} @var{blk}
@defunx membuffer-pop-memblock! @var{mb} @var{blk} @var{blk.start}
@defunx membuffer-pop-memblock! @var{mb} @var{blk} @var{blk.start} @var{blk.past}
Fill the @class{memblock} record @var{blk}, starting at offset
@var{blk.start} and stopping before offset @var{blk.past}, with bytes
dequeued from the @class{membuffer} record @var{mb}.  Return the offset
in @var{blk} of the position past the last filled byte.  If @var{blk} is
filled to @var{blk.past}, the return value is @var{blk.past}.

When @var{blk.past} is not given, it defaults to the size of @var{blk}.
When @var{blk.start} is not given, it defaults to zero.
@end defun


@defun membuffer-push-bytevector! @var{mb} @var{bv}
@defunx membuffer-push-bytevector! @var{mb} @var{bv} @var{bv.start}
@defunx membuffer-push-bytevector! @var{mb} @var{bv} @var{bv.start} @var{bv.past}
Enqueue in the @class{membuffer} record @var{mb} bytes from the
bytevector @var{bv}; bytes are read from @var{bv} starting at offset
@var{bv.start} and stopping before offset @var{bv.past}.

If no error occurs allocating memory, all the bytes in the selected
range of @var{bv} are enqueued in @var{mb}.  If an error occurs
allocating memory, @var{mb} is left in a consistent state and an
exception is raised with a condition object of type
@condition{membuffer-incomplete-push}.
@end defun


@defun membuffer-pop-bytevector! @var{mb} @var{bv}
@defunx membuffer-pop-bytevector! @var{mb} @var{bv} @var{bv.start}
@defunx membuffer-pop-bytevector! @var{mb} @var{bv} @var{bv.start} @var{bv.past}
Fill the bytevector @var{bv}, starting at offset @var{bv.start} and
stopping before offset @var{bv.past}, with bytes from the
@class{membuffer} record @var{mb}.  Return the offset in @var{bv} of
the position past the last filled byte.  If @var{bv} is filled to
@var{bv.past}, the return value is @var{bv.past}.

When @var{bv.past} is not given, it defaults to the length of the
bytevector.  When @var{bv.start} is not given, it defaults to zero.
@end defun

@c ------------------------------------------------------------

@subsubheading Incomplete push condition object

@deftp {Condition Type} &membuffer-incomplete-push
Type of condition describing an incomplete push operation on a
@class{membuffer} record.  It has the following fields:

@table @samp
@item membuffer
The @class{membuffer} record for which the push was incomplete.

@item source
The source object from which data was read.  It is a bytevector or a
@class{memblock} record.

@item source-start-offset
The offset in the source object from which data should have been read.

@item source-past-offset
The exclusive upper limit offset of data in the source object.
@end table
@end deftp


@defun make-membuffer-incomplete-push-condition @var{mb} @var{source} @var{source-offset}
Build and return a condition object of type
@condition{membuffer-incomplete-push}.
@end defun


@defun membuffer-incomplete-push-condition? @var{obj}
Return true if @var{obj} is a condition object of type
@condition{membuffer-incomplete-push}.
@end defun


@defun membuffer-incomplete-push/membuffer @var{obj}
@defunx membuffer-incomplete-push/source @var{obj}
@defunx membuffer-incomplete-push/source-start-offset @var{obj}
@defunx membuffer-incomplete-push/source-past-offset @var{obj}
Field accessors for condition objects of type
@condition{membuffer-incomplete-push}.
@end defun

@c page
@node memory guarded
@subsection Guarded memory allocation


The functions described in this section are usable only when the Scheme
implementation provides guardians (only Ikarus at present, Tue Oct 13,
2009).  The following bindings are exported by @library{foreign memory
guarded-malloc}.


@defun malloc/guarded @var{number-of-bytes}
A wrapper for @func{malloc} which (if the allocation is successful)
registers the pointer into a guardian and return it.

The library registers a cleanup function for the guardian in the state
of the @library{cleanup-handlers} library, so memory allocated with this
function is released by invoking @func{cleanup}.  @strong{Do not} free
this memory with @func{primitive-free} or any other free function.
@end defun


@defun calloc/guarded @var{count} @var{element-size}
Like @func{malloc/guarded} but makes use of @func{calloc}.
@end defun


@c page
@node cstrings
@section C language strings handling


A @dfn{C string} is a block of memory holding a string of characters
terminated by a zero byte.  The functions described in this chapter are
exported by the @library{foreign cstrings} library.

@menu
* cstrings inspection::         Inspecting cstrings.
* cstrings operations::         Acting upon cstrings.
* cstrings conversion::         Converting to and from cstrings.
* cstrings argv::               Converting arrays of cstrings.
@end menu

@c page
@node cstrings inspection
@subsection Inspecting strings


@defun strlen @var{pointer}
Return the number of characters in the C string referenced by
@var{pointer}.
@end defun


@defun strcmp @vari{pointer} @varii{pointer}
@defunx strncmp @vari{pointer} @varii{pointer} @var{number-of-bytes}
An interface to the @cfunc{strcmp} and @cfunc{strncmp} system functions.
Compare @var{number-of-bytes} starting at @vari{pointer} and
@varii{pointer} and return an integer having the same sign as the
difference between the first different bytes from the blocks.  If the
blocks are equal, the return value is zero.
@end defun

@c page
@node cstrings operations
@subsection Acting upon cstrings


@defun strdup @var{pointer}
@defunx strdup @var{pointer} @var{malloc}
Build a new C string copying the C string referenced by @var{pointer}
and return a pointer to it.  The new string is allocated using the
supplied @var{malloc} function, or @func{malloc} if no function is
given.
@end defun


@defun strndup @var{pointer} @var{size}
@defunx strndup @var{pointer} @var{size} @var{malloc}
Build a new C string copying the first @var{size} bytes from the C
string referenced by @var{pointer} and return a pointer to it.  The new
string is allocated using the supplied @var{malloc} function, or
@func{malloc} if no function is given.
@end defun

@c page
@node cstrings conversion
@subsection Converting to and from cstrings


@defun string->cstring @var{string/symbol}
@defunx string->cstring @var{string/symbol} @var{malloc}
@defunx string->cstring/c @var{string/symbol}
Build and return new C string representing the Scheme
@var{string/symbol} and return a pointer value referencing it.  The
returned string is encoded in @acronym{UTF8} format and terminated by a
zero byte.

@func{string->cstring} allocates memory using the supplied @var{malloc}
function, or @func{malloc} if @var{malloc} is not given.  To use a
compensated allocation: We can use @func{malloc/c} or
@func{malloc-block/c} as @var{malloc} argument.

The conversion is performed as follows:

@enumerate
@item
If @var{string/symbol} is a Scheme symbol, its string name is acquired
and becomes the input string.

@item
The function @func{string->utf8} is used to convert the Scheme string
into a bytevector holding the string representation in @acronym{UTF8}
format.

@item
Raw memory is allocated and, byte by byte, the bytevector is duplicated
into the memory block; a zero terminating byte is appended.
@end enumerate

@func{string->cstring/c} allocates memory using @func{malloc-block/c}.
@end defun


@defun cstring->string @var{cstr}
@defunx cstring->string @var{cstr} @var{number-of-bytes}
Build and return a new Scheme string representing @var{cstr}, which must
be a pointer to a memory block holding a zero terminated, @acronym{UTF8}
encoded, C language string.

The conversion is performed as follows:

@enumerate
@item
If @var{number-of-bytes} is given, that number of bytes are taken from
the memory block; else the length of the input string is determined
using @func{strlen}.

@item
A bytevector is allocated and, byte by byte, the string is copied into
it.

@item
The function @func{utf8->string} is used to convert the bytevector into
a Scheme string.
@end enumerate
@end defun

@c ------------------------------------------------------------

@defun string->memblock @var{string/symbol}
@defunx string->memblock @var{string/symbol} @var{malloc}
@defunx string->memblock/c @var{string/symbol}
Build and return new record of type @class{memblock} representing the
Scheme @var{string/symbol} and return a pointer value referencing it.
The returned memblock represents the string encoded in @acronym{UTF8}
format @strong{without} the trailing zero byte.

@func{string->memblock} allocates memory using the supplied @var{malloc}
function, or @func{malloc} if @var{malloc} is not given.  To use a
compensated allocation: We can use @func{malloc/c} or
@func{malloc-block/c} as @var{malloc} argument.

The conversion is performed as follows:

@enumerate
@item
If @var{string/symbol} is a Scheme symbol, its string name is acquired
and becomes the input string.

@item
The function @func{string->utf8} is used to convert the Scheme string
into a bytevector holding the string representation in @acronym{UTF8}
format.

@item
Raw memory is allocated and, byte by byte, the bytevector is duplicated
into the memory block.
@end enumerate

@func{string->memblock/c} allocates memory using @func{malloc-block/c}.
@end defun


@defun memblock->string @var{mb}
@defunx memblock->string @var{mb} @var{number-of-bytes}
Build and return a new Scheme string representing the @class{memblock}
record @var{mb}, which must hold a @acronym{UTF8} encoded, C language
string with or without the trailing zero byte.

The conversion is performed as follows:

@enumerate
@item
If @var{number-of-bytes} is given, that number of bytes are taken from
the memory block; else the length of the input string is the size of the
@class{memblock} itself.

@item
A bytevector is allocated and, byte by byte, the string is copied into
it.

@item
The function @func{utf8->string} is used to convert the bytevector into
a Scheme string.
@end enumerate
@end defun

@c page
@node cstrings argv
@subsection Converting arrays of cstrings


A null--terminated array of C strings looks like this:

@example
                  -
argv pointer ---> | pointer to string -----> C string 0
                  -
                  | pointer to string -----> C string 1
                  -
                  | pointer to string -----> C string 2
                  -
                  | pointer to string -----> C string 3
                  -
                  | null pointer
                  -
@end example


@defun strings->argv @var{args}
@defunx strings->argv @var{args} @var{malloc-func}
Convert the list of Scheme strings and symbols in @var{args} into a
null--terminated array of strings.  Return the pointer to the array.

The array and the strings are allocated with the function
@var{malloc-func}, or with @func{malloc} if @var{malloc-func} is not
given.
@end defun


@defun argv-length @var{argv}
Return the number of strings in the null--terminated array of strings
referenced by the @var{argv} pointer.
@end defun


@defun argv->strings @var{argv}
Convert the null--terminated array of strings referenced by the
@var{argv} pointer to a list of Scheme strings.
@end defun

@c page
@node errno
@section C language system errors


The bindings described in this chapter are exported by the
@library{foreign errno} library.

@menu
* errno values::                Error codes.
* errno conversion::            Conversion of error codes.
* errno condition::             Raising exceptions.
@end menu

@c page
@node errno values
@subsection Error codes


@cindex @code{E2BIG}
@cindex @code{EACCES}
@cindex @code{EADDRINUSE}
@cindex @code{EADDRNOTAVAIL}
@cindex @code{EADV}
@cindex @code{EAFNOSUPPORT}
@cindex @code{EAGAIN}
@cindex @code{EALREADY}
@cindex @code{EBADE}
@cindex @code{EBADF}
@cindex @code{EBADFD}
@cindex @code{EBADMSG}
@cindex @code{EBADR}
@cindex @code{EBADRQC}
@cindex @code{EBADSLT}
@cindex @code{EBFONT}
@cindex @code{EBUSY}
@cindex @code{ECANCELED}
@cindex @code{ECHILD}
@cindex @code{ECHRNG}
@cindex @code{ECOMM}
@cindex @code{ECONNABORTED}
@cindex @code{ECONNREFUSED}
@cindex @code{ECONNRESET}
@cindex @code{EDEADLK}
@cindex @code{EDEADLOCK}
@cindex @code{EDESTADDRREQ}
@cindex @code{EDOM}
@cindex @code{EDOTDOT}
@cindex @code{EDQUOT}
@cindex @code{EEXIST}
@cindex @code{EFAULT}
@cindex @code{EFBIG}
@cindex @code{EHOSTDOWN}
@cindex @code{EHOSTUNREACH}
@cindex @code{EIDRM}
@cindex @code{EILSEQ}
@cindex @code{EINPROGRESS}
@cindex @code{EINTR}
@cindex @code{EINVAL}
@cindex @code{EIO}
@cindex @code{EISCONN}
@cindex @code{EISDIR}
@cindex @code{EISNAM}
@cindex @code{EKEYEXPIRED}
@cindex @code{EKEYREJECTED}
@cindex @code{EKEYREVOKED}
@cindex @code{EL2HLT}
@cindex @code{EL2NSYNC}
@cindex @code{EL3HLT}
@cindex @code{EL3RST}
@cindex @code{ELIBACC}
@cindex @code{ELIBBAD}
@cindex @code{ELIBEXEC}
@cindex @code{ELIBMAX}
@cindex @code{ELIBSCN}
@cindex @code{ELNRNG}
@cindex @code{ELOOP}
@cindex @code{EMEDIUMTYPE}
@cindex @code{EMFILE}
@cindex @code{EMLINK}
@cindex @code{EMSGSIZE}
@cindex @code{EMULTIHOP}
@cindex @code{ENAMETOOLONG}
@cindex @code{ENAVAIL}
@cindex @code{ENETDOWN}
@cindex @code{ENETRESET}
@cindex @code{ENETUNREACH}
@cindex @code{ENFILE}
@cindex @code{ENOANO}
@cindex @code{ENOBUFS}
@cindex @code{ENOCSI}
@cindex @code{ENODATA}
@cindex @code{ENODEV}
@cindex @code{ENOENT}
@cindex @code{ENOEXEC}
@cindex @code{ENOKEY}
@cindex @code{ENOLCK}
@cindex @code{ENOLINK}
@cindex @code{ENOMEDIUM}
@cindex @code{ENOMEM}
@cindex @code{ENOMSG}
@cindex @code{ENONET}
@cindex @code{ENOPKG}
@cindex @code{ENOPROTOOPT}
@cindex @code{ENOSPC}
@cindex @code{ENOSR}
@cindex @code{ENOSTR}
@cindex @code{ENOSYS}
@cindex @code{ENOTBLK}
@cindex @code{ENOTCONN}
@cindex @code{ENOTDIR}
@cindex @code{ENOTEMPTY}
@cindex @code{ENOTNAM}
@cindex @code{ENOTRECOVERABLE}
@cindex @code{ENOTSOCK}
@cindex @code{ENOTTY}
@cindex @code{ENOTUNIQ}
@cindex @code{ENXIO}
@cindex @code{EOPNOTSUPP}
@cindex @code{EOVERFLOW}
@cindex @code{EOWNERDEAD}
@cindex @code{EPERM}
@cindex @code{EPFNOSUPPORT}
@cindex @code{EPIPE}
@cindex @code{EPROTO}
@cindex @code{EPROTONOSUPPORT}
@cindex @code{EPROTOTYPE}
@cindex @code{ERANGE}
@cindex @code{EREMCHG}
@cindex @code{EREMOTE}
@cindex @code{EREMOTEIO}
@cindex @code{ERESTART}
@cindex @code{EROFS}
@cindex @code{ESHUTDOWN}
@cindex @code{ESOCKTNOSUPPORT}
@cindex @code{ESPIPE}
@cindex @code{ESRCH}
@cindex @code{ESRMNT}
@cindex @code{ESTALE}
@cindex @code{ESTRPIPE}
@cindex @code{ETIME}
@cindex @code{ETIMEDOUT}
@cindex @code{ETOOMANYREFS}
@cindex @code{ETXTBSY}
@cindex @code{EUCLEAN}
@cindex @code{EUNATCH}
@cindex @code{EUSERS}
@cindex @code{EWOULDBLOCK}
@cindex @code{EXDEV}
@cindex @code{EXFULL}

It may be that not all the constants are defined on our platform, if a
symbol is not defined the value of the corresponding variable is
@false{}.  @value{PACKAGE} attempts to define the following symbols (in
row--then--column alphabetical order):

@example
E2BIG               EACCES              EADDRINUSE
EADDRNOTAVAIL       EADV                EAFNOSUPPORT
EAGAIN              EALREADY            EBADE
EBADF               EBADFD              EBADMSG
EBADR               EBADRQC             EBADSLT
EBFONT              EBUSY               ECANCELED
ECHILD              ECHRNG              ECOMM
ECONNABORTED        ECONNREFUSED        ECONNRESET
EDEADLK             EDEADLOCK           EDESTADDRREQ
EDOM                EDOTDOT             EDQUOT
EEXIST              EFAULT              EFBIG
EHOSTDOWN           EHOSTUNREACH        EIDRM
EILSEQ              EINPROGRESS         EINTR
EINVAL              EIO                 EISCONN
EISDIR              EISNAM              EKEYEXPIRED
EKEYREJECTED        EKEYREVOKED         EL2HLT
EL2NSYNC            EL3HLT              EL3RST
ELIBACC             ELIBBAD             ELIBEXEC
ELIBMAX             ELIBSCN             ELNRNG
ELOOP               EMEDIUMTYPE         EMFILE
EMLINK              EMSGSIZE            EMULTIHOP
ENAMETOOLONG        ENAVAIL             ENETDOWN
ENETRESET           ENETUNREACH         ENFILE
ENOANO              ENOBUFS             ENOCSI
ENODATA             ENODEV              ENOENT
ENOEXEC             ENOKEY              ENOLCK
ENOLINK             ENOMEDIUM           ENOMEM
ENOMSG              ENONET              ENOPKG
ENOPROTOOPT         ENOSPC              ENOSR
ENOSTR              ENOSYS              ENOTBLK
ENOTCONN            ENOTDIR             ENOTEMPTY
ENOTNAM             ENOTRECOVERABLE     ENOTSOCK
ENOTTY              ENOTUNIQ            ENXIO
EOPNOTSUPP          EOVERFLOW           EOWNERDEAD
EPERM               EPFNOSUPPORT        EPIPE
EPROTO              EPROTONOSUPPORT     EPROTOTYPE
ERANGE              EREMCHG             EREMOTE
EREMOTEIO           ERESTART            EROFS
ESHUTDOWN           ESOCKTNOSUPPORT     ESPIPE
ESRCH               ESRMNT              ESTALE
ESTRPIPE            ETIME               ETIMEDOUT
ETOOMANYREFS        ETXTBSY             EUCLEAN
EUNATCH             EUSERS              EWOULDBLOCK
EXDEV               EXFULL
@end example

@c page
@node errno conversion
@subsection Conversion of error codes


@defun strerror @var{errno-numeric-value}
An interface to the system @cfunc{strerror} function.  Return the string
message coresponding to @var{errno-numeric-value}.
@end defun


@defun symbol->errno @var{symbol}
@defunx symbol->errno/or-error @var{symbol}
Attempt the conversion from an @samp{errno} symbolic value to the
corresponding numeric value.  @func{symbol->errno} returns an integer or
@false{} if the symbol is not defined on the underlying platform.  The
@samp{or-error} variant raises an assertion violation if @var{symbol} is
not an @samp{errno} symbolic value.
@end defun


@defun errno->symbol @var{number}
@defunx errno->symbol/or-error @var{number}
Attempt the conversion from an @samp{errno} numeric value to the
corresponding symbolic value.  @func{errno->symbol} returns a symbol or
@false{} if @var{number} is not an @samp{errno} numeric value.  The
@samp{or-error} variant raises an assertion violation if @var{number} is
not an @samp{errno} numeric value.
@end defun

@c page
@node errno condition
@subsection Raising exceptions


@deftp Condition {&errno}
Type of condition objects that represent an error in a foreign function
signaled with the @samp{errno} variable.  It is derived from
@condition{error}.
@end deftp


@deffn {Condition Constructor} make-errno-condition @var{errno-numeric-value} @var{errno-symbolic-value}
@deffnx {Condition Predicate} errno-condition? @var{object}
@deffnx {Field Accessor} errno-numeric-value @var{object}
@deffnx {Field Accessor} errno-symbolic-value @var{object}
Functions to handle foreign system error condition objects.

Fake example:

@example
(let ((errno ---))
  (raise
    (condition
      (make-who-condition 'read)
      (make-message-condition (strerror errno))
      (make-errno-condition errno
        (errno->symbol/or-error errno)))))
@end example
@end deffn


@defun make-errno-condition* @var{errno-numeric-value}
Wrapper for @func{make-errno-condition} that builds an @condition{errno}
condition from the numeric value only.
@end defun


@defun raise-errno-error @var{who} @var{errno-numeric-value}
@defunx raise-errno-error @var{who} @var{errno-numeric-value} @var{irritants}
Raise a non--continuable exception representing a foreign function
system error signaled through the @samp{errno} variable.  If
@var{irritants} is not given, the condition object has no
@condition{irritants} component.

The following form:

@example
(let ((errno ---)
      (pathname ---))
  (raise-errno-error 'write errno pathname))
@end example

@noindent
is equivalent to:

@example
(raise
  (condition (make-who-condition 'write)
             (make-message-condition (strerror errno))
             (make-errno-condition* errno)
             (make-irritants-condition pathname)))
@end example
@end defun

@c end of file
@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c End:
