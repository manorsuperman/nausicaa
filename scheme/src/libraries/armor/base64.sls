;;; -*- coding: utf-8-unix -*-
;;;
;;;Part of: Nausicaa/Scheme
;;;Contents: ASCII armor functions for base64
;;;Date: Sun Jan 24, 2010
;;;
;;;Abstract
;;;
;;;	This library  is derived from the  code in Nettle,  a C language
;;;	library of cryptographic building blocks.
;;;
;;;Copyright (c) 2010 Marco Maggi <marco.maggi-ipsu@poste.it>
;;;Copyright (C) 2002 Niels MÃ¶ller
;;;
;;;This program is free software:  you can redistribute it and/or modify
;;;it under the terms of the  GNU General Public License as published by
;;;the Free Software Foundation, either version 3 of the License, or (at
;;;your option) any later version.
;;;
;;;This program is  distributed in the hope that it  will be useful, but
;;;WITHOUT  ANY   WARRANTY;  without   even  the  implied   warranty  of
;;;MERCHANTABILITY  or FITNESS FOR  A PARTICULAR  PURPOSE.  See  the GNU
;;;General Public License for more details.
;;;
;;;You should  have received  a copy of  the GNU General  Public License
;;;along with this program.  If not, see <http://www.gnu.org/licenses/>.
;;;


(library (armor base64)
  (export
    <base64-encode-ctx>
    make-<base64-encode-ctx>		<base64-encode-ctx>?

    <base64-decode-ctx>
    make-<base64-decode-ctx>		<base64-decode-ctx>?

    base64-encode-length		base64-decode-length
    base64-encode-partial-length
    base64-encode-final-length
    base64-encode-update!		base64-decode-update!
    base64-encode-final!
    base64-encode-finished?)
  (import (rnrs)
    (armor helpers))


;;;; helpers

(define-syntax define-decode-accessor
  (lambda (stx)
    (define (%field->accessor field-stx)
      (string->symbol (string-append "<base64-decode-ctx>-"
				     (symbol->string (syntax->datum field-stx)))))
    (define (%field->mutator field-stx)
      (string->symbol (string-append "<base64-decode-ctx>-"
				     (symbol->string (syntax->datum field-stx))
				     "-set!")))
    (syntax-case stx ()
      ((_ ?record ?field)
       (with-syntax ((ACCESSOR	(datum->syntax #'field (%field->accessor #'?field)))
		     (MUTATOR	(datum->syntax #'field (%field->mutator  #'?field))))
       #'(define-syntax ?field
	   (identifier-syntax
	    (?id
	     (ACCESSOR ?record))
	    ((set! ?id ?e)
	     (MUTATOR ?record ?e)))))))))


(define-record-type <base64-encode-ctx>
  (fields (mutable word)  ;leftover bits
	  (mutable bits)) ;number of bits, always 0, 2, or 4
  (protocol (lambda (maker)
	      (lambda ()
		(maker 0 0)))))

(define-record-type <base64-decode-ctx>
  (fields (mutable word)    ;leftover bist
	  (mutable bits)    ;number of buffered bits
	  (mutable padding) ;number of padding characters encountered
	  (immutable allow-blanks?))
  (protocol (lambda (maker)
	      (lambda (allow-blanks?)
		(maker 0 0 0 allow-blanks?)))))


(define (base64-encode-length len)
  ;;Maximum  length  of  output  for  BASE64-ENCODE-UPDATE!.   Does  not
  ;;include any padding that  BASE64-ENCODE-FINAL!  may add.  We have at
  ;;most 4 buffered bits, and a total of (4 + len * 8) bits.
  ;;
  (+ base64-encode-final-length (base64-encode-partial-length len)))

(define (base64-encode-partial-length len)
  ;;Maximum  length of output  for BASE64-ENCODE-UPDATE!,  not including
  ;;any padding that  BASE64-ENCODE-FINAL!  may add.  We have  at most 4
  ;;buffered bits, and a total of (4 + len * 8) bits.
  ;;
  (div (+ 4 (* len 8)) 6))

(define (%encode-raw-length len)
  ;;Exact  length of  output generated  by  BASE64-ENCODE-RAW, including
  ;;padding.
  ;;
  (* 4 (div (+ 2 len) 3)))

;;Maximum length of output generated by BASE64-ENCODE-FINAL!.
(define base64-encode-final-length 3)

(define (base64-decode-length len)
  ;;Maximum length of output for BASE64-DECODE-UPDATE!.  We have at most
  ;;6 buffered bits, and a total of (length + 1) * 6 bits.
  (div (* 6 (+ 1 len)) 8))


(define encode-table
  (list->vector (map char->integer
		  '(#\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M
		    #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z
		    #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m
		    #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z
		    #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\+ #\/))))

(define-syntax %encode
  (syntax-rules ()
    ((_ ?x)
     (vector-ref encode-table (bitwise-and #x3F ?x)))))

(define decode-table
  ;; TABLE_INVALID  = -1
  ;; TABLE_SPACE    = -2
  ;; TABLE_END      = -3
  ;; White space is HT, VT, FF, CR, LF and SPC
  ;;
  '#(-1 -1 -1 -1 -1 -1 -1 -1 -1 -2 -2 -2 -2 -2 -1 -1
	-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
	-2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 62 -1 -1 -1 63
	52 53 54 55 56 57 58 59 60 61 -1 -1 -1 -3 -1 -1
	-1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14
	15 16 17 18 19 20 21 22 23 24 25 -1 -1 -1 -1 -1
	-1 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
	41 42 43 44 45 46 47 48 49 50 51 -1 -1 -1 -1 -1
	-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
	-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
	-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
	-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
	-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
	-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
	-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
	-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1))

(define-syntax %decode
  (syntax-rules ()
    ((_ ?index)
     (vector-ref decode-table ?index))))

(define the= (char->integer #\=))


(define (base64-encode-update! ctx dst-bv dst-start src-bv src-start src-len)
  (let ((i 0)	;offset in DST-BV from DST-START
	(j 0))	;offset in SRC-BV from SRC-START
    ;; consume the bits in the context
    (while (and (< 0 (<base64-encode-ctx>-bits ctx))
		(< 0 src-len))
	   (decr! src-len)
	   (incr! i (%encode-single ctx dst-bv (+ i dst-start) src-bv (+ j src-start)))
	   (incr! j))
    (let* ((over-len	(mod src-len 3))
	   (bulk-len	(- src-len over-len)))
      ;; encode the bulk of the input, triplets of bytes
      (when (< 0 bulk-len)
	(incr! i (%encode-raw dst-bv (+ i dst-start) src-bv (+ j src-start) bulk-len))
	(incr! j bulk-len))
      ;; encode the rest of the input, 1 or 2 bytes
      (while (< 0 over-len)
	     (decr! over-len)
	     (incr! i (%encode-single ctx dst-bv (+ i dst-start) src-bv (+ j src-start)))
	     (incr! j))
      i)))

(define (%encode-single ctx dst-bv dst-start src-bv src-start)
  ;;Encode  the single  byte at  SRC-START  index SRC-BV  and store  the
  ;;produced  output at  index DST-START  in DST-BV.   Some bits  may be
  ;;stored in  the context  CTX.  Return the  number of bytes  stored in
  ;;DST-BV.
  ;;
  (let ((i 0))	;offset in DST-BV from DST-START
    (let ((word (bitwise-ior (<< (<base64-encode-ctx>-word ctx) 8)
			     (bytevector-u8-ref src-bv src-start)))
	  (bits (+ 8 (<base64-encode-ctx>-bits ctx))))
      (while (<= 6 bits)
	     (decr! bits 6)
	     (bytevector-u8-set! dst-bv (+ i dst-start) (%encode (>> word bits)))
	     (incr! i))
      (<base64-encode-ctx>-bits-set! ctx bits)
      (<base64-encode-ctx>-word-set! ctx word)
      i)))

(define (%encode-raw dst-bv dst-start src-bv src-start src-len)
  ;;Encode SRC-LEN bytes in SRC-BV starting at index SRC-START and store
  ;;the produced  output in DST-BV startgin at  index DST-START.  Return
  ;;the number of bytes stored in DST-BV.
  ;;
  ;;This function  is called to  process a number  of bytes which  is an
  ;;exact multiple  of 3.  It  is meant to  be used when the  context is
  ;;empty, and it stores NO bits in the context.
  ;;
  (let* ((done	(%encode-raw-length src-len))
	 (i	done)
	 (j	src-len))
    (define-macro (*src ?offset)
      (bytevector-u8-ref src-bv (+ j src-start ?offset)))
    (define-macro (*dst ?expr)
      (decr! i)
      (bytevector-u8-set! dst-bv (+ i dst-start) ?expr))
    (while (> i 0)
	   (decr! j 3)
	   (*dst (%encode (*src 2)))
	   (*dst (%encode (bitwise-ior (<< (*src 1) 2) (>> (*src 2) 6))))
	   (*dst (%encode (bitwise-ior (<< (*src 0) 4) (>> (*src 1) 4))))
	   (*dst (%encode (>> (*src 0) 2))))
    done))

(define (base64-encode-final! ctx dst-bv dst-start)
  (let ((i    0) ;offset in DST-BV from DST-START
	(bits (<base64-encode-ctx>-bits ctx)))
    (define-macro (*dst ?expr)
      (bytevector-u8-set! dst-bv (+ i dst-start) ?expr)
      (incr! i))
    (when (< 0 bits)
      (*dst (%encode (<< (<base64-encode-ctx>-word ctx) (- 6 bits))))
      (let loop ((bits bits))
	(when (< bits 6)
	  (*dst the=)
	  (loop (+ 2 bits))))
      (<base64-encode-ctx>-bits-set! ctx 0))
    i))

(define (base64-encode-finished? ctx)
  (= 0 (<base64-encode-ctx>-bits ctx)))


(define (base64-decode-update! ctx dst-bv dst-start src-bv src-start src-len)
  (define-decode-accessor ctx padding)
  (define-decode-accessor ctx word)
  (define-decode-accessor ctx bits)
  (let loop ((i 0) (j 0))
    (if (= j src-len)
	i
      (let* ((byte (bytevector-u8-ref src-bv (+ j src-start)))
	     (data (%decode byte)))
	(define (invalid-input)
	  (error 'base64-decode-update! "invalid base64 decoder input byte" byte))
	(case data
	  ((-1)	;TABLE_INVALID
	   (invalid-input))
	  ((-2)	;TABLE_SPACE
	   (if (<base64-decode-ctx>-allow-blanks? ctx)
	       (loop i (+ 1 j))
	     (error 'base64-decode-update!
	       "invalid base64 decoder input byte, blanks are not allowed" byte)))
	  ((-3) ;TABLE_END
	   (if (or (= 0 bits) (< 2 padding) ; there can be at most two padding characters
		   (not (= 0 (bitwise-and word (- (<< bits 1) 1)))))
		; we should not have any leftover bits
	       (invalid-input)
	     (begin
	       (incr! padding)
	       (decr! bits 2)
	       (loop i (+ 1 j)))))
	  (else
	   ;; (assert (<= 0 data))
	   ;; (assert (< data #x40))
	   (unless (= 0 padding)
	     (invalid-input))
	   (set! word (bitwise-and #xFFFF (bitwise-ior (<< word 6) data)))
	   (incr! bits 6)
	   (if (< bits 8)
	       (loop i (+ 1 j))
	     (begin
	       (incr! bits -8)
	       (bytevector-u8-set! dst-bv (+ i dst-start) (bitwise-and #xFF (>> word bits)))
	       (loop (+ 1 i) (+ 1 j))))))))))

;; (define (%decode-single ctx dst-bv dst-start src-bv src-start)
;;   (define-decode-accessor ctx padding)
;;   (define-decode-accessor ctx word)
;;   (define-decode-accessor ctx bits)
;;   (let* ((byte (bytevector-u8-ref src-bv src-start))
;; 	 (data (%decode byte)))
;;     (define (invalid-input)
;;       (error 'base64-decode-update! "invalid base64 decoder input byte" byte))
;;     (case data
;;       ((-1)	;TABLE_INVALID
;;        (invalid-input))
;;       ((-2)	;TABLE_SPACE
;;        (if (<base64-decode-ctx>-allow-blanks? ctx)
;; 	   0
;; 	 (error 'base64-decode-update!
;; 	   "invalid base64 decoder input byte, blanks are not allowed" byte)))
;;       ((-3)	;TABLE_END
;;        (if (or (or (= 0 bits) (< 2 padding))
;; 		; there can be at most two padding characters
;; 	       (not (= 0 (bitwise-and word (- (<< bits 1) 1)))))
;; 		; we should not have any leftover bits
;; 	   (invalid-input)
;; 	 (begin
;; 	   (incr! padding)
;; 	   (decr! bits 2)
;; 	   0)))
;;       (else
;;        (assert (<= 0 data))
;;        (assert (< data #x40))
;;        (unless (= 0 padding)
;; 	 (invalid-input))
;;        (set! word (bitwise-and #xFFFF (bitwise-ior (<< word 6) data)))
;;        (incr! bits 6)
;;        (if (< bits 8)
;; 	   0
;; 	 (begin
;; 	   (incr! bits -8)
;; 	   (bytevector-u8-set! dst-bv dst-start (bitwise-and #xFF (>> word bits)))
;; 	   1))))))


;;;; done

)

;;; end of file
